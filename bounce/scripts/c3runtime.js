// Generated by Construct 3, the game and app creator :: https://www.construct.net
'use strict';
var $jscomp = $jscomp || {};
$jscomp.scope = {};
$jscomp.ASSUME_ES5 = !1;
$jscomp.ASSUME_NO_NATIVE_MAP = !1;
$jscomp.ASSUME_NO_NATIVE_SET = !1;
$jscomp.SIMPLE_FROUND_POLYFILL = !1;
$jscomp.ISOLATE_POLYFILLS = !1;
$jscomp.defineProperty = $jscomp.ASSUME_ES5 || "function" == typeof Object.defineProperties ? Object.defineProperty : function(d, b, a) {
    if (d == Array.prototype || d == Object.prototype) return d;
    d[b] = a.value;
    return d
};
$jscomp.getGlobal = function(d) {
    d = ["object" == typeof globalThis && globalThis, d, "object" == typeof window && window, "object" == typeof self && self, "object" == typeof global && global];
    for (var b = 0; b < d.length; ++b) {
        var a = d[b];
        if (a && a.Math == Math) return a
    }
    throw Error("Cannot find global object");
};
$jscomp.global = $jscomp.getGlobal(this);
$jscomp.IS_SYMBOL_NATIVE = "function" === typeof Symbol && "symbol" === typeof Symbol("x");
$jscomp.TRUST_ES6_POLYFILLS = !$jscomp.ISOLATE_POLYFILLS || $jscomp.IS_SYMBOL_NATIVE;
$jscomp.polyfills = {};
$jscomp.propertyToPolyfillSymbol = {};
$jscomp.POLYFILL_PREFIX = "$jscp$";
var $jscomp$lookupPolyfilledValue = function(d, b) {
    var a = $jscomp.propertyToPolyfillSymbol[b];
    if (null == a) return d[b];
    a = d[a];
    return void 0 !== a ? a : d[b]
};
$jscomp.polyfill = function(d, b, a, f) {
    b && ($jscomp.ISOLATE_POLYFILLS ? $jscomp.polyfillIsolated(d, b, a, f) : $jscomp.polyfillUnisolated(d, b, a, f))
};
$jscomp.polyfillUnisolated = function(d, b, a, f) {
    a = $jscomp.global;
    d = d.split(".");
    for (f = 0; f < d.length - 1; f++) {
        var c = d[f];
        if (!(c in a)) return;
        a = a[c]
    }
    d = d[d.length - 1];
    f = a[d];
    b = b(f);
    b != f && null != b && $jscomp.defineProperty(a, d, {
        configurable: !0,
        writable: !0,
        value: b
    })
};
$jscomp.polyfillIsolated = function(d, b, a, f) {
    var c = d.split(".");
    d = 1 === c.length;
    f = c[0];
    f = !d && f in $jscomp.polyfills ? $jscomp.polyfills : $jscomp.global;
    for (var e = 0; e < c.length - 1; e++) {
        var g = c[e];
        if (!(g in f)) return;
        f = f[g]
    }
    c = c[c.length - 1];
    a = $jscomp.IS_SYMBOL_NATIVE && "es6" === a ? f[c] : null;
    b = b(a);
    null != b && (d ? $jscomp.defineProperty($jscomp.polyfills, c, {
        configurable: !0,
        writable: !0,
        value: b
    }) : b !== a && ($jscomp.propertyToPolyfillSymbol[c] = $jscomp.IS_SYMBOL_NATIVE ? $jscomp.global.Symbol(c) : $jscomp.POLYFILL_PREFIX + c, c =
        $jscomp.propertyToPolyfillSymbol[c], $jscomp.defineProperty(f, c, {
            configurable: !0,
            writable: !0,
            value: b
        })))
};
$jscomp.polyfill("globalThis", function(d) {
    return d || $jscomp.global
}, "es_2020", "es3");
(function(d, b) {
    "object" === typeof exports && "undefined" !== typeof module ? b(exports) : "function" === typeof define && define.amd ? define(["exports"], b) : (d = d || self, b(d.glMatrix = {}))
})(this, function(d) {
    function b(k, n, v) {
        var z = n[0],
            B = n[1],
            D = n[2];
        n = n[3];
        var F = v[0],
            H = v[1],
            I = v[2];
        v = v[3];
        k[0] = z * F + D * H;
        k[1] = B * F + n * H;
        k[2] = z * I + D * v;
        k[3] = B * I + n * v;
        return k
    }

    function a(k, n, v) {
        k[0] = n[0] - v[0];
        k[1] = n[1] - v[1];
        k[2] = n[2] - v[2];
        k[3] = n[3] - v[3];
        return k
    }

    function f(k, n, v) {
        var z = n[0],
            B = n[1],
            D = n[2],
            F = n[3],
            H = n[4];
        n = n[5];
        var I = v[0],
            M = v[1],
            Q = v[2],
            S = v[3],
            W = v[4];
        v = v[5];
        k[0] = z * I + D * M;
        k[1] = B * I + F * M;
        k[2] = z * Q + D * S;
        k[3] = B * Q + F * S;
        k[4] = z * W + D * v + H;
        k[5] = B * W + F * v + n;
        return k
    }

    function c(k, n, v) {
        k[0] = n[0] - v[0];
        k[1] = n[1] - v[1];
        k[2] = n[2] - v[2];
        k[3] = n[3] - v[3];
        k[4] = n[4] - v[4];
        k[5] = n[5] - v[5];
        return k
    }

    function e() {
        var k = new ma(9);
        ma != Float32Array && (k[1] = 0, k[2] = 0, k[3] = 0, k[5] = 0, k[6] = 0, k[7] = 0);
        k[0] = 1;
        k[4] = 1;
        k[8] = 1;
        return k
    }

    function g(k, n, v) {
        var z = n[0],
            B = n[1],
            D = n[2],
            F = n[3],
            H = n[4],
            I = n[5],
            M = n[6],
            Q = n[7];
        n = n[8];
        var S = v[0],
            W = v[1],
            U = v[2],
            ca = v[3],
            ba = v[4],
            Y = v[5],
            qa = v[6],
            la =
            v[7];
        v = v[8];
        k[0] = S * z + W * F + U * M;
        k[1] = S * B + W * H + U * Q;
        k[2] = S * D + W * I + U * n;
        k[3] = ca * z + ba * F + Y * M;
        k[4] = ca * B + ba * H + Y * Q;
        k[5] = ca * D + ba * I + Y * n;
        k[6] = qa * z + la * F + v * M;
        k[7] = qa * B + la * H + v * Q;
        k[8] = qa * D + la * I + v * n;
        return k
    }

    function h(k, n, v) {
        k[0] = n[0] - v[0];
        k[1] = n[1] - v[1];
        k[2] = n[2] - v[2];
        k[3] = n[3] - v[3];
        k[4] = n[4] - v[4];
        k[5] = n[5] - v[5];
        k[6] = n[6] - v[6];
        k[7] = n[7] - v[7];
        k[8] = n[8] - v[8];
        return k
    }

    function l(k) {
        k[0] = 1;
        k[1] = 0;
        k[2] = 0;
        k[3] = 0;
        k[4] = 0;
        k[5] = 1;
        k[6] = 0;
        k[7] = 0;
        k[8] = 0;
        k[9] = 0;
        k[10] = 1;
        k[11] = 0;
        k[12] = 0;
        k[13] = 0;
        k[14] = 0;
        k[15] = 1;
        return k
    }

    function m(k,
        n, v) {
        var z = n[0],
            B = n[1],
            D = n[2],
            F = n[3],
            H = n[4],
            I = n[5],
            M = n[6],
            Q = n[7],
            S = n[8],
            W = n[9],
            U = n[10],
            ca = n[11],
            ba = n[12],
            Y = n[13],
            qa = n[14];
        n = n[15];
        var la = v[0],
            oa = v[1],
            pa = v[2],
            na = v[3];
        k[0] = la * z + oa * H + pa * S + na * ba;
        k[1] = la * B + oa * I + pa * W + na * Y;
        k[2] = la * D + oa * M + pa * U + na * qa;
        k[3] = la * F + oa * Q + pa * ca + na * n;
        la = v[4];
        oa = v[5];
        pa = v[6];
        na = v[7];
        k[4] = la * z + oa * H + pa * S + na * ba;
        k[5] = la * B + oa * I + pa * W + na * Y;
        k[6] = la * D + oa * M + pa * U + na * qa;
        k[7] = la * F + oa * Q + pa * ca + na * n;
        la = v[8];
        oa = v[9];
        pa = v[10];
        na = v[11];
        k[8] = la * z + oa * H + pa * S + na * ba;
        k[9] = la * B + oa * I + pa * W + na * Y;
        k[10] = la * D + oa *
            M + pa * U + na * qa;
        k[11] = la * F + oa * Q + pa * ca + na * n;
        la = v[12];
        oa = v[13];
        pa = v[14];
        na = v[15];
        k[12] = la * z + oa * H + pa * S + na * ba;
        k[13] = la * B + oa * I + pa * W + na * Y;
        k[14] = la * D + oa * M + pa * U + na * qa;
        k[15] = la * F + oa * Q + pa * ca + na * n;
        return k
    }

    function p(k, n, v) {
        var z = n[0],
            B = n[1],
            D = n[2],
            F = n[3],
            H = z + z,
            I = B + B,
            M = D + D;
        n = z * H;
        var Q = z * I;
        z *= M;
        var S = B * I;
        B *= M;
        D *= M;
        H *= F;
        I *= F;
        F *= M;
        k[0] = 1 - (S + D);
        k[1] = Q + F;
        k[2] = z - I;
        k[3] = 0;
        k[4] = Q - F;
        k[5] = 1 - (n + D);
        k[6] = B + H;
        k[7] = 0;
        k[8] = z + I;
        k[9] = B - H;
        k[10] = 1 - (n + S);
        k[11] = 0;
        k[12] = v[0];
        k[13] = v[1];
        k[14] = v[2];
        k[15] = 1;
        return k
    }

    function t(k, n) {
        k[0] =
            n[12];
        k[1] = n[13];
        k[2] = n[14];
        return k
    }

    function q(k, n) {
        var v = n[4],
            z = n[5],
            B = n[6],
            D = n[8],
            F = n[9],
            H = n[10];
        k[0] = Math.hypot(n[0], n[1], n[2]);
        k[1] = Math.hypot(v, z, B);
        k[2] = Math.hypot(D, F, H);
        return k
    }

    function r(k, n) {
        var v = new ma(3);
        q(v, n);
        var z = 1 / v[0],
            B = 1 / v[1],
            D = 1 / v[2],
            F = n[0] * z;
        v = n[1] * B;
        var H = n[2] * D,
            I = n[4] * z,
            M = n[5] * B,
            Q = n[6] * D;
        z *= n[8];
        B *= n[9];
        n = n[10] * D;
        D = F + M + n;
        0 < D ? (F = 2 * Math.sqrt(D + 1), k[3] = .25 * F, k[0] = (Q - B) / F, k[1] = (z - H) / F, k[2] = (v - I) / F) : F > M && F > n ? (F = 2 * Math.sqrt(1 + F - M - n), k[3] = (Q - B) / F, k[0] = .25 * F, k[1] = (v + I) / F, k[2] = (z +
            H) / F) : M > n ? (F = 2 * Math.sqrt(1 + M - F - n), k[3] = (z - H) / F, k[0] = (v + I) / F, k[1] = .25 * F, k[2] = (Q + B) / F) : (F = 2 * Math.sqrt(1 + n - F - M), k[3] = (v - I) / F, k[0] = (z + H) / F, k[1] = (Q + B) / F, k[2] = .25 * F);
        return k
    }

    function u(k, n, v) {
        k[0] = n[0] - v[0];
        k[1] = n[1] - v[1];
        k[2] = n[2] - v[2];
        k[3] = n[3] - v[3];
        k[4] = n[4] - v[4];
        k[5] = n[5] - v[5];
        k[6] = n[6] - v[6];
        k[7] = n[7] - v[7];
        k[8] = n[8] - v[8];
        k[9] = n[9] - v[9];
        k[10] = n[10] - v[10];
        k[11] = n[11] - v[11];
        k[12] = n[12] - v[12];
        k[13] = n[13] - v[13];
        k[14] = n[14] - v[14];
        k[15] = n[15] - v[15];
        return k
    }

    function x() {
        var k = new ma(3);
        ma != Float32Array &&
            (k[0] = 0, k[1] = 0, k[2] = 0);
        return k
    }

    function y(k) {
        return Math.hypot(k[0], k[1], k[2])
    }

    function C(k, n, v) {
        var z = new ma(3);
        z[0] = k;
        z[1] = n;
        z[2] = v;
        return z
    }

    function w(k, n, v) {
        k[0] = n[0] - v[0];
        k[1] = n[1] - v[1];
        k[2] = n[2] - v[2];
        return k
    }

    function A(k, n, v) {
        k[0] = n[0] * v[0];
        k[1] = n[1] * v[1];
        k[2] = n[2] * v[2];
        return k
    }

    function E(k, n, v) {
        k[0] = n[0] / v[0];
        k[1] = n[1] / v[1];
        k[2] = n[2] / v[2];
        return k
    }

    function K(k, n) {
        return Math.hypot(n[0] - k[0], n[1] - k[1], n[2] - k[2])
    }

    function O(k, n) {
        var v = n[0] - k[0],
            z = n[1] - k[1];
        k = n[2] - k[2];
        return v * v + z * z + k * k
    }

    function G(k) {
        var n =
            k[0],
            v = k[1];
        k = k[2];
        return n * n + v * v + k * k
    }

    function J(k, n) {
        var v = n[0],
            z = n[1],
            B = n[2];
        v = v * v + z * z + B * B;
        0 < v && (v = 1 / Math.sqrt(v));
        k[0] = n[0] * v;
        k[1] = n[1] * v;
        k[2] = n[2] * v;
        return k
    }

    function P(k, n) {
        return k[0] * n[0] + k[1] * n[1] + k[2] * n[2]
    }

    function R(k, n, v) {
        var z = n[0],
            B = n[1];
        n = n[2];
        var D = v[0],
            F = v[1];
        v = v[2];
        k[0] = B * v - n * F;
        k[1] = n * D - z * v;
        k[2] = z * F - B * D;
        return k
    }

    function T() {
        var k = new ma(4);
        ma != Float32Array && (k[0] = 0, k[1] = 0, k[2] = 0, k[3] = 0);
        return k
    }

    function X(k) {
        var n = new ma(4);
        n[0] = k[0];
        n[1] = k[1];
        n[2] = k[2];
        n[3] = k[3];
        return n
    }

    function aa(k,
        n, v, z) {
        var B = new ma(4);
        B[0] = k;
        B[1] = n;
        B[2] = v;
        B[3] = z;
        return B
    }

    function ea(k, n) {
        k[0] = n[0];
        k[1] = n[1];
        k[2] = n[2];
        k[3] = n[3];
        return k
    }

    function sa(k, n, v, z, B) {
        k[0] = n;
        k[1] = v;
        k[2] = z;
        k[3] = B;
        return k
    }

    function ia(k, n, v) {
        k[0] = n[0] + v[0];
        k[1] = n[1] + v[1];
        k[2] = n[2] + v[2];
        k[3] = n[3] + v[3];
        return k
    }

    function Aa(k, n, v) {
        k[0] = n[0] - v[0];
        k[1] = n[1] - v[1];
        k[2] = n[2] - v[2];
        k[3] = n[3] - v[3];
        return k
    }

    function ua(k, n, v) {
        k[0] = n[0] * v[0];
        k[1] = n[1] * v[1];
        k[2] = n[2] * v[2];
        k[3] = n[3] * v[3];
        return k
    }

    function Da(k, n, v) {
        k[0] = n[0] / v[0];
        k[1] = n[1] / v[1];
        k[2] =
            n[2] / v[2];
        k[3] = n[3] / v[3];
        return k
    }

    function Ea(k, n, v) {
        k[0] = n[0] * v;
        k[1] = n[1] * v;
        k[2] = n[2] * v;
        k[3] = n[3] * v;
        return k
    }

    function Ba(k, n) {
        return Math.hypot(n[0] - k[0], n[1] - k[1], n[2] - k[2], n[3] - k[3])
    }

    function za(k, n) {
        var v = n[0] - k[0],
            z = n[1] - k[1],
            B = n[2] - k[2];
        k = n[3] - k[3];
        return v * v + z * z + B * B + k * k
    }

    function ja(k) {
        return Math.hypot(k[0], k[1], k[2], k[3])
    }

    function Fa(k) {
        var n = k[0],
            v = k[1],
            z = k[2];
        k = k[3];
        return n * n + v * v + z * z + k * k
    }

    function wa(k, n) {
        var v = n[0],
            z = n[1],
            B = n[2];
        n = n[3];
        var D = v * v + z * z + B * B + n * n;
        0 < D && (D = 1 / Math.sqrt(D));
        k[0] =
            v * D;
        k[1] = z * D;
        k[2] = B * D;
        k[3] = n * D;
        return k
    }

    function Ca(k, n) {
        return k[0] * n[0] + k[1] * n[1] + k[2] * n[2] + k[3] * n[3]
    }

    function Pa(k, n, v, z) {
        var B = n[0],
            D = n[1],
            F = n[2];
        n = n[3];
        k[0] = B + z * (v[0] - B);
        k[1] = D + z * (v[1] - D);
        k[2] = F + z * (v[2] - F);
        k[3] = n + z * (v[3] - n);
        return k
    }

    function Qa(k, n) {
        return k[0] === n[0] && k[1] === n[1] && k[2] === n[2] && k[3] === n[3]
    }

    function Ra(k, n) {
        var v = k[0],
            z = k[1],
            B = k[2];
        k = k[3];
        var D = n[0],
            F = n[1],
            H = n[2];
        n = n[3];
        return Math.abs(v - D) <= 1E-6 * Math.max(1, Math.abs(v), Math.abs(D)) && Math.abs(z - F) <= 1E-6 * Math.max(1, Math.abs(z),
            Math.abs(F)) && Math.abs(B - H) <= 1E-6 * Math.max(1, Math.abs(B), Math.abs(H)) && Math.abs(k - n) <= 1E-6 * Math.max(1, Math.abs(k), Math.abs(n))
    }

    function Ja() {
        var k = new ma(4);
        ma != Float32Array && (k[0] = 0, k[1] = 0, k[2] = 0);
        k[3] = 1;
        return k
    }

    function Sa(k, n, v) {
        v *= .5;
        var z = Math.sin(v);
        k[0] = z * n[0];
        k[1] = z * n[1];
        k[2] = z * n[2];
        k[3] = Math.cos(v);
        return k
    }

    function Ta(k, n, v) {
        var z = n[0],
            B = n[1],
            D = n[2];
        n = n[3];
        var F = v[0],
            H = v[1],
            I = v[2];
        v = v[3];
        k[0] = z * v + n * F + B * I - D * H;
        k[1] = B * v + n * H + D * F - z * I;
        k[2] = D * v + n * I + z * H - B * F;
        k[3] = n * v - z * F - B * H - D * I;
        return k
    }

    function Ua(k,
        n, v) {
        v *= .5;
        var z = n[0],
            B = n[1],
            D = n[2];
        n = n[3];
        var F = Math.sin(v);
        v = Math.cos(v);
        k[0] = z * v + n * F;
        k[1] = B * v + D * F;
        k[2] = D * v - B * F;
        k[3] = n * v - z * F;
        return k
    }

    function Va(k, n, v) {
        v *= .5;
        var z = n[0],
            B = n[1],
            D = n[2];
        n = n[3];
        var F = Math.sin(v);
        v = Math.cos(v);
        k[0] = z * v - D * F;
        k[1] = B * v + n * F;
        k[2] = D * v + z * F;
        k[3] = n * v - B * F;
        return k
    }

    function Wa(k, n, v) {
        v *= .5;
        var z = n[0],
            B = n[1],
            D = n[2];
        n = n[3];
        var F = Math.sin(v);
        v = Math.cos(v);
        k[0] = z * v + B * F;
        k[1] = B * v - z * F;
        k[2] = D * v + n * F;
        k[3] = n * v - D * F;
        return k
    }

    function Xa(k, n) {
        var v = n[0],
            z = n[1],
            B = n[2],
            D = Math.sqrt(v * v + z * z + B * B);
        n = Math.exp(n[3]);
        var F = 0 < D ? n * Math.sin(D) / D : 0;
        k[0] = v * F;
        k[1] = z * F;
        k[2] = B * F;
        k[3] = n * Math.cos(D);
        return k
    }

    function Ya(k, n) {
        var v = n[0],
            z = n[1],
            B = n[2];
        n = n[3];
        var D = Math.sqrt(v * v + z * z + B * B);
        D = 0 < D ? Math.atan2(D, n) / D : 0;
        k[0] = v * D;
        k[1] = z * D;
        k[2] = B * D;
        k[3] = .5 * Math.log(v * v + z * z + B * B + n * n);
        return k
    }

    function Ka(k, n, v, z) {
        var B = n[0],
            D = n[1],
            F = n[2];
        n = n[3];
        var H = v[0],
            I = v[1],
            M = v[2];
        v = v[3];
        var Q = B * H + D * I + F * M + n * v;
        0 > Q && (Q = -Q, H = -H, I = -I, M = -M, v = -v);
        if (1E-6 < 1 - Q) {
            var S = Math.acos(Q);
            var W = Math.sin(S);
            Q = Math.sin((1 - z) * S) / W;
            z = Math.sin(z * S) /
                W
        } else Q = 1 - z;
        k[0] = Q * B + z * H;
        k[1] = Q * D + z * I;
        k[2] = Q * F + z * M;
        k[3] = Q * n + z * v;
        return k
    }

    function Za(k, n) {
        var v = n[0] + n[4] + n[8];
        if (0 < v) v = Math.sqrt(v + 1), k[3] = .5 * v, v = .5 / v, k[0] = (n[5] - n[7]) * v, k[1] = (n[6] - n[2]) * v, k[2] = (n[1] - n[3]) * v;
        else {
            var z = 0;
            n[4] > n[0] && (z = 1);
            n[8] > n[3 * z + z] && (z = 2);
            var B = (z + 1) % 3,
                D = (z + 2) % 3;
            v = Math.sqrt(n[3 * z + z] - n[3 * B + B] - n[3 * D + D] + 1);
            k[z] = .5 * v;
            v = .5 / v;
            k[3] = (n[3 * B + D] - n[3 * D + B]) * v;
            k[B] = (n[3 * B + z] + n[3 * z + B]) * v;
            k[D] = (n[3 * D + z] + n[3 * z + D]) * v
        }
        return k
    }

    function $a(k, n, v) {
        var z = .5 * v[0],
            B = .5 * v[1];
        v = .5 * v[2];
        var D = n[0],
            F = n[1],
            H = n[2];
        n = n[3];
        k[0] = D;
        k[1] = F;
        k[2] = H;
        k[3] = n;
        k[4] = z * n + B * H - v * F;
        k[5] = B * n + v * D - z * H;
        k[6] = v * n + z * F - B * D;
        k[7] = -z * D - B * F - v * H;
        return k
    }

    function ab(k, n) {
        k[0] = n[0];
        k[1] = n[1];
        k[2] = n[2];
        k[3] = n[3];
        k[4] = n[4];
        k[5] = n[5];
        k[6] = n[6];
        k[7] = n[7];
        return k
    }

    function bb(k, n, v) {
        var z = n[0],
            B = n[1],
            D = n[2],
            F = n[3],
            H = v[4],
            I = v[5],
            M = v[6],
            Q = v[7],
            S = n[4],
            W = n[5],
            U = n[6];
        n = n[7];
        var ca = v[0],
            ba = v[1],
            Y = v[2];
        v = v[3];
        k[0] = z * v + F * ca + B * Y - D * ba;
        k[1] = B * v + F * ba + D * ca - z * Y;
        k[2] = D * v + F * Y + z * ba - B * ca;
        k[3] = F * v - z * ca - B * ba - D * Y;
        k[4] = z * Q + F * H + B * M - D * I + S * v + n * ca + W * Y - U * ba;
        k[5] =
            B * Q + F * I + D * H - z * M + W * v + n * ba + U * ca - S * Y;
        k[6] = D * Q + F * M + z * I - B * H + U * v + n * Y + S * ba - W * ca;
        k[7] = F * Q - z * H - B * I - D * M + n * v - S * ca - W * ba - U * Y;
        return k
    }

    function cb() {
        var k = new ma(2);
        ma != Float32Array && (k[0] = 0, k[1] = 0);
        return k
    }

    function db(k, n, v) {
        k[0] = n[0] - v[0];
        k[1] = n[1] - v[1];
        return k
    }

    function eb(k, n, v) {
        k[0] = n[0] * v[0];
        k[1] = n[1] * v[1];
        return k
    }

    function fb(k, n, v) {
        k[0] = n[0] / v[0];
        k[1] = n[1] / v[1];
        return k
    }

    function gb(k, n) {
        return Math.hypot(n[0] - k[0], n[1] - k[1])
    }

    function hb(k, n) {
        var v = n[0] - k[0];
        k = n[1] - k[1];
        return v * v + k * k
    }

    function ib(k) {
        return Math.hypot(k[0],
            k[1])
    }

    function jb(k) {
        var n = k[0];
        k = k[1];
        return n * n + k * k
    }
    var ma = "undefined" !== typeof Float32Array ? Float32Array : Array,
        Ga = Math.random,
        kb = Math.PI / 180;
    Math.hypot || (Math.hypot = function() {
        for (var k = 0, n = arguments.length; n--;) k += arguments[n] * arguments[n];
        return Math.sqrt(k)
    });
    var lb = Object.freeze({
            __proto__: null,
            EPSILON: 1E-6,
            get ARRAY_TYPE() {
                return ma
            },
            RANDOM: Ga,
            setMatrixArrayType: function(k) {
                ma = k
            },
            toRadian: function(k) {
                return k * kb
            },
            equals: function(k, n) {
                return Math.abs(k - n) <= 1E-6 * Math.max(1, Math.abs(k), Math.abs(n))
            }
        }),
        mb = Object.freeze({
            __proto__: null,
            create: function() {
                var k = new ma(4);
                ma != Float32Array && (k[1] = 0, k[2] = 0);
                k[0] = 1;
                k[3] = 1;
                return k
            },
            clone: function(k) {
                var n = new ma(4);
                n[0] = k[0];
                n[1] = k[1];
                n[2] = k[2];
                n[3] = k[3];
                return n
            },
            copy: function(k, n) {
                k[0] = n[0];
                k[1] = n[1];
                k[2] = n[2];
                k[3] = n[3];
                return k
            },
            identity: function(k) {
                k[0] = 1;
                k[1] = 0;
                k[2] = 0;
                k[3] = 1;
                return k
            },
            fromValues: function(k, n, v, z) {
                var B = new ma(4);
                B[0] = k;
                B[1] = n;
                B[2] = v;
                B[3] = z;
                return B
            },
            set: function(k, n, v, z, B) {
                k[0] = n;
                k[1] = v;
                k[2] = z;
                k[3] = B;
                return k
            },
            transpose: function(k,
                n) {
                if (k === n) {
                    var v = n[1];
                    k[1] = n[2];
                    k[2] = v
                } else k[0] = n[0], k[1] = n[2], k[2] = n[1], k[3] = n[3];
                return k
            },
            invert: function(k, n) {
                var v = n[0],
                    z = n[1],
                    B = n[2];
                n = n[3];
                var D = v * n - B * z;
                if (!D) return null;
                D = 1 / D;
                k[0] = n * D;
                k[1] = -z * D;
                k[2] = -B * D;
                k[3] = v * D;
                return k
            },
            adjoint: function(k, n) {
                var v = n[0];
                k[0] = n[3];
                k[1] = -n[1];
                k[2] = -n[2];
                k[3] = v;
                return k
            },
            determinant: function(k) {
                return k[0] * k[3] - k[2] * k[1]
            },
            multiply: b,
            rotate: function(k, n, v) {
                var z = n[0],
                    B = n[1],
                    D = n[2];
                n = n[3];
                var F = Math.sin(v);
                v = Math.cos(v);
                k[0] = z * v + D * F;
                k[1] = B * v + n * F;
                k[2] = z * -F +
                    D * v;
                k[3] = B * -F + n * v;
                return k
            },
            scale: function(k, n, v) {
                var z = n[1],
                    B = n[2],
                    D = n[3],
                    F = v[0];
                v = v[1];
                k[0] = n[0] * F;
                k[1] = z * F;
                k[2] = B * v;
                k[3] = D * v;
                return k
            },
            fromRotation: function(k, n) {
                var v = Math.sin(n);
                n = Math.cos(n);
                k[0] = n;
                k[1] = v;
                k[2] = -v;
                k[3] = n;
                return k
            },
            fromScaling: function(k, n) {
                k[0] = n[0];
                k[1] = 0;
                k[2] = 0;
                k[3] = n[1];
                return k
            },
            str: function(k) {
                return "mat2(" + k[0] + ", " + k[1] + ", " + k[2] + ", " + k[3] + ")"
            },
            frob: function(k) {
                return Math.hypot(k[0], k[1], k[2], k[3])
            },
            LDU: function(k, n, v, z) {
                k[2] = z[2] / z[0];
                v[0] = z[0];
                v[1] = z[1];
                v[3] = z[3] - k[2] *
                    v[1];
                return [k, n, v]
            },
            add: function(k, n, v) {
                k[0] = n[0] + v[0];
                k[1] = n[1] + v[1];
                k[2] = n[2] + v[2];
                k[3] = n[3] + v[3];
                return k
            },
            subtract: a,
            exactEquals: function(k, n) {
                return k[0] === n[0] && k[1] === n[1] && k[2] === n[2] && k[3] === n[3]
            },
            equals: function(k, n) {
                var v = k[0],
                    z = k[1],
                    B = k[2];
                k = k[3];
                var D = n[0],
                    F = n[1],
                    H = n[2];
                n = n[3];
                return Math.abs(v - D) <= 1E-6 * Math.max(1, Math.abs(v), Math.abs(D)) && Math.abs(z - F) <= 1E-6 * Math.max(1, Math.abs(z), Math.abs(F)) && Math.abs(B - H) <= 1E-6 * Math.max(1, Math.abs(B), Math.abs(H)) && Math.abs(k - n) <= 1E-6 * Math.max(1, Math.abs(k),
                    Math.abs(n))
            },
            multiplyScalar: function(k, n, v) {
                k[0] = n[0] * v;
                k[1] = n[1] * v;
                k[2] = n[2] * v;
                k[3] = n[3] * v;
                return k
            },
            multiplyScalarAndAdd: function(k, n, v, z) {
                k[0] = n[0] + v[0] * z;
                k[1] = n[1] + v[1] * z;
                k[2] = n[2] + v[2] * z;
                k[3] = n[3] + v[3] * z;
                return k
            },
            mul: b,
            sub: a
        }),
        nb = Object.freeze({
            __proto__: null,
            create: function() {
                var k = new ma(6);
                ma != Float32Array && (k[1] = 0, k[2] = 0, k[4] = 0, k[5] = 0);
                k[0] = 1;
                k[3] = 1;
                return k
            },
            clone: function(k) {
                var n = new ma(6);
                n[0] = k[0];
                n[1] = k[1];
                n[2] = k[2];
                n[3] = k[3];
                n[4] = k[4];
                n[5] = k[5];
                return n
            },
            copy: function(k, n) {
                k[0] =
                    n[0];
                k[1] = n[1];
                k[2] = n[2];
                k[3] = n[3];
                k[4] = n[4];
                k[5] = n[5];
                return k
            },
            identity: function(k) {
                k[0] = 1;
                k[1] = 0;
                k[2] = 0;
                k[3] = 1;
                k[4] = 0;
                k[5] = 0;
                return k
            },
            fromValues: function(k, n, v, z, B, D) {
                var F = new ma(6);
                F[0] = k;
                F[1] = n;
                F[2] = v;
                F[3] = z;
                F[4] = B;
                F[5] = D;
                return F
            },
            set: function(k, n, v, z, B, D, F) {
                k[0] = n;
                k[1] = v;
                k[2] = z;
                k[3] = B;
                k[4] = D;
                k[5] = F;
                return k
            },
            invert: function(k, n) {
                var v = n[0],
                    z = n[1],
                    B = n[2],
                    D = n[3],
                    F = n[4];
                n = n[5];
                var H = v * D - z * B;
                if (!H) return null;
                H = 1 / H;
                k[0] = D * H;
                k[1] = -z * H;
                k[2] = -B * H;
                k[3] = v * H;
                k[4] = (B * n - D * F) * H;
                k[5] = (z * F - v * n) * H;
                return k
            },
            determinant: function(k) {
                return k[0] * k[3] - k[1] * k[2]
            },
            multiply: f,
            rotate: function(k, n, v) {
                var z = n[0],
                    B = n[1],
                    D = n[2],
                    F = n[3],
                    H = n[4];
                n = n[5];
                var I = Math.sin(v);
                v = Math.cos(v);
                k[0] = z * v + D * I;
                k[1] = B * v + F * I;
                k[2] = z * -I + D * v;
                k[3] = B * -I + F * v;
                k[4] = H;
                k[5] = n;
                return k
            },
            scale: function(k, n, v) {
                var z = n[1],
                    B = n[2],
                    D = n[3],
                    F = n[4],
                    H = n[5],
                    I = v[0];
                v = v[1];
                k[0] = n[0] * I;
                k[1] = z * I;
                k[2] = B * v;
                k[3] = D * v;
                k[4] = F;
                k[5] = H;
                return k
            },
            translate: function(k, n, v) {
                var z = n[0],
                    B = n[1],
                    D = n[2],
                    F = n[3],
                    H = n[4];
                n = n[5];
                var I = v[0];
                v = v[1];
                k[0] = z;
                k[1] = B;
                k[2] = D;
                k[3] = F;
                k[4] =
                    z * I + D * v + H;
                k[5] = B * I + F * v + n;
                return k
            },
            fromRotation: function(k, n) {
                var v = Math.sin(n);
                n = Math.cos(n);
                k[0] = n;
                k[1] = v;
                k[2] = -v;
                k[3] = n;
                k[4] = 0;
                k[5] = 0;
                return k
            },
            fromScaling: function(k, n) {
                k[0] = n[0];
                k[1] = 0;
                k[2] = 0;
                k[3] = n[1];
                k[4] = 0;
                k[5] = 0;
                return k
            },
            fromTranslation: function(k, n) {
                k[0] = 1;
                k[1] = 0;
                k[2] = 0;
                k[3] = 1;
                k[4] = n[0];
                k[5] = n[1];
                return k
            },
            str: function(k) {
                return "mat2d(" + k[0] + ", " + k[1] + ", " + k[2] + ", " + k[3] + ", " + k[4] + ", " + k[5] + ")"
            },
            frob: function(k) {
                return Math.hypot(k[0], k[1], k[2], k[3], k[4], k[5], 1)
            },
            add: function(k, n, v) {
                k[0] =
                    n[0] + v[0];
                k[1] = n[1] + v[1];
                k[2] = n[2] + v[2];
                k[3] = n[3] + v[3];
                k[4] = n[4] + v[4];
                k[5] = n[5] + v[5];
                return k
            },
            subtract: c,
            multiplyScalar: function(k, n, v) {
                k[0] = n[0] * v;
                k[1] = n[1] * v;
                k[2] = n[2] * v;
                k[3] = n[3] * v;
                k[4] = n[4] * v;
                k[5] = n[5] * v;
                return k
            },
            multiplyScalarAndAdd: function(k, n, v, z) {
                k[0] = n[0] + v[0] * z;
                k[1] = n[1] + v[1] * z;
                k[2] = n[2] + v[2] * z;
                k[3] = n[3] + v[3] * z;
                k[4] = n[4] + v[4] * z;
                k[5] = n[5] + v[5] * z;
                return k
            },
            exactEquals: function(k, n) {
                return k[0] === n[0] && k[1] === n[1] && k[2] === n[2] && k[3] === n[3] && k[4] === n[4] && k[5] === n[5]
            },
            equals: function(k, n) {
                var v =
                    k[0],
                    z = k[1],
                    B = k[2],
                    D = k[3],
                    F = k[4];
                k = k[5];
                var H = n[0],
                    I = n[1],
                    M = n[2],
                    Q = n[3],
                    S = n[4];
                n = n[5];
                return Math.abs(v - H) <= 1E-6 * Math.max(1, Math.abs(v), Math.abs(H)) && Math.abs(z - I) <= 1E-6 * Math.max(1, Math.abs(z), Math.abs(I)) && Math.abs(B - M) <= 1E-6 * Math.max(1, Math.abs(B), Math.abs(M)) && Math.abs(D - Q) <= 1E-6 * Math.max(1, Math.abs(D), Math.abs(Q)) && Math.abs(F - S) <= 1E-6 * Math.max(1, Math.abs(F), Math.abs(S)) && Math.abs(k - n) <= 1E-6 * Math.max(1, Math.abs(k), Math.abs(n))
            },
            mul: f,
            sub: c
        }),
        ob = Object.freeze({
            __proto__: null,
            create: e,
            fromMat4: function(k,
                n) {
                k[0] = n[0];
                k[1] = n[1];
                k[2] = n[2];
                k[3] = n[4];
                k[4] = n[5];
                k[5] = n[6];
                k[6] = n[8];
                k[7] = n[9];
                k[8] = n[10];
                return k
            },
            clone: function(k) {
                var n = new ma(9);
                n[0] = k[0];
                n[1] = k[1];
                n[2] = k[2];
                n[3] = k[3];
                n[4] = k[4];
                n[5] = k[5];
                n[6] = k[6];
                n[7] = k[7];
                n[8] = k[8];
                return n
            },
            copy: function(k, n) {
                k[0] = n[0];
                k[1] = n[1];
                k[2] = n[2];
                k[3] = n[3];
                k[4] = n[4];
                k[5] = n[5];
                k[6] = n[6];
                k[7] = n[7];
                k[8] = n[8];
                return k
            },
            fromValues: function(k, n, v, z, B, D, F, H, I) {
                var M = new ma(9);
                M[0] = k;
                M[1] = n;
                M[2] = v;
                M[3] = z;
                M[4] = B;
                M[5] = D;
                M[6] = F;
                M[7] = H;
                M[8] = I;
                return M
            },
            set: function(k, n,
                v, z, B, D, F, H, I, M) {
                k[0] = n;
                k[1] = v;
                k[2] = z;
                k[3] = B;
                k[4] = D;
                k[5] = F;
                k[6] = H;
                k[7] = I;
                k[8] = M;
                return k
            },
            identity: function(k) {
                k[0] = 1;
                k[1] = 0;
                k[2] = 0;
                k[3] = 0;
                k[4] = 1;
                k[5] = 0;
                k[6] = 0;
                k[7] = 0;
                k[8] = 1;
                return k
            },
            transpose: function(k, n) {
                if (k === n) {
                    var v = n[1],
                        z = n[2],
                        B = n[5];
                    k[1] = n[3];
                    k[2] = n[6];
                    k[3] = v;
                    k[5] = n[7];
                    k[6] = z;
                    k[7] = B
                } else k[0] = n[0], k[1] = n[3], k[2] = n[6], k[3] = n[1], k[4] = n[4], k[5] = n[7], k[6] = n[2], k[7] = n[5], k[8] = n[8];
                return k
            },
            invert: function(k, n) {
                var v = n[0],
                    z = n[1],
                    B = n[2],
                    D = n[3],
                    F = n[4],
                    H = n[5],
                    I = n[6],
                    M = n[7];
                n = n[8];
                var Q = n * F - H * M,
                    S = -n * D + H * I,
                    W = M * D - F * I,
                    U = v * Q + z * S + B * W;
                if (!U) return null;
                U = 1 / U;
                k[0] = Q * U;
                k[1] = (-n * z + B * M) * U;
                k[2] = (H * z - B * F) * U;
                k[3] = S * U;
                k[4] = (n * v - B * I) * U;
                k[5] = (-H * v + B * D) * U;
                k[6] = W * U;
                k[7] = (-M * v + z * I) * U;
                k[8] = (F * v - z * D) * U;
                return k
            },
            adjoint: function(k, n) {
                var v = n[0],
                    z = n[1],
                    B = n[2],
                    D = n[3],
                    F = n[4],
                    H = n[5],
                    I = n[6],
                    M = n[7];
                n = n[8];
                k[0] = F * n - H * M;
                k[1] = B * M - z * n;
                k[2] = z * H - B * F;
                k[3] = H * I - D * n;
                k[4] = v * n - B * I;
                k[5] = B * D - v * H;
                k[6] = D * M - F * I;
                k[7] = z * I - v * M;
                k[8] = v * F - z * D;
                return k
            },
            determinant: function(k) {
                var n = k[3],
                    v = k[4],
                    z = k[5],
                    B = k[6],
                    D = k[7],
                    F = k[8];
                return k[0] * (F *
                    v - z * D) + k[1] * (-F * n + z * B) + k[2] * (D * n - v * B)
            },
            multiply: g,
            translate: function(k, n, v) {
                var z = n[0],
                    B = n[1],
                    D = n[2],
                    F = n[3],
                    H = n[4],
                    I = n[5],
                    M = n[6],
                    Q = n[7];
                n = n[8];
                var S = v[0];
                v = v[1];
                k[0] = z;
                k[1] = B;
                k[2] = D;
                k[3] = F;
                k[4] = H;
                k[5] = I;
                k[6] = S * z + v * F + M;
                k[7] = S * B + v * H + Q;
                k[8] = S * D + v * I + n;
                return k
            },
            rotate: function(k, n, v) {
                var z = n[0],
                    B = n[1],
                    D = n[2],
                    F = n[3],
                    H = n[4],
                    I = n[5],
                    M = n[6],
                    Q = n[7];
                n = n[8];
                var S = Math.sin(v);
                v = Math.cos(v);
                k[0] = v * z + S * F;
                k[1] = v * B + S * H;
                k[2] = v * D + S * I;
                k[3] = v * F - S * z;
                k[4] = v * H - S * B;
                k[5] = v * I - S * D;
                k[6] = M;
                k[7] = Q;
                k[8] = n;
                return k
            },
            scale: function(k,
                n, v) {
                var z = v[0];
                v = v[1];
                k[0] = z * n[0];
                k[1] = z * n[1];
                k[2] = z * n[2];
                k[3] = v * n[3];
                k[4] = v * n[4];
                k[5] = v * n[5];
                k[6] = n[6];
                k[7] = n[7];
                k[8] = n[8];
                return k
            },
            fromTranslation: function(k, n) {
                k[0] = 1;
                k[1] = 0;
                k[2] = 0;
                k[3] = 0;
                k[4] = 1;
                k[5] = 0;
                k[6] = n[0];
                k[7] = n[1];
                k[8] = 1;
                return k
            },
            fromRotation: function(k, n) {
                var v = Math.sin(n);
                n = Math.cos(n);
                k[0] = n;
                k[1] = v;
                k[2] = 0;
                k[3] = -v;
                k[4] = n;
                k[5] = 0;
                k[6] = 0;
                k[7] = 0;
                k[8] = 1;
                return k
            },
            fromScaling: function(k, n) {
                k[0] = n[0];
                k[1] = 0;
                k[2] = 0;
                k[3] = 0;
                k[4] = n[1];
                k[5] = 0;
                k[6] = 0;
                k[7] = 0;
                k[8] = 1;
                return k
            },
            fromMat2d: function(k,
                n) {
                k[0] = n[0];
                k[1] = n[1];
                k[2] = 0;
                k[3] = n[2];
                k[4] = n[3];
                k[5] = 0;
                k[6] = n[4];
                k[7] = n[5];
                k[8] = 1;
                return k
            },
            fromQuat: function(k, n) {
                var v = n[0],
                    z = n[1],
                    B = n[2];
                n = n[3];
                var D = v + v,
                    F = z + z,
                    H = B + B;
                v *= D;
                var I = z * D;
                z *= F;
                var M = B * D,
                    Q = B * F;
                B *= H;
                D *= n;
                F *= n;
                n *= H;
                k[0] = 1 - z - B;
                k[3] = I - n;
                k[6] = M + F;
                k[1] = I + n;
                k[4] = 1 - v - B;
                k[7] = Q - D;
                k[2] = M - F;
                k[5] = Q + D;
                k[8] = 1 - v - z;
                return k
            },
            normalFromMat4: function(k, n) {
                var v = n[0],
                    z = n[1],
                    B = n[2],
                    D = n[3],
                    F = n[4],
                    H = n[5],
                    I = n[6],
                    M = n[7],
                    Q = n[8],
                    S = n[9],
                    W = n[10],
                    U = n[11],
                    ca = n[12],
                    ba = n[13],
                    Y = n[14];
                n = n[15];
                var qa = v * H - z * F,
                    la = v * I - B *
                    F,
                    oa = v * M - D * F,
                    pa = z * I - B * H,
                    na = z * M - D * H,
                    ya = B * M - D * I,
                    L = Q * ba - S * ca,
                    N = Q * Y - W * ca;
                Q = Q * n - U * ca;
                var V = S * Y - W * ba;
                S = S * n - U * ba;
                W = W * n - U * Y;
                U = qa * W - la * S + oa * V + pa * Q - na * N + ya * L;
                if (!U) return null;
                U = 1 / U;
                k[0] = (H * W - I * S + M * V) * U;
                k[1] = (I * Q - F * W - M * N) * U;
                k[2] = (F * S - H * Q + M * L) * U;
                k[3] = (B * S - z * W - D * V) * U;
                k[4] = (v * W - B * Q + D * N) * U;
                k[5] = (z * Q - v * S - D * L) * U;
                k[6] = (ba * ya - Y * na + n * pa) * U;
                k[7] = (Y * oa - ca * ya - n * la) * U;
                k[8] = (ca * na - ba * oa + n * qa) * U;
                return k
            },
            projection: function(k, n, v) {
                k[0] = 2 / n;
                k[1] = 0;
                k[2] = 0;
                k[3] = 0;
                k[4] = -2 / v;
                k[5] = 0;
                k[6] = -1;
                k[7] = 1;
                k[8] = 1;
                return k
            },
            str: function(k) {
                return "mat3(" +
                    k[0] + ", " + k[1] + ", " + k[2] + ", " + k[3] + ", " + k[4] + ", " + k[5] + ", " + k[6] + ", " + k[7] + ", " + k[8] + ")"
            },
            frob: function(k) {
                return Math.hypot(k[0], k[1], k[2], k[3], k[4], k[5], k[6], k[7], k[8])
            },
            add: function(k, n, v) {
                k[0] = n[0] + v[0];
                k[1] = n[1] + v[1];
                k[2] = n[2] + v[2];
                k[3] = n[3] + v[3];
                k[4] = n[4] + v[4];
                k[5] = n[5] + v[5];
                k[6] = n[6] + v[6];
                k[7] = n[7] + v[7];
                k[8] = n[8] + v[8];
                return k
            },
            subtract: h,
            multiplyScalar: function(k, n, v) {
                k[0] = n[0] * v;
                k[1] = n[1] * v;
                k[2] = n[2] * v;
                k[3] = n[3] * v;
                k[4] = n[4] * v;
                k[5] = n[5] * v;
                k[6] = n[6] * v;
                k[7] = n[7] * v;
                k[8] = n[8] * v;
                return k
            },
            multiplyScalarAndAdd: function(k,
                n, v, z) {
                k[0] = n[0] + v[0] * z;
                k[1] = n[1] + v[1] * z;
                k[2] = n[2] + v[2] * z;
                k[3] = n[3] + v[3] * z;
                k[4] = n[4] + v[4] * z;
                k[5] = n[5] + v[5] * z;
                k[6] = n[6] + v[6] * z;
                k[7] = n[7] + v[7] * z;
                k[8] = n[8] + v[8] * z;
                return k
            },
            exactEquals: function(k, n) {
                return k[0] === n[0] && k[1] === n[1] && k[2] === n[2] && k[3] === n[3] && k[4] === n[4] && k[5] === n[5] && k[6] === n[6] && k[7] === n[7] && k[8] === n[8]
            },
            equals: function(k, n) {
                var v = k[0],
                    z = k[1],
                    B = k[2],
                    D = k[3],
                    F = k[4],
                    H = k[5],
                    I = k[6],
                    M = k[7];
                k = k[8];
                var Q = n[0],
                    S = n[1],
                    W = n[2],
                    U = n[3],
                    ca = n[4],
                    ba = n[5],
                    Y = n[6],
                    qa = n[7];
                n = n[8];
                return Math.abs(v - Q) <= 1E-6 *
                    Math.max(1, Math.abs(v), Math.abs(Q)) && Math.abs(z - S) <= 1E-6 * Math.max(1, Math.abs(z), Math.abs(S)) && Math.abs(B - W) <= 1E-6 * Math.max(1, Math.abs(B), Math.abs(W)) && Math.abs(D - U) <= 1E-6 * Math.max(1, Math.abs(D), Math.abs(U)) && Math.abs(F - ca) <= 1E-6 * Math.max(1, Math.abs(F), Math.abs(ca)) && Math.abs(H - ba) <= 1E-6 * Math.max(1, Math.abs(H), Math.abs(ba)) && Math.abs(I - Y) <= 1E-6 * Math.max(1, Math.abs(I), Math.abs(Y)) && Math.abs(M - qa) <= 1E-6 * Math.max(1, Math.abs(M), Math.abs(qa)) && Math.abs(k - n) <= 1E-6 * Math.max(1, Math.abs(k), Math.abs(n))
            },
            mul: g,
            sub: h
        }),
        pb = Object.freeze({
            __proto__: null,
            create: function() {
                var k = new ma(16);
                ma != Float32Array && (k[1] = 0, k[2] = 0, k[3] = 0, k[4] = 0, k[6] = 0, k[7] = 0, k[8] = 0, k[9] = 0, k[11] = 0, k[12] = 0, k[13] = 0, k[14] = 0);
                k[0] = 1;
                k[5] = 1;
                k[10] = 1;
                k[15] = 1;
                return k
            },
            clone: function(k) {
                var n = new ma(16);
                n[0] = k[0];
                n[1] = k[1];
                n[2] = k[2];
                n[3] = k[3];
                n[4] = k[4];
                n[5] = k[5];
                n[6] = k[6];
                n[7] = k[7];
                n[8] = k[8];
                n[9] = k[9];
                n[10] = k[10];
                n[11] = k[11];
                n[12] = k[12];
                n[13] = k[13];
                n[14] = k[14];
                n[15] = k[15];
                return n
            },
            copy: function(k, n) {
                k[0] = n[0];
                k[1] = n[1];
                k[2] = n[2];
                k[3] = n[3];
                k[4] =
                    n[4];
                k[5] = n[5];
                k[6] = n[6];
                k[7] = n[7];
                k[8] = n[8];
                k[9] = n[9];
                k[10] = n[10];
                k[11] = n[11];
                k[12] = n[12];
                k[13] = n[13];
                k[14] = n[14];
                k[15] = n[15];
                return k
            },
            fromValues: function(k, n, v, z, B, D, F, H, I, M, Q, S, W, U, ca, ba) {
                var Y = new ma(16);
                Y[0] = k;
                Y[1] = n;
                Y[2] = v;
                Y[3] = z;
                Y[4] = B;
                Y[5] = D;
                Y[6] = F;
                Y[7] = H;
                Y[8] = I;
                Y[9] = M;
                Y[10] = Q;
                Y[11] = S;
                Y[12] = W;
                Y[13] = U;
                Y[14] = ca;
                Y[15] = ba;
                return Y
            },
            set: function(k, n, v, z, B, D, F, H, I, M, Q, S, W, U, ca, ba, Y) {
                k[0] = n;
                k[1] = v;
                k[2] = z;
                k[3] = B;
                k[4] = D;
                k[5] = F;
                k[6] = H;
                k[7] = I;
                k[8] = M;
                k[9] = Q;
                k[10] = S;
                k[11] = W;
                k[12] = U;
                k[13] = ca;
                k[14] = ba;
                k[15] = Y;
                return k
            },
            identity: l,
            transpose: function(k, n) {
                if (k === n) {
                    var v = n[1],
                        z = n[2],
                        B = n[3],
                        D = n[6],
                        F = n[7],
                        H = n[11];
                    k[1] = n[4];
                    k[2] = n[8];
                    k[3] = n[12];
                    k[4] = v;
                    k[6] = n[9];
                    k[7] = n[13];
                    k[8] = z;
                    k[9] = D;
                    k[11] = n[14];
                    k[12] = B;
                    k[13] = F;
                    k[14] = H
                } else k[0] = n[0], k[1] = n[4], k[2] = n[8], k[3] = n[12], k[4] = n[1], k[5] = n[5], k[6] = n[9], k[7] = n[13], k[8] = n[2], k[9] = n[6], k[10] = n[10], k[11] = n[14], k[12] = n[3], k[13] = n[7], k[14] = n[11], k[15] = n[15];
                return k
            },
            invert: function(k, n) {
                var v = n[0],
                    z = n[1],
                    B = n[2],
                    D = n[3],
                    F = n[4],
                    H = n[5],
                    I = n[6],
                    M = n[7],
                    Q = n[8],
                    S = n[9],
                    W = n[10],
                    U = n[11],
                    ca = n[12],
                    ba = n[13],
                    Y = n[14];
                n = n[15];
                var qa = v * H - z * F,
                    la = v * I - B * F,
                    oa = v * M - D * F,
                    pa = z * I - B * H,
                    na = z * M - D * H,
                    ya = B * M - D * I,
                    L = Q * ba - S * ca,
                    N = Q * Y - W * ca,
                    V = Q * n - U * ca,
                    Z = S * Y - W * ba,
                    fa = S * n - U * ba,
                    ha = W * n - U * Y,
                    da = qa * ha - la * fa + oa * Z + pa * V - na * N + ya * L;
                if (!da) return null;
                da = 1 / da;
                k[0] = (H * ha - I * fa + M * Z) * da;
                k[1] = (B * fa - z * ha - D * Z) * da;
                k[2] = (ba * ya - Y * na + n * pa) * da;
                k[3] = (W * na - S * ya - U * pa) * da;
                k[4] = (I * V - F * ha - M * N) * da;
                k[5] = (v * ha - B * V + D * N) * da;
                k[6] = (Y * oa - ca * ya - n * la) * da;
                k[7] = (Q * ya - W * oa + U * la) * da;
                k[8] = (F * fa - H * V + M * L) * da;
                k[9] = (z * V - v * fa - D * L) * da;
                k[10] = (ca *
                    na - ba * oa + n * qa) * da;
                k[11] = (S * oa - Q * na - U * qa) * da;
                k[12] = (H * N - F * Z - I * L) * da;
                k[13] = (v * Z - z * N + B * L) * da;
                k[14] = (ba * la - ca * pa - Y * qa) * da;
                k[15] = (Q * pa - S * la + W * qa) * da;
                return k
            },
            adjoint: function(k, n) {
                var v = n[0],
                    z = n[1],
                    B = n[2],
                    D = n[3],
                    F = n[4],
                    H = n[5],
                    I = n[6],
                    M = n[7],
                    Q = n[8],
                    S = n[9],
                    W = n[10],
                    U = n[11],
                    ca = n[12],
                    ba = n[13],
                    Y = n[14];
                n = n[15];
                k[0] = H * (W * n - U * Y) - S * (I * n - M * Y) + ba * (I * U - M * W);
                k[1] = -(z * (W * n - U * Y) - S * (B * n - D * Y) + ba * (B * U - D * W));
                k[2] = z * (I * n - M * Y) - H * (B * n - D * Y) + ba * (B * M - D * I);
                k[3] = -(z * (I * U - M * W) - H * (B * U - D * W) + S * (B * M - D * I));
                k[4] = -(F * (W * n - U * Y) - Q * (I * n - M *
                    Y) + ca * (I * U - M * W));
                k[5] = v * (W * n - U * Y) - Q * (B * n - D * Y) + ca * (B * U - D * W);
                k[6] = -(v * (I * n - M * Y) - F * (B * n - D * Y) + ca * (B * M - D * I));
                k[7] = v * (I * U - M * W) - F * (B * U - D * W) + Q * (B * M - D * I);
                k[8] = F * (S * n - U * ba) - Q * (H * n - M * ba) + ca * (H * U - M * S);
                k[9] = -(v * (S * n - U * ba) - Q * (z * n - D * ba) + ca * (z * U - D * S));
                k[10] = v * (H * n - M * ba) - F * (z * n - D * ba) + ca * (z * M - D * H);
                k[11] = -(v * (H * U - M * S) - F * (z * U - D * S) + Q * (z * M - D * H));
                k[12] = -(F * (S * Y - W * ba) - Q * (H * Y - I * ba) + ca * (H * W - I * S));
                k[13] = v * (S * Y - W * ba) - Q * (z * Y - B * ba) + ca * (z * W - B * S);
                k[14] = -(v * (H * Y - I * ba) - F * (z * Y - B * ba) + ca * (z * I - B * H));
                k[15] = v * (H * W - I * S) - F * (z * W - B * S) + Q * (z *
                    I - B * H);
                return k
            },
            determinant: function(k) {
                var n = k[0],
                    v = k[1],
                    z = k[2],
                    B = k[3],
                    D = k[4],
                    F = k[5],
                    H = k[6],
                    I = k[7],
                    M = k[8],
                    Q = k[9],
                    S = k[10],
                    W = k[11],
                    U = k[12],
                    ca = k[13],
                    ba = k[14];
                k = k[15];
                return (n * F - v * D) * (S * k - W * ba) - (n * H - z * D) * (Q * k - W * ca) + (n * I - B * D) * (Q * ba - S * ca) + (v * H - z * F) * (M * k - W * U) - (v * I - B * F) * (M * ba - S * U) + (z * I - B * H) * (M * ca - Q * U)
            },
            multiply: m,
            translate: function(k, n, v) {
                var z = v[0],
                    B = v[1];
                v = v[2];
                if (n === k) k[12] = n[0] * z + n[4] * B + n[8] * v + n[12], k[13] = n[1] * z + n[5] * B + n[9] * v + n[13], k[14] = n[2] * z + n[6] * B + n[10] * v + n[14], k[15] = n[3] * z + n[7] * B + n[11] * v + n[15];
                else {
                    var D = n[0];
                    var F = n[1];
                    var H = n[2];
                    var I = n[3];
                    var M = n[4];
                    var Q = n[5];
                    var S = n[6];
                    var W = n[7];
                    var U = n[8];
                    var ca = n[9];
                    var ba = n[10];
                    var Y = n[11];
                    k[0] = D;
                    k[1] = F;
                    k[2] = H;
                    k[3] = I;
                    k[4] = M;
                    k[5] = Q;
                    k[6] = S;
                    k[7] = W;
                    k[8] = U;
                    k[9] = ca;
                    k[10] = ba;
                    k[11] = Y;
                    k[12] = D * z + M * B + U * v + n[12];
                    k[13] = F * z + Q * B + ca * v + n[13];
                    k[14] = H * z + S * B + ba * v + n[14];
                    k[15] = I * z + W * B + Y * v + n[15]
                }
                return k
            },
            scale: function(k, n, v) {
                var z = v[0],
                    B = v[1];
                v = v[2];
                k[0] = n[0] * z;
                k[1] = n[1] * z;
                k[2] = n[2] * z;
                k[3] = n[3] * z;
                k[4] = n[4] * B;
                k[5] = n[5] * B;
                k[6] = n[6] * B;
                k[7] = n[7] * B;
                k[8] = n[8] * v;
                k[9] = n[9] *
                    v;
                k[10] = n[10] * v;
                k[11] = n[11] * v;
                k[12] = n[12];
                k[13] = n[13];
                k[14] = n[14];
                k[15] = n[15];
                return k
            },
            rotate: function(k, n, v, z) {
                var B = z[0],
                    D = z[1];
                z = z[2];
                var F = Math.hypot(B, D, z);
                if (1E-6 > F) return null;
                F = 1 / F;
                B *= F;
                D *= F;
                z *= F;
                var H = Math.sin(v);
                var I = Math.cos(v);
                var M = 1 - I;
                v = n[0];
                F = n[1];
                var Q = n[2];
                var S = n[3];
                var W = n[4];
                var U = n[5];
                var ca = n[6];
                var ba = n[7];
                var Y = n[8];
                var qa = n[9];
                var la = n[10];
                var oa = n[11];
                var pa = B * B * M + I;
                var na = D * B * M + z * H;
                var ya = z * B * M - D * H;
                var L = B * D * M - z * H;
                var N = D * D * M + I;
                var V = z * D * M + B * H;
                var Z = B * z * M + D * H;
                B = D * z * M -
                    B * H;
                D = z * z * M + I;
                k[0] = v * pa + W * na + Y * ya;
                k[1] = F * pa + U * na + qa * ya;
                k[2] = Q * pa + ca * na + la * ya;
                k[3] = S * pa + ba * na + oa * ya;
                k[4] = v * L + W * N + Y * V;
                k[5] = F * L + U * N + qa * V;
                k[6] = Q * L + ca * N + la * V;
                k[7] = S * L + ba * N + oa * V;
                k[8] = v * Z + W * B + Y * D;
                k[9] = F * Z + U * B + qa * D;
                k[10] = Q * Z + ca * B + la * D;
                k[11] = S * Z + ba * B + oa * D;
                n !== k && (k[12] = n[12], k[13] = n[13], k[14] = n[14], k[15] = n[15]);
                return k
            },
            rotateX: function(k, n, v) {
                var z = Math.sin(v);
                v = Math.cos(v);
                var B = n[4],
                    D = n[5],
                    F = n[6],
                    H = n[7],
                    I = n[8],
                    M = n[9],
                    Q = n[10],
                    S = n[11];
                n !== k && (k[0] = n[0], k[1] = n[1], k[2] = n[2], k[3] = n[3], k[12] = n[12], k[13] = n[13],
                    k[14] = n[14], k[15] = n[15]);
                k[4] = B * v + I * z;
                k[5] = D * v + M * z;
                k[6] = F * v + Q * z;
                k[7] = H * v + S * z;
                k[8] = I * v - B * z;
                k[9] = M * v - D * z;
                k[10] = Q * v - F * z;
                k[11] = S * v - H * z;
                return k
            },
            rotateY: function(k, n, v) {
                var z = Math.sin(v);
                v = Math.cos(v);
                var B = n[0],
                    D = n[1],
                    F = n[2],
                    H = n[3],
                    I = n[8],
                    M = n[9],
                    Q = n[10],
                    S = n[11];
                n !== k && (k[4] = n[4], k[5] = n[5], k[6] = n[6], k[7] = n[7], k[12] = n[12], k[13] = n[13], k[14] = n[14], k[15] = n[15]);
                k[0] = B * v - I * z;
                k[1] = D * v - M * z;
                k[2] = F * v - Q * z;
                k[3] = H * v - S * z;
                k[8] = B * z + I * v;
                k[9] = D * z + M * v;
                k[10] = F * z + Q * v;
                k[11] = H * z + S * v;
                return k
            },
            rotateZ: function(k, n, v) {
                var z =
                    Math.sin(v);
                v = Math.cos(v);
                var B = n[0],
                    D = n[1],
                    F = n[2],
                    H = n[3],
                    I = n[4],
                    M = n[5],
                    Q = n[6],
                    S = n[7];
                n !== k && (k[8] = n[8], k[9] = n[9], k[10] = n[10], k[11] = n[11], k[12] = n[12], k[13] = n[13], k[14] = n[14], k[15] = n[15]);
                k[0] = B * v + I * z;
                k[1] = D * v + M * z;
                k[2] = F * v + Q * z;
                k[3] = H * v + S * z;
                k[4] = I * v - B * z;
                k[5] = M * v - D * z;
                k[6] = Q * v - F * z;
                k[7] = S * v - H * z;
                return k
            },
            fromTranslation: function(k, n) {
                k[0] = 1;
                k[1] = 0;
                k[2] = 0;
                k[3] = 0;
                k[4] = 0;
                k[5] = 1;
                k[6] = 0;
                k[7] = 0;
                k[8] = 0;
                k[9] = 0;
                k[10] = 1;
                k[11] = 0;
                k[12] = n[0];
                k[13] = n[1];
                k[14] = n[2];
                k[15] = 1;
                return k
            },
            fromScaling: function(k, n) {
                k[0] = n[0];
                k[1] = 0;
                k[2] = 0;
                k[3] = 0;
                k[4] = 0;
                k[5] = n[1];
                k[6] = 0;
                k[7] = 0;
                k[8] = 0;
                k[9] = 0;
                k[10] = n[2];
                k[11] = 0;
                k[12] = 0;
                k[13] = 0;
                k[14] = 0;
                k[15] = 1;
                return k
            },
            fromRotation: function(k, n, v) {
                var z = v[0],
                    B = v[1];
                v = v[2];
                var D = Math.hypot(z, B, v);
                if (1E-6 > D) return null;
                D = 1 / D;
                z *= D;
                B *= D;
                v *= D;
                D = Math.sin(n);
                n = Math.cos(n);
                var F = 1 - n;
                k[0] = z * z * F + n;
                k[1] = B * z * F + v * D;
                k[2] = v * z * F - B * D;
                k[3] = 0;
                k[4] = z * B * F - v * D;
                k[5] = B * B * F + n;
                k[6] = v * B * F + z * D;
                k[7] = 0;
                k[8] = z * v * F + B * D;
                k[9] = B * v * F - z * D;
                k[10] = v * v * F + n;
                k[11] = 0;
                k[12] = 0;
                k[13] = 0;
                k[14] = 0;
                k[15] = 1;
                return k
            },
            fromXRotation: function(k,
                n) {
                var v = Math.sin(n);
                n = Math.cos(n);
                k[0] = 1;
                k[1] = 0;
                k[2] = 0;
                k[3] = 0;
                k[4] = 0;
                k[5] = n;
                k[6] = v;
                k[7] = 0;
                k[8] = 0;
                k[9] = -v;
                k[10] = n;
                k[11] = 0;
                k[12] = 0;
                k[13] = 0;
                k[14] = 0;
                k[15] = 1;
                return k
            },
            fromYRotation: function(k, n) {
                var v = Math.sin(n);
                n = Math.cos(n);
                k[0] = n;
                k[1] = 0;
                k[2] = -v;
                k[3] = 0;
                k[4] = 0;
                k[5] = 1;
                k[6] = 0;
                k[7] = 0;
                k[8] = v;
                k[9] = 0;
                k[10] = n;
                k[11] = 0;
                k[12] = 0;
                k[13] = 0;
                k[14] = 0;
                k[15] = 1;
                return k
            },
            fromZRotation: function(k, n) {
                var v = Math.sin(n);
                n = Math.cos(n);
                k[0] = n;
                k[1] = v;
                k[2] = 0;
                k[3] = 0;
                k[4] = -v;
                k[5] = n;
                k[6] = 0;
                k[7] = 0;
                k[8] = 0;
                k[9] = 0;
                k[10] = 1;
                k[11] = 0;
                k[12] =
                    0;
                k[13] = 0;
                k[14] = 0;
                k[15] = 1;
                return k
            },
            fromRotationTranslation: p,
            fromQuat2: function(k, n) {
                var v = new ma(3),
                    z = -n[0],
                    B = -n[1],
                    D = -n[2],
                    F = n[3],
                    H = n[4],
                    I = n[5],
                    M = n[6],
                    Q = n[7],
                    S = z * z + B * B + D * D + F * F;
                0 < S ? (v[0] = 2 * (H * F + Q * z + I * D - M * B) / S, v[1] = 2 * (I * F + Q * B + M * z - H * D) / S, v[2] = 2 * (M * F + Q * D + H * B - I * z) / S) : (v[0] = 2 * (H * F + Q * z + I * D - M * B), v[1] = 2 * (I * F + Q * B + M * z - H * D), v[2] = 2 * (M * F + Q * D + H * B - I * z));
                p(k, n, v);
                return k
            },
            getTranslation: t,
            getScaling: q,
            getRotation: r,
            fromRotationTranslationScale: function(k, n, v, z) {
                var B = n[0],
                    D = n[1],
                    F = n[2],
                    H = n[3],
                    I = B + B,
                    M = D + D,
                    Q = F +
                    F;
                n = B * I;
                var S = B * M;
                B *= Q;
                var W = D * M;
                D *= Q;
                F *= Q;
                I *= H;
                M *= H;
                H *= Q;
                Q = z[0];
                var U = z[1];
                z = z[2];
                k[0] = (1 - (W + F)) * Q;
                k[1] = (S + H) * Q;
                k[2] = (B - M) * Q;
                k[3] = 0;
                k[4] = (S - H) * U;
                k[5] = (1 - (n + F)) * U;
                k[6] = (D + I) * U;
                k[7] = 0;
                k[8] = (B + M) * z;
                k[9] = (D - I) * z;
                k[10] = (1 - (n + W)) * z;
                k[11] = 0;
                k[12] = v[0];
                k[13] = v[1];
                k[14] = v[2];
                k[15] = 1;
                return k
            },
            fromRotationTranslationScaleOrigin: function(k, n, v, z, B) {
                var D = n[0],
                    F = n[1],
                    H = n[2],
                    I = n[3],
                    M = D + D,
                    Q = F + F,
                    S = H + H;
                n = D * M;
                var W = D * Q,
                    U = D * S;
                D = F * Q;
                F *= S;
                var ca = H * S;
                H = I * M;
                Q *= I;
                var ba = I * S,
                    Y = z[0],
                    qa = z[1];
                S = z[2];
                z = B[0];
                I = B[1];
                B = B[2];
                M =
                    (1 - (D + ca)) * Y;
                var la = (W + ba) * Y;
                Y *= U - Q;
                W = (W - ba) * qa;
                ca = (1 - (n + ca)) * qa;
                qa *= F + H;
                U = (U + Q) * S;
                F = (F - H) * S;
                n = (1 - (n + D)) * S;
                k[0] = M;
                k[1] = la;
                k[2] = Y;
                k[3] = 0;
                k[4] = W;
                k[5] = ca;
                k[6] = qa;
                k[7] = 0;
                k[8] = U;
                k[9] = F;
                k[10] = n;
                k[11] = 0;
                k[12] = v[0] + z - (M * z + W * I + U * B);
                k[13] = v[1] + I - (la * z + ca * I + F * B);
                k[14] = v[2] + B - (Y * z + qa * I + n * B);
                k[15] = 1;
                return k
            },
            fromQuat: function(k, n) {
                var v = n[0],
                    z = n[1],
                    B = n[2];
                n = n[3];
                var D = v + v,
                    F = z + z,
                    H = B + B;
                v *= D;
                var I = z * D;
                z *= F;
                var M = B * D,
                    Q = B * F;
                B *= H;
                D *= n;
                F *= n;
                n *= H;
                k[0] = 1 - z - B;
                k[1] = I + n;
                k[2] = M - F;
                k[3] = 0;
                k[4] = I - n;
                k[5] = 1 - v - B;
                k[6] = Q + D;
                k[7] =
                    0;
                k[8] = M + F;
                k[9] = Q - D;
                k[10] = 1 - v - z;
                k[11] = 0;
                k[12] = 0;
                k[13] = 0;
                k[14] = 0;
                k[15] = 1;
                return k
            },
            frustum: function(k, n, v, z, B, D, F) {
                var H = 1 / (v - n),
                    I = 1 / (B - z),
                    M = 1 / (D - F);
                k[0] = 2 * D * H;
                k[1] = 0;
                k[2] = 0;
                k[3] = 0;
                k[4] = 0;
                k[5] = 2 * D * I;
                k[6] = 0;
                k[7] = 0;
                k[8] = (v + n) * H;
                k[9] = (B + z) * I;
                k[10] = (F + D) * M;
                k[11] = -1;
                k[12] = 0;
                k[13] = 0;
                k[14] = F * D * 2 * M;
                k[15] = 0;
                return k
            },
            perspective: function(k, n, v, z, B) {
                n = 1 / Math.tan(n / 2);
                k[0] = n / v;
                k[1] = 0;
                k[2] = 0;
                k[3] = 0;
                k[4] = 0;
                k[5] = n;
                k[6] = 0;
                k[7] = 0;
                k[8] = 0;
                k[9] = 0;
                k[11] = -1;
                k[12] = 0;
                k[13] = 0;
                k[15] = 0;
                null != B && Infinity !== B ? (v = 1 / (z - B), k[10] =
                    (B + z) * v, k[14] = 2 * B * z * v) : (k[10] = -1, k[14] = -2 * z);
                return k
            },
            perspectiveFromFieldOfView: function(k, n, v, z) {
                var B = Math.tan(n.upDegrees * Math.PI / 180),
                    D = Math.tan(n.downDegrees * Math.PI / 180),
                    F = Math.tan(n.leftDegrees * Math.PI / 180);
                n = Math.tan(n.rightDegrees * Math.PI / 180);
                var H = 2 / (F + n),
                    I = 2 / (B + D);
                k[0] = H;
                k[1] = 0;
                k[2] = 0;
                k[3] = 0;
                k[4] = 0;
                k[5] = I;
                k[6] = 0;
                k[7] = 0;
                k[8] = -((F - n) * H * .5);
                k[9] = (B - D) * I * .5;
                k[10] = z / (v - z);
                k[11] = -1;
                k[12] = 0;
                k[13] = 0;
                k[14] = z * v / (v - z);
                k[15] = 0;
                return k
            },
            ortho: function(k, n, v, z, B, D, F) {
                var H = 1 / (n - v),
                    I = 1 / (z - B),
                    M = 1 /
                    (D - F);
                k[0] = -2 * H;
                k[1] = 0;
                k[2] = 0;
                k[3] = 0;
                k[4] = 0;
                k[5] = -2 * I;
                k[6] = 0;
                k[7] = 0;
                k[8] = 0;
                k[9] = 0;
                k[10] = 2 * M;
                k[11] = 0;
                k[12] = (n + v) * H;
                k[13] = (B + z) * I;
                k[14] = (F + D) * M;
                k[15] = 1;
                return k
            },
            lookAt: function(k, n, v, z) {
                var B = n[0],
                    D = n[1];
                n = n[2];
                var F = z[0];
                var H = z[1];
                var I = z[2];
                var M = v[0];
                z = v[1];
                var Q = v[2];
                if (1E-6 > Math.abs(B - M) && 1E-6 > Math.abs(D - z) && 1E-6 > Math.abs(n - Q)) return l(k);
                v = B - M;
                z = D - z;
                M = n - Q;
                var S = 1 / Math.hypot(v, z, M);
                v *= S;
                z *= S;
                M *= S;
                Q = H * M - I * z;
                I = I * v - F * M;
                F = F * z - H * v;
                (S = Math.hypot(Q, I, F)) ? (S = 1 / S, Q *= S, I *= S, F *= S) : F = I = Q = 0;
                H = z * F - M * I;
                var W =
                    M * Q - v * F;
                var U = v * I - z * Q;
                (S = Math.hypot(H, W, U)) ? (S = 1 / S, H *= S, W *= S, U *= S) : U = W = H = 0;
                k[0] = Q;
                k[1] = H;
                k[2] = v;
                k[3] = 0;
                k[4] = I;
                k[5] = W;
                k[6] = z;
                k[7] = 0;
                k[8] = F;
                k[9] = U;
                k[10] = M;
                k[11] = 0;
                k[12] = -(Q * B + I * D + F * n);
                k[13] = -(H * B + W * D + U * n);
                k[14] = -(v * B + z * D + M * n);
                k[15] = 1;
                return k
            },
            targetTo: function(k, n, v, z) {
                var B = n[0],
                    D = n[1];
                n = n[2];
                var F = z[0],
                    H = z[1],
                    I = z[2];
                z = B - v[0];
                var M = D - v[1];
                v = n - v[2];
                var Q = z * z + M * M + v * v;
                0 < Q && (Q = 1 / Math.sqrt(Q), z *= Q, M *= Q, v *= Q);
                var S = H * v - I * M;
                I = I * z - F * v;
                F = F * M - H * z;
                Q = S * S + I * I + F * F;
                0 < Q && (Q = 1 / Math.sqrt(Q), S *= Q, I *= Q, F *= Q);
                k[0] = S;
                k[1] = I;
                k[2] = F;
                k[3] = 0;
                k[4] = M * F - v * I;
                k[5] = v * S - z * F;
                k[6] = z * I - M * S;
                k[7] = 0;
                k[8] = z;
                k[9] = M;
                k[10] = v;
                k[11] = 0;
                k[12] = B;
                k[13] = D;
                k[14] = n;
                k[15] = 1;
                return k
            },
            str: function(k) {
                return "mat4(" + k[0] + ", " + k[1] + ", " + k[2] + ", " + k[3] + ", " + k[4] + ", " + k[5] + ", " + k[6] + ", " + k[7] + ", " + k[8] + ", " + k[9] + ", " + k[10] + ", " + k[11] + ", " + k[12] + ", " + k[13] + ", " + k[14] + ", " + k[15] + ")"
            },
            frob: function(k) {
                return Math.hypot(k[0], k[1], k[2], k[3], k[4], k[5], k[6], k[7], k[8], k[9], k[10], k[11], k[12], k[13], k[14], k[15])
            },
            add: function(k, n, v) {
                k[0] = n[0] + v[0];
                k[1] = n[1] +
                    v[1];
                k[2] = n[2] + v[2];
                k[3] = n[3] + v[3];
                k[4] = n[4] + v[4];
                k[5] = n[5] + v[5];
                k[6] = n[6] + v[6];
                k[7] = n[7] + v[7];
                k[8] = n[8] + v[8];
                k[9] = n[9] + v[9];
                k[10] = n[10] + v[10];
                k[11] = n[11] + v[11];
                k[12] = n[12] + v[12];
                k[13] = n[13] + v[13];
                k[14] = n[14] + v[14];
                k[15] = n[15] + v[15];
                return k
            },
            subtract: u,
            multiplyScalar: function(k, n, v) {
                k[0] = n[0] * v;
                k[1] = n[1] * v;
                k[2] = n[2] * v;
                k[3] = n[3] * v;
                k[4] = n[4] * v;
                k[5] = n[5] * v;
                k[6] = n[6] * v;
                k[7] = n[7] * v;
                k[8] = n[8] * v;
                k[9] = n[9] * v;
                k[10] = n[10] * v;
                k[11] = n[11] * v;
                k[12] = n[12] * v;
                k[13] = n[13] * v;
                k[14] = n[14] * v;
                k[15] = n[15] * v;
                return k
            },
            multiplyScalarAndAdd: function(k,
                n, v, z) {
                k[0] = n[0] + v[0] * z;
                k[1] = n[1] + v[1] * z;
                k[2] = n[2] + v[2] * z;
                k[3] = n[3] + v[3] * z;
                k[4] = n[4] + v[4] * z;
                k[5] = n[5] + v[5] * z;
                k[6] = n[6] + v[6] * z;
                k[7] = n[7] + v[7] * z;
                k[8] = n[8] + v[8] * z;
                k[9] = n[9] + v[9] * z;
                k[10] = n[10] + v[10] * z;
                k[11] = n[11] + v[11] * z;
                k[12] = n[12] + v[12] * z;
                k[13] = n[13] + v[13] * z;
                k[14] = n[14] + v[14] * z;
                k[15] = n[15] + v[15] * z;
                return k
            },
            exactEquals: function(k, n) {
                return k[0] === n[0] && k[1] === n[1] && k[2] === n[2] && k[3] === n[3] && k[4] === n[4] && k[5] === n[5] && k[6] === n[6] && k[7] === n[7] && k[8] === n[8] && k[9] === n[9] && k[10] === n[10] && k[11] === n[11] && k[12] ===
                    n[12] && k[13] === n[13] && k[14] === n[14] && k[15] === n[15]
            },
            equals: function(k, n) {
                var v = k[0],
                    z = k[1],
                    B = k[2],
                    D = k[3],
                    F = k[4],
                    H = k[5],
                    I = k[6],
                    M = k[7],
                    Q = k[8],
                    S = k[9],
                    W = k[10],
                    U = k[11],
                    ca = k[12],
                    ba = k[13],
                    Y = k[14];
                k = k[15];
                var qa = n[0],
                    la = n[1],
                    oa = n[2],
                    pa = n[3],
                    na = n[4],
                    ya = n[5],
                    L = n[6],
                    N = n[7],
                    V = n[8],
                    Z = n[9],
                    fa = n[10],
                    ha = n[11],
                    da = n[12],
                    ra = n[13],
                    ta = n[14];
                n = n[15];
                return Math.abs(v - qa) <= 1E-6 * Math.max(1, Math.abs(v), Math.abs(qa)) && Math.abs(z - la) <= 1E-6 * Math.max(1, Math.abs(z), Math.abs(la)) && Math.abs(B - oa) <= 1E-6 * Math.max(1, Math.abs(B), Math.abs(oa)) &&
                    Math.abs(D - pa) <= 1E-6 * Math.max(1, Math.abs(D), Math.abs(pa)) && Math.abs(F - na) <= 1E-6 * Math.max(1, Math.abs(F), Math.abs(na)) && Math.abs(H - ya) <= 1E-6 * Math.max(1, Math.abs(H), Math.abs(ya)) && Math.abs(I - L) <= 1E-6 * Math.max(1, Math.abs(I), Math.abs(L)) && Math.abs(M - N) <= 1E-6 * Math.max(1, Math.abs(M), Math.abs(N)) && Math.abs(Q - V) <= 1E-6 * Math.max(1, Math.abs(Q), Math.abs(V)) && Math.abs(S - Z) <= 1E-6 * Math.max(1, Math.abs(S), Math.abs(Z)) && Math.abs(W - fa) <= 1E-6 * Math.max(1, Math.abs(W), Math.abs(fa)) && Math.abs(U - ha) <= 1E-6 * Math.max(1, Math.abs(U),
                        Math.abs(ha)) && Math.abs(ca - da) <= 1E-6 * Math.max(1, Math.abs(ca), Math.abs(da)) && Math.abs(ba - ra) <= 1E-6 * Math.max(1, Math.abs(ba), Math.abs(ra)) && Math.abs(Y - ta) <= 1E-6 * Math.max(1, Math.abs(Y), Math.abs(ta)) && Math.abs(k - n) <= 1E-6 * Math.max(1, Math.abs(k), Math.abs(n))
            },
            mul: m,
            sub: u
        }),
        La = function() {
            var k = x();
            return function(n, v, z, B, D, F) {
                v || (v = 3);
                z || (z = 0);
                for (B = B ? Math.min(B * v + z, n.length) : n.length; z < B; z += v) k[0] = n[z], k[1] = n[z + 1], k[2] = n[z + 2], D(k, k, F), n[z] = k[0], n[z + 1] = k[1], n[z + 2] = k[2];
                return n
            }
        }();
    La = Object.freeze({
        __proto__: null,
        create: x,
        clone: function(k) {
            var n = new ma(3);
            n[0] = k[0];
            n[1] = k[1];
            n[2] = k[2];
            return n
        },
        length: y,
        fromValues: C,
        copy: function(k, n) {
            k[0] = n[0];
            k[1] = n[1];
            k[2] = n[2];
            return k
        },
        set: function(k, n, v, z) {
            k[0] = n;
            k[1] = v;
            k[2] = z;
            return k
        },
        add: function(k, n, v) {
            k[0] = n[0] + v[0];
            k[1] = n[1] + v[1];
            k[2] = n[2] + v[2];
            return k
        },
        subtract: w,
        multiply: A,
        divide: E,
        ceil: function(k, n) {
            k[0] = Math.ceil(n[0]);
            k[1] = Math.ceil(n[1]);
            k[2] = Math.ceil(n[2]);
            return k
        },
        floor: function(k, n) {
            k[0] = Math.floor(n[0]);
            k[1] = Math.floor(n[1]);
            k[2] = Math.floor(n[2]);
            return k
        },
        min: function(k, n, v) {
            k[0] = Math.min(n[0], v[0]);
            k[1] = Math.min(n[1], v[1]);
            k[2] = Math.min(n[2], v[2]);
            return k
        },
        max: function(k, n, v) {
            k[0] = Math.max(n[0], v[0]);
            k[1] = Math.max(n[1], v[1]);
            k[2] = Math.max(n[2], v[2]);
            return k
        },
        round: function(k, n) {
            k[0] = Math.round(n[0]);
            k[1] = Math.round(n[1]);
            k[2] = Math.round(n[2]);
            return k
        },
        scale: function(k, n, v) {
            k[0] = n[0] * v;
            k[1] = n[1] * v;
            k[2] = n[2] * v;
            return k
        },
        scaleAndAdd: function(k, n, v, z) {
            k[0] = n[0] + v[0] * z;
            k[1] = n[1] + v[1] * z;
            k[2] = n[2] + v[2] * z;
            return k
        },
        distance: K,
        squaredDistance: O,
        squaredLength: G,
        negate: function(k, n) {
            k[0] = -n[0];
            k[1] = -n[1];
            k[2] = -n[2];
            return k
        },
        inverse: function(k, n) {
            k[0] = 1 / n[0];
            k[1] = 1 / n[1];
            k[2] = 1 / n[2];
            return k
        },
        normalize: J,
        dot: P,
        cross: R,
        lerp: function(k, n, v, z) {
            var B = n[0],
                D = n[1];
            n = n[2];
            k[0] = B + z * (v[0] - B);
            k[1] = D + z * (v[1] - D);
            k[2] = n + z * (v[2] - n);
            return k
        },
        hermite: function(k, n, v, z, B, D) {
            var F = D * D,
                H = F * (2 * D - 3) + 1,
                I = F * (D - 2) + D,
                M = F * (D - 1);
            D = F * (3 - 2 * D);
            k[0] = n[0] * H + v[0] * I + z[0] * M + B[0] * D;
            k[1] = n[1] * H + v[1] * I + z[1] * M + B[1] * D;
            k[2] = n[2] * H + v[2] * I + z[2] * M + B[2] * D;
            return k
        },
        bezier: function(k,
            n, v, z, B, D) {
            var F = 1 - D,
                H = F * F,
                I = D * D,
                M = H * F;
            H *= 3 * D;
            F *= 3 * I;
            D *= I;
            k[0] = n[0] * M + v[0] * H + z[0] * F + B[0] * D;
            k[1] = n[1] * M + v[1] * H + z[1] * F + B[1] * D;
            k[2] = n[2] * M + v[2] * H + z[2] * F + B[2] * D;
            return k
        },
        random: function(k, n) {
            n = n || 1;
            var v = 2 * Ga() * Math.PI,
                z = 2 * Ga() - 1,
                B = Math.sqrt(1 - z * z) * n;
            k[0] = Math.cos(v) * B;
            k[1] = Math.sin(v) * B;
            k[2] = z * n;
            return k
        },
        transformMat4: function(k, n, v) {
            var z = n[0],
                B = n[1];
            n = n[2];
            var D = v[3] * z + v[7] * B + v[11] * n + v[15];
            D = D || 1;
            k[0] = (v[0] * z + v[4] * B + v[8] * n + v[12]) / D;
            k[1] = (v[1] * z + v[5] * B + v[9] * n + v[13]) / D;
            k[2] = (v[2] * z + v[6] * B + v[10] * n +
                v[14]) / D;
            return k
        },
        transformMat3: function(k, n, v) {
            var z = n[0],
                B = n[1];
            n = n[2];
            k[0] = z * v[0] + B * v[3] + n * v[6];
            k[1] = z * v[1] + B * v[4] + n * v[7];
            k[2] = z * v[2] + B * v[5] + n * v[8];
            return k
        },
        transformQuat: function(k, n, v) {
            var z = v[0],
                B = v[1],
                D = v[2],
                F = n[0],
                H = n[1];
            n = n[2];
            var I = B * n - D * H,
                M = D * F - z * n,
                Q = z * H - B * F;
            v = 2 * v[3];
            k[0] = F + I * v + 2 * (B * Q - D * M);
            k[1] = H + M * v + 2 * (D * I - z * Q);
            k[2] = n + Q * v + 2 * (z * M - B * I);
            return k
        },
        rotateX: function(k, n, v, z) {
            var B = [],
                D = [];
            B[0] = n[0] - v[0];
            B[1] = n[1] - v[1];
            B[2] = n[2] - v[2];
            D[0] = B[0];
            D[1] = B[1] * Math.cos(z) - B[2] * Math.sin(z);
            D[2] = B[1] *
                Math.sin(z) + B[2] * Math.cos(z);
            k[0] = D[0] + v[0];
            k[1] = D[1] + v[1];
            k[2] = D[2] + v[2];
            return k
        },
        rotateY: function(k, n, v, z) {
            var B = [],
                D = [];
            B[0] = n[0] - v[0];
            B[1] = n[1] - v[1];
            B[2] = n[2] - v[2];
            D[0] = B[2] * Math.sin(z) + B[0] * Math.cos(z);
            D[1] = B[1];
            D[2] = B[2] * Math.cos(z) - B[0] * Math.sin(z);
            k[0] = D[0] + v[0];
            k[1] = D[1] + v[1];
            k[2] = D[2] + v[2];
            return k
        },
        rotateZ: function(k, n, v, z) {
            var B = [],
                D = [];
            B[0] = n[0] - v[0];
            B[1] = n[1] - v[1];
            B[2] = n[2] - v[2];
            D[0] = B[0] * Math.cos(z) - B[1] * Math.sin(z);
            D[1] = B[0] * Math.sin(z) + B[1] * Math.cos(z);
            D[2] = B[2];
            k[0] = D[0] + v[0];
            k[1] =
                D[1] + v[1];
            k[2] = D[2] + v[2];
            return k
        },
        angle: function(k, n) {
            var v = k[0],
                z = k[1],
                B = k[2],
                D = n[0],
                F = n[1],
                H = n[2];
            k = (v = Math.sqrt(v * v + z * z + B * B) * Math.sqrt(D * D + F * F + H * H)) && P(k, n) / v;
            return Math.acos(Math.min(Math.max(k, -1), 1))
        },
        zero: function(k) {
            k[0] = 0;
            k[1] = 0;
            k[2] = 0;
            return k
        },
        str: function(k) {
            return "vec3(" + k[0] + ", " + k[1] + ", " + k[2] + ")"
        },
        exactEquals: function(k, n) {
            return k[0] === n[0] && k[1] === n[1] && k[2] === n[2]
        },
        equals: function(k, n) {
            var v = k[0],
                z = k[1];
            k = k[2];
            var B = n[0],
                D = n[1];
            n = n[2];
            return Math.abs(v - B) <= 1E-6 * Math.max(1, Math.abs(v),
                Math.abs(B)) && Math.abs(z - D) <= 1E-6 * Math.max(1, Math.abs(z), Math.abs(D)) && Math.abs(k - n) <= 1E-6 * Math.max(1, Math.abs(k), Math.abs(n))
        },
        sub: w,
        mul: A,
        div: E,
        dist: K,
        sqrDist: O,
        len: y,
        sqrLen: G,
        forEach: La
    });
    var Ma = function() {
        var k = T();
        return function(n, v, z, B, D, F) {
            v || (v = 4);
            z || (z = 0);
            for (B = B ? Math.min(B * v + z, n.length) : n.length; z < B; z += v) k[0] = n[z], k[1] = n[z + 1], k[2] = n[z + 2], k[3] = n[z + 3], D(k, k, F), n[z] = k[0], n[z + 1] = k[1], n[z + 2] = k[2], n[z + 3] = k[3];
            return n
        }
    }();
    Ma = Object.freeze({
        __proto__: null,
        create: T,
        clone: X,
        fromValues: aa,
        copy: ea,
        set: sa,
        add: ia,
        subtract: Aa,
        multiply: ua,
        divide: Da,
        ceil: function(k, n) {
            k[0] = Math.ceil(n[0]);
            k[1] = Math.ceil(n[1]);
            k[2] = Math.ceil(n[2]);
            k[3] = Math.ceil(n[3]);
            return k
        },
        floor: function(k, n) {
            k[0] = Math.floor(n[0]);
            k[1] = Math.floor(n[1]);
            k[2] = Math.floor(n[2]);
            k[3] = Math.floor(n[3]);
            return k
        },
        min: function(k, n, v) {
            k[0] = Math.min(n[0], v[0]);
            k[1] = Math.min(n[1], v[1]);
            k[2] = Math.min(n[2], v[2]);
            k[3] = Math.min(n[3], v[3]);
            return k
        },
        max: function(k, n, v) {
            k[0] = Math.max(n[0], v[0]);
            k[1] = Math.max(n[1], v[1]);
            k[2] = Math.max(n[2], v[2]);
            k[3] = Math.max(n[3], v[3]);
            return k
        },
        round: function(k, n) {
            k[0] = Math.round(n[0]);
            k[1] = Math.round(n[1]);
            k[2] = Math.round(n[2]);
            k[3] = Math.round(n[3]);
            return k
        },
        scale: Ea,
        scaleAndAdd: function(k, n, v, z) {
            k[0] = n[0] + v[0] * z;
            k[1] = n[1] + v[1] * z;
            k[2] = n[2] + v[2] * z;
            k[3] = n[3] + v[3] * z;
            return k
        },
        distance: Ba,
        squaredDistance: za,
        length: ja,
        squaredLength: Fa,
        negate: function(k, n) {
            k[0] = -n[0];
            k[1] = -n[1];
            k[2] = -n[2];
            k[3] = -n[3];
            return k
        },
        inverse: function(k, n) {
            k[0] = 1 / n[0];
            k[1] = 1 / n[1];
            k[2] = 1 / n[2];
            k[3] = 1 / n[3];
            return k
        },
        normalize: wa,
        dot: Ca,
        cross: function(k, n, v, z) {
            var B = v[0] * z[1] - v[1] * z[0],
                D = v[0] * z[2] - v[2] * z[0],
                F = v[0] * z[3] - v[3] * z[0],
                H = v[1] * z[2] - v[2] * z[1],
                I = v[1] * z[3] - v[3] * z[1];
            v = v[2] * z[3] - v[3] * z[2];
            z = n[0];
            var M = n[1],
                Q = n[2];
            n = n[3];
            k[0] = M * v - Q * I + n * H;
            k[1] = -(z * v) + Q * F - n * D;
            k[2] = z * I - M * F + n * B;
            k[3] = -(z * H) + M * D - Q * B;
            return k
        },
        lerp: Pa,
        random: function(k, n) {
            n = n || 1;
            do {
                var v = 2 * Ga() - 1;
                var z = 2 * Ga() - 1;
                var B = v * v + z * z
            } while (1 <= B);
            do {
                var D = 2 * Ga() - 1;
                var F = 2 * Ga() - 1;
                var H = D * D + F * F
            } while (1 <= H);
            B = Math.sqrt((1 - B) / H);
            k[0] = n * v;
            k[1] = n * z;
            k[2] = n * D * B;
            k[3] = n * F * B;
            return k
        },
        transformMat4: function(k, n, v) {
            var z = n[0],
                B = n[1],
                D = n[2];
            n = n[3];
            k[0] = v[0] * z + v[4] * B + v[8] * D + v[12] * n;
            k[1] = v[1] * z + v[5] * B + v[9] * D + v[13] * n;
            k[2] = v[2] * z + v[6] * B + v[10] * D + v[14] * n;
            k[3] = v[3] * z + v[7] * B + v[11] * D + v[15] * n;
            return k
        },
        transformQuat: function(k, n, v) {
            var z = n[0],
                B = n[1],
                D = n[2],
                F = v[0],
                H = v[1],
                I = v[2];
            v = v[3];
            var M = v * z + H * D - I * B,
                Q = v * B + I * z - F * D,
                S = v * D + F * B - H * z;
            z = -F * z - H * B - I * D;
            k[0] = M * v + z * -F + Q * -I - S * -H;
            k[1] = Q * v + z * -H + S * -F - M * -I;
            k[2] = S * v + z * -I + M * -H - Q * -F;
            k[3] = n[3];
            return k
        },
        zero: function(k) {
            k[0] = 0;
            k[1] = 0;
            k[2] = 0;
            k[3] = 0;
            return k
        },
        str: function(k) {
            return "vec4(" + k[0] + ", " + k[1] + ", " + k[2] + ", " + k[3] + ")"
        },
        exactEquals: Qa,
        equals: Ra,
        sub: Aa,
        mul: ua,
        div: Da,
        dist: Ba,
        sqrDist: za,
        len: ja,
        sqrLen: Fa,
        forEach: Ma
    });
    var Na = function() {
            var k = x(),
                n = C(1, 0, 0),
                v = C(0, 1, 0);
            return function(z, B, D) {
                var F = P(B, D);
                if (-.999999 > F) return R(k, n, B), 1E-6 > y(k) && R(k, v, B), J(k, k), Sa(z, k, Math.PI), z;
                if (.999999 < F) return z[0] = 0, z[1] = 0, z[2] = 0, z[3] = 1, z;
                R(k, B, D);
                z[0] = k[0];
                z[1] = k[1];
                z[2] = k[2];
                z[3] = 1 + F;
                return wa(z, z)
            }
        }(),
        Oa = function() {
            var k = Ja(),
                n = Ja();
            return function(v, z, B, D, F,
                H) {
                Ka(k, z, F, H);
                Ka(n, B, D, H);
                Ka(v, k, n, 2 * H * (1 - H));
                return v
            }
        }(),
        Ia = function() {
            var k = e();
            return function(n, v, z, B) {
                k[0] = z[0];
                k[3] = z[1];
                k[6] = z[2];
                k[1] = B[0];
                k[4] = B[1];
                k[7] = B[2];
                k[2] = -v[0];
                k[5] = -v[1];
                k[8] = -v[2];
                return wa(n, Za(n, k))
            }
        }();
    Na = Object.freeze({
        __proto__: null,
        create: Ja,
        identity: function(k) {
            k[0] = 0;
            k[1] = 0;
            k[2] = 0;
            k[3] = 1;
            return k
        },
        setAxisAngle: Sa,
        getAxisAngle: function(k, n) {
            var v = 2 * Math.acos(n[3]),
                z = Math.sin(v / 2);
            1E-6 < z ? (k[0] = n[0] / z, k[1] = n[1] / z, k[2] = n[2] / z) : (k[0] = 1, k[1] = 0, k[2] = 0);
            return v
        },
        getAngle: function(k,
            n) {
            k = Ca(k, n);
            return Math.acos(2 * k * k - 1)
        },
        multiply: Ta,
        rotateX: Ua,
        rotateY: Va,
        rotateZ: Wa,
        calculateW: function(k, n) {
            var v = n[0],
                z = n[1];
            n = n[2];
            k[0] = v;
            k[1] = z;
            k[2] = n;
            k[3] = Math.sqrt(Math.abs(1 - v * v - z * z - n * n));
            return k
        },
        exp: Xa,
        ln: Ya,
        pow: function(k, n, v) {
            Ya(k, n);
            Ea(k, k, v);
            Xa(k, k);
            return k
        },
        slerp: Ka,
        random: function(k) {
            var n = Ga(),
                v = Ga(),
                z = Ga(),
                B = Math.sqrt(1 - n);
            n = Math.sqrt(n);
            k[0] = B * Math.sin(2 * Math.PI * v);
            k[1] = B * Math.cos(2 * Math.PI * v);
            k[2] = n * Math.sin(2 * Math.PI * z);
            k[3] = n * Math.cos(2 * Math.PI * z);
            return k
        },
        invert: function(k,
            n) {
            var v = n[0],
                z = n[1],
                B = n[2];
            n = n[3];
            var D = v * v + z * z + B * B + n * n;
            D = D ? 1 / D : 0;
            k[0] = -v * D;
            k[1] = -z * D;
            k[2] = -B * D;
            k[3] = n * D;
            return k
        },
        conjugate: function(k, n) {
            k[0] = -n[0];
            k[1] = -n[1];
            k[2] = -n[2];
            k[3] = n[3];
            return k
        },
        fromMat3: Za,
        fromEuler: function(k, n, v, z) {
            var B = .5 * Math.PI / 180;
            n *= B;
            v *= B;
            z *= B;
            B = Math.sin(n);
            n = Math.cos(n);
            var D = Math.sin(v);
            v = Math.cos(v);
            var F = Math.sin(z);
            z = Math.cos(z);
            k[0] = B * v * z - n * D * F;
            k[1] = n * D * z + B * v * F;
            k[2] = n * v * F - B * D * z;
            k[3] = n * v * z + B * D * F;
            return k
        },
        str: function(k) {
            return "quat(" + k[0] + ", " + k[1] + ", " + k[2] + ", " + k[3] +
                ")"
        },
        clone: X,
        fromValues: aa,
        copy: ea,
        set: sa,
        add: ia,
        mul: Ta,
        scale: Ea,
        dot: Ca,
        lerp: Pa,
        length: ja,
        len: ja,
        squaredLength: Fa,
        sqrLen: Fa,
        normalize: wa,
        exactEquals: Qa,
        equals: Ra,
        rotationTo: Na,
        sqlerp: Oa,
        setAxes: Ia
    });
    Oa = Object.freeze({
        __proto__: null,
        create: function() {
            var k = new ma(8);
            ma != Float32Array && (k[0] = 0, k[1] = 0, k[2] = 0, k[4] = 0, k[5] = 0, k[6] = 0, k[7] = 0);
            k[3] = 1;
            return k
        },
        clone: function(k) {
            var n = new ma(8);
            n[0] = k[0];
            n[1] = k[1];
            n[2] = k[2];
            n[3] = k[3];
            n[4] = k[4];
            n[5] = k[5];
            n[6] = k[6];
            n[7] = k[7];
            return n
        },
        fromValues: function(k, n, v,
            z, B, D, F, H) {
            var I = new ma(8);
            I[0] = k;
            I[1] = n;
            I[2] = v;
            I[3] = z;
            I[4] = B;
            I[5] = D;
            I[6] = F;
            I[7] = H;
            return I
        },
        fromRotationTranslationValues: function(k, n, v, z, B, D, F) {
            var H = new ma(8);
            H[0] = k;
            H[1] = n;
            H[2] = v;
            H[3] = z;
            B *= .5;
            D *= .5;
            F *= .5;
            H[4] = B * z + D * v - F * n;
            H[5] = D * z + F * k - B * v;
            H[6] = F * z + B * n - D * k;
            H[7] = -B * k - D * n - F * v;
            return H
        },
        fromRotationTranslation: $a,
        fromTranslation: function(k, n) {
            k[0] = 0;
            k[1] = 0;
            k[2] = 0;
            k[3] = 1;
            k[4] = .5 * n[0];
            k[5] = .5 * n[1];
            k[6] = .5 * n[2];
            k[7] = 0;
            return k
        },
        fromRotation: function(k, n) {
            k[0] = n[0];
            k[1] = n[1];
            k[2] = n[2];
            k[3] = n[3];
            k[4] =
                0;
            k[5] = 0;
            k[6] = 0;
            k[7] = 0;
            return k
        },
        fromMat4: function(k, n) {
            var v = Ja();
            r(v, n);
            var z = new ma(3);
            t(z, n);
            $a(k, v, z);
            return k
        },
        copy: ab,
        identity: function(k) {
            k[0] = 0;
            k[1] = 0;
            k[2] = 0;
            k[3] = 1;
            k[4] = 0;
            k[5] = 0;
            k[6] = 0;
            k[7] = 0;
            return k
        },
        set: function(k, n, v, z, B, D, F, H, I) {
            k[0] = n;
            k[1] = v;
            k[2] = z;
            k[3] = B;
            k[4] = D;
            k[5] = F;
            k[6] = H;
            k[7] = I;
            return k
        },
        getReal: ea,
        getDual: function(k, n) {
            k[0] = n[4];
            k[1] = n[5];
            k[2] = n[6];
            k[3] = n[7];
            return k
        },
        setReal: ea,
        setDual: function(k, n) {
            k[4] = n[0];
            k[5] = n[1];
            k[6] = n[2];
            k[7] = n[3];
            return k
        },
        getTranslation: function(k,
            n) {
            var v = n[4],
                z = n[5],
                B = n[6],
                D = n[7],
                F = -n[0],
                H = -n[1],
                I = -n[2];
            n = n[3];
            k[0] = 2 * (v * n + D * F + z * I - B * H);
            k[1] = 2 * (z * n + D * H + B * F - v * I);
            k[2] = 2 * (B * n + D * I + v * H - z * F);
            return k
        },
        translate: function(k, n, v) {
            var z = n[0],
                B = n[1],
                D = n[2],
                F = n[3],
                H = .5 * v[0],
                I = .5 * v[1];
            v = .5 * v[2];
            var M = n[4],
                Q = n[5],
                S = n[6];
            n = n[7];
            k[0] = z;
            k[1] = B;
            k[2] = D;
            k[3] = F;
            k[4] = F * H + B * v - D * I + M;
            k[5] = F * I + D * H - z * v + Q;
            k[6] = F * v + z * I - B * H + S;
            k[7] = -z * H - B * I - D * v + n;
            return k
        },
        rotateX: function(k, n, v) {
            var z = -n[0],
                B = -n[1],
                D = -n[2],
                F = n[3],
                H = n[4],
                I = n[5],
                M = n[6],
                Q = n[7],
                S = H * F + Q * z + I * D - M * B,
                W = I * F + Q * B +
                M * z - H * D,
                U = M * F + Q * D + H * B - I * z;
            H = Q * F - H * z - I * B - M * D;
            Ua(k, n, v);
            z = k[0];
            B = k[1];
            D = k[2];
            F = k[3];
            k[4] = S * F + H * z + W * D - U * B;
            k[5] = W * F + H * B + U * z - S * D;
            k[6] = U * F + H * D + S * B - W * z;
            k[7] = H * F - S * z - W * B - U * D;
            return k
        },
        rotateY: function(k, n, v) {
            var z = -n[0],
                B = -n[1],
                D = -n[2],
                F = n[3],
                H = n[4],
                I = n[5],
                M = n[6],
                Q = n[7],
                S = H * F + Q * z + I * D - M * B,
                W = I * F + Q * B + M * z - H * D,
                U = M * F + Q * D + H * B - I * z;
            H = Q * F - H * z - I * B - M * D;
            Va(k, n, v);
            z = k[0];
            B = k[1];
            D = k[2];
            F = k[3];
            k[4] = S * F + H * z + W * D - U * B;
            k[5] = W * F + H * B + U * z - S * D;
            k[6] = U * F + H * D + S * B - W * z;
            k[7] = H * F - S * z - W * B - U * D;
            return k
        },
        rotateZ: function(k, n, v) {
            var z = -n[0],
                B = -n[1],
                D = -n[2],
                F = n[3],
                H = n[4],
                I = n[5],
                M = n[6],
                Q = n[7],
                S = H * F + Q * z + I * D - M * B,
                W = I * F + Q * B + M * z - H * D,
                U = M * F + Q * D + H * B - I * z;
            H = Q * F - H * z - I * B - M * D;
            Wa(k, n, v);
            z = k[0];
            B = k[1];
            D = k[2];
            F = k[3];
            k[4] = S * F + H * z + W * D - U * B;
            k[5] = W * F + H * B + U * z - S * D;
            k[6] = U * F + H * D + S * B - W * z;
            k[7] = H * F - S * z - W * B - U * D;
            return k
        },
        rotateByQuatAppend: function(k, n, v) {
            var z = v[0],
                B = v[1],
                D = v[2];
            v = v[3];
            var F = n[0],
                H = n[1],
                I = n[2],
                M = n[3];
            k[0] = F * v + M * z + H * D - I * B;
            k[1] = H * v + M * B + I * z - F * D;
            k[2] = I * v + M * D + F * B - H * z;
            k[3] = M * v - F * z - H * B - I * D;
            F = n[4];
            H = n[5];
            I = n[6];
            M = n[7];
            k[4] = F * v + M * z + H * D - I * B;
            k[5] = H * v + M * B + I *
                z - F * D;
            k[6] = I * v + M * D + F * B - H * z;
            k[7] = M * v - F * z - H * B - I * D;
            return k
        },
        rotateByQuatPrepend: function(k, n, v) {
            var z = n[0],
                B = n[1],
                D = n[2];
            n = n[3];
            var F = v[0],
                H = v[1],
                I = v[2],
                M = v[3];
            k[0] = z * M + n * F + B * I - D * H;
            k[1] = B * M + n * H + D * F - z * I;
            k[2] = D * M + n * I + z * H - B * F;
            k[3] = n * M - z * F - B * H - D * I;
            F = v[4];
            H = v[5];
            I = v[6];
            M = v[7];
            k[4] = z * M + n * F + B * I - D * H;
            k[5] = B * M + n * H + D * F - z * I;
            k[6] = D * M + n * I + z * H - B * F;
            k[7] = n * M - z * F - B * H - D * I;
            return k
        },
        rotateAroundAxis: function(k, n, v, z) {
            if (1E-6 > Math.abs(z)) return ab(k, n);
            var B = Math.hypot(v[0], v[1], v[2]);
            z *= .5;
            var D = Math.sin(z),
                F = D * v[0] / B,
                H = D * v[1] / B;
            v = D * v[2] / B;
            z = Math.cos(z);
            B = n[0];
            D = n[1];
            var I = n[2],
                M = n[3];
            k[0] = B * z + M * F + D * v - I * H;
            k[1] = D * z + M * H + I * F - B * v;
            k[2] = I * z + M * v + B * H - D * F;
            k[3] = M * z - B * F - D * H - I * v;
            B = n[4];
            D = n[5];
            I = n[6];
            n = n[7];
            k[4] = B * z + n * F + D * v - I * H;
            k[5] = D * z + n * H + I * F - B * v;
            k[6] = I * z + n * v + B * H - D * F;
            k[7] = n * z - B * F - D * H - I * v;
            return k
        },
        add: function(k, n, v) {
            k[0] = n[0] + v[0];
            k[1] = n[1] + v[1];
            k[2] = n[2] + v[2];
            k[3] = n[3] + v[3];
            k[4] = n[4] + v[4];
            k[5] = n[5] + v[5];
            k[6] = n[6] + v[6];
            k[7] = n[7] + v[7];
            return k
        },
        multiply: bb,
        mul: bb,
        scale: function(k, n, v) {
            k[0] = n[0] * v;
            k[1] = n[1] * v;
            k[2] = n[2] * v;
            k[3] = n[3] * v;
            k[4] = n[4] * v;
            k[5] = n[5] * v;
            k[6] = n[6] * v;
            k[7] = n[7] * v;
            return k
        },
        dot: Ca,
        lerp: function(k, n, v, z) {
            var B = 1 - z;
            0 > Ca(n, v) && (z = -z);
            k[0] = n[0] * B + v[0] * z;
            k[1] = n[1] * B + v[1] * z;
            k[2] = n[2] * B + v[2] * z;
            k[3] = n[3] * B + v[3] * z;
            k[4] = n[4] * B + v[4] * z;
            k[5] = n[5] * B + v[5] * z;
            k[6] = n[6] * B + v[6] * z;
            k[7] = n[7] * B + v[7] * z;
            return k
        },
        invert: function(k, n) {
            var v = Fa(n);
            k[0] = -n[0] / v;
            k[1] = -n[1] / v;
            k[2] = -n[2] / v;
            k[3] = n[3] / v;
            k[4] = -n[4] / v;
            k[5] = -n[5] / v;
            k[6] = -n[6] / v;
            k[7] = n[7] / v;
            return k
        },
        conjugate: function(k, n) {
            k[0] = -n[0];
            k[1] = -n[1];
            k[2] = -n[2];
            k[3] = n[3];
            k[4] = -n[4];
            k[5] = -n[5];
            k[6] = -n[6];
            k[7] = n[7];
            return k
        },
        length: ja,
        len: ja,
        squaredLength: Fa,
        sqrLen: Fa,
        normalize: function(k, n) {
            var v = Fa(n);
            if (0 < v) {
                v = Math.sqrt(v);
                var z = n[0] / v,
                    B = n[1] / v,
                    D = n[2] / v,
                    F = n[3] / v,
                    H = n[4],
                    I = n[5],
                    M = n[6];
                n = n[7];
                var Q = z * H + B * I + D * M + F * n;
                k[0] = z;
                k[1] = B;
                k[2] = D;
                k[3] = F;
                k[4] = (H - z * Q) / v;
                k[5] = (I - B * Q) / v;
                k[6] = (M - D * Q) / v;
                k[7] = (n - F * Q) / v
            }
            return k
        },
        str: function(k) {
            return "quat2(" + k[0] + ", " + k[1] + ", " + k[2] + ", " + k[3] + ", " + k[4] + ", " + k[5] + ", " + k[6] + ", " + k[7] + ")"
        },
        exactEquals: function(k, n) {
            return k[0] === n[0] &&
                k[1] === n[1] && k[2] === n[2] && k[3] === n[3] && k[4] === n[4] && k[5] === n[5] && k[6] === n[6] && k[7] === n[7]
        },
        equals: function(k, n) {
            var v = k[0],
                z = k[1],
                B = k[2],
                D = k[3],
                F = k[4],
                H = k[5],
                I = k[6];
            k = k[7];
            var M = n[0],
                Q = n[1],
                S = n[2],
                W = n[3],
                U = n[4],
                ca = n[5],
                ba = n[6];
            n = n[7];
            return Math.abs(v - M) <= 1E-6 * Math.max(1, Math.abs(v), Math.abs(M)) && Math.abs(z - Q) <= 1E-6 * Math.max(1, Math.abs(z), Math.abs(Q)) && Math.abs(B - S) <= 1E-6 * Math.max(1, Math.abs(B), Math.abs(S)) && Math.abs(D - W) <= 1E-6 * Math.max(1, Math.abs(D), Math.abs(W)) && Math.abs(F - U) <= 1E-6 * Math.max(1, Math.abs(F),
                Math.abs(U)) && Math.abs(H - ca) <= 1E-6 * Math.max(1, Math.abs(H), Math.abs(ca)) && Math.abs(I - ba) <= 1E-6 * Math.max(1, Math.abs(I), Math.abs(ba)) && Math.abs(k - n) <= 1E-6 * Math.max(1, Math.abs(k), Math.abs(n))
        }
    });
    Ia = function() {
        var k = cb();
        return function(n, v, z, B, D, F) {
            v || (v = 2);
            z || (z = 0);
            for (B = B ? Math.min(B * v + z, n.length) : n.length; z < B; z += v) k[0] = n[z], k[1] = n[z + 1], D(k, k, F), n[z] = k[0], n[z + 1] = k[1];
            return n
        }
    }();
    Ia = Object.freeze({
        __proto__: null,
        create: cb,
        clone: function(k) {
            var n = new ma(2);
            n[0] = k[0];
            n[1] = k[1];
            return n
        },
        fromValues: function(k,
            n) {
            var v = new ma(2);
            v[0] = k;
            v[1] = n;
            return v
        },
        copy: function(k, n) {
            k[0] = n[0];
            k[1] = n[1];
            return k
        },
        set: function(k, n, v) {
            k[0] = n;
            k[1] = v;
            return k
        },
        add: function(k, n, v) {
            k[0] = n[0] + v[0];
            k[1] = n[1] + v[1];
            return k
        },
        subtract: db,
        multiply: eb,
        divide: fb,
        ceil: function(k, n) {
            k[0] = Math.ceil(n[0]);
            k[1] = Math.ceil(n[1]);
            return k
        },
        floor: function(k, n) {
            k[0] = Math.floor(n[0]);
            k[1] = Math.floor(n[1]);
            return k
        },
        min: function(k, n, v) {
            k[0] = Math.min(n[0], v[0]);
            k[1] = Math.min(n[1], v[1]);
            return k
        },
        max: function(k, n, v) {
            k[0] = Math.max(n[0], v[0]);
            k[1] =
                Math.max(n[1], v[1]);
            return k
        },
        round: function(k, n) {
            k[0] = Math.round(n[0]);
            k[1] = Math.round(n[1]);
            return k
        },
        scale: function(k, n, v) {
            k[0] = n[0] * v;
            k[1] = n[1] * v;
            return k
        },
        scaleAndAdd: function(k, n, v, z) {
            k[0] = n[0] + v[0] * z;
            k[1] = n[1] + v[1] * z;
            return k
        },
        distance: gb,
        squaredDistance: hb,
        length: ib,
        squaredLength: jb,
        negate: function(k, n) {
            k[0] = -n[0];
            k[1] = -n[1];
            return k
        },
        inverse: function(k, n) {
            k[0] = 1 / n[0];
            k[1] = 1 / n[1];
            return k
        },
        normalize: function(k, n) {
            var v = n[0],
                z = n[1];
            v = v * v + z * z;
            0 < v && (v = 1 / Math.sqrt(v));
            k[0] = n[0] * v;
            k[1] = n[1] * v;
            return k
        },
        dot: function(k, n) {
            return k[0] * n[0] + k[1] * n[1]
        },
        cross: function(k, n, v) {
            n = n[0] * v[1] - n[1] * v[0];
            k[0] = k[1] = 0;
            k[2] = n;
            return k
        },
        lerp: function(k, n, v, z) {
            var B = n[0];
            n = n[1];
            k[0] = B + z * (v[0] - B);
            k[1] = n + z * (v[1] - n);
            return k
        },
        random: function(k, n) {
            n = n || 1;
            var v = 2 * Ga() * Math.PI;
            k[0] = Math.cos(v) * n;
            k[1] = Math.sin(v) * n;
            return k
        },
        transformMat2: function(k, n, v) {
            var z = n[0];
            n = n[1];
            k[0] = v[0] * z + v[2] * n;
            k[1] = v[1] * z + v[3] * n;
            return k
        },
        transformMat2d: function(k, n, v) {
            var z = n[0];
            n = n[1];
            k[0] = v[0] * z + v[2] * n + v[4];
            k[1] = v[1] * z + v[3] * n +
                v[5];
            return k
        },
        transformMat3: function(k, n, v) {
            var z = n[0];
            n = n[1];
            k[0] = v[0] * z + v[3] * n + v[6];
            k[1] = v[1] * z + v[4] * n + v[7];
            return k
        },
        transformMat4: function(k, n, v) {
            var z = n[0];
            n = n[1];
            k[0] = v[0] * z + v[4] * n + v[12];
            k[1] = v[1] * z + v[5] * n + v[13];
            return k
        },
        rotate: function(k, n, v, z) {
            var B = n[0] - v[0];
            n = n[1] - v[1];
            var D = Math.sin(z);
            z = Math.cos(z);
            k[0] = B * z - n * D + v[0];
            k[1] = B * D + n * z + v[1];
            return k
        },
        angle: function(k, n) {
            var v = k[0];
            k = k[1];
            var z = n[0];
            n = n[1];
            var B = Math.sqrt(v * v + k * k) * Math.sqrt(z * z + n * n);
            return Math.acos(Math.min(Math.max(B && (v *
                z + k * n) / B, -1), 1))
        },
        zero: function(k) {
            k[0] = 0;
            k[1] = 0;
            return k
        },
        str: function(k) {
            return "vec2(" + k[0] + ", " + k[1] + ")"
        },
        exactEquals: function(k, n) {
            return k[0] === n[0] && k[1] === n[1]
        },
        equals: function(k, n) {
            var v = k[0];
            k = k[1];
            var z = n[0];
            n = n[1];
            return Math.abs(v - z) <= 1E-6 * Math.max(1, Math.abs(v), Math.abs(z)) && Math.abs(k - n) <= 1E-6 * Math.max(1, Math.abs(k), Math.abs(n))
        },
        len: ib,
        sub: db,
        mul: eb,
        div: fb,
        dist: gb,
        sqrDist: hb,
        sqrLen: jb,
        forEach: Ia
    });
    d.glMatrix = lb;
    d.mat2 = mb;
    d.mat2d = nb;
    d.mat3 = ob;
    d.mat4 = pb;
    d.quat = Na;
    d.quat2 = Oa;
    d.vec2 = Ia;
    d.vec3 = La;
    d.vec4 = Ma;
    Object.defineProperty(d, "__esModule", {
        value: !0
    })
});
"use strict";
{
    function d(G, J, P) {
        var R = [0, 0];
        var T = G[1][1] - G[0][1];
        var X = G[0][0] - G[1][0];
        G = T * G[0][0] + X * G[0][1];
        var aa = J[1][1] - J[0][1];
        var ea = J[0][0] - J[1][0];
        J = aa * J[0][0] + ea * J[0][1];
        var sa = T * ea - aa * X;
        K(sa, 0, P || 0) || (R[0] = (ea * G - X * J) / sa, R[1] = (T * J - aa * G) / sa);
        return R
    }

    function b(G, J, P, R) {
        var T = J[0] - G[0];
        J = J[1] - G[1];
        var X = R[0] - P[0],
            aa = R[1] - P[1];
        if (0 === X * J - aa * T) return !1;
        R = (T * (P[1] - G[1]) + J * (G[0] - P[0])) / (X * J - aa * T);
        G = (X * (G[1] - P[1]) + aa * (P[0] - G[0])) / (aa * T - X * J);
        return 0 <= R && 1 >= R && 0 <= G && 1 >= G
    }

    function a(G, J, P) {
        return (J[0] - G[0]) *
            (P[1] - G[1]) - (P[0] - G[0]) * (J[1] - G[1])
    }

    function f(G, J, P) {
        return 0 < a(G, J, P)
    }

    function c(G, J, P) {
        return 0 <= a(G, J, P)
    }

    function e(G, J, P) {
        return 0 > a(G, J, P)
    }

    function g(G, J, P) {
        return 0 >= a(G, J, P)
    }
    var tmpPoint1$$module$str$c3runtime = [],
        tmpPoint2$$module$str$c3runtime = [];

    function h(G, J, P, R) {
        if (R) {
            var T = tmpPoint1$$module$str$c3runtime,
                X = tmpPoint2$$module$str$c3runtime;
            T[0] = J[0] - G[0];
            T[1] = J[1] - G[1];
            X[0] = P[0] - J[0];
            X[1] = P[1] - J[1];
            return Math.acos((T[0] * X[0] + T[1] * X[1]) / (Math.sqrt(T[0] * T[0] + T[1] * T[1]) * Math.sqrt(X[0] * X[0] +
                X[1] * X[1]))) < R
        }
        return 0 === a(G, J, P)
    }

    function l(G, J) {
        var P = J[0] - G[0];
        G = J[1] - G[1];
        return P * P + G * G
    }

    function m(G, J) {
        var P = G.length;
        return G[0 > J ? J % P + P : J % P]
    }

    function p(G) {
        G.length = 0
    }

    function t(G, J, P, R) {
        for (; P < R; P++) G.push(J[P])
    }

    function q(G) {
        for (var J = [], P = G.length, R = 0; R !== P; R++) J.push(G.pop());
        for (R = 0; R !== P; R++) G[R] = J[R]
    }

    function r(G, J) {
        return e(m(G, J - 1), m(G, J), m(G, J + 1))
    }
    var tmpLine1$$module$str$c3runtime = [],
        tmpLine2$$module$str$c3runtime = [];

    function u(G, J, P) {
        var R = tmpLine1$$module$str$c3runtime,
            T = tmpLine2$$module$str$c3runtime;
        if (c(m(G, J + 1), m(G, J), m(G, P)) && g(m(G, J - 1), m(G, J), m(G, P))) return !1;
        var X = l(m(G, J), m(G, P));
        for (var aa = 0; aa !== G.length; ++aa)
            if ((aa + 1) % G.length !== J && aa !== J && c(m(G, J), m(G, P), m(G, aa + 1)) && g(m(G, J), m(G, P), m(G, aa))) {
                R[0] = m(G, J);
                R[1] = m(G, P);
                T[0] = m(G, aa);
                T[1] = m(G, aa + 1);
                var ea = d(R, T);
                if (l(m(G, J), ea) < X) return !1
            } return !0
    }

    function x(G, J, P) {
        for (var R = 0; R !== G.length; ++R)
            if (R !== J && R !== P && (R + 1) % G.length !== J && (R + 1) % G.length !== P && b(m(G, J), m(G, P), m(G, R), m(G, R + 1))) return !1;
        return !0
    }

    function y(G, J, P, R) {
        R = R || [];
        p(R);
        if (J <
            P)
            for (var T = J; T <= P; T++) R.push(G[T]);
        else {
            for (T = 0; T <= P; T++) R.push(G[T]);
            for (T = J; T < G.length; T++) R.push(G[T])
        }
        return R
    }

    function C(G) {
        for (var J = [], P, R, T = [], X = Number.MAX_VALUE, aa = 0; aa < G.length; ++aa)
            if (r(G, aa))
                for (var ea = 0; ea < G.length; ++ea)
                    if (u(G, aa, ea)) {
                        P = C(y(G, aa, ea, T));
                        R = C(y(G, ea, aa, T));
                        for (var sa = 0; sa < R.length; sa++) P.push(R[sa]);
                        P.length < X && (J = P, X = P.length, J.push([m(G, aa), m(G, ea)]))
                    } return J
    }

    function w(G, J) {
        if (0 === J.length) return [G];
        if (J instanceof Array && J.length && J[0] instanceof Array && 2 === J[0].length &&
            J[0][0] instanceof Array) {
            G = [G];
            for (var P = 0; P < J.length; P++)
                for (var R = J[P], T = 0; T < G.length; T++) {
                    var X = w(G[T], R);
                    if (X) {
                        G.splice(T, 1);
                        G.push(X[0], X[1]);
                        break
                    }
                }
            return G
        }
        R = J;
        P = G.indexOf(R[0]);
        T = G.indexOf(R[1]);
        return -1 !== P && -1 !== T ? [y(G, P, T), y(G, T, P)] : !1
    }

    function A(G, J, P, R, T) {
        var X = J[1] - G[1];
        J = G[0] - J[0];
        G = X * G[0] + J * G[1];
        var aa = R[1] - P[1];
        R = P[0] - R[0];
        P = aa * P[0] + R * P[1];
        var ea = X * R - aa * J;
        return K(ea, 0, T || 0) ? [0, 0] : [(R * G - J * P) / ea, (X * P - aa * G) / ea]
    }

    function E(G, J, P, R, T, X, aa) {
        X = X || 100;
        aa = aa || 0;
        T = T || 25;
        J = "undefined" !== typeof J ?
            J : [];
        P = P || [];
        R = R || [];
        var ea = [0, 0],
            sa = [0, 0],
            ia = [0, 0],
            Aa, ua = 0,
            Da = 0,
            Ea = 0,
            Ba = [],
            za = [];
        if (3 > G.length) return J;
        aa++;
        if (aa > X) return console.warn("quickDecomp: max level (" + X + ") reached."), J;
        for (var ja = 0; ja < G.length; ++ja)
            if (r(G, ja)) {
                P.push(G[ja]);
                var Fa = Aa = Number.MAX_VALUE;
                for (var wa = 0; wa < G.length; ++wa) {
                    if (f(m(G, ja - 1), m(G, ja), m(G, wa)) && g(m(G, ja - 1), m(G, ja), m(G, wa - 1)) && (ia = A(m(G, ja - 1), m(G, ja), m(G, wa), m(G, wa - 1)), e(m(G, ja + 1), m(G, ja), ia))) {
                        var Ca = l(G[ja], ia);
                        Ca < Aa && (Aa = Ca, sa = ia, Da = wa)
                    }
                    f(m(G, ja + 1), m(G, ja), m(G,
                        wa + 1)) && g(m(G, ja + 1), m(G, ja), m(G, wa)) && (ia = A(m(G, ja + 1), m(G, ja), m(G, wa), m(G, wa + 1)), f(m(G, ja - 1), m(G, ja), ia) && (Ca = l(G[ja], ia), Ca < Fa && (Fa = Ca, ea = ia, ua = wa)))
                }
                if (Da === (ua + 1) % G.length) ia[0] = (sa[0] + ea[0]) / 2, ia[1] = (sa[1] + ea[1]) / 2, R.push(ia), ja < ua ? (t(Ba, G, ja, ua + 1), Ba.push(ia), za.push(ia), 0 !== Da && t(za, G, Da, G.length), t(za, G, 0, ja + 1)) : (0 !== ja && t(Ba, G, ja, G.length), t(Ba, G, 0, ua + 1), Ba.push(ia), za.push(ia), t(za, G, Da, ja + 1));
                else {
                    Da > ua && (ua += G.length);
                    ea = Number.MAX_VALUE;
                    if (ua < Da) return J;
                    for (wa = Da; wa <= ua; ++wa) c(m(G, ja -
                        1), m(G, ja), m(G, wa)) && g(m(G, ja + 1), m(G, ja), m(G, wa)) && (Ca = l(m(G, ja), m(G, wa)), Ca < ea && x(G, ja, wa) && (ea = Ca, Ea = wa % G.length));
                    ja < Ea ? (t(Ba, G, ja, Ea + 1), 0 !== Ea && t(za, G, Ea, G.length), t(za, G, 0, ja + 1)) : (0 !== ja && t(Ba, G, ja, G.length), t(Ba, G, 0, Ea + 1), t(za, G, Ea, ja + 1))
                }
                Ba.length < za.length ? (E(Ba, J, P, R, T, X, aa), E(za, J, P, R, T, X, aa)) : (E(za, J, P, R, T, X, aa), E(Ba, J, P, R, T, X, aa));
                return J
            } J.push(G);
        return J
    }

    function K(G, J, P) {
        return Math.abs(G - J) <= (P || 0)
    }

    function O(G, J, P) {
        return K(G[0], J[0], P) && K(G[1], J[1], P)
    }
    self.polyDecomp = {
        decomp: function(G) {
            var J =
                C(G);
            return 0 < J.length ? w(G, J) : [G]
        },
        quickDecomp: E,
        isSimple: function(G) {
            var J;
            for (J = 0; J < G.length - 1; J++)
                for (var P = 0; P < J - 1; P++)
                    if (b(G[J], G[J + 1], G[P], G[P + 1])) return !1;
            for (J = 1; J < G.length - 2; J++)
                if (b(G[0], G[G.length - 1], G[J], G[J + 1])) return !1;
            return !0
        },
        removeCollinearPoints: function(G, J) {
            for (var P = 0, R = G.length - 1; 3 < G.length && 0 <= R; --R) h(m(G, R - 1), m(G, R), m(G, R + 1), J) && (G.splice(R % G.length, 1), P++);
            return P
        },
        removeDuplicatePoints: function(G, J) {
            for (var P = G.length - 1; 1 <= P; --P)
                for (var R = G[P], T = P - 1; 0 <= T; --T) O(R, G[T], J) &&
                    G.splice(P, 1)
        },
        makeCCW: function(G) {
            for (var J = 0, P = 1; P < G.length; ++P)
                if (G[P][1] < G[J][1] || G[P][1] === G[J][1] && G[P][0] > G[J][0]) J = P;
            if (f(m(G, J - 1), m(G, J), m(G, J + 1))) return !1;
            q(G);
            return !0
        }
    }
}
"use strict";
{
    let d = !1,
        b = !1,
        a = "dev";
    const f = self.C3 = class {
        constructor() {
            throw TypeError("static class can't be instantiated");
        }
        static SetReady() {
            d = !0
        }
        static IsReady() {
            return d
        }
        static SetAppStarted() {
            b = !0
        }
        static HasAppStarted() {
            return b
        }
        static SetBuildMode(c) {
            a = c
        }
        static GetBuildMode() {
            return a
        }
        static IsReleaseBuild() {
            return "final" === a
        }
    };
    f.isDebug = !1;
    f.isDebugDefend = !1;
    f.hardwareConcurrency = navigator.hardwareConcurrency || 2
}
"use strict";
{
    const d = self.C3;
    d.QueryParser = class {
        constructor(b) {
            this._queryString = b;
            this._parameters = new Map;
            this._Parse()
        }
        _Parse() {
            var b = this._queryString;
            if (b.startsWith("?") || b.startsWith("#")) b = b.substr(1);
            b = b.split("&");
            for (const a of b) this._ParseParameter(a)
        }
        _ParseParameter(b) {
            if (b)
                if (b.includes("=")) {
                    var a = b.indexOf("="),
                        f = decodeURIComponent(b.substring(0, a));
                    b = decodeURIComponent(b.substring(a + 1));
                    this._parameters.set(f, b)
                } else this._parameters.set(b, null)
        }
        LogAll() {
            for (const b of this._parameters) console.log("[QueryParser] Parameter '" +
                b[0] + "' = " + (null === b[1] ? "null" : "'" + b[1] + "'"))
        }
        Has(b) {
            return this._parameters.has(b)
        }
        Get(b) {
            b = this._parameters.get(b);
            return "undefined" === typeof b ? null : b
        }
        ClearHash() {
            history.replaceState("", document.title, location.pathname + location.search)
        }
        Reparse(b) {
            this._queryString = b;
            this._parameters.clear();
            this._Parse()
        }
    };
    d.QueryString = new d.QueryParser(location.search);
    d.LocationHashString = new d.QueryParser(location.hash);
    "dev" !== d.QueryString.Get("mode") && d.SetBuildMode("final")
}
"use strict";
{
    const d = self.C3,
        b = navigator.userAgent;
    let a = {
        linux: /linux|openbsd|freebsd|netbsd/i.test(b),
        chromeOS: /CrOS/.test(b),
        windowsTizen: /trident|iemobile|msie|tizen/i.test(b),
        genericMS: /trident|iemobile|msie|edge\//i.test(b),
        opera: /OPR\//.test(b),
        blackberry: /bb10/i.test(b),
        edge: /edge\//i.test(b),
        trident: /trident/i.test(b),
        webkit: /webkit/i.test(b),
        safari: /safari\//i.test(b),
        chrome: /chrome\//i.test(b),
        chromium: /chromium\//i.test(b),
        crosswalk: /crosswalk|xwalk/i.test(b),
        nwjs: /nwjs/i.test(b),
        amazonwebapp: /amazonwebappplatform/i.test(b),
        webview: /wv\)/.test(b),
        android: /android/i.test(b),
        nokia: /nokiabrowser\/[0-9.]+/i.test(b)
    };
    var JSCompiler_object_inline_windows_0 = /windows\s+nt\s+\d+\.\d+/i.exec(b),
        JSCompiler_object_inline_OSX_1 = /mac\s+os\s+x\s+[0-9_]+/i.exec(b),
        JSCompiler_object_inline_android_2 = /android\s+[0-9.]+/i.exec(b),
        JSCompiler_object_inline_opera_3 = /OPR\/[0-9.]+/.exec(b),
        JSCompiler_object_inline_tizen_4 = /tizen\s+[0-9.]+/i.exec(b),
        JSCompiler_object_inline_iphone_5 = /iphone\s+os\s+[0-9_]+/i.exec(b),
        JSCompiler_object_inline_ipad_6 =
        /ipad[^)]*os\s+[0-9_]+/i.exec(b),
        JSCompiler_object_inline_winPhone_7 = /windows\s+phone\s+[0-9.]+/i.exec(b),
        JSCompiler_object_inline_winPhoneOS_8 = /windows\s+phone\s+os\s+[0-9.]+/i.exec(b),
        JSCompiler_object_inline_chrome_9 = /chrome\/[0-9.]+/i.exec(b),
        JSCompiler_object_inline_chromium_10 = /chromium\/[0-9.]+/i.exec(b),
        JSCompiler_object_inline_nwjs_11 = /nwjs\/[0-9.]+/i.exec(b),
        JSCompiler_object_inline_firefox_12 = /firefox\/[0-9.]+/i.exec(b),
        JSCompiler_object_inline_ie_13 = /msie\s+[0-9.]+/i.exec(b),
        JSCompiler_object_inline_edge_14 =
        /edge\/[0-9.]+/i.exec(b),
        JSCompiler_object_inline_edgeChromium_15 = /edg\/[0-9.]+/i.exec(b),
        JSCompiler_object_inline_silk_16 = /silk\/[0-9.]+/i.exec(b);
    let f = "(unknown)",
        c = "(unknown)",
        e = "(unknown)",
        g = "(unknown)",
        h = "(unknown)",
        l = "(unknown)",
        m = "(unknown)",
        p = "browser",
        t = !1,
        q = !1,
        r = new Map;

    function u(y, C, w) {
        !0 === C ? (w(), r.set(y, !0)) : C && C.length && (w(C[0]), r.set(y, !0))
    }
    u("isWindows", JSCompiler_object_inline_windows_0, y => {
        f = "Windows";
        if (y = y.split(" ")[2]) switch (y) {
            case "5.0":
                c = "2000";
                break;
            case "5.1":
                c = "XP";
                break;
            case "5.2":
                c = "XP";
                break;
            case "6.0":
                c = "Vista";
                break;
            case "6.1":
                c = "7";
                break;
            case "6.2":
                c = "8";
                break;
            case "6.3":
                c = "8.1";
                break;
            case "10.0":
                c = "10"
        }
    });
    u("isOSX", JSCompiler_object_inline_OSX_1, y => {
        f = "Mac OS X";
        (y = y.split(" ")[3]) && (c = y.replace("_", "."))
    });
    u("isLinux", a.linux, () => {
        f = "Linux"
    });
    u("isChromeOS", a.chromeOS, () => {
        f = "Chrome OS"
    });
    u("isAndroid", !a.windowsTizen && JSCompiler_object_inline_android_2, y => {
        f = "Android";
        (y = y.split(" ")[1]) && (c = y)
    });
    u("isTizen", JSCompiler_object_inline_tizen_4, y => {
        f = "Tizen";
        (y = y.split(" ")[1]) && (c = y)
    });
    u("isIPhone", !a.windowsTizen && JSCompiler_object_inline_iphone_5, y => {
        f = "iOS";
        (y = y.split(" ")[2]) && (c = y.replace("_", "."))
    });
    u("isIPad", !a.windowsTizen && JSCompiler_object_inline_ipad_6, y => {
        f = "iOS";
        (y = y.split(" ")[3]) && (c = y.replace("_", "."))
    });
    u("isWindowsPhone", JSCompiler_object_inline_winPhone_7, y => {
        f = "Windows Phone";
        (y = y.split(" ")[2]) && (c = y)
    });
    u("isWindowsPhoneOS", JSCompiler_object_inline_winPhoneOS_8, y => {
        f = "Windows Phone";
        (y = y.split(" ")[3]) && (c = y)
    });
    u("isBlackberry",
        a.blackberry, () => {
            f = "Blackberry";
            c = "10";
            g = "stock";
            m = "webkit"
        });
    u("isChrome", !a.edge && !a.opera && JSCompiler_object_inline_chrome_9, y => {
        g = "Chrome";
        m = "Chromium";
        (y = y.split("/")[1]) && (h = y)
    });
    u("isOpera", JSCompiler_object_inline_opera_3, y => {
        g = "Opera";
        m = "Chromium";
        (y = y.split("/")[1]) && (h = y)
    });
    u("isChromium", JSCompiler_object_inline_chromium_10, y => {
        m = g = "Chromium";
        (y = y.split("/")[1]) && (h = y)
    });
    u("isFirefox", JSCompiler_object_inline_firefox_12, y => {
        g = "Firefox";
        m = "Gecko";
        (y = y.split("/")[1]) && (h = y)
    });
    u("isInternetExplorer",
        JSCompiler_object_inline_ie_13, y => {
            g = "Internet Explorer";
            m = "Trident";
            (y = y.split(" ")[1]) && (h = y)
        });
    u("isTrident", "Internet Explorer" !== g && a.trident, () => {
        m = "Trident";
        var y = /rv:[0-9.]+/i.exec(b);
        y && y.length && (g = "Internet Explorer", (y = y[0].split(":")[1]) && (h = y))
    });
    u("isEdge", JSCompiler_object_inline_edge_14, y => {
        m = g = "Edge";
        (y = y.split("/")[1]) && (h = y)
    });
    u("isEdgeChromium", JSCompiler_object_inline_edgeChromium_15, y => {
        g = "Edge";
        m = "Chromium";
        (y = y.split("/")[1]) && (h = y)
    });
    u("isSafari", a.safari && !a.nokia && !a.chrome &&
        !a.chromium && !a.genericIE && !a.blackberry, () => {
            g = "Safari";
            m = "WebKit";
            var y = /version\/[0-9.]+/i.exec(b),
                C = /crios\/[0-9.]+/i.exec(b),
                w = /fxios\/[0-9.]+/i.exec(b);
            y && y.length && (y = y[0].split("/")[1]) && (h = y);
            C && C.length && (g = "Chrome for iOS", (C = C[0].split("/")[1]) && (h = C));
            w && w.length && (g = "Firefox for iOS", (w = w[0].split("/")[1]) && (h = w))
        });
    u("isSilk", JSCompiler_object_inline_silk_16, y => {
        g = "Silk";
        (y = y.split("/")[1]) && (h = y)
    });
    u("isCrosswalk", a.crosswalk, () => p = "crosswalk");
    u("isCordova", self.device && (self.device.cordova ||
        self.device.phonegap), () => p = "cordova");
    u("isNWJS", JSCompiler_object_inline_nwjs_11, y => {
        p = "nwjs";
        g = "NW.js";
        m = "Chromium";
        (y = y.split("/")[1]) && (h = y)
    });
    u("isAmazonWebApp", a.amazonwebapp, () => p = "webapp");
    u("isHomeScreenWebApp", "nwjs" !== p && "undefined" !== typeof window && (window.matchMedia && window.matchMedia("(display-mode: standalone)").matches || navigator.standalone), () => p = "webapp");
    u("isFalseSafari", "Safari" === g && ("Android" === f || "Tizen" === f || "Blackberry" === f), () => g = "stock");
    u("isAndroidWebview", "Chrome" ===
        g && "browser" === p && a.webview, () => p = "webview");
    u("isFirefoxOS", "Firefox" === g && "(unknown)" === f, () => f = "Firefox OS");
    u("isAndroidFallback", "(unknown)" === f && !a.windowsTizen && a.android, () => f = "Android");
    u("isTridentFallback", "(unknown)" === f && a.trident, () => m = "Trident");
    u("isWebkitFallback", "(unknown)" === f && a.webkit, () => m = "WebKit");
    u("is64Bit", (y => y.test(b) || y.test(navigator.platform) || "x64" === navigator.cpuClass)(/x86_64|x86-64|win64|x64;|x64\)|x64_|amd64|wow64|ia64|arm64|arch64|sparc64|ppc64|irix64/i), () =>
        e = "64-bit");
    u("is32Bit", (y => y.test(b) || y.test(navigator.platform) || "x86" === navigator.cpuClass)(/x86;|x86\)|i86|i386|i486|i586|i686|armv1|armv2|armv3|armv4|armv5|armv6|armv7/i), () => e = "32-bit");
    u("is64BitFallback", "(unknown)" === e && "Mac OS X" === f && 10.7 <= parseFloat(c), () => e = "64-bit");
    u("is32BitFallback", "(unknown)" === e && "Windows" === f || "Android" === f && 5 > parseFloat(c), () => e = "32-bit");
    u("is32BitBrowser", "32-bit" === e || /wow64/i.test(b), () => l = "32-bit");
    u("is64BitBrowser", /win64/i.test(b), () => l = "64-bit");
    u("isDesktop",
        (() => "Windows" === f || "Mac OS X" === f || "Linux" === f || "Chrome OS" === f || "nwjs" === p)(), () => t = !0);
    "Edge" === m && "undefined" !== typeof Windows && "undefined" !== typeof Windows.System && (p = "windows-store");
    q = "nwjs" === p;
    const x = "Mac OS X" === f && navigator.maxTouchPoints && 2 < navigator.maxTouchPoints;
    x && (f = "iOS", c = h, q = t = !1);
    d.Platform = {
        OS: f,
        OSVersion: c,
        OSArchitecture: e,
        Browser: g,
        BrowserVersion: h,
        BrowserVersionNumber: parseFloat(h),
        BrowserArchitecture: l,
        BrowserEngine: m,
        Context: p,
        IsDesktop: t,
        IsMobile: !t,
        IsDesktopApp: q,
        IsChromeWebStore: !!(self.chrome &&
            self.chrome.runtime && self.chrome.runtime.id),
        IsAppleOS: "Mac OS X" === f || "iOS" === f,
        IsIpadOS: x,
        IsLinux: "Linux" === f
    }
}
"use strict";
{
    const d = new Map,
        b = "undefined" !== typeof IDBObjectStore && "function" === typeof IDBObjectStore.prototype.getAll,
        a = "undefined" !== typeof IDBObjectStore && "function" === typeof IDBObjectStore.prototype.getAllKeys;

    function f(r) {
        return new Promise((u, x) => {
            r.onsuccess = () => u(r.result);
            r.onerror = () => x(r.error)
        })
    }

    function c(r) {
        return new Promise((u, x) => {
            r.oncomplete = () => u();
            r.onerror = () => x(r.error);
            r.onabort = () => x(r.error)
        })
    }

    function e(r, u) {
        return h(r, u)
    }

    function g(r, u) {
        return h(r, u, !0)
    }
    async function h(r, u, x = !1,
        y = !0) {
        const C = await l(r);
        try {
            const w = C.transaction(["keyvaluepairs"], x ? "readwrite" : "readonly");
            return u(w)
        } catch (w) {
            if (y && "InvalidStateError" === w.name) return d.delete(r), h(r, u, x, !1);
            throw w;
        }
    }

    function l(r) {
        p(r);
        let u = d.get(r);
        u instanceof Promise || (u = m(r), d.set(r, u), u.catch(x => d.delete(r)));
        return u
    }
    async function m(r) {
        p(r);
        const u = indexedDB.open(r, 2);
        u.addEventListener("upgradeneeded", x => {
            try {
                x.target.result.createObjectStore("keyvaluepairs")
            } catch (y) {
                console.error(`Failed to create objectstore for database ${r}`,
                    y)
            }
        });
        return f(u)
    }

    function p(r) {
        if ("string" !== typeof r) throw new TypeError("expected string");
    }

    function t(r, u) {
        const x = r.objectStore("keyvaluepairs").openCursor();
        return new Promise(y => {
            const C = [];
            x.onsuccess = w => {
                if (w = w.target.result) {
                    switch (u) {
                        case "entries":
                            C.push([w.key, w.value]);
                            break;
                        case "keys":
                            C.push(w.key);
                            break;
                        case "values":
                            C.push(w.value)
                    }
                    w.continue()
                } else y(C)
            }
        })
    }
    class q {
        constructor(r) {
            p(r);
            this.name = r
        }
        async ready() {
            await l(this.name)
        }
        set(r, u) {
            p(r);
            return g(this.name, async x => {
                var y = x.objectStore("keyvaluepairs").put(u,
                    r);
                y = f(y);
                x = c(x);
                await Promise.all([x, y])
            })
        }
        get(r) {
            p(r);
            return e(this.name, async u => {
                var x = u.objectStore("keyvaluepairs").get(r);
                x = f(x);
                u = c(u);
                [, u] = await Promise.all([u, x]);
                return u
            })
        }
        delete(r) {
            p(r);
            return g(this.name, async u => {
                var x = u.objectStore("keyvaluepairs").delete(r);
                x = f(x);
                u = c(u);
                await Promise.all([u, x])
            })
        }
        clear() {
            return g(this.name, async r => {
                var u = r.objectStore("keyvaluepairs").clear();
                u = f(u);
                r = c(r);
                await Promise.all([r, u])
            })
        }
        keys() {
            return e(this.name, async r => {
                if (a) {
                    var u = r.objectStore("keyvaluepairs").getAllKeys();
                    u = f(u)
                } else u = t(r, "keys");
                r = c(r);
                [, r] = await Promise.all([r, u]);
                return r
            })
        }
        values() {
            return e(this.name, async r => {
                if (b) {
                    var u = r.objectStore("keyvaluepairs").getAll();
                    u = f(u)
                } else u = t(r, "values");
                r = c(r);
                [, r] = await Promise.all([r, u]);
                return r
            })
        }
        entries() {
            return e(this.name, async r => {
                var u = t(r, "entries");
                r = c(r);
                [, u] = await Promise.all([r, u]);
                return u
            })
        }
    }
    self.KVStorageContainer = q
}
"use strict";
{
    const d = self.KVStorageContainer,
        b = [/no available storage method found/i, /an attempt was made to break through the security policy of the user agent/i, /the user denied permission to access the database/i, /a mutation operation was attempted on a database that did not allow mutations/i, /idbfactory\.open\(\) called in an invalid security context/i],
        a = new WeakMap;
    let f = !1;
    "undefined" === typeof indexedDB && (f = !0, console.warn("Unable to use local storage because indexedDB is not defined"));

    function c(l) {
        throw Error(`"${l}" is not implemented`);
    }

    function e(l) {
        if ("function" === typeof l) throw Error("localforage callback API is not implemented; please use the promise API instead");
    }

    function g(l) {
        return "object" === typeof l ? new Promise(m => {
            const {
                port1: p,
                port2: t
            } = new MessageChannel;
            t.onmessage = q => m(q.data);
            p.postMessage(l)
        }) : Promise.resolve(l)
    }
    class h {
        constructor(l) {
            this._inst = l;
            a.set(this, new Map)
        }
        _MaybeSwitchToMemoryFallback(l) {
            if (!f)
                for (const m of b)
                    if (l && m.test(l.message)) {
                        console.error("Unable to use local storage, reverting to in-memory store: ",
                            l, l.message);
                        f = !0;
                        break
                    }
        }
        async _getItemFallback(l) {
            l = a.get(this).get(l);
            l = await g(l);
            return "undefined" === typeof l ? null : l
        }
        async _setItemFallback(l, m) {
            m = await g(m);
            a.get(this).set(l, m)
        }
        _removeItemFallback(l) {
            a.get(this).delete(l)
        }
        _clearFallback() {
            a.get(this).clear()
        }
        _keysFallback() {
            return Array.from(a.get(this).keys())
        }
        IsUsingFallback() {
            return f
        }
        async getItem(l, m) {
            e(m);
            if (f) return await this._getItemFallback(l);
            let p;
            try {
                p = await this._inst.get(l)
            } catch (t) {
                this._MaybeSwitchToMemoryFallback(t);
                if (f) return await this._getItemFallback(l);
                console.error(`Error reading '${l}' from storage, returning null: `, t);
                return null
            }
            return "undefined" === typeof p ? null : p
        }
        async setItem(l, m, p) {
            e(p);
            "undefined" === typeof m && (m = null);
            if (f) await this._setItemFallback(l, m);
            else try {
                await this._inst.set(l, m)
            } catch (t) {
                if (this._MaybeSwitchToMemoryFallback(t), f) await this._setItemFallback(l, m);
                else throw t;
            }
        }
        async removeItem(l, m) {
            e(m);
            if (f) this._removeItemFallback(l);
            else try {
                await this._inst.delete(l)
            } catch (p) {
                this._MaybeSwitchToMemoryFallback(p), f ? this._removeItemFallback(l) :
                    console.error(`Error removing '${l}' from storage: `, p)
            }
        }
        async clear(l) {
            e(l);
            if (f) this._clearFallback();
            else try {
                await this._inst.clear()
            } catch (m) {
                this._MaybeSwitchToMemoryFallback(m), f ? this._clearFallback() : console.error("Error clearing storage: ", m)
            }
        }
        async keys(l) {
            e(l);
            if (f) return this._keysFallback();
            l = [];
            try {
                l = await this._inst.keys()
            } catch (m) {
                this._MaybeSwitchToMemoryFallback(m);
                if (f) return this._keysFallback();
                console.error("Error getting storage keys: ", m)
            }
            return l
        }
        ready(l) {
            e(l);
            return f ? Promise.resolve(!0) :
                this._inst.ready()
        }
        createInstance(l) {
            if ("object" !== typeof l) throw new TypeError("invalid options object");
            l = l.name;
            if ("string" !== typeof l) throw new TypeError("invalid store name");
            l = new d(l);
            return new h(l)
        }
        length(l) {
            c("localforage.length()")
        }
        key(l, m) {
            c("localforage.key()")
        }
        iterate(l, m) {
            c("localforage.iterate()")
        }
        setDriver(l) {
            c("localforage.setDriver()")
        }
        config(l) {
            c("localforage.config()")
        }
        defineDriver(l) {
            c("localforage.defineDriver()")
        }
        driver() {
            c("localforage.driver()")
        }
        supports(l) {
            c("localforage.supports()")
        }
        dropInstance() {
            c("localforage.dropInstance()")
        }
        disableMemoryMode() {
            f = !1
        }
    }
    self.localforage = new h(new d("localforage"))
}
"use strict";
{
    const d = self.C3;
    d.Supports = {};
    d.Supports.WebAnimations = (() => {
        try {
            if ("Safari" === d.Platform.Browser || "undefined" === typeof document) return !1;
            const b = document.createElement("div");
            return "undefined" === typeof b.animate ? !1 : "undefined" !== typeof b.animate([{
                opacity: "0"
            }, {
                opacity: "1"
            }], 1E3).reverse
        } catch (b) {
            return !1
        }
    })();
    d.Supports.DialogElement = "undefined" !== typeof HTMLDialogElement;
    d.Supports.RequestIdleCallback = !!self.requestIdleCallback;
    d.Supports.ImageBitmap = !!self.createImageBitmap;
    d.Supports.ImageBitmapOptions = !1;
    if (d.Supports.ImageBitmap) try {
        self.createImageBitmap(new ImageData(32, 32), {
            premultiplyAlpha: "none"
        }).then(b => {
            d.Supports.ImageBitmapOptions = !0
        }).catch(b => {
            d.Supports.ImageBitmapOptions = !1
        })
    } catch (b) {
        d.Supports.ImageBitmapOptions = !1
    }
    d.Supports.ClipboardReadText = !(!navigator.clipboard || !navigator.clipboard.readText || "Firefox" === d.Platform.Browser);
    d.Supports.PermissionsQuery = !(!navigator.permissions || !navigator.permissions.query);
    d.Supports.Proxies = "undefined" !== typeof Proxy;
    d.Supports.DownloadAttribute =
        (() => "undefined" === typeof document ? !1 : "undefined" !== typeof document.createElement("a").download)();
    d.Supports.CanvasToBlob = (() => "undefined" !== typeof HTMLCanvasElement && HTMLCanvasElement.prototype.toBlob)();
    d.Supports.Fetch = "function" === typeof fetch;
    d.Supports.PersistentStorage = !!(self.isSecureContext && "Opera" !== d.Platform.Browser && navigator.storage && navigator.storage.persist);
    d.Supports.StorageQuotaEstimate = !!(self.isSecureContext && navigator.storage && navigator.storage.estimate);
    d.Supports.Fullscreen =
        (() => {
            if ("undefined" === typeof document || "iOS" === d.Platform.OS) return !1;
            const b = document.documentElement;
            return !!(b.requestFullscreen || b.msRequestFullscreen || b.mozRequestFullScreen || b.webkitRequestFullscreen)
        })();
    d.Supports.ImageDecoder = "undefined" !== typeof self.ImageDecoder;
    d.Supports.NativeFileSystemAPI = !!self.showOpenFilePicker;
    d.Supports.NavigatorFontsQuery = !(!navigator.fonts || !navigator.fonts.query)
}
"use strict";
{
    const d = self.C3;
    if (!String.prototype.trimStart) {
        const b = /^[\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF]*/;
        String.prototype.trimStart = function() {
            return this.replace(b, "")
        }
    }
    if (!String.prototype.trimEnd) {
        const b = /[\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF]*$/;
        String.prototype.trimEnd = function() {
            return this.replace(b,
                "")
        }
    }
    String.prototype.replaceAll || (String.prototype.replaceAll = function(b, a) {
        return this.replace(new RegExp(d.EscapeRegex(b), "g"), a)
    });
    Array.prototype.values || (Array.prototype.values = function*() {
        for (const b of this) yield b
    });
    if (!Array.prototype.flat) {
        function b(a, f) {
            return a.reduce((c, e) => {
                0 < f && Array.isArray(e) ? Array.prototype.push.apply(c, b(e, f - 1)) : c.push(e);
                return c
            }, [])
        }
        Array.prototype.flat = function(a = 1) {
            return b(this, a)
        }
    }
    RegExp.escape || (RegExp.escape = function(b) {
        return String(b).replace(/[\\^$*+?.()|[\]{}]/g,
            "\\$&")
    });
    navigator.storage && !navigator.storage.estimate && navigator.webkitTemporaryStorage && navigator.webkitTemporaryStorage.queryUsageAndQuota && (navigator.storage.estimate = function() {
        return new Promise((b, a) => navigator.webkitTemporaryStorage.queryUsageAndQuota((f, c) => b({
            usage: f,
            quota: c
        }), a))
    });
    "undefined" === typeof HTMLCollection || HTMLCollection.prototype[Symbol.iterator] || (HTMLCollection.prototype[Symbol.iterator] = function() {
        let b = 0;
        return {
            next: () => b >= this.length ? {
                done: !0
            } : {
                value: this.item(b++),
                done: !1
            }
        }
    });
    "undefined" === typeof NodeList || NodeList.prototype[Symbol.iterator] || (NodeList.prototype[Symbol.iterator] = function() {
        let b = 0;
        return {
            next: () => b >= this.length ? {
                done: !0
            } : {
                value: this.item(b++),
                done: !1
            }
        }
    });
    "undefined" === typeof DOMTokenList || DOMTokenList.prototype[Symbol.iterator] || (DOMTokenList.prototype[Symbol.iterator] = function() {
        let b = 0;
        return {
            next: () => b >= this.length ? {
                done: !0
            } : {
                value: this.item(b++),
                done: !1
            }
        }
    });
    "undefined" === typeof FileList || FileList.prototype[Symbol.iterator] || (FileList.prototype[Symbol.iterator] =
        function() {
            let b = 0;
            return {
                next: () => b >= this.length ? {
                    done: !0
                } : {
                    value: this.item(b++),
                    done: !1
                }
            }
        });
    "undefined" === typeof TextEncoder && (self.TextEncoder = class {
        constructor() {
            Object.defineProperty(this, "encoding", {
                value: "utf-8",
                writable: !1
            })
        }
        encode(b) {
            for (var a = b.length, f = -1, c = new Uint8Array(3 * a), e, g, h = 0; h !== a;) {
                e = b.charCodeAt(h);
                h += 1;
                if (55296 <= e && 56319 >= e) {
                    if (h === a) {
                        c[f += 1] = 239;
                        c[f += 1] = 191;
                        c[f += 1] = 189;
                        break
                    }
                    g = b.charCodeAt(h);
                    if (56320 <= g && 57343 >= g) {
                        if (e = 1024 * (e - 55296) + g - 56320 + 65536, h += 1, 65535 < e) {
                            c[f += 1] = 240 |
                                e >>> 18;
                            c[f += 1] = 128 | e >>> 12 & 63;
                            c[f += 1] = 128 | e >>> 6 & 63;
                            c[f += 1] = 128 | e & 63;
                            continue
                        }
                    } else {
                        c[f += 1] = 239;
                        c[f += 1] = 191;
                        c[f += 1] = 189;
                        continue
                    }
                }
                127 >= e ? c[f += 1] = 0 | e : (2047 >= e ? c[f += 1] = 192 | e >>> 6 : (c[f += 1] = 224 | e >>> 12, c[f += 1] = 128 | e >>> 6 & 63), c[f += 1] = 128 | e & 63)
            }
            return new Uint8Array(c.buffer.slice(0, f + 1))
        }
        toString() {
            return "[object TextEncoder]"
        }
    }, TextEncoder[Symbol.toStringTag] = "TextEncoder");
    if ("undefined" === typeof TextDecoder) {
        function b(c) {
            const e = c[Symbol.iterator]();
            return {
                next: g => e.next(),
                [Symbol.iterator]() {
                    return this
                }
            }
        }

        function a(c) {
            c = c.next();
            if (c.done) throw Error("unexpected end of input");
            if (0 != (c.value & 192 ^ 128)) throw Error("invalid byte");
            return c.value & 63
        }
        const f = new Map;
        f.set("utf-8", (c, e) => {
            if (c.buffer) var g = new Uint8Array(c.buffer, c.byteOffset, c.byteLength);
            else if (g instanceof ArrayBuffer) g = new Uint8Array(c);
            else throw Error("Invalid parameter");
            c = b(g);
            g = [];
            try {
                for (const h of c) {
                    let l;
                    if (127 > h) l = h & 127;
                    else if (223 > h) l = (h & 31) << 6 | a(c);
                    else if (239 > h) l = (h & 15) << 12 | a(c) << 6 | a(c);
                    else if (247 > h) l = (h & 7) << 18 | a(c) <<
                        12 | a(c) << 6 | a(c);
                    else throw Error("Invalid character");
                    g.push(String.fromCodePoint(l))
                }
            } catch (h) {
                if (e) throw h;
                g.push("\ufffd")
            }
            return g.join("")
        });
        f.set("utf8", f.get("utf-8"));
        f.set("utf-16le", (c, e) => {
            throw Error("utf-16le decoder not implemented");
        });
        self.TextDecoder = class {
            constructor(c = "utf-8", e = {}) {
                const g = f.get(c);
                if (!g) throw Error(`TextDecoder polyfill does not support "${c}"`);
                Object.defineProperty(this, "fatal", {
                    value: !0 === e.fatal,
                    writable: !1
                });
                Object.defineProperty(this, "_decoder", {
                    value: g,
                    writable: !1
                });
                Object.defineProperty(this, "encoding", {
                    value: c,
                    writable: !1
                })
            }
            decode(c) {
                return this._decoder(c, this.fatal)
            }
            toString() {
                return "[object TextDecoder]"
            }
        };
        TextDecoder[Symbol.toStringTag] = "TextDecoder"
    }
    "undefined" === typeof self.isSecureContext && (self.isSecureContext = "https:" === location.protocol);
    "undefined" === typeof self.globalThis && (self.globalThis = self)
}
"use strict";
{
    const d = self.C3;

    function b(a) {
        let f = d.GetCallStack();
        console.error("Assertion failure: " + a + "\n\nStack trace:\n" + f)
    }
    self.assert = function(a, f) {
        a || b(f)
    }
}
"use strict";
{
    const d = self.C3;
    d.IsNumber = function(a) {
        return "number" === typeof a
    };
    d.IsFiniteNumber = function(a) {
        return d.IsNumber(a) && isFinite(a)
    };
    d.RequireNumber = function(a) {
        if (!d.IsNumber(a)) throw new TypeError("expected number");
    };
    d.RequireOptionalNumber = function(a) {
        d.IsNullOrUndefined(a)
    };
    d.RequireNumberInRange = function(a, f, c) {
        if (!d.IsNumber(a) || isNaN(a) || f > a || c < a) throw new RangeError("number outside of range");
    };
    d.RequireAllNumber = function(...a) {
        for (let f of a);
    };
    d.RequireFiniteNumber = function(a) {
        if (!d.IsFiniteNumber(a)) throw new TypeError("expected finite number");
    };
    d.RequireOptionalFiniteNumber = function(a) {
        d.IsNullOrUndefined(a)
    };
    d.RequireAllFiniteNumber = function(...a) {
        for (let f of a);
    };
    d.IsString = function(a) {
        return "string" === typeof a
    };
    d.RequireString = function(a) {
        if (!d.IsString(a)) throw new TypeError("expected string");
    };
    d.RequireOptionalString = function(a) {
        d.IsNullOrUndefined(a)
    };
    d.RequireAllString = function(...a) {
        for (let f of a);
    };
    d.IsSimpleObject = function(a) {
        return "object" !== typeof a || null === a ? !1 : (a = Object.getPrototypeOf(a)) ? a.constructor === Object : null ===
            a
    };
    d.RequireSimpleObject = function(a) {
        if (!d.IsSimpleObject(a)) throw new TypeError("expected simple object");
    };
    d.RequireOptionalSimpleObject = function(a) {
        if (!d.IsNullOrUndefined(a) && !d.IsSimpleObject(a)) throw new TypeError("expected simple object");
    };
    d.IsObject = function(a) {
        return "object" === typeof a && null !== a && !Array.isArray(a)
    };
    d.RequireObject = function(a) {
        if (!d.IsObject(a)) throw new TypeError("expected object");
    };
    d.RequireOptionalObject = function(a) {
        d.IsNullOrUndefined(a)
    };
    d.RequireAllObject = function(...a) {
        for (let f of a);
    };
    d.IsFileLike = function(a) {
        return d.IsInstanceOf(a, Blob) && "string" === typeof a.name
    };
    d.RequireFileLike = function(a) {
        if (!d.IsFileLike(a)) throw new TypeError("expected file");
    };
    d.RequireOptionalFileLike = function(a) {
        d.IsNullOrUndefined(a)
    };
    d.IsArray = function(a) {
        return Array.isArray(a)
    };
    d.RequireArray = function(a) {
        if (!d.IsArray(a)) throw new TypeError("expected array");
    };
    d.RequireOptionalArray = function(a) {
        d.IsNullOrUndefined(a)
    };
    d.RequireAllArray = function(...a) {
        for (let f of a);
    };
    d.Is2DArray = function(a) {
        return d.IsArray(a) ?
            a.length ? d.IsArray(a[0]) ? !0 : !1 : !0 : !1
    };
    d.Require2DArray = function(a) {
        if (!d.Is2DArray(a)) throw new TypeError("expected 2d array");
        for (let f of a)
            if (!d.IsArray(f)) throw new TypeError("expected 2d array");
    };
    d.RequireOptional2DArray = function(a) {
        d.IsNullOrUndefined(a)
    };
    d.IsFunction = function(a) {
        return "function" === typeof a
    };
    d.RequireFunction = function(a, f) {
        if (!d.IsFunction(a)) throw new TypeError("expected function");
        if (!d.IsNullOrUndefined(f) && a !== f) throw new TypeError("expected same function reference");
    };
    d.RequireOptionalFunction = function(a) {
        d.IsNullOrUndefined(a)
    };
    d.RequireAllFunction = function(...a) {
        for (let f of a);
    };
    d.RequireAnyFunction = function(a, ...f) {
        if (!d.IsFunction(a)) throw new TypeError("expected function");
        if (!f.length) throw Error("missing comparison functions");
        for (let c of f)
            if (!d.IsNullOrUndefined(c) && a === c) return;
        throw new TypeError("expected same function reference");
    };
    d.RequireOptionalAllFunction = function(...a) {
        if (!d.IsNullOrUndefined(a))
            for (let f of a);
    };
    d.IsInstanceOf = function(a,
        f) {
        return a instanceof f
    };
    d.IsInstanceOfAny = function(a, ...f) {
        for (let c of f)
            if (d.IsInstanceOf(a, c)) return !0;
        return !1
    };
    d.RequireInstanceOf = function(a, f) {
        if (!d.IsInstanceOf(a, f)) throw new TypeError("unexpected type");
    };
    d.RequireOptionalInstanceOf = function(a, f) {
        d.IsNullOrUndefined(a)
    };
    d.RequireAllInstanceOf = function(a, ...f) {
        for (let c of f);
    };
    d.RequireAnyInstanceOf = function(a, ...f) {
        if (!d.IsInstanceOfAny(a, ...f)) throw new TypeError("unexpected type");
    };
    d.RequireAnyOptionalInstanceOf = function(a, ...f) {
        if (!d.IsNullOrUndefined(a) &&
            !d.IsInstanceOfAny(a, ...f)) throw new TypeError("unexpected type");
    };
    d.IsArrayOf = function(a, f) {
        for (let c of a)
            if (!d.IsInstanceOf(c, f)) return !1;
        return !0
    };
    d.IsArrayOfFiniteNumbers = function(a) {
        for (let f of a)
            if (!d.IsFiniteNumber(f)) return !1;
        return !0
    };
    d.RequireArrayOf = function(a, f) {
        for (let c of a);
    };
    d.RequireOptionalArrayOf = function(a, f) {
        if (!d.IsNullOrUndefined(a))
            for (let c of a);
    };
    d.RequireArrayOfAny = function(a, ...f) {
        for (let c of a);
    };
    d.RequireOptionalArrayOfAny = function(a, ...f) {
        if (!d.IsNullOrUndefined(a))
            for (let c of a);
    };
    d.IsDOMNode = function(a, f) {
        return d.IsNullOrUndefined(a) || !d.IsString(a.nodeName) ? !1 : !f || d.equalsNoCase(a.nodeName, f)
    };
    d.RequireDOMNode = function(a, f) {
        if (d.IsNullOrUndefined(a) || !d.IsString(a.nodeName)) throw new TypeError("expected DOM node");
        if (f && !d.equalsNoCase(a.nodeName, f)) throw new TypeError(`expected DOM '${f}' node`);
    };
    d.RequireOptionalDOMNode = function(a, f) {
        d.IsNullOrUndefined(a)
    };
    d.IsHTMLElement = function(a, f) {
        return d.IsNullOrUndefined(a) || !d.IsString(a.tagName) ? !1 : !f || d.equalsNoCase(a.tagName,
            f)
    };
    d.RequireHTMLElement = function(a, f) {
        if (d.IsNullOrUndefined(a) || !d.IsString(a.tagName)) throw new TypeError("expected HTML element");
        if (f && !d.equalsNoCase(a.tagName, f)) throw new TypeError(`expected HTML '${f}' element`);
    };
    d.RequireOptionalHTMLElement = function(a, f) {
        d.IsNullOrUndefined(a)
    };
    d.IsDrawable = function(a) {
        return d.IsHTMLElement(a, "img") || d.IsHTMLElement(a, "canvas") || d.IsHTMLElement(a, "video") || "undefined" !== typeof OffscreenCanvas && a instanceof OffscreenCanvas || "undefined" !== typeof ImageBitmap &&
            a instanceof ImageBitmap
    };
    d.RequireDrawable = function(a) {
        if (!d.IsDrawable(a)) throw new TypeError("expected drawable");
    };
    d.RequireOptionalDrawable = function(a) {
        d.IsNullOrUndefined(a)
    };
    d.IsDrawableOrImageData = function(a) {
        return a instanceof ImageData ? !0 : d.IsDrawable(a)
    };
    d.RequireDrawableOrImageData = function(a) {
        if (!d.IsDrawableOrImageData(a)) throw new TypeError("expected drawable or image data");
    };
    d.RequireOptionalDrawableOrImageData = function(a) {
        if (!d.IsNullOrUndefined(a) && !d.IsDrawableOrImageData(a)) throw new TypeError("expected drawable or image data");
    };
    d.IsStringLike = function(a) {
        return "string" === typeof a || a instanceof d.HtmlString || a instanceof d.BBString
    };
    d.RequireStringLike = function(a) {
        if (!d.IsStringLike(a)) throw new TypeError("expected string-like");
    };
    d.RequireOptionalStringLike = function(a) {
        d.IsNullOrUndefined(a)
    };
    d.RequireAllStringLike = function(...a) {
        for (let f of a);
    };
    d.RequireOverride = function() {
        throw Error("must be overridden");
    };
    d.NotYetImplemented = function() {
        throw Error("not yet implemented");
    };
    d.IsDefined = function(a, ...f) {
        if ("undefined" ===
            typeof a) return !1;
        for (let c of f) {
            if ("undefined" === typeof a[c]) return !1;
            a = a[c]
        }
        return !0
    };
    d.IsNullOrUndefined = function(a) {
        return "undefined" === typeof a || null === a
    };
    d.AreArrayElementsOfSameType = function(a) {
        let f = a[0].constructor;
        for (let c of a)
            if (c.constructor !== f) return !1;
        return f
    };
    d.AreArrayElementsOfType = function(a, f) {
        for (let c of a)
            if (!(c instanceof f)) return !1;
        return !0
    };
    const b = Object.getPrototypeOf(Uint8Array);
    d.IsTypedArray = function(a) {
        return d.IsInstanceOf(a, b)
    };
    d.RequireTypedArray = function(a) {};
    d.WeakRequireTypedArray = function(a) {
        d.WeakRequireInstanceOf(a, b)
    };
    d.WeakRequireAnyInstanceOf = function(a, ...f) {
        if (!d.WeakIsAnyInstanceOf(a, ...f)) throw new TypeError("unexpected type");
    };
    d.WeakIsAnyInstanceOf = function(a, ...f) {
        for (const c of f)
            if (d.WeakIsInstanceOf(a, c)) return !0;
        return !1
    };
    d.WeakRequireInstanceOf = function(a, f) {
        if (!d.WeakIsInstanceOf(a, f)) throw new TypeError("unexpected type");
    };
    d.WeakIsInstanceOf = function(a, f) {
        for (; a = Object.getPrototypeOf(a);)
            if (a.constructor.name === f.name) return !0;
        return !1
    }
}
"use strict";
{
    const d = self.C3;
    d.GetCallStack = function() {
        return Error().stack
    };
    d.Debugger = function() {
        debugger
    };
    d.cast = function(r, u) {
        return r && r instanceof u ? r : null
    };
    d.getName = function(r) {
        return "undefined" === typeof r ? "undefined" : null === r ? "null" : "boolean" === typeof r ? "<boolean>" : d.IsNumber(r) ? "<number>" : d.IsString(r) ? "<string>" : d.IsArray(r) ? "<array>" : "symbol" === typeof r ? "<" + r.toString() + ">" : d.IsFunction(r) ? r.name && "Function" !== r.name ? r.name : "<anonymous function>" : "object" === typeof r ? r.constructor && r.constructor.name &&
            "Object" !== r.constructor.name ? r.constructor.name : "<anonymous object>" : "<unknown>"
    };
    d.getType = function(r) {
        return null === r ? "null" : Array.isArray(r) ? "array" : typeof r
    };
    d.range = function*(r, u) {
        if (!isFinite(Math.abs(r - u))) throw Error("Invalid parameters");
        if (r > u)
            for (--r; r >= u; r--) yield r;
        else
            for (; r < u; r++) yield r
    };

    function b(r, u) {
        r = d.getType(r);
        u = d.getType(u);
        return "null" === r || "null" === u ? !0 : "undefined" === r || "undefined" === u ? !1 : r === u
    }
    let a = new Map,
        f = new Map,
        c = new WeakMap,
        e = new WeakMap;
    d.DefendHandler = {};
    const g =
        new Set(["then", "splice"]);

    function h(r) {
        console.warn("[Defence] " + r + " @", d.GetCallStack())
    }
    d.DefendHandler.get = function(r, u) {
        u in r || "symbol" === typeof u || g.has(u) || h(`Accessed missing property '${u}' from defended object '${d.getName(r)}', returning undefined`);
        e.has(r) && "symbol" !== typeof u && !g.has(u) && h(`Accessed property '${u}' on a released object '${d.getName(r)}'\nObject was originally released at: ${e.get(r)})\nCall stack at access: `);
        return r[u]
    };
    d.DefendHandler.set = function(r, u, x) {
        u in r ||
            a.has(r) || h(`Set non-existent property '${u}' to '${x}' on defended object '${d.getName(r)}'`);
        b(r[u], x) || a.has(r) || h(`Set '${d.getType(r[u])}' property '${u}' to type '${d.getType(x)}' on defended object '${d.getName(r)}'`);
        e.has(r) && h(`Set property '${u}' on a released object '${d.getName(r)}'\nObject was originally released at: ${e.get(r)})\nCall stack at access: `);
        r[u] = x;
        return !0
    };
    d.DefendHandler.deleteProperty = function(r, u) {
        throw new ReferenceError(`Cannot delete property '${u}' from defended object '${d.getName(r)}'`);
    };
    d.DefendHandler.defineProperty = function(r, u, x) {
        throw new ReferenceError(`Cannot define property '${u}' on defended object '${d.getName(r)}'`);
    };
    d.DefendHandler.enumerate = function(r) {
        throw new ReferenceError(`Cannot enumerate defended object '${d.getName(r)}'`);
    };
    let l = -1;

    function m() {
        l = -1;
        if (0 < a.size || 0 < f.size) {
            let r = [...new Set([...a.keys()].map(u => d.getName(u)))].join();
            console.warn(`An object derived from DefendedBase was not protected with debugDefend(). This will disable some checks. See the coding guidelines! Possible affected class names: ${r}`);
            a.clear();
            f.clear()
        }
    }
    d.DefendedBase = class {
        constructor() {
            if (d.isDebugDefend && d.Supports.Proxies) {
                var r = new.target;
                r = Object.create(r.prototype);
                var u = new Proxy(r, d.DefendHandler);
                a.set(r, u);
                f.set(u, r);
                c.set(u, r); - 1 === l && (l = requestAnimationFrame(m));
                return u
            }
        }
    };
    d.debugDefend = function(r) {
        if (d.isDebugDefend && d.Supports.Proxies && r instanceof d.DefendedBase) {
            if (!f.has(r)) return r;
            let u = f.get(r);
            f.delete(r);
            a.delete(u);
            return r
        }
        return d.isDebug ? Object.seal(r) : r
    };
    d.New = function(r, ...u) {
        let x;
        try {
            x = new r(...u)
        } catch (y) {
            throw f.clear(),
                a.clear(), y;
        }
        d.isDebugDefend && q(r, x);
        return d.debugDefend(x)
    };
    d.Release = function(r) {
        (r = c.get(r)) && e.set(r, d.GetCallStack())
    };
    d.WasReleased = function(r) {
        return (r = c.get(r)) ? !!e.get(r) : !1
    };
    let p = new Map;

    function t(r) {
        let u = new Set;
        for (let x in r) u.add(x);
        return u
    }

    function q(r, u) {
        u = t(u);
        let x = p.get(r);
        if (x) {
            let y = [];
            for (let C of x.values()) u.has(C) ? u.delete(C) : y.push(C);
            d.appendArray(y, [...u]);
            y.length && console.warn(`[Defence] '${d.getName(r)}' constructor creates inconsistent properties: ${y.join(", ")}`)
        } else p.set(r,
            u)
    }
    d.PerfMark = class {
        constructor(r) {
            this._name = "";
            r && this.start(r)
        }
        start(r) {
            this._name = r;
            performance.mark(this._name + "-Start")
        }
        end() {
            performance.mark(this._name + "-End");
            performance.measure(this._name, this._name + "-Start", this._name + "-End")
        }
        next(r) {
            this.end();
            this._name = r;
            performance.mark(this._name + "-Start")
        }
    }
}
"use strict";
{
    const d = self.C3,
        b = 2 * Math.PI,
        a = Math.PI / 180,
        f = 180 / Math.PI;
    d.wrap = function(g, h, l) {
        g = Math.floor(g);
        h = Math.floor(h);
        l = Math.floor(l);
        return g < h ? (g = l - (h - g) % (l - h), g === l ? 0 : g) : h + (g - h) % (l - h)
    };
    d.mapToRange = function(g, h, l, m, p) {
        return (g - h) * (p - m) / (l - h) + m
    };
    d.normalize = function(g, h, l) {
        return (g - h) / (l - h)
    };
    d.clamp = function(g, h, l) {
        return g < h ? h : g > l ? l : g
    };
    d.clampAngle = function(g) {
        g %= b;
        0 > g && (g += b);
        return g
    };
    d.toRadians = function(g) {
        return g * a
    };
    d.toDegrees = function(g) {
        return g * f
    };
    d.distanceTo = function(g, h, l, m) {
        return Math.hypot(l -
            g, m - h)
    };
    d.distanceSquared = function(g, h, l, m) {
        g = l - g;
        h = m - h;
        return g * g + h * h
    };
    d.angleTo = function(g, h, l, m) {
        return Math.atan2(m - h, l - g)
    };
    d.angleDiff = function(g, h) {
        if (g === h) return 0;
        g = Math.sin(g) * Math.sin(h) + Math.cos(g) * Math.cos(h);
        return 1 <= g ? 0 : -1 >= g ? Math.PI : Math.acos(g)
    };
    d.angleRotate = function(g, h, l) {
        let m = Math.sin(g),
            p = Math.cos(g),
            t = Math.sin(h),
            q = Math.cos(h);
        return Math.acos(m * t + p * q) > l ? 0 < p * t - m * q ? d.clampAngle(g + l) : d.clampAngle(g - l) : d.clampAngle(h)
    };
    d.angleClockwise = function(g, h) {
        return 0 >= Math.cos(g) * Math.sin(h) -
            Math.sin(g) * Math.cos(h)
    };
    d.angleLerp = function(g, h, l, m = 0) {
        let p = d.angleDiff(g, h);
        m *= b;
        return d.angleClockwise(h, g) ? d.clampAngle(g + (p + m) * l) : d.clampAngle(g - (p + m) * l)
    };
    d.angleLerpClockwise = function(g, h, l, m = 0) {
        const p = d.angleDiff(g, h);
        m *= b;
        return d.angleClockwise(h, g) ? d.clampAngle(g + (p + m) * l) : d.clampAngle((b - p + m) * l)
    };
    d.angleLerpAntiClockwise = function(g, h, l, m = 0) {
        const p = d.angleDiff(g, h);
        m *= b;
        return d.angleClockwise(h, g) ? d.clampAngle((-b + p - m) * l) : d.clampAngle(g - (p + m) * l)
    };
    d.lerp = function(g, h, l) {
        return g + l * (h -
            g)
    };
    d.unlerp = function(g, h, l) {
        return g === h ? 0 : (l - g) / (h - g)
    };
    d.relerp = function(g, h, l, m, p) {
        return d.lerp(m, p, d.unlerp(g, h, l))
    };
    d.qarp = function(g, h, l, m) {
        return d.lerp(d.lerp(g, h, m), d.lerp(h, l, m), m)
    };
    d.cubic = function(g, h, l, m, p) {
        return d.lerp(d.qarp(g, h, l, p), d.qarp(h, l, m, p), p)
    };
    d.cosp = function(g, h, l) {
        return (g + h + (g - h) * Math.cos(l * Math.PI)) / 2
    };
    d.isPOT = function(g) {
        return 0 < g && 0 === (g - 1 & g)
    };
    d.nextHighestPowerOfTwo = function(g) {
        --g;
        for (let h = 1; 32 > h; h <<= 1) g |= g >> h;
        return g + 1
    };
    d.roundToNearestFraction = function(g, h) {
        return Math.round(g *
            h) / h
    };
    d.floorToNearestFraction = function(g, h) {
        return Math.floor(g * h) / h
    };
    d.round6dp = function(g) {
        return Math.round(1E6 * g) / 1E6
    };
    d.toFixed = function(g, h) {
        g = g.toFixed(h);
        for (h = g.length - 1; 0 <= h && "0" === g.charAt(h); --h);
        0 <= h && "." === g.charAt(h) && --h;
        return 0 > h ? g : g.substr(0, h + 1)
    };
    d.PackRGB = function(g, h, l) {
        return d.clamp(g, 0, 255) | d.clamp(h, 0, 255) << 8 | d.clamp(l, 0, 255) << 16
    };
    d.PackRGBAEx = function(g, h, l, m) {
        g = d.clamp(Math.floor(1024 * g), -8192, 8191);
        h = d.clamp(Math.floor(1024 * h), -8192, 8191);
        l = d.clamp(Math.floor(1024 * l),
            -8192, 8191);
        m = d.clamp(Math.floor(1023 * m), 0, 1023);
        0 > g && (g += 16384);
        0 > h && (h += 16384);
        0 > l && (l += 16384);
        return -(274877906944 * g + 16777216 * h + 1024 * l + m)
    };
    d.PackRGBEx = function(g, h, l) {
        return d.PackRGBAEx(g, h, l, 1)
    };

    function c(g) {
        return 0 === g && 0 > 1 / g
    }
    d.GetRValue = function(g) {
        if (0 <= g) return (g & 255) / 255;
        g = Math.floor(-g / 274877906944);
        8191 < g && (g -= 16384);
        return g / 1024
    };
    d.GetGValue = function(g) {
        if (0 <= g) return ((g & 65280) >> 8) / 255;
        g = Math.floor(-g % 274877906944 / 16777216);
        8191 < g && (g -= 16384);
        return g / 1024
    };
    d.GetBValue = function(g) {
        if (0 <=
            g) return ((g & 16711680) >> 16) / 255;
        g = Math.floor(-g % 16777216 / 1024);
        8191 < g && (g -= 16384);
        return g / 1024
    };
    d.GetAValue = function(g) {
        return c(g) ? 0 : 0 <= g ? 1 : Math.floor(-g % 1024) / 1023
    };
    d.greatestCommonDivisor = function(g, h) {
        g = Math.floor(g);
        for (h = Math.floor(h); 0 !== h;) {
            let l = h;
            h = g % h;
            g = l
        }
        return g
    };
    const e = [
        [3, 2],
        [4, 3],
        [5, 4],
        [5, 3],
        [6, 5],
        [14, 9],
        [16, 9],
        [16, 10],
        [21, 9]
    ];
    d.getAspectRatio = function(g, h) {
        g = Math.floor(g);
        h = Math.floor(h);
        if (g === h) return [1, 1];
        for (var l of e) {
            let m = g / l[0] * l[1];
            if (1 > Math.abs(h - m)) return l.slice(0);
            m = g / l[1] * l[0];
            if (1 > Math.abs(h - m)) return [l[1], l[0]]
        }
        l = d.greatestCommonDivisor(g, h);
        return [g / l, h / l]
    };
    d.segmentsIntersect = function(g, h, l, m, p, t, q, r) {
        var u = Math.min(g, l),
            x = Math.max(p, q);
        if (Math.max(g, l) < Math.min(p, q) || u > x) return !1;
        u = Math.min(h, m);
        x = Math.max(t, r);
        if (Math.max(h, m) < Math.min(t, r) || u > x) return !1;
        u = p - g + q - l;
        x = t - h + r - m;
        g = l - g;
        h = m - h;
        p = q - p;
        t = r - t;
        r = Math.abs(h * p - t * g);
        return Math.abs(p * x - t * u) > r ? !1 : Math.abs(g * x - h * u) <= r
    };
    d.segmentsIntersectPreCalc = function(g, h, l, m, p, t, q, r, u, x, y, C) {
        const w = Math.max(u, y);
        if (t < Math.min(u, y) || p > w) return !1;
        p = Math.max(x, C);
        if (r < Math.min(x, C) || q > p) return !1;
        q = u - g + y - l;
        r = x - h + C - m;
        g = l - g;
        h = m - h;
        u = y - u;
        x = C - x;
        C = Math.abs(h * u - x * g);
        return Math.abs(u * r - x * q) > C ? !1 : Math.abs(g * r - h * q) <= C
    };
    d.segmentIntersectsQuad = function(g, h, l, m, p) {
        const t = Math.min(g, l),
            q = Math.max(g, l),
            r = Math.min(h, m),
            u = Math.max(h, m),
            x = p.getTlx(),
            y = p.getTly(),
            C = p.getTrx(),
            w = p.getTry(),
            A = p.getBrx(),
            E = p.getBry(),
            K = p.getBlx();
        p = p.getBly();
        return d.segmentsIntersectPreCalc(g, h, l, m, t, q, r, u, x, y, C, w) || d.segmentsIntersectPreCalc(g,
            h, l, m, t, q, r, u, C, w, A, E) || d.segmentsIntersectPreCalc(g, h, l, m, t, q, r, u, A, E, K, p) || d.segmentsIntersectPreCalc(g, h, l, m, t, q, r, u, K, p, x, y)
    };
    d.segmentIntersectsAnyN = function(g, h, l, m, p) {
        const t = Math.min(g, l),
            q = Math.max(g, l),
            r = Math.min(h, m),
            u = Math.max(h, m);
        let x = 0;
        for (let y = p.length - 4; x <= y; x += 2)
            if (d.segmentsIntersectPreCalc(g, h, l, m, t, q, r, u, p[x], p[x + 1], p[x + 2], p[x + 3])) return !0;
        return d.segmentsIntersectPreCalc(g, h, l, m, t, q, r, u, p[x], p[x + 1], p[0], p[1])
    };
    d.rayIntersect = function(g, h, l, m, p, t, q, r) {
        l -= g;
        t = r - t;
        const u = l *
            t - (m - h) * (q - p);
        if (0 === u) return 2;
        m = ((h - m) * (q - g) + l * (r - h)) / u;
        return 0 < m && 1.000001 > m ? (t * (q - g) + (p - q) * (r - h)) / u : 2
    };
    d.rayIntersectExtended = function(g, h, l, m, p, t, q, r, u) {
        const x = (q - p) * u;
        u *= r - t;
        return d.rayIntersect(g, h, l, m, p - x, t - u, q + x, r + u)
    };
    d.isPointInTriangleInclusive = function(g, h, l, m, p, t, q, r) {
        p -= l;
        t -= m;
        q -= l;
        r -= m;
        g -= l;
        l = h - m;
        h = p * p + t * t;
        m = p * q + t * r;
        p = p * g + t * l;
        t = q * q + r * r;
        q = q * g + r * l;
        r = 1 / (h * t - m * m);
        t = (t * p - m * q) * r;
        p = (h * q - m * p) * r;
        return 0 <= t && 0 <= p && 1 >= t + p
    };
    d.triangleCartesianToBarycentric = function(g, h, l, m, p, t, q, r) {
        p -= l;
        t -=
            m;
        q -= l;
        r -= m;
        g -= l;
        const u = h - m;
        h = p * p + t * t;
        m = p * q + t * r;
        l = q * q + r * r;
        p = g * p + u * t;
        t = g * q + u * r;
        q = h * l - m * m;
        r = (l * p - m * t) / q;
        p = (h * t - m * p) / q;
        return [1 - r - p, r, p]
    };
    d.triangleBarycentricToCartesian = function(g, h, l, m, p, t, q, r, u) {
        return [g * m + h * t + l * r, g * p + h * q + l * u]
    }
}
"use strict";
{
    const d = self.C3;
    let b = null,
        a = "";
    if ("undefined" !== typeof document) {
        b = document;
        const l = document.querySelector("base");
        if (a = l && l.hasAttribute("href") ? l.getAttribute("href") : "") a.startsWith("/") && (a = a.substr(1)), a.endsWith("/") || (a += "/")
    }
    d.GetBaseHref = function() {
        return a
    };
    d.GetBaseURL = function() {
        if (!b) return "";
        const l = b.location;
        return d.GetPathFromURL(l.origin + l.pathname) + a
    };
    d.GetPathFromURL = function(l) {
        if (!l.length || l.endsWith("/") || l.endsWith("\\")) return l;
        const m = Math.max(l.lastIndexOf("/"), l.lastIndexOf("\\"));
        return -1 === m ? "" : l.substr(0, m + 1)
    };
    d.GetFilenameFromURL = function(l) {
        if (!l.length) return l;
        if (l.endsWith("/") || l.endsWith("\\")) return "";
        const m = Math.max(l.lastIndexOf("/"), l.lastIndexOf("\\"));
        return -1 === m ? l : l.substr(m + 1)
    };
    d.DataTransferHasFiles = function(l) {
        if (l.types)
            for (let m = 0; m < l.types.length; m++)
                if ("Files" === l.types[m] || "application/x-c3-file" === l.types[m]) return !0;
        return !1
    };
    d.DataTransferFilterFiles = async function(l, m) {
        l = Array.from(l.files).filter(p => 0 !== p.size).filter(p => m(p)).map(async p => {
            try {
                return await d.CloneFile(p)
            } catch (t) {
                return null
            }
        });
        return (await Promise.all(l)).filter(p => p)
    };
    d.IsFileAnImage = function(l) {
        return l.type ? -1 !== l.type.search(/image\/.*/) : -1 !== d.MimeType.GetForFileExtension(d.GetFileExtension(l.name)).GetString().search(/image\/.*/)
    };
    d.IsFileAnSVG = function(l) {
        return "image/svg+xml" === l.type
    };
    d.IsFileAMultiImageContainer = function(l) {
        return l.type ? d.MimeType.Get(l.type).IsAnimatedImage() : d.MimeType.GetForFileExtension(d.GetFileExtension(l.name)).IsAnimatedImage()
    };
    d.GetFileExtension = function(l) {
        let m = l.lastIndexOf(".");
        return 1 > m ? "" : l.substr(m)
    };
    d.GetFileNamePart = function(l) {
        let m = l.lastIndexOf(".");
        return 1 > m ? l : l.substr(0, m)
    };
    d.NormalizeFileSeparator = function(l) {
        return l.replace(/\\/g, "/")
    };
    d.ParseFilePath = function(l) {
        l = d.NormalizeFileSeparator(l);
        let m = /^\w:\//.exec(l);
        m ? (m = m[0], l = l.slice(3), "/" !== l[0] && (l = "/" + l)) : m = "";
        l = l.replace(/\/{2,}/g, "/");
        1 < l.length && "/" === l.slice(-1) && (l = l.slice(0, -1));
        var p = l.lastIndexOf("/") + 1;
        let t = "",
            q = l,
            r = "";
        0 < p && (t = l.slice(0, p), q = l.slice(p));
        l = q;
        p = q.lastIndexOf(".");
        0 < p && (r = q.slice(p),
            l = q.slice(0, -r.length));
        return {
            dir: t,
            base: q,
            name: l,
            root: m,
            ext: r,
            full: m + t + q
        }
    };
    d.Wait = function(l, m) {
        return new Promise((p, t) => {
            self.setTimeout(p, l, m)
        })
    };
    d.swallowException = function(l) {
        try {
            l()
        } catch (m) {
            d.isDebug && console.warn("Swallowed exception: ", m)
        }
    };
    d.noop = function() {};
    d.equalsNoCase = function(l, m) {
        return "string" !== typeof l || "string" !== typeof m ? !1 : l === m || l.normalize().toLowerCase() === m.normalize().toLowerCase()
    };
    d.equalsCase = function(l, m) {
        return "string" !== typeof l || "string" !== typeof m ? !1 : l === m ? !0 :
            l.normalize() === m.normalize()
    };
    d.typedArraySet16 = function(l, m, p) {
        l[p++] = m[0];
        l[p++] = m[1];
        l[p++] = m[2];
        l[p++] = m[3];
        l[p++] = m[4];
        l[p++] = m[5];
        l[p++] = m[6];
        l[p++] = m[7];
        l[p++] = m[8];
        l[p++] = m[9];
        l[p++] = m[10];
        l[p++] = m[11];
        l[p++] = m[12];
        l[p++] = m[13];
        l[p++] = m[14];
        l[p] = m[15]
    };
    d.truncateArray = function(l, m) {
        l.length = m
    };
    d.clearArray = function(l) {
        l && 0 !== l.length && d.truncateArray(l, 0)
    };
    d.clear2DArray = function(l) {
        if (l) {
            for (let m = 0; m < l.length; m++) d.truncateArray(l[m], 0);
            d.truncateArray(l, 0)
        }
    };
    d.extendArray = function(l, m,
        p) {
        m |= 0;
        var t = l.length;
        if (!(m <= t))
            for (; t < m; ++t) l.push(p)
    };
    d.resizeArray = function(l, m, p) {
        m |= 0;
        const t = l.length;
        m < t ? d.truncateArray(l, m) : m > t && d.extendArray(l, m, p)
    };
    d.shallowAssignArray = function(l, m) {
        d.clearArray(l);
        d.appendArray(l, m)
    };
    d.appendArray = function(l, m) {
        if (1E4 > m.length) l.push(...m);
        else
            for (let p = 0, t = m.length; p < t; ++p) l.push(m[p])
    };
    d.arrayRemove = function(l, m) {
        m = Math.floor(m);
        if (!(0 > m || m >= l.length)) {
            for (var p = l.length - 1; m < p; ++m) l[m] = l[m + 1];
            d.truncateArray(l, p)
        }
    };
    d.arrayFindRemove = function(l,
        m) {
        m = l.indexOf(m);
        0 <= m && l.splice(m, 1)
    };
    d.arraysEqual = function(l, m) {
        let p = l.length;
        if (m.length !== p) return !1;
        for (let t = 0; t < p; ++t)
            if (l[t] !== m[t]) return !1;
        return !0
    };
    d.arrayFilterOut = function(l, m) {
        let p = [],
            t = 0;
        for (let q = 0, r = l.length; q < r; ++q) {
            let u = l[q];
            m(u) ? p.push(u) : (l[t] = u, ++t)
        }
        d.truncateArray(l, t);
        return p
    };
    d.arrayRemoveAllInSet = function(l, m) {
        const p = l.length;
        let t = 0;
        for (let q = 0, r = l.length; q < r; ++q) {
            let u = l[q];
            m.has(u) || (l[t++] = u)
        }
        d.truncateArray(l, t);
        return p - t
    };
    d.isArrayIndexInBounds = function(l, m) {
        return l !==
            Math.floor(l) ? !1 : 0 <= l && l < m.length
    };
    d.validateArrayIndex = function(l, m) {
        if (!d.isArrayIndexInBounds(l, m)) throw new RangeError("array index out of bounds");
    };
    d.cloneArray = function(l) {
        return l.slice()
    };
    d.deepCloneArray = function(l, m) {
        let p = [];
        for (let t of l)
            if (d.IsObject(t)) {
                l = m(t);
                if (!l) throw Error("missing clone");
                if (l.constructor !== t.constructor) throw Error("object is not a clone");
                p.push(l)
            } else d.IsArray(t) ? p.push(d.deepCloneArray(t, m)) : p.push(t);
        return p
    };
    d.clone2DArray = function(l) {
        let m = [];
        for (let p of l) m.push(p.slice());
        return m
    };
    d.mergeSets = function(l, m) {
        return new Set([...l, ...m])
    };
    d.mergeSetsInPlace = function(l, m) {
        for (const p of m) l.add(p);
        return l
    };
    d.first = function(l) {
        for (let m of l) return m;
        return null
    };
    d.xor = function(l, m) {
        return !l !== !m
    };
    d.compare = function(l, m, p) {
        switch (m) {
            case 0:
                return l === p;
            case 1:
                return l !== p;
            case 2:
                return l < p;
            case 3:
                return l <= p;
            case 4:
                return l > p;
            case 5:
                return l >= p;
            default:
                return !1
        }
    };
    d.hasAnyOwnProperty = function(l) {
        for (let m in l)
            if (l.hasOwnProperty(m)) return !0;
        return !1
    };
    d.PromiseAllWithProgress =
        function(l, m) {
            return l.length ? new Promise((p, t) => {
                const q = [];
                let r = 0,
                    u = !1;
                for (let x = 0, y = l.length; x < y; ++x) q.push(void 0), l[x].then(C => {
                    u || (q[x] = C, ++r, r === l.length ? p(q) : m(r, l.length))
                }).catch(C => {
                    u = !0;
                    t(C)
                })
            }) : Promise.resolve([])
        };
    let f = [];
    d.AddLibraryMemoryCallback = function(l) {
        f.push(l)
    };
    d.GetEstimatedLibraryMemoryUsage = function() {
        let l = 0;
        for (let m of f) {
            let p = m();
            l += p
        }
        return Math.floor(l)
    };
    let c = 1;
    const e = new Map,
        g = new MessageChannel;
    g.port2.onmessage = function(l) {
        const m = l.data,
            p = e.get(m);
        e.delete(m);
        p && p(l.timeStamp)
    };
    d.RequestUnlimitedAnimationFrame = function(l) {
        const m = c++;
        e.set(m, l);
        g.port1.postMessage(m);
        return m
    };
    d.CancelUnlimitedAnimationFrame = function(l) {
        e.delete(l)
    };
    d.PostTask = d.RequestUnlimitedAnimationFrame;
    d.WaitForNextTask = function() {
        return new Promise(l => d.PostTask(l))
    };
    const h = new Set;
    d.RequestPostAnimationFrame = function(l) {
        const m = self.requestAnimationFrame(async p => {
            await d.WaitForNextTask();
            h.has(m) && (h.delete(m), l(p))
        });
        h.add(m);
        return m
    };
    d.CancelPostAnimationFrame = function(l) {
        h.has(l) &&
            (self.cancelAnimationFrame(l), h.delete(l))
    }
}
"use strict";
{
    const d = self.C3;
    d.IsAbsoluteURL = function(b) {
        return /^(?:[a-z\-]+:)?\/\//.test(b) || "data:" === b.substr(0, 5) || "blob:" === b.substr(0, 5)
    };
    d.IsRelativeURL = function(b) {
        return !d.IsAbsoluteURL(b)
    };
    d.ThrowIfNotOk = function(b) {
        if (!b.ok) throw Error(`fetch '${b.url}' response returned ${b.status} ${b.statusText}`);
    };
    d.FetchOk = function(b, a) {
        return fetch(b, a).then(f => {
            d.ThrowIfNotOk(f);
            return f
        })
    };
    d.FetchText = function(b) {
        return d.FetchOk(b).then(a => a.text())
    };
    d.FetchJson = function(b) {
        return d.FetchOk(b).then(a => a.json())
    };
    d.FetchBlob = function(b) {
        return d.FetchOk(b).then(a => a.blob())
    };
    d.FetchArrayBuffer = function(b) {
        return d.FetchOk(b).then(a => a.arrayBuffer())
    };
    d.FetchImage = function(b) {
        return new Promise((a, f) => {
            const c = new Image;
            c.onload = () => a(c);
            c.onerror = e => f(e);
            c.src = b
        })
    };
    d.BlobToArrayBuffer = function(b) {
        return "function" === typeof b.arrayBuffer ? b.arrayBuffer() : new Promise((a, f) => {
            const c = new FileReader;
            c.onload = () => a(c.result);
            c.onerror = () => f(c.error);
            c.readAsArrayBuffer(b)
        })
    };
    d.BlobToString = function(b) {
        return "function" ===
            typeof b.text ? b.text() : new Promise((a, f) => {
                const c = new FileReader;
                c.onload = () => a(c.result);
                c.onerror = () => f(c.error);
                c.readAsText(b)
            })
    };
    d.BlobToJson = function(b) {
        return d.BlobToString(b).then(a => JSON.parse(a))
    };
    d.BlobToImage = async function(b, a) {
        b = URL.createObjectURL(b);
        try {
            const f = await d.FetchImage(b);
            URL.revokeObjectURL(b);
            b = "";
            a && "function" === typeof f.decode && await f.decode();
            return f
        } finally {
            b && URL.revokeObjectURL(b)
        }
    };
    d.CreateCanvas = function(b, a) {
        if ("undefined" !== typeof document && "function" ===
            typeof document.createElement) {
            const f = document.createElement("canvas");
            f.width = b;
            f.height = a;
            return f
        }
        return new OffscreenCanvas(b, a)
    };
    d.CanvasToBlob = function(b, a, f) {
        "number" !== typeof f && (f = 1);
        a = a || "image/png";
        f = d.clamp(f, 0, 1);
        return b.toBlob ? new Promise(c => b.toBlob(c, a, f)) : b.convertToBlob ? b.convertToBlob({
            type: a,
            quality: f
        }) : d.Asyncify(() => d.CanvasToBlobSync(b, a, f))
    };
    d.CanvasToBlobSync = function(b, a, f) {
        "number" !== typeof f && (f = 1);
        a = a || "image/png";
        f = d.clamp(f, 0, 1);
        return d.DataURIToBinaryBlobSync(b.toDataURL(a,
            f))
    };
    d.DataURIToBinaryBlobSync = function(b) {
        b = d.ParseDataURI(b);
        return d.BinaryStringToBlob(b.data, b.mime_type)
    };
    d.ParseDataURI = function(b) {
        if ("data:" !== b.substr(0, 5)) throw new URIError("expected data: uri");
        var a = b.indexOf(",");
        if (0 > a) throw new URIError("expected comma in data: uri");
        var f = b.substring(5, a);
        b = b.substring(a + 1);
        a = f.split(";");
        f = a[0] || "";
        let c = a[2];
        b = "base64" === a[1] || "base64" === c ? atob(b) : decodeURIComponent(b);
        return {
            mime_type: f,
            data: b
        }
    };
    d.BinaryStringToBlob = function(b, a) {
        var f = b.length;
        let c = f >> 2,
            e = new Uint8Array(f),
            g = new Uint32Array(e.buffer, 0, c),
            h, l;
        for (l = h = 0; h < c; ++h) g[h] = b.charCodeAt(l++) | b.charCodeAt(l++) << 8 | b.charCodeAt(l++) << 16 | b.charCodeAt(l++) << 24;
        for (f &= 3; f--;) e[l] = b.charCodeAt(l), ++l;
        return a ? new Blob([e], {
            type: a
        }) : new Blob([e])
    };
    d.DrawableToBlob = function(b, a, f) {
        const c = d.CreateCanvas(b.width, b.height);
        c.getContext("2d").drawImage(b, 0, 0);
        return d.CanvasToBlob(c, a, f)
    };
    d.ImageDataToBlobSync = function(b, a, f) {
        const c = d.CreateCanvas(b.width, b.height);
        c.getContext("2d").putImageData(b,
            0, 0);
        return d.CanvasToBlobSync(c, a, f)
    };
    d.ImageDataToBlob = function(b, a, f) {
        if (d.Supports.ImageBitmapOptions) return createImageBitmap(b, {
            premultiplyAlpha: "none"
        }).then(c => d.DrawableToBlob(c, a, f));
        if (d.Supports.ImageBitmap) return createImageBitmap(b).then(c => d.DrawableToBlob(c, a, f));
        {
            const c = d.CreateCanvas(b.width, b.height);
            c.getContext("2d").putImageData(b, 0, 0);
            return d.CanvasToBlob(c, a, f)
        }
    };
    d.CopySet = function(b, a) {
        b.clear();
        for (const f of a) b.add(f)
    };
    d.MapToObject = function(b) {
        const a = Object.create(null);
        for (const [f, c] of b.entries()) a[f] = c;
        return a
    };
    d.ObjectToMap = function(b, a) {
        a.clear();
        for (const [f, c] of Object.entries(b)) a.set(f, c)
    };
    d.ToSuperJSON = function f(a) {
        if ("object" === typeof a && null !== a) {
            if (a instanceof Set) return {
                _c3type_: "set",
                data: [...a].map(c => f(c))
            };
            if (a instanceof Map) return {
                _c3type_: "map",
                data: [...a].map(c => [c[0], f(c[1])])
            };
            {
                const c = Object.create(null);
                for (const [e, g] of Object.entries(a)) c[e] = f(g);
                return c
            }
        }
        return a
    };
    d.FromSuperJSON = function c(f) {
        if ("object" === typeof f & null !== f) {
            if ("set" ===
                f._c3type_) return new Set(f.data.map(e => c(e)));
            if ("map" === f._c3type_) return new Map(f.data.map(e => [e[0], c(e[1])]));
            {
                const e = Object.create(null);
                for (const [g, h] of Object.entries(f)) e[g] = c(h);
                return e
            }
        }
        return f
    };
    d.CSSToCamelCase = function(f) {
        let c = "",
            e = !1;
        for (const g of f) "-" === g ? e = !0 : e ? (c += g.toUpperCase(), e = !1) : c += g;
        return c
    };
    d.IsIterator = function(f) {
        return "object" === typeof f && "function" === typeof f.next
    };
    d.MakeFilledArray = function(f, c) {
        const e = [];
        if ("function" === typeof c)
            for (var g = 0; g < f; ++g) e.push(c());
        else
            for (g = 0; g < f; ++g) e.push(c);
        return e
    }
}
"use strict";
{
    const d = self.C3,
        b = /([0-9.]+),([0-9.]+)%?,([0-9.]+)%?/i,
        a = /([0-9.]+),([0-9.]+)%?,([0-9.]+)%?,([0-9.])/i;

    function f(e) {
        return 0 === e.length ? "00" : 1 === e.length ? "0" + e : e
    }

    function c(e, g, h) {
        0 > h && (h += 1);
        1 < h && --h;
        return h < 1 / 6 ? e + 6 * (g - e) * h : .5 > h ? g : h < 2 / 3 ? e + (g - e) * (2 / 3 - h) * 6 : e
    }
    d.Color = class {
        constructor(e, g, h, l) {
            this._a = this._b = this._g = this._r = 0;
            e instanceof d.Color ? this.set(e) : this.setRgba(e || 0, g || 0, h || 0, l || 0)
        }
        setRgb(e, g, h) {
            this._r = +e;
            this._g = +g;
            this._b = +h;
            this.clamp();
            return this
        }
        setRgba(e, g, h, l) {
            this._r = +e;
            this._g = +g;
            this._b = +h;
            this._a = +l;
            this.clamp();
            return this
        }
        set(e) {
            this._r = e._r;
            this._g = e._g;
            this._b = e._b;
            this._a = e._a;
            return this
        }
        copy(e) {
            return this.set(e)
        }
        add(e) {
            this._r += e._r;
            this._g += e._g;
            this._b += e._b;
            this._a += e._a;
            this.clamp()
        }
        addRgb(e, g, h, l = 0) {
            this._r += +e;
            this._g += +g;
            this._b += +h;
            this._a += +l;
            this.clamp()
        }
        diff(e) {
            this.setR(Math.max(this._r, e._r) - Math.min(this._r, e._r));
            this.setG(Math.max(this._g, e._g) - Math.min(this._g, e._g));
            this.setB(Math.max(this._b, e._b) - Math.min(this._b, e._b));
            this.setA(Math.max(this._a,
                e._a) - Math.min(this._a, e._a));
            this.clamp()
        }
        copyRgb(e) {
            this._r = e._r;
            this._g = e._g;
            this._b = e._b
        }
        setR(e) {
            this._r = d.clamp(+e, 0, 1)
        }
        getR() {
            return this._r
        }
        setG(e) {
            this._g = d.clamp(+e, 0, 1)
        }
        getG() {
            return this._g
        }
        setB(e) {
            this._b = d.clamp(+e, 0, 1)
        }
        getB() {
            return this._b
        }
        setA(e) {
            this._a = d.clamp(+e, 0, 1)
        }
        getA() {
            return this._a
        }
        clone() {
            return d.New(d.Color, this._r, this._g, this._b, this._a)
        }
        toArray() {
            return [this._r, this._g, this._b, this._a]
        }
        toTypedArray() {
            return new Float64Array(this.toArray())
        }
        writeToTypedArray(e, g) {
            e[g++] =
                this._r;
            e[g++] = this._g;
            e[g++] = this._b;
            e[g] = this._a
        }
        equals(e) {
            return this._r === e._r && this._g === e._g && this._b === e._b && this._a === e._a
        }
        equalsIgnoringAlpha(e) {
            return this._r === e._r && this._g === e._g && this._b === e._b
        }
        equalsRgb(e, g, h) {
            return this._r === e && this._g === g && this._b === h
        }
        equalsRgba(e, g, h, l) {
            return this._r === e && this._g === g && this._b === h && this._a === l
        }
        multiply(e) {
            this._r *= e._r;
            this._g *= e._g;
            this._b *= e._b;
            this._a *= e._a
        }
        multiplyAlpha(e) {
            this._r *= e;
            this._g *= e;
            this._b *= e;
            this._a *= e
        }
        premultiply() {
            this._r *= this._a;
            this._g *= this._a;
            this._b *= this._a;
            return this
        }
        unpremultiply() {
            this._r /= this._a;
            this._g /= this._a;
            this._b /= this._a;
            return this
        }
        clamp() {
            this._r = d.clamp(this._r, 0, 1);
            this._g = d.clamp(this._g, 0, 1);
            this._b = d.clamp(this._b, 0, 1);
            this._a = d.clamp(this._a, 0, 1);
            return this
        }
        setFromRgbValue(e) {
            this._r = d.GetRValue(e);
            this._g = d.GetGValue(e);
            this._b = d.GetBValue(e);
            this._a = d.GetAValue(e)
        }
        getCssRgb(e, g, h) {
            e = d.IsFiniteNumber(e) ? e : this.getR();
            g = d.IsFiniteNumber(g) ? g : this.getG();
            h = d.IsFiniteNumber(h) ? h : this.getB();
            return `rgb(${100 *
                e}%, ${100 * g}%, ${100 * h}%)`
        }
        getCssRgba(e, g, h, l) {
            e = d.IsFiniteNumber(e) ? e : this.getR();
            g = d.IsFiniteNumber(g) ? g : this.getG();
            h = d.IsFiniteNumber(h) ? h : this.getB();
            l = d.IsFiniteNumber(l) ? l : this.getA();
            return `rgba(${100 * e}%, ${100 * g}%, ${100 * h}%, ${l})`
        }
        toHexString() {
            const e = Math.round(255 * this.getR()),
                g = Math.round(255 * this.getG()),
                h = Math.round(255 * this.getB());
            return "#" + f(e.toString(16)) + f(g.toString(16)) + f(h.toString(16))
        }
        parseHexString(e) {
            if ("string" !== typeof e) return !1;
            e = e.trim();
            "#" === e.charAt(0) && (e =
                e.substr(1));
            let g, h;
            if (3 === e.length) g = parseInt(e[0], 16) / 15, h = parseInt(e[1], 16) / 15, e = parseInt(e[2], 16) / 15;
            else if (6 === e.length) g = parseInt(e.substr(0, 2), 16) / 255, h = parseInt(e.substr(2, 2), 16) / 255, e = parseInt(e.substr(4, 2), 16) / 255;
            else return !1;
            isFinite(g) && this.setR(g);
            isFinite(h) && this.setG(h);
            isFinite(e) && this.setB(e);
            this.setA(1);
            return !0
        }
        toCommaSeparatedRgb() {
            const e = Math.round(255 * this.getR()),
                g = Math.round(255 * this.getG()),
                h = Math.round(255 * this.getB());
            return `${e}, ${g}, ${h}`
        }
        toRgbArray() {
            const e =
                Math.round(255 * this.getR()),
                g = Math.round(255 * this.getG()),
                h = Math.round(255 * this.getB());
            return [e, g, h]
        }
        parseCommaSeparatedRgb(e) {
            if ("string" !== typeof e) return !1;
            e = e.replace(/^rgb\(|\)|%/, "");
            var g = e.split(",");
            if (3 > g.length) return !1;
            e = parseInt(g[0].trim(), 10) / 255;
            const h = parseInt(g[1].trim(), 10) / 255;
            g = parseInt(g[2].trim(), 10) / 255;
            isFinite(e) && this.setR(e);
            isFinite(h) && this.setG(h);
            isFinite(g) && this.setB(g);
            this.setA(1);
            return !0
        }
        parseCommaSeparatedPercentageRgb(e) {
            if ("string" !== typeof e) return !1;
            e =
                e.replace(/^rgb\(|\)|%/, "");
            var g = e.split(",");
            if (3 > g.length) return !1;
            e = parseInt(g[0].trim(), 10) / 100;
            const h = parseInt(g[1].trim(), 10) / 100;
            g = parseInt(g[2].trim(), 10) / 100;
            isFinite(e) && this.setR(e);
            isFinite(h) && this.setG(h);
            isFinite(g) && this.setB(g);
            this.setA(1);
            return !0
        }
        parseCommaSeparatedRgba(e) {
            if ("string" !== typeof e) return !1;
            e = e.replace(/^rgba\(|\)|%/, "");
            var g = e.split(",");
            if (4 > g.length) return !1;
            e = parseInt(g[0].trim(), 10) / 255;
            const h = parseInt(g[1].trim(), 10) / 255,
                l = parseInt(g[2].trim(), 10) / 255;
            g =
                parseFloat(g[3].trim());
            isFinite(e) && this.setR(e);
            isFinite(h) && this.setG(h);
            isFinite(l) && this.setB(l);
            isFinite(g) && this.setA(g);
            return !0
        }
        parseCommaSeparatedPercentageRgba(e) {
            if ("string" !== typeof e) return !1;
            e = e.replace(/^rgba\(|\)|%/, "");
            var g = e.split(",");
            if (4 > g.length) return !1;
            e = parseInt(g[0].trim(), 10) / 100;
            const h = parseInt(g[1].trim(), 10) / 100,
                l = parseInt(g[2].trim(), 10) / 100;
            g = parseFloat(g[3].trim());
            isFinite(e) && this.setR(e);
            isFinite(h) && this.setG(h);
            isFinite(l) && this.setB(l);
            isFinite(g) && this.setA(g);
            return !0
        }
        parseString(e) {
            if ("string" !== typeof e) return !1;
            e = e.replace(/\s+/, "");
            if (e.includes(",")) {
                if (e.startsWith("rgb(")) return e.includes("%") ? this.parseCommaSeparatedPercentageRgb(e) : this.parseCommaSeparatedRgb(e);
                if (e.startsWith("rgba(")) return e.includes("%") ? this.parseCommaSeparatedPercentageRgba(e) : this.parseCommaSeparatedRgba(e);
                if (e.startsWith("hsl(") || e.startsWith("hsla(")) return this.parseHSLString(e);
                {
                    const g = e.split(",");
                    if (e.includes("%")) {
                        if (3 === g.length) return this.parseCommaSeparatedPercentageRgb(e);
                        if (4 === g.length) return this.parseCommaSeparatedPercentageRgba(e)
                    } else {
                        if (3 === g.length) return this.parseCommaSeparatedRgb(e);
                        if (4 === g.length) return this.parseCommaSeparatedRgba(e)
                    }
                    return !1
                }
            }
            return this.parseHexString(e)
        }
        toJSON() {
            return [this._r, this._g, this._b, this._a]
        }
        setFromHSLA(e, g, h, l) {
            e %= 360;
            g = d.clamp(g, 0, 100);
            h = d.clamp(h, 0, 100);
            l = d.clamp(l, 0, 1);
            e /= 360;
            g /= 100;
            h /= 100;
            if (0 === g) h = g = e = h;
            else {
                const m = .5 > h ? h * (1 + g) : h + g - h * g,
                    p = 2 * h - m;
                h = c(p, m, e + 1 / 3);
                g = c(p, m, e);
                e = c(p, m, e - 1 / 3)
            }
            this.setR(h);
            this.setG(g);
            this.setB(e);
            this.setA(l);
            return this
        }
        parseHSLString(e) {
            var g = e.replace(/ |hsl|hsla|\(|\)|;/gi, "");
            e = b.exec(g);
            g = a.exec(g);
            return e && 4 === e.length ? (this.setFromHSLA(+e[1], +e[2], +e[3], 1), !0) : g && 5 === g.length ? (this.setFromHSLA(+e[1], +e[2], +e[3], +e[4]), !0) : !1
        }
        toHSLAString() {
            var e = this._r;
            const g = this._g,
                h = this._b,
                l = this._a,
                m = d.Color.GetHue(e, g, h),
                p = d.Color.GetSaturation(e, g, h);
            e = d.Color.GetLuminosity(e, g, h);
            return `hsla(${m}, ${p}%, ${e}%, ${l})`
        }
        toHSLAArray() {
            const e = this._r,
                g = this._g,
                h = this._b;
            return [d.Color.GetHue(e,
                g, h), d.Color.GetSaturation(e, g, h), d.Color.GetLuminosity(e, g, h), this._a]
        }
        setFromJSON(e) {
            !Array.isArray(e) || 3 > e.length || (this._r = e[0], this._g = e[1], this._b = e[2], this._a = 4 <= e.length ? e[3] : 1)
        }
        set r(e) {
            this.setR(e)
        }
        get r() {
            return this.getR()
        }
        set g(e) {
            this.setG(e)
        }
        get g() {
            return this.getG()
        }
        set b(e) {
            this.setB(e)
        }
        get b() {
            return this.getB()
        }
        set a(e) {
            this.setA(e)
        }
        get a() {
            return this.getA()
        }
        setAtIndex(e, g) {
            switch (e) {
                case 0:
                    this.setR(g);
                    break;
                case 1:
                    this.setG(g);
                    break;
                case 2:
                    this.setB(g);
                    break;
                case 3:
                    this.setA(g);
                    break;
                default:
                    throw new RangeError("invalid color index");
            }
        }
        getAtIndex(e) {
            switch (e) {
                case 0:
                    return this.getR();
                case 1:
                    return this.getG();
                case 2:
                    return this.getB();
                case 3:
                    return this.getA();
                default:
                    throw new RangeError("invalid color index");
            }
        }
        static DiffChannel(e, g) {
            return d.clamp(Math.max(e, g) - Math.min(e, g), 0, 1)
        }
        static Diff(e, g) {
            const h = new d.Color;
            h.setR(Math.max(e._r, g._r) - Math.min(e._r, g._r));
            h.setG(Math.max(e._g, g._g) - Math.min(e._g, g._g));
            h.setB(Math.max(e._b, g._b) - Math.min(e._b, g._b));
            h.setA(Math.max(e._a,
                g._a) - Math.min(e._a, g._a));
            return h
        }
        static DiffNoAlpha(e, g) {
            const h = new d.Color(0, 0, 0, 1);
            h.setR(Math.max(e._r, g._r) - Math.min(e._r, g._r));
            h.setG(Math.max(e._g, g._g) - Math.min(e._g, g._g));
            h.setB(Math.max(e._b, g._b) - Math.min(e._b, g._b));
            return h
        }
        static GetHue(e, g, h) {
            const l = Math.max(e, g, h),
                m = Math.min(e, g, h);
            if (l === m) return 0;
            let p = 0;
            switch (l) {
                case e:
                    p = (g - h) / (l - m) + (g < h ? 6 : 0);
                    break;
                case g:
                    p = (h - e) / (l - m) + 2;
                    break;
                case h:
                    p = (e - g) / (l - m) + 4
            }
            return Math.round(p / 6 * 360)
        }
        static GetSaturation(e, g, h) {
            const l = Math.max(e,
                g, h);
            e = Math.min(e, g, h);
            if (l === e) return 0;
            g = l - e;
            return Math.round(100 * (.5 < (l + e) / 2 ? g / (2 - l - e) : g / (l + e)))
        }
        static GetLuminosity(e, g, h) {
            const l = Math.max(e, g, h);
            return l ? Math.round((l + Math.min(e, g, h)) / 2 * 100) : 0
        }
    };
    d.Color.White = Object.freeze(d.New(d.Color, 1, 1, 1, 1));
    d.Color.Black = Object.freeze(d.New(d.Color, 0, 0, 0, 1));
    d.Color.TransparentBlack = Object.freeze(d.New(d.Color, 0, 0, 0, 0))
}
"use strict";
{
    const d = self.C3;
    d.Vector2 = class {
        constructor(b, a) {
            this._y = this._x = 0;
            b instanceof d.Vector2 ? this.copy(b) : this.set(b || 0, a || 0)
        }
        set(b, a) {
            this._x = +b;
            this._y = +a
        }
        copy(b) {
            this._x = b._x;
            this._y = b._y
        }
        equals(b) {
            return this._x === b._x && this._y === b._y
        }
        equalsValues(b, a) {
            return this._x === b && this._y === a
        }
        setX(b) {
            this._x = +b
        }
        getX() {
            return this._x
        }
        setY(b) {
            this._y = +b
        }
        getY() {
            return this._y
        }
        toArray() {
            return [this._x, this._y]
        }
        toTypedArray() {
            return new Float64Array(this.toArray())
        }
        writeToTypedArray(b, a) {
            b[a++] = this._x;
            b[a] =
                this._y
        }
        offset(b, a) {
            this._x += +b;
            this._y += +a
        }
        scale(b, a) {
            this._x *= b;
            this._y *= a
        }
        divide(b, a) {
            this._x /= b;
            this._y /= a
        }
        round() {
            this._x = Math.round(this._x);
            this._y = Math.round(this._y)
        }
        floor() {
            this._x = Math.floor(this._x);
            this._y = Math.floor(this._y)
        }
        ceil() {
            this._x = Math.ceil(this._x);
            this._y = Math.ceil(this._y)
        }
        angle() {
            return d.angleTo(0, 0, this._x, this._y)
        }
        lengthSquared() {
            return this._x * this._x + this._y * this._y
        }
        length() {
            return Math.sqrt(this.lengthSquared())
        }
        rotatePrecalc(b, a) {
            const f = this._x * a - this._y * b;
            this._y =
                this._y * a + this._x * b;
            this._x = f
        }
        rotate(b) {
            0 !== b && this.rotatePrecalc(Math.sin(b), Math.cos(b))
        }
        rotateAbout(b, a, f) {
            0 === b || a === this._x && f === this._y || (this._x -= a, this._y -= f, this.rotatePrecalc(Math.sin(b), Math.cos(b)), this._x += +a, this._y += +f)
        }
        move(b, a) {
            0 !== a && (this._x += Math.cos(b) * a, this._y += Math.sin(b) * a)
        }
        normalize() {
            const b = this.length();
            0 !== b && 1 !== b && (this._x /= b, this._y /= b)
        }
        clamp(b, a) {
            this._x = d.clamp(this._x, b, a);
            this._y = d.clamp(this._y, b, a)
        }
    }
}
"use strict";
{
    const d = self.C3;
    d.Rect = class {
        constructor(b, a, f, c) {
            this._bottom = this._right = this._top = this._left = 0;
            b instanceof d.Rect ? this.copy(b) : this.set(b || 0, a || 0, f || 0, c || 0)
        }
        set(b, a, f, c) {
            this._left = +b;
            this._top = +a;
            this._right = +f;
            this._bottom = +c
        }
        setWH(b, a, f, c) {
            b = +b;
            a = +a;
            this._left = b;
            this._top = a;
            this._right = b + +f;
            this._bottom = a + +c
        }
        copy(b) {
            this._left = +b._left;
            this._top = +b._top;
            this._right = +b._right;
            this._bottom = +b._bottom
        }
        clone() {
            return new d.Rect(this._left, this._top, this._right, this._bottom)
        }
        static Merge(b, a) {
            const f =
                new d.Rect;
            f.setLeft(Math.min(b._left, a._left));
            f.setTop(Math.min(b._top, a._top));
            f.setRight(Math.max(b._right, a._right));
            f.setBottom(Math.max(b._bottom, a._bottom));
            return f
        }
        static FromObject(b) {
            return new d.Rect(b.left, b.top, b.right, b.bottom)
        }
        equals(b) {
            return this._left === b._left && this._top === b._top && this._right === b._right && this._bottom === b._bottom
        }
        setLeft(b) {
            this._left = +b
        }
        getLeft() {
            return this._left
        }
        setTop(b) {
            this._top = +b
        }
        getTop() {
            return this._top
        }
        setRight(b) {
            this._right = +b
        }
        getRight() {
            return this._right
        }
        setBottom(b) {
            this._bottom = +b
        }
        getBottom() {
            return this._bottom
        }
        toArray() {
            return [this._left, this._top, this._right, this._bottom]
        }
        toTypedArray() {
            return new Float64Array(this.toArray())
        }
        toDOMRect() {
            return new DOMRect(this._left, this._top, this.width(), this.height())
        }
        writeToTypedArray(b, a) {
            b[a++] = this._left;
            b[a++] = this._top;
            b[a++] = this._right;
            b[a] = this._bottom
        }
        writeAsQuadToTypedArray(b, a) {
            b[a++] = this._left;
            b[a++] = this._top;
            b[a++] = this._right;
            b[a++] = this._top;
            b[a++] = this._right;
            b[a++] = this._bottom;
            b[a++] = this._left;
            b[a] = this._bottom
        }
        width() {
            return this._right -
                this._left
        }
        height() {
            return this._bottom - this._top
        }
        midX() {
            return (this._left + this._right) / 2
        }
        midY() {
            return (this._top + this._bottom) / 2
        }
        offset(b, a) {
            b = +b;
            a = +a;
            this._left += b;
            this._top += a;
            this._right += b;
            this._bottom += a
        }
        offsetLeft(b) {
            this._left += +b
        }
        offsetTop(b) {
            this._top += +b
        }
        offsetRight(b) {
            this._right += +b
        }
        offsetBottom(b) {
            this._bottom += +b
        }
        toSquare(b) {
            if ("x" !== b) throw Error("invalid axis, only 'x' supported");
            this._bottom = this._top < this._bottom ? this._left < this._right ? this._top + this.width() : this._top - this.width() :
                this._left < this._right ? this._top - this.width() : this._top + this.width()
        }
        inflate(b, a) {
            b = +b;
            a = +a;
            this._left -= b;
            this._top -= a;
            this._right += b;
            this._bottom += a
        }
        deflate(b, a) {
            b = +b;
            a = +a;
            this._left += b;
            this._top += a;
            this._right -= b;
            this._bottom -= a
        }
        multiply(b, a) {
            this._left *= b;
            this._top *= a;
            this._right *= b;
            this._bottom *= a
        }
        divide(b, a) {
            this._left /= b;
            this._top /= a;
            this._right /= b;
            this._bottom /= a
        }
        mirrorAround(b) {
            this._left = +b - this._left;
            this._right = +b - this._right
        }
        flipAround(b) {
            this._top = +b - this._top;
            this._bottom = +b - this._bottom
        }
        swapLeftRight() {
            const b =
                this._left;
            this._left = this._right;
            this._right = b
        }
        swapTopBottom() {
            const b = this._top;
            this._top = this._bottom;
            this._bottom = b
        }
        shuntY(b) {
            const a = this._top;
            this._top = +b - this._bottom;
            this._bottom = +b - a
        }
        round() {
            this._left = Math.round(this._left);
            this._top = Math.round(this._top);
            this._right = Math.round(this._right);
            this._bottom = Math.round(this._bottom)
        }
        roundInner() {
            this._left = Math.ceil(this._left);
            this._top = Math.ceil(this._top);
            this._right = Math.floor(this._right);
            this._bottom = Math.floor(this._bottom)
        }
        roundOuter() {
            this._left =
                Math.floor(this._left);
            this._top = Math.floor(this._top);
            this._right = Math.ceil(this._right);
            this._bottom = Math.ceil(this._bottom)
        }
        floor() {
            this._left = Math.floor(this._left);
            this._top = Math.floor(this._top);
            this._right = Math.floor(this._right);
            this._bottom = Math.floor(this._bottom)
        }
        ceil() {
            this._left = Math.ceil(this._left);
            this._top = Math.ceil(this._top);
            this._right = Math.ceil(this._right);
            this._bottom = Math.ceil(this._bottom)
        }
        clamp(b, a, f, c) {
            this._left < b && (this._left = +b);
            this._top < a && (this._top = +a);
            this._right >
                f && (this._right = +f);
            this._bottom > c && (this._bottom = +c)
        }
        clampFlipped(b, a, f, c) {
            this._left < b && (this._left = +b);
            this._top > a && (this._top = +a);
            this._right > f && (this._right = +f);
            this._bottom < c && (this._bottom = +c)
        }
        normalize() {
            this._left > this._right && this.swapLeftRight();
            this._top > this._bottom && this.swapTopBottom()
        }
        intersectsRect(b) {
            return !(b._right < this._left || b._bottom < this._top || b._left > this._right || b._top > this._bottom)
        }
        intersectsRectOffset(b, a, f) {
            return !(b._right + a < this._left || b._bottom + f < this._top || b._left +
                a > this._right || b._top + f > this._bottom)
        }
        containsPoint(b, a) {
            return b >= this._left && b <= this._right && a >= this._top && a <= this._bottom
        }
        containsRect(b) {
            return b._left >= this._left && b._top >= this._top && b._right <= this._right && b._bottom <= this._bottom
        }
        expandToContain(b) {
            b._left < this._left && (this._left = +b._left);
            b._top < this._top && (this._top = +b._top);
            b._right > this._right && (this._right = +b._right);
            b._bottom > this._bottom && (this._bottom = +b._bottom)
        }
        lerpInto(b) {
            this._left = d.lerp(b._left, b._right, this._left);
            this._top = d.lerp(b._top,
                b._bottom, this._top);
            this._right = d.lerp(b._left, b._right, this._right);
            this._bottom = d.lerp(b._top, b._bottom, this._bottom)
        }
    }
}
"use strict";
{
    const d = self.C3;
    d.Quad = class {
        constructor(b, a, f, c, e, g, h, l) {
            this._bly = this._blx = this._bry = this._brx = this._try = this._trx = this._tly = this._tlx = 0;
            b instanceof d.Quad ? this.copy(b) : this.set(b || 0, a || 0, f || 0, c || 0, e || 0, g || 0, h || 0, l || 0)
        }
        set(b, a, f, c, e, g, h, l) {
            this._tlx = +b;
            this._tly = +a;
            this._trx = +f;
            this._try = +c;
            this._brx = +e;
            this._bry = +g;
            this._blx = +h;
            this._bly = +l
        }
        setRect(b, a, f, c) {
            this.set(b, a, f, a, f, c, b, c)
        }
        copy(b) {
            this._tlx = b._tlx;
            this._tly = b._tly;
            this._trx = b._trx;
            this._try = b._try;
            this._brx = b._brx;
            this._bry = b._bry;
            this._blx = b._blx;
            this._bly = b._bly
        }
        equals(b) {
            return this._tlx === b._tlx && this._tly === b._tly && this._trx === b._trx && this._try === b._try && this._brx === b._brx && this._bry === b._bry && this._blx === b._blx && this._bly === b._bly
        }
        setTlx(b) {
            this._tlx = +b
        }
        getTlx() {
            return this._tlx
        }
        setTly(b) {
            this._tly = +b
        }
        getTly() {
            return this._tly
        }
        setTrx(b) {
            this._trx = +b
        }
        getTrx() {
            return this._trx
        }
        setTry(b) {
            this._try = +b
        }
        getTry() {
            return this._try
        }
        setBrx(b) {
            this._brx = +b
        }
        getBrx() {
            return this._brx
        }
        setBry(b) {
            this._bry = +b
        }
        getBry() {
            return this._bry
        }
        setBlx(b) {
            this._blx = +b
        }
        getBlx() {
            return this._blx
        }
        setBly(b) {
            this._bly = +b
        }
        getBly() {
            return this._bly
        }
        toDOMQuad() {
            return new DOMQuad(new DOMPoint(this._tlx, this._tly), new DOMPoint(this._trx, this._try), new DOMPoint(this._brx, this._bry), new DOMPoint(this._blx, this._bly))
        }
        toArray() {
            return [this._tlx, this._tly, this._trx, this._try, this._brx, this._bry, this._blx, this._bly]
        }
        toTypedArray() {
            return new Float64Array(this.toArray())
        }
        writeToTypedArray(b, a) {
            b[a++] = this._tlx;
            b[a++] = this._tly;
            b[a++] = this._trx;
            b[a++] = this._try;
            b[a++] = this._brx;
            b[a++] = this._bry;
            b[a++] = this._blx;
            b[a] = this._bly
        }
        writeToTypedArray3D(b, a, f) {
            b[a++] = this._tlx;
            b[a++] = this._tly;
            b[a++] = f;
            b[a++] = this._trx;
            b[a++] = this._try;
            b[a++] = f;
            b[a++] = this._brx;
            b[a++] = this._bry;
            b[a++] = f;
            b[a++] = this._blx;
            b[a++] = this._bly;
            b[a] = f
        }
        offset(b, a) {
            b = +b;
            a = +a;
            this._tlx += b;
            this._tly += a;
            this._trx += b;
            this._try += a;
            this._brx += b;
            this._bry += a;
            this._blx += b;
            this._bly += a
        }
        round() {
            this._tlx = Math.round(this._tlx);
            this._tly = Math.round(this._tly);
            this._trx = Math.round(this._trx);
            this._try = Math.round(this._try);
            this._brx = Math.round(this._brx);
            this._bry = Math.round(this._bry);
            this._blx = Math.round(this._blx);
            this._bly = Math.round(this._bly)
        }
        floor() {
            this._tlx = Math.floor(this._tlx);
            this._tly = Math.floor(this._tly);
            this._trx = Math.floor(this._trx);
            this._try = Math.floor(this._try);
            this._brx = Math.floor(this._brx);
            this._bry = Math.floor(this._bry);
            this._blx = Math.floor(this._blx);
            this._bly = Math.floor(this._bly)
        }
        ceil() {
            this._tlx = Math.ceil(this._tlx);
            this._tly = Math.ceil(this._tly);
            this._trx = Math.ceil(this._trx);
            this._try =
                Math.ceil(this._try);
            this._brx = Math.ceil(this._brx);
            this._bry = Math.ceil(this._bry);
            this._blx = Math.ceil(this._blx);
            this._bly = Math.ceil(this._bly)
        }
        setFromRect(b) {
            this._tlx = b._left;
            this._tly = b._top;
            this._trx = b._right;
            this._try = b._top;
            this._brx = b._right;
            this._bry = b._bottom;
            this._blx = b._left;
            this._bly = b._bottom
        }
        setFromRotatedRect(b, a) {
            0 === a ? this.setFromRect(b) : this.setFromRotatedRectPrecalc(b, Math.sin(a), Math.cos(a))
        }
        setFromRotatedRectPrecalc(b, a, f) {
            const c = b._left * a,
                e = b._top * a,
                g = b._right * a;
            a *= b._bottom;
            const h = b._left * f,
                l = b._top * f,
                m = b._right * f;
            b = b._bottom * f;
            this._tlx = h - e;
            this._tly = l + c;
            this._trx = m - e;
            this._try = l + g;
            this._brx = m - a;
            this._bry = b + g;
            this._blx = h - a;
            this._bly = b + c
        }
        getBoundingBox(b) {
            b.set(Math.min(this._tlx, this._trx, this._brx, this._blx), Math.min(this._tly, this._try, this._bry, this._bly), Math.max(this._tlx, this._trx, this._brx, this._blx), Math.max(this._tly, this._try, this._bry, this._bly))
        }
        containsPoint(b, a) {
            var f = this._trx - this._tlx,
                c = this._try - this._tly;
            const e = this._brx - this._tlx,
                g = this._bry - this._tly;
            b -= this._tlx;
            a -= this._tly;
            var h = f * f + c * c;
            let l = f * e + c * g;
            c = f * b + c * a;
            const m = e * e + g * g,
                p = e * b + g * a;
            let t = 1 / (h * m - l * l);
            f = (m * c - l * p) * t;
            h = (h * p - l * c) * t;
            if (0 <= f && 0 < h && 1 > f + h) return !0;
            f = this._blx - this._tlx;
            c = this._bly - this._tly;
            h = f * f + c * c;
            l = f * e + c * g;
            c = f * b + c * a;
            t = 1 / (h * m - l * l);
            f = (m * c - l * p) * t;
            h = (h * p - l * c) * t;
            return 0 <= f && 0 < h && 1 > f + h
        }
        midX() {
            return (this._tlx + this._trx + this._brx + this._blx) / 4
        }
        midY() {
            return (this._tly + this._try + this._bry + this._bly) / 4
        }
        intersectsSegment(b, a, f, c) {
            return this.containsPoint(b, a) || this.containsPoint(f, c) ?
                !0 : d.segmentIntersectsQuad(b, a, f, c, this)
        }
        intersectsQuad(b) {
            var a = b.midX(),
                f = b.midY();
            if (this.containsPoint(a, f)) return !0;
            a = this.midX();
            f = this.midY();
            if (b.containsPoint(a, f)) return !0;
            a = this._tlx;
            f = this._tly;
            const c = this._trx,
                e = this._try,
                g = this._brx,
                h = this._bry,
                l = this._blx,
                m = this._bly;
            return d.segmentIntersectsQuad(a, f, c, e, b) || d.segmentIntersectsQuad(c, e, g, h, b) || d.segmentIntersectsQuad(g, h, l, m, b) || d.segmentIntersectsQuad(l, m, a, f, b)
        }
        mirror() {
            this._swap(0, 2);
            this._swap(1, 3);
            this._swap(6, 4);
            this._swap(7,
                5)
        }
        flip() {
            this._swap(0, 6);
            this._swap(1, 7);
            this._swap(2, 4);
            this._swap(3, 5)
        }
        diag() {
            this._swap(2, 6);
            this._swap(3, 7)
        }
        _swap(b, a) {
            const f = this._getAtIndex(b);
            this._setAtIndex(b, this._getAtIndex(a));
            this._setAtIndex(a, f)
        }
        _getAtIndex(b) {
            switch (b) {
                case 0:
                    return this._tlx;
                case 1:
                    return this._tly;
                case 2:
                    return this._trx;
                case 3:
                    return this._try;
                case 4:
                    return this._brx;
                case 5:
                    return this._bry;
                case 6:
                    return this._blx;
                case 7:
                    return this._bly;
                default:
                    throw new RangeError("invalid quad point index");
            }
        }
        _setAtIndex(b,
            a) {
            a = +a;
            switch (b) {
                case 0:
                    this._tlx = a;
                    break;
                case 1:
                    this._tly = a;
                    break;
                case 2:
                    this._trx = a;
                    break;
                case 3:
                    this._try = a;
                    break;
                case 4:
                    this._brx = a;
                    break;
                case 5:
                    this._bry = a;
                    break;
                case 6:
                    this._blx = a;
                    break;
                case 7:
                    this._bly = a;
                    break;
                default:
                    throw new RangeError("invalid quad point index");
            }
        }
    }
}
"use strict";
{
    const d = self.C3,
        b = [0, 0, 1, 0, 1, 1, 0, 1],
        a = d.New(d.Quad);
    d.CollisionPoly = class extends d.DefendedBase {
        constructor(f, c = !0) {
            super();
            f || (f = b);
            this._ptsArr = Float64Array.from(f);
            this._bbox = new d.Rect;
            this._isBboxChanged = !0;
            this._enabled = c
        }
        Release() {}
        pointsArr() {
            return this._ptsArr
        }
        pointCount() {
            return this._ptsArr.length / 2
        }
        setPoints(f) {
            this._ptsArr.length === f.length ? this._ptsArr.set(f) : this._ptsArr = Float64Array.from(f);
            this._isBboxChanged = !0
        }
        setDefaultPoints() {
            this.setPoints(b)
        }
        copy(f) {
            this.setPoints(f._ptsArr)
        }
        setBboxChanged() {
            this._isBboxChanged = !0
        }
        _updateBbox() {
            if (this._isBboxChanged) {
                var f = this._ptsArr,
                    c = f[0],
                    e = f[1],
                    g = c,
                    h = e;
                for (let l = 0, m = f.length; l < m; l += 2) {
                    const p = f[l],
                        t = f[l + 1];
                    p < c && (c = p);
                    p > g && (g = p);
                    t < e && (e = t);
                    t > h && (h = t)
                }
                this._bbox.set(c, e, g, h);
                this._isBboxChanged = !1
            }
        }
        setFromRect(f, c, e) {
            let g = this._ptsArr;
            8 !== g.length && (this._ptsArr = g = new Float64Array(8));
            g[0] = f.getLeft() - c;
            g[1] = f.getTop() - e;
            g[2] = f.getRight() - c;
            g[3] = f.getTop() - e;
            g[4] = f.getRight() - c;
            g[5] = f.getBottom() - e;
            g[6] = f.getLeft() - c;
            g[7] = f.getBottom() - e;
            this._bbox.copy(f);
            0 === c && 0 ===
                e || this._bbox.offset(-c, -e);
            this._isBboxChanged = !1
        }
        setFromQuad(f, c, e) {
            a.copy(f);
            a.offset(c, e);
            this.setPoints(a.toArray());
            this._isBboxChanged = !0
        }
        transform(f, c, e) {
            let g = 0,
                h = 1;
            0 !== e && (g = Math.sin(e), h = Math.cos(e));
            this.transformPrecalc(f, c, g, h)
        }
        transformPrecalc(f, c, e, g) {
            const h = this._ptsArr;
            for (let l = 0, m = h.length; l < m; l += 2) {
                const p = l + 1,
                    t = h[l] * f,
                    q = h[p] * c;
                h[l] = t * g - q * e;
                h[p] = q * g + t * e
            }
            this._isBboxChanged = !0
        }
        offset(f, c) {
            const e = this._ptsArr;
            for (let g = 0, h = e.length; g < h; g += 2) e[g] += f, e[g + 1] += c
        }
        containsPoint(f, c) {
            const e =
                this._ptsArr;
            if (f === e[0] && c === e[1]) return !0;
            this._updateBbox();
            var g = this._bbox;
            const h = g.getLeft() - 110,
                l = g.getTop() - 101,
                m = g.getRight() + 131;
            g = g.getBottom() + 120;
            let p, t, q, r, u, x, y, C;
            h < f ? (p = h, q = f) : (p = f, q = h);
            l < c ? (t = l, r = c) : (t = c, r = l);
            m < f ? (u = m, y = f) : (u = f, y = m);
            g < c ? (x = g, C = c) : (x = c, C = g);
            let w = 0,
                A = 0;
            for (let K = 0, O = e.length; K < O; K += 2) {
                var E = (K + 2) % O;
                const G = e[K],
                    J = e[K + 1],
                    P = e[E];
                E = e[E + 1];
                d.segmentsIntersectPreCalc(h, l, f, c, p, q, t, r, G, J, P, E) && ++w;
                d.segmentsIntersectPreCalc(m, g, f, c, u, y, x, C, G, J, P, E) && ++A
            }
            return 1 === w % 2 ||
                1 === A % 2
        }
        intersectsPoly(f, c, e) {
            const g = f._ptsArr,
                h = this._ptsArr;
            if (this.containsPoint(g[0] + c, g[1] + e) || f.containsPoint(h[0] - c, h[1] - e)) return !0;
            for (let m = 0, p = h.length; m < p; m += 2) {
                var l = (m + 2) % p;
                f = h[m];
                const t = h[m + 1],
                    q = h[l];
                l = h[l + 1];
                let r, u, x, y;
                f < q ? (r = f, x = q) : (r = q, x = f);
                t < l ? (u = t, y = l) : (u = l, y = t);
                for (let C = 0, w = g.length; C < w; C += 2) {
                    const A = (C + 2) % w;
                    if (d.segmentsIntersectPreCalc(f, t, q, l, r, x, u, y, g[C] + c, g[C + 1] + e, g[A] + c, g[A + 1] + e)) return !0
                }
            }
            return !1
        }
        intersectsSegment(f, c, e, g, h, l) {
            if (this.containsPoint(e - f, g - c) || this.containsPoint(h -
                    f, l - c)) return !0;
            let m, p, t, q;
            e < h ? (m = e, t = h) : (m = h, t = e);
            g < l ? (p = g, q = l) : (p = l, q = g);
            const r = this._ptsArr;
            for (let u = 0, x = r.length; u < x; u += 2) {
                const y = (u + 2) % x;
                if (d.segmentsIntersectPreCalc(e, g, h, l, m, t, p, q, r[u] + f, r[u + 1] + c, r[y] + f, r[y + 1] + c)) return !0
            }
            return !1
        }
        mirror(f) {
            const c = this._ptsArr;
            for (let e = 0, g = c.length; e < g; e += 2) c[e] = 2 * f - c[e];
            this._isBboxChanged = !0
        }
        flip(f) {
            const c = this._ptsArr;
            for (let e = 0, g = c.length; e < g; e += 2) {
                const h = e + 1;
                c[h] = 2 * f - c[h]
            }
            this._isBboxChanged = !0
        }
        diag() {
            const f = this._ptsArr;
            for (let c = 0, e = f.length; c <
                e; c += 2) {
                const g = c + 1,
                    h = f[c];
                f[c] = f[g];
                f[g] = h
            }
            this._isBboxChanged = !0
        }
        GetMidX() {
            const f = this._ptsArr;
            let c = 0;
            for (let e = 0, g = f.length; e < g; e += 2) c += f[e];
            return c / this.pointCount()
        }
        GetMidY() {
            const f = this._ptsArr;
            let c = 0;
            for (let e = 0, g = f.length; e < g; e += 2) c += f[e + 1];
            return c / this.pointCount()
        }
        GetPointsArray() {
            return this._ptsArr
        }
        GetPointCount() {
            return this.pointCount()
        }
        IsEnabled() {
            return this._enabled
        }
    }
}
"use strict";
{
    const d = self.C3;
    d.PairMap = class extends d.DefendedBase {
        constructor(b) {
            super();
            this._firstMap = new Map;
            if (b)
                for (const [a, f, c] of b) this.Set(a, f, c)
        }
        Release() {
            this.Clear();
            this._firstMap = null
        }
        Clear() {
            const b = this._firstMap;
            for (const a of b.values()) a.clear();
            b.clear()
        }
        Set(b, a, f) {
            const c = this._firstMap;
            let e = c.get(b);
            e || (e = new Map, c.set(b, e));
            e.set(a, f)
        }
        Get(b, a) {
            return (b = this._firstMap.get(b)) ? b.get(a) : b
        }
        Has(b, a) {
            return (b = this._firstMap.get(b)) ? b.has(a) : !1
        }
        Delete(b, a) {
            const f = this._firstMap,
                c = f.get(b);
            if (!c) return !1;
            (a = c.delete(a)) && 0 === c.size && f.delete(b);
            return a
        }
        DeleteEither(b) {
            const a = this._firstMap,
                f = a.get(b);
            f && (f.clear(), a.delete(b));
            for (const [c, e] of a.entries()) e.delete(b) && 0 === e.size && a.delete(c)
        }
        GetSize() {
            let b = 0;
            for (const a of this._firstMap.values()) b += a.size;
            return b
        }* values() {
            for (const b of this._firstMap.values()) yield* b.values()
        }* keyPairs() {
            for (const [b, a] of this._firstMap.entries())
                for (const f of a.keys()) yield [b, f]
        }* entries() {
            for (const [b, a] of this._firstMap.entries())
                for (const [f,
                        c
                    ] of a.entries()) yield [b, f, c]
        }
    }
}
"use strict";
{
    const d = self.C3;
    d.ArraySet = class extends d.DefendedBase {
        constructor() {
            super();
            this._set = new Set;
            this._arr = [];
            this._needToRebuildArray = !1
        }
        Release() {
            this.Clear()
        }
        Clear() {
            this._set.clear();
            d.clearArray(this._arr);
            this._needToRebuildArray = !1
        }
        Add(b) {
            this._set.has(b) || (this._set.add(b), this._needToRebuildArray || this._arr.push(b))
        }
        Has(b) {
            return this._set.has(b)
        }
        Delete(b) {
            this._set.delete(b) && (this._needToRebuildArray = !0)
        }
        GetSize() {
            return this._set.size
        }
        IsEmpty() {
            return 0 === this._set.size
        }
        GetArray() {
            this._needToRebuildArray &&
                (this._RebuildArray(), this._needToRebuildArray = !1);
            return this._arr
        }
        _RebuildArray() {
            const b = this._arr;
            d.clearArray(b);
            for (const a of this._set) b.push(a)
        }
    }
}
"use strict";
{
    const d = new Map,
        b = new Map,
        a = new Map,
        f = new Map,
        c = new Map,
        e = new Map;
    e.set("linear", "noease");
    e.set("default", "noease");
    self.Ease = class q {
        constructor() {}
        static InheritEase() {
            return "default"
        }
        static DefaultEase() {
            return "noease"
        }
        static GetEditorEaseNames(r, ...u) {
            this._CreateEaseMap();
            a.has(r) || a.set(r, new Map);
            r = [...a.get(r).keys()];
            r.sort();
            return [...b.keys()].concat(r).filter(x => !u.includes(x))
        }
        static GetRuntimeEaseNames() {
            this._CreateEaseMap();
            const r = [...f.keys()];
            r.sort();
            return [...b.keys()].concat(r)
        }
        static IsNamePredefined(r) {
            this._CreateEaseMap();
            return [...b.keys()].includes(r)
        }
        static _GetEase(r) {
            const u = e.get(r);
            if (u) return d.get(u);
            if (q.IsNamePredefined(r)) return d.get(r);
            if (c.has(r)) return c.get(r)
        }
        static GetEditorEase(r, u) {
            this._CreateEaseMap();
            const x = q._GetEase(r);
            return x ? x : a.get(u).get(r)
        }
        static GetRuntimeEase(r) {
            this._CreateEaseMap();
            const u = q._GetEase(r);
            return u ? u : f.get(r)
        }
        static GetEaseFromIndex(r) {
            this._CreateEaseMap();
            return this.GetRuntimeEaseNames()[r]
        }
        static GetIndexForEase(r, u) {
            this._CreateEaseMap();
            return this.GetEditorEaseNames(u).indexOf(r)
        }
        static _CreateEaseMap() {
            0 ===
                d.size && (this._AddPredifinedEase("default", () => {}), this._AddPredifinedEase("noease", this.NoEase), this._AddPredifinedEase("easeinsine", this.EaseInSine), this._AddPredifinedEase("easeoutsine", this.EaseOutSine), this._AddPredifinedEase("easeinoutsine", this.EaseInOutSine), this._AddPredifinedEase("easeinelastic", this.EaseInElastic), this._AddPredifinedEase("easeoutelastic", this.EaseOutElastic), this._AddPredifinedEase("easeinoutelastic", this.EaseInOutElastic), this._AddPredifinedEase("easeinback", this.EaseInBack),
                    this._AddPredifinedEase("easeoutback", this.EaseOutBack), this._AddPredifinedEase("easeinoutback", this.EaseInOutBack), this._AddPredifinedEase("easeinbounce", this.EaseInBounce), this._AddPredifinedEase("easeoutbounce", this.EaseOutBounce), this._AddPredifinedEase("easeinoutbounce", this.EaseInOutBounce), this._AddPredifinedEase("easeincubic", this.EaseInCubic), this._AddPredifinedEase("easeoutcubic", this.EaseOutCubic), this._AddPredifinedEase("easeinoutcubic", this.EaseInOutCubic), this._AddPredifinedEase("easeinquad",
                        this.EaseInQuad), this._AddPredifinedEase("easeoutquad", this.EaseOutQuad), this._AddPredifinedEase("easeinoutquad", this.EaseInOutQuad), this._AddPredifinedEase("easeinquart", this.EaseInQuart), this._AddPredifinedEase("easeoutquart", this.EaseOutQuart), this._AddPredifinedEase("easeinoutquart", this.EaseInOutQuart), this._AddPredifinedEase("easeinquint", this.EaseInQuint), this._AddPredifinedEase("easeoutquint", this.EaseOutQuint), this._AddPredifinedEase("easeinoutquint", this.EaseInOutQuint), this._AddPredifinedEase("easeincirc",
                        this.EaseInCirc), this._AddPredifinedEase("easeoutcirc", this.EaseOutCirc), this._AddPredifinedEase("easeinoutcirc", this.EaseInOutCirc), this._AddPredifinedEase("easeinexpo", this.EaseInExpo), this._AddPredifinedEase("easeoutexpo", this.EaseOutExpo), this._AddPredifinedEase("easeinoutexpo", this.EaseInOutExpo), this._AddPrivateCustomEase("cubicbezier", this.EaseCubicBezier), this._AddPrivateCustomEase("spline", this.EaseSpline))
        }
        static _AddPredifinedEase(r, u) {
            q._AddEase(r, u, "predefined")
        }
        static _AddPrivateCustomEase(r,
            u) {
            q._AddEase(r, u, "private")
        }
        static AddCustomEase(r, u, x) {
            this._CreateEaseMap();
            q._AddEase(r, u, "custom", x)
        }
        static RemoveCustomEase(r, u) {
            this.IsNamePredefined(r) || [...c.keys()].includes(r) || (u = a.get(u)) && u.delete(r)
        }
        static _AddEase(r, u, x, y) {
            switch (x) {
                case "predefined":
                    d.set(r, u);
                    b.set(r, u);
                    break;
                case "custom":
                    y ? (a.has(y) || a.set(y, new Map), a.get(y).set(r, u)) : f.set(r, u);
                    break;
                case "private":
                    d.set(r, u);
                    c.set(r, u);
                    break;
                default:
                    throw Error("unexpected ease mode");
            }
        }
        static NoEase(r, u, x, y) {
            return x * r / y + u
        }
        static EaseInQuad(r,
            u, x, y) {
            return x * (r /= y) * r + u
        }
        static EaseOutQuad(r, u, x, y) {
            return -x * (r /= y) * (r - 2) + u
        }
        static EaseInOutQuad(r, u, x, y) {
            return 1 > (r /= y / 2) ? x / 2 * r * r + u : -x / 2 * (--r * (r - 2) - 1) + u
        }
        static EaseInCubic(r, u, x, y) {
            return x * (r /= y) * r * r + u
        }
        static EaseOutCubic(r, u, x, y) {
            return x * ((r = r / y - 1) * r * r + 1) + u
        }
        static EaseInOutCubic(r, u, x, y) {
            return 1 > (r /= y / 2) ? x / 2 * r * r * r + u : x / 2 * ((r -= 2) * r * r + 2) + u
        }
        static EaseInQuart(r, u, x, y) {
            return x * (r /= y) * r * r * r + u
        }
        static EaseOutQuart(r, u, x, y) {
            return -x * ((r = r / y - 1) * r * r * r - 1) + u
        }
        static EaseInOutQuart(r, u, x, y) {
            return 1 > (r /=
                y / 2) ? x / 2 * r * r * r * r + u : -x / 2 * ((r -= 2) * r * r * r - 2) + u
        }
        static EaseInQuint(r, u, x, y) {
            return x * (r /= y) * r * r * r * r + u
        }
        static EaseOutQuint(r, u, x, y) {
            return x * ((r = r / y - 1) * r * r * r * r + 1) + u
        }
        static EaseInOutQuint(r, u, x, y) {
            return 1 > (r /= y / 2) ? x / 2 * r * r * r * r * r + u : x / 2 * ((r -= 2) * r * r * r * r + 2) + u
        }
        static EaseInSine(r, u, x, y) {
            return -x * Math.cos(r / y * (Math.PI / 2)) + x + u
        }
        static EaseOutSine(r, u, x, y) {
            return x * Math.sin(r / y * (Math.PI / 2)) + u
        }
        static EaseInOutSine(r, u, x, y) {
            return -x / 2 * (Math.cos(Math.PI * r / y) - 1) + u
        }
        static EaseInExpo(r, u, x, y) {
            return 0 === r ? u : x * Math.pow(2,
                10 * (r / y - 1)) + u
        }
        static EaseOutExpo(r, u, x, y) {
            return r === y ? u + x : x * (-Math.pow(2, -10 * r / y) + 1) + u
        }
        static EaseInOutExpo(r, u, x, y) {
            return 0 === r ? u : r === y ? u + x : 1 > (r /= y / 2) ? x / 2 * Math.pow(2, 10 * (r - 1)) + u : x / 2 * (-Math.pow(2, -10 * --r) + 2) + u
        }
        static EaseInCirc(r, u, x, y) {
            return -x * (Math.sqrt(1 - (r /= y) * r) - 1) + u
        }
        static EaseOutCirc(r, u, x, y) {
            return x * Math.sqrt(1 - (r = r / y - 1) * r) + u
        }
        static EaseInOutCirc(r, u, x, y) {
            return 1 > (r /= y / 2) ? -x / 2 * (Math.sqrt(1 - r * r) - 1) + u : x / 2 * (Math.sqrt(1 - (r -= 2) * r) + 1) + u
        }
        static EaseInElastic(r, u, x, y) {
            let C = 0,
                w = x;
            if (0 === r) return u;
            if (1 === (r /= y)) return u + x;
            C || (C = .3 * y);
            w < Math.abs(x) ? (w = x, x = C / 4) : x = C / (2 * Math.PI) * Math.asin(x / w);
            return -(w * Math.pow(2, 10 * --r) * Math.sin(2 * (r * y - x) * Math.PI / C)) + u
        }
        static EaseOutElastic(r, u, x, y) {
            let C, w = 0,
                A = x;
            if (0 === r) return u;
            if (1 === (r /= y)) return u + x;
            w || (w = .3 * y);
            A < Math.abs(x) ? (A = x, C = w / 4) : C = w / (2 * Math.PI) * Math.asin(x / A);
            return A * Math.pow(2, -10 * r) * Math.sin(2 * (r * y - C) * Math.PI / w) + x + u
        }
        static EaseInOutElastic(r, u, x, y) {
            let C, w = 0,
                A = x;
            if (0 === r) return u;
            if (2 === (r /= y / 2)) return u + x;
            w || (w = .3 * y * 1.5);
            A < Math.abs(x) ? (A = x,
                C = w / 4) : C = w / (2 * Math.PI) * Math.asin(x / A);
            return 1 > r ? -.5 * A * Math.pow(2, 10 * --r) * Math.sin(2 * (r * y - C) * Math.PI / w) + u : A * Math.pow(2, -10 * --r) * Math.sin(2 * (r * y - C) * Math.PI / w) * .5 + x + u
        }
        static EaseInBack(r, u, x, y, C) {
            void 0 === C && (C = 1.70158);
            return x * (r /= y) * r * ((C + 1) * r - C) + u
        }
        static EaseOutBack(r, u, x, y, C) {
            void 0 === C && (C = 1.70158);
            return x * ((r = r / y - 1) * r * ((C + 1) * r + C) + 1) + u
        }
        static EaseInOutBack(r, u, x, y, C) {
            void 0 === C && (C = 1.70158);
            return 1 > (r /= y / 2) ? x / 2 * r * r * (((C *= 1.525) + 1) * r - C) + u : x / 2 * ((r -= 2) * r * (((C *= 1.525) + 1) * r + C) + 2) + u
        }
        static EaseInBounce(r,
            u, x, y) {
            return x - q.EaseOutBounce(y - r, 0, x, y) + u
        }
        static EaseOutBounce(r, u, x, y) {
            return (r /= y) < 1 / 2.75 ? 7.5625 * x * r * r + u : r < 2 / 2.75 ? x * (7.5625 * (r -= 1.5 / 2.75) * r + .75) + u : r < 2.5 / 2.75 ? x * (7.5625 * (r -= 2.25 / 2.75) * r + .9375) + u : x * (7.5625 * (r -= 2.625 / 2.75) * r + .984375) + u
        }
        static EaseInOutBounce(r, u, x, y) {
            return r < y / 2 ? .5 * q.EaseInBounce(2 * r, 0, x, y) + u : .5 * q.EaseOutBounce(2 * r - y, 0, x, y) + .5 * x + u
        }
        static EaseCubicBezier(r, u, x, y, C) {
            return u + 3 * r * (x - u) + 3 * r ** 2 * (u + y - 2 * x) + r ** 3 * (C - u + 3 * x - 3 * y)
        }
        static EaseSpline(r, u, x, y, C, w, A, E, K, O) {
            if (y === C && w === A) return r;
            r = t(r, u, y, w, E, O);
            u = g(x, C, A, K);
            y = h(x, C, A, K);
            x = l(x, C, A, K);
            return m(r, u, y, x)
        }
        static GetBezierSamples(r, u, x, y) {
            const C = [],
                w = g(r, u, x, y),
                A = h(r, u, x, y);
            r = l(r, u, x, y);
            for (u = 0; 11 > u; ++u) x = m(.1 * u, w, A, r), C.push(x);
            return C
        }
    };
    const g = (q, r, u, x) => x - 3 * u + 3 * r - q,
        h = (q, r, u, x) => 3 * u - 6 * r + 3 * q,
        l = (q, r, u, x) => 3 * (r - q),
        m = (q, r, u, x) => ((r * q + u) * q + x) * q,
        p = (q, r, u, x) => 3 * r * q * q + 2 * u * q + x,
        t = (q, r, u, x, y, C) => {
            if (1 == q) return 1;
            for (var w = 0, A = 1, E = C[A]; 10 != A && E <= q;) A++, E = C[A], w += .1;
            A--;
            E = C[A];
            C = w + (q - E) / (C[A + 1] - E) * .1;
            A = g(r, u, x, y);
            E = h(r, u, x, y);
            r = l(r,
                u, x, y);
            u = p(C, A, E, r);
            if (0 !== u)
                if (.02 <= u)
                    for (w = 0; 4 > w; ++w) u = m(C, A, E, r) - q, x = p(C, A, E, r), C -= u / x;
                else {
                    u = w;
                    w += .1;
                    x = 0;
                    let K;
                    do C = u + (w - u) / 2, y = m(C, A, E, r) - q, 0 < y ? w = C : u = C, y = 1E-7 < Math.abs(y), K = 10 > ++x; while (y && K)
                } return C
        }
}
"use strict";
{
    const d = self.C3;

    function b(a) {
        d.IsString(a)
    }
    d.ProbabilityTable = class {
        constructor() {
            this._items = [];
            this._totalWeight = 0
        }
        Release() {
            this.Clear();
            this._items = null
        }
        Clear() {
            d.clear2DArray(this._items);
            this._totalWeight = 0
        }
        GetTotalWeight() {
            return this._totalWeight
        }
        Sample(a = Math.random() * this.GetTotalWeight()) {
            let f = 0;
            for (const [c, e] of this._items)
                if (f += c, a < f) return e;
            return 0
        }
        AddItem(a, f) {
            b(f);
            this._totalWeight += a;
            this._items.push([a, f])
        }
        RemoveItem(a, f) {
            b(f);
            const c = 0 === a;
            for (let e = 0; e < this._items.length; e++) {
                const g =
                    this._items[e],
                    h = g[1] === f;
                if ((c || g[0] === a) && h) {
                    this._items.splice(e, 1);
                    this._totalWeight -= g[0];
                    break
                }
            }
        }
        asJSON() {
            return JSON.stringify(this._items)
        }
        static fromJSON(a) {
            const f = new d.ProbabilityTable;
            a = JSON.parse(a);
            for (const c of a) f.AddItem(c[0], c[1]);
            return f
        }
    }
}
"use strict";
self.C3.Event = class {
    constructor(d, b) {
        this.type = d;
        this.cancelable = !!b;
        this.isAsync = this.propagationStopped = this.defaultPrevented = !1
    }
    preventDefault() {
        if (!this.cancelable) throw Error(`event '${this.type}' is not cancelable`);
        this.defaultPrevented = !0
    }
    stopPropagation() {
        if (!this.cancelable) throw Error(`event '${this.type}' cannot be stopped`);
        if (this.isAsync) throw Error(`cannot stop async event '${this.type}' propagation`);
        this.propagationStopped = !0
    }
};
"use strict";
{
    const d = self.C3;
    d.Event.Handler = class extends d.DefendedBase {
        constructor(b) {
            super();
            this._type = b;
            this._captureListeners = [];
            this._captureListenersSet = new Set;
            this._listeners = [];
            this._listenersSet = new Set;
            this._fireDepth = 0;
            this._queueAddListeners = [];
            this._queueRemoveCaptureListeners = [];
            this._queueRemoveListeners = []
        }
        Release() {
            0 < this._fireDepth || (d.clearArray(this._captureListeners), this._captureListenersSet.clear(), d.clearArray(this._listeners), this._listenersSet.clear(), d.clearArray(this._queueAddListeners),
                d.clearArray(this._queueRemoveCaptureListeners), d.clearArray(this._queueRemoveListeners), d.Release(this))
        }
        _AddListener(b, a) {
            this._IsFiring() ? this._queueAddListeners.push([b, a]) : a ? this._captureListenersSet.has(b) || (this._captureListeners.push(b), this._captureListenersSet.add(b)) : this._listenersSet.has(b) || (this._listeners.push(b), this._listenersSet.add(b))
        }
        _RemoveListener(b, a) {
            this._IsFiring() ? a ? this._queueRemoveCaptureListeners.push(b) : this._queueRemoveListeners.push(b) : a ? this._captureListenersSet.has(b) &&
                (this._captureListenersSet.delete(b), d.arrayFindRemove(this._captureListeners, b)) : this._listenersSet.has(b) && (this._listenersSet.delete(b), d.arrayFindRemove(this._listeners, b))
        }
        _IsEmpty() {
            return !this._captureListeners.length && !this._listeners.length
        }
        _IsFiring() {
            return 0 < this._fireDepth
        }
        _ProcessQueuedListeners() {
            for (var b of this._queueAddListeners) this._AddListener(...b);
            d.clearArray(this._queueAddListeners);
            for (var a of this._queueRemoveListeners) this._listenersSet.delete(a);
            for (const f of this._queueRemoveCaptureListeners) this._captureListenersSet.delete(f);
            b = new Set(this._queueRemoveListeners);
            a = new Set(this._queueRemoveCaptureListeners);
            d.arrayRemoveAllInSet(this._listeners, b);
            d.arrayRemoveAllInSet(this._captureListeners, a);
            d.clearArray(this._queueRemoveCaptureListeners);
            d.clearArray(this._queueRemoveListeners)
        }
        _FireCancellable(b) {
            this._IncreaseFireDepth();
            let a = !1;
            for (let f = 0, c = this._captureListeners.length; f < c; ++f)
                if (this._captureListeners[f](b), b.propagationStopped) {
                    a = !0;
                    break
                } if (!a)
                for (let f = 0, c = this._listeners.length; f < c && (this._listeners[f](b),
                        !b.propagationStopped); ++f);
            this._DecreaseFireDepth();
            return !b.defaultPrevented
        }
        _FireNonCancellable(b) {
            this._IncreaseFireDepth();
            for (let a = 0, f = this._captureListeners.length; a < f; ++a) this._captureListeners[a](b);
            for (let a = 0, f = this._listeners.length; a < f; ++a) this._listeners[a](b);
            this._DecreaseFireDepth();
            return !0
        }
        _IncreaseFireDepth() {
            this._fireDepth++
        }
        _DecreaseFireDepth() {
            this._fireDepth--;
            0 === this._fireDepth && (this._queueAddListeners.length || this._queueRemoveCaptureListeners.length || this._queueRemoveListeners.length) &&
                this._ProcessQueuedListeners()
        }
        SetDelayRemoveEventsEnabled(b) {
            b ? this._IncreaseFireDepth() : this._DecreaseFireDepth()
        }
        _FireAsync(b) {
            let a = [];
            for (let f = 0, c = this._captureListeners.length; f < c; ++f) {
                let e = this._captureListeners[f];
                a.push(d.Asyncify(() => e(b)))
            }
            for (let f = 0, c = this._listeners.length; f < c; ++f) {
                let e = this._listeners[f];
                a.push(d.Asyncify(() => e(b)))
            }
            return Promise.all(a).then(() => !b.defaultPrevented)
        }
        _FireAndWait_AsyncOptional(b) {
            const a = [];
            this._IncreaseFireDepth();
            for (let c = 0, e = this._captureListeners.length; c <
                e; ++c) {
                var f = this._captureListeners[c](b);
                f instanceof Promise && a.push(f)
            }
            for (let c = 0, e = this._listeners.length; c < e; ++c) f = this._listeners[c](b), f instanceof Promise && a.push(f);
            this._DecreaseFireDepth();
            return a.length ? Promise.all(a).then(() => !b.defaultPrevented) : !b.defaultPrevented
        }
        async _FireAndWaitAsync(b) {
            return await this._FireAndWait_AsyncOptional(b)
        }
        async _FireAndWaitAsyncSequential(b) {
            this._IncreaseFireDepth();
            for (let f = 0, c = this._captureListeners.length; f < c; ++f) {
                var a = this._captureListeners[f](b);
                a instanceof Promise && await a
            }
            for (let f = 0, c = this._listeners.length; f < c; ++f) a = this._listeners[f](b), a instanceof Promise && await a;
            this._DecreaseFireDepth();
            return !b.defaultPrevented
        }* _FireAsGenerator(b) {
            this._IncreaseFireDepth();
            for (let f = 0, c = this._captureListeners.length; f < c; ++f) {
                var a = this._captureListeners[f](b);
                d.IsIterator(a) && (yield* a)
            }
            for (let f = 0, c = this._listeners.length; f < c; ++f) a = this._listeners[f](b), d.IsIterator(a) && (yield* a);
            this._DecreaseFireDepth()
        }
    }
}
"use strict";
{
    const d = self.C3;
    d.Event.Dispatcher = class extends d.DefendedBase {
        constructor() {
            super();
            this._eventHandlers = new Map;
            this._dispatcherWasReleased = !1
        }
        Release() {
            if (this._dispatcherWasReleased) throw Error("already released");
            this.ClearEvents();
            this._dispatcherWasReleased = !0;
            d.Release(this)
        }
        WasReleased() {
            return this._dispatcherWasReleased
        }
        ClearEvents() {
            for (let b of this._eventHandlers.values()) b.Release();
            this._eventHandlers.clear()
        }
        _GetHandlerByType(b, a) {
            let f = this._eventHandlers.get(b);
            return f ? f : a ? (f =
                d.New(d.Event.Handler, b), this._eventHandlers.set(b, f), f) : null
        }
        HasAnyHandlerFor(b) {
            return this._eventHandlers.has(b)
        }
        addEventListener(b, a, f) {
            this._GetHandlerByType(b, !0)._AddListener(a, !!f)
        }
        removeEventListener(b, a, f) {
            let c = this._GetHandlerByType(b, !1);
            c && (c._RemoveListener(a, !!f), c._IsEmpty() && this._eventHandlers.delete(b))
        }
        dispatchEvent(b) {
            const a = this._GetHandlerByType(b.type, !1);
            return a ? b.cancelable ? a._FireCancellable(b) : a._FireNonCancellable(b) : !0
        }
        dispatchEventAsync(b) {
            const a = this._GetHandlerByType(b.type,
                !1);
            if (!a) return Promise.resolve(!0);
            b.isAsync = !0;
            return a._FireAsync(b)
        }
        async dispatchEventAndClearAsync(b) {
            const a = this._GetHandlerByType(b.type, !1);
            if (!a) return !0;
            this._eventHandlers.delete(b.type);
            b.isAsync = !0;
            b = await a._FireAsync(b);
            a.Release();
            return b
        }
        async dispatchEventAndWaitAsync(b) {
            const a = this._GetHandlerByType(b.type, !1);
            return a ? await a._FireAndWaitAsync(b) : !0
        }
        dispatchEventAndWait_AsyncOptional(b) {
            const a = this._GetHandlerByType(b.type, !1);
            return a ? a._FireAndWait_AsyncOptional(b) : !0
        }
        async dispatchEventAndWaitAsyncSequential(b) {
            const a =
                this._GetHandlerByType(b.type, !1);
            return a ? await a._FireAndWaitAsyncSequential(b) : !0
        }
        dispatchGeneratorEvent(b) {
            const a = this._GetHandlerByType(b.type, !1);
            if (!a) return null;
            if (b.cancelable) throw Error("not supported");
            return a._FireAsGenerator(b)
        }
        SetDelayRemoveEventsEnabled(b) {
            for (const a of this._eventHandlers.values()) a.SetDelayRemoveEventsEnabled(b)
        }
    }
}
"use strict";
{
    const d = self.C3,
        b = "undefined" !== typeof requestIdleCallback;
    let a = [],
        f = -1,
        c = 0;

    function e(m) {
        f = b && 0 === c ? requestIdleCallback(g, {
            timeout: 35
        }) : setTimeout(g, 0 < c ? 1 : m)
    }

    function g(m) {
        f = -1;
        if (a.length) {
            var p = performance.now(),
                t = 0;
            do {
                h(a.shift());
                var q = performance.now();
                ++t;
                var r = (q - p) / t * 1.1
            } while (a.length && (b && 0 === c && "undefined" !== typeof m ? r < m.timeRemaining() : 12 > q - p + r)); - 1 === f && a.length && e(Math.max(16 - (q - p), 4))
        }
    }

    function h(m) {
        let p;
        try {
            p = m.func()
        } catch (t) {
            m.reject(t);
            return
        }
        m.resolve(p)
    }
    let l = d.QueryString.Has("disable-asyncify");
    l && console.warn("[Asyncify] Asyncify has been disabled due to disable-asyncify in the query string. Some work will now be done synchronously.");
    d.Asyncify = function(m) {
        let p = null;
        d.isDebug && (p = d.GetCallStack());
        return new Promise((t, q) => {
            a.push({
                func: m,
                resolve: t,
                reject: q,
                stack: p
            });
            l ? h(a.pop()) : -1 === f && e(16)
        })
    };
    d.Asyncify.SetHighThroughputMode = function(m) {
        if (m) ++c;
        else if (--c, 0 > c) throw Error("already turned off high throughput mode");
    }
}
"use strict";
{
    const d = self.C3;
    let b = -1;

    function a() {
        b = -1
    }
    d.FastGetDateNow = function() {
        -1 === b && (b = Date.now(), self.setTimeout(a, 16));
        return b
    };
    let f = -1,
        c = -1,
        e = new Set;

    function g() {
        c = f = -1;
        let h = Date.now();
        for (let l of e)
            if (l._CheckTimeout(h)) {
                let m = l._GetDeadline();
                if (-1 === c || m < c) c = m
            } else e.delete(l); - 1 !== c && (f = self.setTimeout(g, Math.max(c - h + 100, 1E3)))
    }
    d.IdleTimeout = class {
        constructor(h, l) {
            this._callback = h;
            this._timeout = 1E3 * l;
            this._deadline = 0;
            this._isActive = !1
        }
        Reset() {
            let h = d.FastGetDateNow();
            this._deadline = h + this._timeout;
            this._isActive || (e.add(this), this._isActive = !0); - 1 === f ? (c = this._deadline, f = self.setTimeout(g, this._timeout + 100)) : this._deadline < c && c > h + 1E3 && (self.clearTimeout(f), c = this._deadline, f = self.setTimeout(g, this._timeout + 100))
        }
        _CheckTimeout(h) {
            return h >= this._deadline ? this._callback() ? (this._deadline = h + this._timeout, !0) : this._isActive = !1 : !0
        }
        _GetDeadline() {
            return this._deadline
        }
        Cancel() {
            this._isActive && (e.delete(this), this._isActive = !1, 0 === e.size && -1 !== f && (self.clearTimeout(f), c = f = -1))
        }
        Release() {
            this.Cancel();
            this._callback = null
        }
    }
}
"use strict";
{
    const d = self.C3;
    d.Disposable = class b {
        constructor(a) {
            this._disposed = !1;
            this._disposeAction = a
        }
        Dispose() {
            this._disposed || (this._disposed = !0, this._disposeAction && (this._disposeAction(), this._disposeAction = null))
        }
        IsDisposed() {
            return this._disposed
        }
        Release() {
            this.Dispose()
        }
        static Release(a) {
            return new b(() => a.Release())
        }
        static From(a, f, c, e, g) {
            if ("undefined" === typeof e || null === e) e = !1;
            else if ("boolean" !== typeof e && "object" !== typeof e) throw new TypeError("invalid event listener options");
            g && (c = c.bind(g));
            if (f.includes(" ")) {
                f = f.split(" ");
                g = new d.CompositeDisposable;
                for (let h of f) a.addEventListener(h, c, e), g.Add(d.New(d.Disposable, () => a.removeEventListener(h, c, e)));
                return g
            }
            a.addEventListener(f, c, e);
            return d.New(d.Disposable, () => a.removeEventListener(f, c, e))
        }
    };
    d.StubDisposable = class extends d.Disposable {
        SetAction(b) {
            this._disposeAction = b
        }
    };
    d.CompositeDisposable = class extends d.Disposable {
        constructor(...b) {
            super();
            this._disposables = new Set;
            for (let a of b) this.Add(a)
        }
        Add(...b) {
            if (this._disposed) throw Error("already disposed");
            for (let a of b) this._disposables.add(a)
        }
        Remove(b) {
            if (this._disposed) throw Error("already disposed");
            this._disposables.delete(b)
        }
        RemoveAll() {
            if (this._disposed) throw Error("already disposed");
            if (this._disposables) {
                for (let b of this._disposables) b.Dispose();
                this._disposables.clear()
            }
        }
        IsDisposed() {
            return this._disposed
        }
        Dispose() {
            if (this._disposed) throw Error("already disposed");
            this._disposed = !0;
            for (let b of this._disposables) b.Dispose();
            this._disposables.clear();
            this._disposables = null
        }
        Release() {
            this.Dispose()
        }
    }
}
"use strict";
{
    const d = self.C3;
    d.KahanSum = class extends d.DefendedBase {
        constructor() {
            super();
            this._sum = this._t = this._y = this._c = 0
        }
        Add(b) {
            this._y = +b - this._c;
            this._t = this._sum + this._y;
            this._c = this._t - this._sum - this._y;
            this._sum = this._t
        }
        Subtract(b) {
            this._sum -= +b
        }
        Get() {
            return this._sum
        }
        Reset() {
            this._sum = this._t = this._y = this._c = 0
        }
        Set(b) {
            this._t = this._y = this._c = 0;
            this._sum = +b
        }
        Release() {}
    }
}
"use strict";
{
    const d = self.C3,
        b = {
            RBnode: function(a) {
                this.tree = a;
                this.left = this.right = this.tree.sentinel;
                this.parent = null;
                this.color = !1;
                this.key = null
            },
            RedBlackSet: function(a) {
                this.size = 0;
                this.sentinel = new b.RBnode(this);
                this.sentinel.color = !1;
                this.root = this.sentinel;
                this.root.parent = this.sentinel;
                this.compare = a || this.default_compare
            }
        };
    b.RedBlackSet.prototype.default_compare = function(a, f) {
        return a < f ? -1 : f < a ? 1 : 0
    };
    b.RedBlackSet.prototype.clone = function() {
        var a = new b.RedBlackSet(this.compare);
        a.insertAll(this);
        return a
    };
    b.RedBlackSet.prototype.clear = function() {
        this.size = 0;
        this.sentinel = new b.RBnode(this);
        this.sentinel.color = !1;
        this.root = this.sentinel;
        this.root.parent = this.sentinel
    };
    b.RedBlackSet.prototype.leftRotate = function(a) {
        var f = a.right;
        a.right = f.left;
        f.left != this.sentinel && (f.left.parent = a);
        f.parent = a.parent;
        a.parent == this.sentinel ? this.root = f : a == a.parent.left ? a.parent.left = f : a.parent.right = f;
        f.left = a;
        a.parent = f
    };
    b.RedBlackSet.prototype.rightRotate = function(a) {
        var f = a.left;
        a.left = f.right;
        f.right != this.sentinel &&
            (f.right.parent = a);
        f.parent = a.parent;
        a.parent == this.sentinel ? this.root = f : a == a.parent.right ? a.parent.right = f : a.parent.left = f;
        f.right = a;
        a.parent = f
    };
    b.RedBlackSet.prototype.insert = function(a) {
        if (this.contains(a)) this.get_(a).key = a;
        else {
            var f = new b.RBnode(this);
            f.key = a;
            a = this.sentinel;
            for (var c = this.root; c != this.sentinel;) a = c, c = 0 > this.compare(f.key, c.key) ? c.left : c.right;
            f.parent = a;
            a == this.sentinel ? this.root = f : 0 > this.compare(f.key, a.key) ? a.left = f : a.right = f;
            f.left = this.sentinel;
            f.right = this.sentinel;
            f.color = !0;
            this.insertFixup(f);
            this.size++
        }
    };
    b.RedBlackSet.prototype.insertFixup = function(a) {
        for (; a != this.sentinel && a != this.root && 1 == a.parent.color;)
            if (a.parent == a.parent.parent.left) {
                var f = a.parent.parent.right;
                1 == f.color ? (a.parent.color = !1, f.color = !1, a.parent.parent.color = !0, a = a.parent.parent) : (a == a.parent.right && (a = a.parent, this.leftRotate(a)), a.parent.color = !1, a.parent.parent.color = !0, a.parent.parent != this.sentinel && this.rightRotate(a.parent.parent))
            } else f = a.parent.parent.left, 1 == f.color ? (a.parent.color = !1, f.color = !1, a.parent.parent.color = !0, a = a.parent.parent) : (a == a.parent.left && (a = a.parent, this.rightRotate(a)), a.parent.color = !1, a.parent.parent.color = !0, a.parent.parent != this.sentinel && this.leftRotate(a.parent.parent));
        this.root.color = !1
    };
    b.RedBlackSet.prototype.delete_ = function(a) {
        var f = a.left == this.sentinel || a.right == this.sentinel ? a : this.successor_(a);
        var c = f.left != this.sentinel ? f.left : f.right;
        c.parent = f.parent;
        f.parent == this.sentinel ? this.root = c : f == f.parent.left ? f.parent.left = c : f.parent.right =
            c;
        f != a && (a.key = f.key);
        0 == f.color && this.deleteFixup(c);
        this.size--
    };
    b.RedBlackSet.prototype.deleteFixup = function(a) {
        for (; a != this.root && 0 == a.color;)
            if (a == a.parent.left) {
                var f = a.parent.right;
                1 == f.color && (f.color = !1, a.parent.color = !0, this.leftRotate(a.parent), f = a.parent.right);
                0 == f.left.color && 0 == f.right.color ? (f.color = !0, a = a.parent) : (0 == f.right.color && (f.left.color = !1, f.color = !0, this.rightRotate(f), f = a.parent.right), f.color = a.parent.color, a.parent.color = !1, f.right.color = !1, this.leftRotate(a.parent),
                    a = this.root)
            } else f = a.parent.left, 1 == f.color && (f.color = !1, a.parent.color = !0, this.rightRotate(a.parent), f = a.parent.left), 0 == f.right.color && 0 == f.left.color ? (f.color = !0, a = a.parent) : (0 == f.left.color && (f.right.color = !1, f.color = !0, this.leftRotate(f), f = a.parent.left), f.color = a.parent.color, a.parent.color = !1, f.left.color = !1, this.rightRotate(a.parent), a = this.root);
        a.color = !1
    };
    b.RedBlackSet.prototype.remove = function(a) {
        a = this.get_(a);
        if (a != this.sentinel) {
            var f = a.key;
            this.delete_(a);
            return f
        }
        return null
    };
    b.RedBlackSet.prototype.removeSwapped =
        function(a, f) {
            this.remove(f)
        };
    b.RedBlackSet.prototype.min = function(a) {
        for (; a.left != this.sentinel;) a = a.left;
        return a
    };
    b.RedBlackSet.prototype.max = function(a) {
        for (; a.right != this.sentinel;) a = a.right;
        return a
    };
    b.RedBlackSet.prototype.successor_ = function(a) {
        if (a.right != this.sentinel) return this.min(a.right);
        for (var f = a.parent; f != this.sentinel && a == f.right;) a = f, f = f.parent;
        return f
    };
    b.RedBlackSet.prototype.predeccessor_ = function(a) {
        if (a.left != this.sentinel) return this.max(a.left);
        for (var f = a.parent; f != this.sentinel &&
            a == f.left;) a = f, f = f.parent;
        return f
    };
    b.RedBlackSet.prototype.successor = function(a) {
        if (0 < this.size) {
            a = this.get_(a);
            if (a == this.sentinel) return null;
            if (a.right != this.sentinel) return this.min(a.right).key;
            for (var f = a.parent; f != this.sentinel && a == f.right;) a = f, f = f.parent;
            return f != this.sentinel ? f.key : null
        }
        return null
    };
    b.RedBlackSet.prototype.predecessor = function(a) {
        if (0 < this.size) {
            a = this.get_(a);
            if (a == this.sentinel) return null;
            if (a.left != this.sentinel) return this.max(a.left).key;
            for (var f = a.parent; f != this.sentinel &&
                a == f.left;) a = f, f = f.parent;
            return f != this.sentinel ? f.key : null
        }
        return null
    };
    b.RedBlackSet.prototype.getMin = function() {
        return this.min(this.root).key
    };
    b.RedBlackSet.prototype.getMax = function() {
        return this.max(this.root).key
    };
    b.RedBlackSet.prototype.get_ = function(a) {
        for (var f = this.root; f != this.sentinel && 0 != this.compare(f.key, a);) f = 0 > this.compare(a, f.key) ? f.left : f.right;
        return f
    };
    b.RedBlackSet.prototype.contains = function(a) {
        return null != this.get_(a).key
    };
    b.RedBlackSet.prototype.getValues = function() {
        var a = [];
        this.forEach(function(f) {
            a.push(f)
        });
        return a
    };
    b.RedBlackSet.prototype.insertAll = function(a) {
        if ("array" == b.typeOf(a))
            for (var f = 0; f < a.length; f++) this.insert(a[f]);
        else if ("function" == b.typeOf(a.forEach)) a.forEach(this.insert, this);
        else if ("function" == b.typeOf(a.getValues))
            for (a = a.getValues(), f = 0; f < a.length; f++) this.insert(a[f]);
        else if ("object" == b.typeOf(a))
            for (f in a) this.insert(a[f])
    };
    b.RedBlackSet.prototype.removeAll = function(a) {
        if ("array" == b.typeOf(a))
            for (var f = 0; f < a.length; f++) this.remove(a[f]);
        else if ("function" == b.typeOf(a.forEach)) a.forEach(this.removeSwapped, this);
        else if ("function" == b.typeOf(a.getValues))
            for (a = a.getValues(), f = 0; f < a.length; f++) this.remove(a[f]);
        else if ("object" == b.typeOf(a))
            for (f in a) this.remove(a[f])
    };
    b.RedBlackSet.prototype.containsAll = function(a) {
        if ("array" == b.typeOf(a)) {
            for (var f = 0; f < a.length; f++)
                if (!this.contains(a[f])) return !1;
            return !0
        }
        if ("function" == b.typeOf(a.forEach)) return a.every(this.contains, this);
        if ("function" == b.typeOf(a.getValues)) {
            a = a.getValues();
            for (f =
                0; f < a.length; f++)
                if (!this.contains(a[f])) return !1;
            return !0
        }
        if ("object" == b.typeOf(a)) {
            for (f in a)
                if (!this.contains(a[f])) return !1;
            return !0
        }
    };
    b.RedBlackSet.prototype.range = function(a, f) {
        var c = [];
        this.traverseFromTo(function(e) {
            c.push(e)
        }, a, f);
        return c
    };
    b.RedBlackSet.prototype.traverse = function(a, f) {
        if (!this.isEmpty())
            for (var c = this.min(this.root); c != this.sentinel && !a.call(f, c.key, this);) c = this.successor_(c)
    };
    b.RedBlackSet.prototype.traverseFrom = function(a, f, c) {
        if (!this.isEmpty())
            for (f = this.get_(f); f !=
                this.sentinel && !a.call(c, f.key, this);) f = this.successor_(f)
    };
    b.RedBlackSet.prototype.traverseTo = function(a, f, c) {
        if (!this.isEmpty()) {
            var e = this.min(this.root);
            for (f = this.get_(f); e != f && !a.call(c, e.key, this);) e = this.successor_(e)
        }
    };
    b.RedBlackSet.prototype.traverseFromTo = function(a, f, c, e) {
        if (!this.isEmpty())
            for (f = this.get_(f), c = this.get_(c); f != c && !a.call(e, f.key, this);) f = this.successor_(f)
    };
    b.RedBlackSet.prototype.traverseBackwards = function(a, f) {
        if (!this.isEmpty())
            for (var c = this.max(this.root); c != this.sentinel &&
                !a.call(f, c.key, this);) c = this.predeccessor_(c)
    };
    b.RedBlackSet.prototype.forEach = function(a, f) {
        if (!this.isEmpty())
            for (var c = this.min(this.root); c != this.sentinel; c = this.successor_(c)) a.call(f, c.key, c.key, this)
    };
    b.RedBlackSet.prototype.some = function(a, f) {
        if (this.isEmpty()) return !1;
        for (var c = this.min(this.root); c != this.sentinel; c = this.successor_(c))
            if (a.call(f, c.key, c.key, this)) return !0;
        return !1
    };
    b.RedBlackSet.prototype.every = function(a, f) {
        if (this.isEmpty()) return !1;
        for (var c = this.min(this.root); c != this.sentinel; c =
            this.successor_(c))
            if (!a.call(f, c.key, c.key, this)) return !1;
        return !0
    };
    b.RedBlackSet.prototype.map = function(a, f) {
        var c = [];
        if (this.isEmpty()) return c;
        for (var e = this.min(this.root); e != this.sentinel; e = this.successor_(e)) c.push(a.call(f, e.key, e.key, this));
        return c
    };
    b.RedBlackSet.prototype.filter = function(a, f) {
        var c = [];
        if (this.isEmpty()) return c;
        for (var e = this.min(this.root); e != this.sentinel; e = this.successor_(e)) a.call(f, e.key, e.key, this) && c.push(e.key);
        return c
    };
    b.RedBlackSet.prototype.getCount = function() {
        return this.size
    };
    b.RedBlackSet.prototype.isEmpty = function() {
        return 0 == this.size
    };
    b.RedBlackSet.prototype.isSubsetOf = function(a) {
        var f = b.getCount(a);
        if (this.getCount() > f) return !1;
        f = 0;
        if (this.isEmpty()) return !0;
        for (var c = this.min(this.root); c != this.sentinel; c = this.successor_(c)) b.contains.call(a, a, c.key) && f++;
        return f == this.getCount()
    };
    b.RedBlackSet.prototype.intersection = function(a) {
        var f = new b.RedBlackSet(this.compare);
        if (this.isEmpty()) return f;
        for (var c = this.min(this.root); c != this.sentinel; c = this.successor_(c)) a.contains.call(a,
            c.key, c.key, this) && f.insert(c.key);
        return f
    };
    d.RedBlackSet = class extends d.DefendedBase {
        constructor(a) {
            super();
            this._rbSet = new b.RedBlackSet(a);
            this._enableQueue = !1;
            this._queueInsert = new Set;
            this._queueRemove = new Set
        }
        Add(a) {
            this._enableQueue ? this._rbSet.contains(a) ? this._queueRemove.delete(a) : this._queueInsert.add(a) : this._rbSet.insert(a)
        }
        Remove(a) {
            this._enableQueue ? this._rbSet.contains(a) ? this._queueRemove.add(a) : this._queueInsert.delete(a) : this._rbSet.remove(a)
        }
        Has(a) {
            return this._enableQueue ? this._queueInsert.has(a) ?
                !0 : !this._queueRemove.has(a) && this._rbSet.contains(a) : this._rbSet.contains(a)
        }
        Clear() {
            this._rbSet.clear();
            this._queueInsert.clear();
            this._queueRemove.clear()
        }
        toArray() {
            if (this._enableQueue) throw Error("cannot be used in queueing mode");
            return this._rbSet.getValues()
        }
        GetSize() {
            return this._rbSet.getCount() + this._queueInsert.size - this._queueRemove.size
        }
        IsEmpty() {
            return 0 === this.GetSize()
        }
        Front() {
            if (this.IsEmpty()) throw Error("empty set");
            if (this._enableQueue) throw Error("cannot be used in queueing mode");
            const a = this._rbSet;
            return a.min(a.root).key
        }
        Shift() {
            if (this.IsEmpty()) throw Error("empty set");
            if (this._enableQueue) throw Error("cannot be used in queueing mode");
            const a = this.Front();
            this.Remove(a);
            return a
        }
        SetQueueingEnabled(a) {
            a = !!a;
            if (this._enableQueue !== a && (this._enableQueue = a, !a)) {
                for (const f of this._queueRemove) this._rbSet.remove(f);
                this._queueRemove.clear();
                for (const f of this._queueInsert) this._rbSet.insert(f);
                this._queueInsert.clear()
            }
        }
        ForEach(a) {
            this._rbSet.forEach(a)
        }* values() {
            if (!this.IsEmpty()) {
                var a =
                    this._rbSet;
                for (let f = a.min(a.root); f != a.sentinel; f = a.successor_(f)) yield f.key
            }
        } [Symbol.iterator]() {
            return this.values()
        }
    }
}
"use strict";
{
    const d = self.C3;
    d.PromiseThrottle = class {
        constructor(b = d.hardwareConcurrency) {
            this._maxParallel = b;
            this._queue = [];
            this._activeCount = 0
        }
        Add(b) {
            return new Promise((a, f) => {
                this._queue.push({
                    func: b,
                    resolve: a,
                    reject: f
                });
                this._MaybeStartNext()
            })
        }
        _FindInQueue(b) {
            for (let a = 0, f = this._queue.length; a < f; ++a)
                if (this._queue[a].func === b) return a;
            return -1
        }
        RemoveAndResolve(b, a) {
            b = this._FindInQueue(b);
            if (-1 === b) throw Error("cannot find promise to resolve");
            this._queue[b].resolve(a);
            this._queue.splice(b, 1)
        }
        RemoveAndReject(b,
            a) {
            b = this._FindInQueue(b);
            if (-1 === b) throw Error("cannot find promise to reject");
            this._queue[b].reject(a);
            this._queue.splice(b, 1)
        }
        async _MaybeStartNext() {
            if (this._queue.length && !(this._activeCount >= this._maxParallel)) {
                this._activeCount++;
                var b = this._queue.shift();
                try {
                    const a = await b.func();
                    b.resolve(a)
                } catch (a) {
                    b.reject(a)
                }
                this._activeCount--;
                this._MaybeStartNext()
            }
        }
        static async Batch(b, a) {
            const f = [];
            let c = !1;
            const e = async h => {
                for (;
                    (h = a.pop()) && !c;) try {
                    f.push(await h())
                } catch (l) {
                    throw c = !0, l;
                }
            }, g = [];
            for (; b--;) g.push(e());
            await Promise.all(g);
            return f
        }
    }
}
"use strict";
{
    const d = self.C3;
    d.RateLimiter = class {
        constructor(b, a, f) {
            this._callback = b;
            this._interval = a;
            this._intervalOnBattery = f || 2 * a;
            this._timerId = -1;
            this._lastCallTime = -Infinity;
            this._timerCallFunc = () => this._OnTimer();
            this._canRunImmediate = this._ignoreReset = !1;
            this._callbackArguments = null
        }
        SetCanRunImmediate(b) {
            this._canRunImmediate = !!b
        }
        _GetInterval() {
            return "undefined" !== typeof d.Battery && d.Battery.IsOnBatteryPower() ? this._intervalOnBattery : this._interval
        }
        Call(...b) {
            if (-1 === this._timerId) {
                this._callbackArguments =
                    b;
                b = d.FastGetDateNow();
                var a = b - this._lastCallTime,
                    f = this._GetInterval();
                a >= f && this._canRunImmediate ? (this._lastCallTime = b, this._RunCallback()) : this._timerId = self.setTimeout(this._timerCallFunc, Math.max(f - a, 4))
            }
        }
        _RunCallback() {
            this._ignoreReset = !0;
            const b = this._callbackArguments;
            this._callbackArguments = null;
            b ? this._callback(...b) : this._callback();
            this._ignoreReset = !1
        }
        Reset() {
            this._ignoreReset || (this._CancelTimer(), this._callbackArguments = null, this._lastCallTime = d.FastGetDateNow())
        }
        _OnTimer() {
            this._timerId = -1;
            this._lastCallTime = d.FastGetDateNow();
            this._RunCallback()
        }
        _CancelTimer() {
            -1 !== this._timerId && (self.clearTimeout(this._timerId), this._timerId = -1)
        }
        Release() {
            this._CancelTimer();
            this._timerCallFunc = this._callbackArguments = this._callback = null
        }
    }
}
"use strict";
{
    const d = self.C3;
    d.SVGRasterManager = class {
        constructor() {
            this._images = new Map;
            this._allowNpotSurfaces = !1;
            this._redrawCallback = this._releaseResultCallback = this._rasterAtSizeCallback = this._getBaseSizeCallback = null
        }
        SetNpotSurfaceAllowed(b) {
            this._allowNpotSurfaces = !!b
        }
        IsNpotSurfaceAllowed() {
            return this._allowNpotSurfaces
        }
        SetGetBaseSizeCallback(b) {
            this._getBaseSizeCallback = b
        }
        GetBaseSize(b) {
            if (!this._getBaseSizeCallback) throw Error("no get base size callback set");
            return this._getBaseSizeCallback(b)
        }
        SetRasterAtSizeCallback(b) {
            this._rasterAtSizeCallback =
                b
        }
        RasterAtSize(b, a, f, c, e, g) {
            if (!this._rasterAtSizeCallback) throw Error("no raster at size callback set");
            return this._rasterAtSizeCallback(b, a, f, c, e, g)
        }
        SetReleaseResultCallback(b) {
            this._releaseResultCallback = b
        }
        ReleaseResult(b) {
            if (!this._releaseResultCallback) throw Error("no release result callback set");
            this._releaseResultCallback(b)
        }
        SetRedrawCallback(b) {
            this._redrawCallback = b
        }
        Redraw() {
            if (!this._redrawCallback) throw Error("no redraw callback set");
            this._redrawCallback()
        }
        AddImage(b) {
            let a = this._images.get(b);
            a || (a = d.New(d.SVGRasterImage, this, b), this._images.set(b, a));
            a.IncReference();
            return a
        }
        _RemoveImage(b) {
            this._images.delete(b.GetDataSource())
        }
        OnTexturesChanged() {
            for (const b of this._images.values()) b.ReleaseRasterizedResult(), b.ForceRasterAgain()
        }
    }
}
"use strict";
{
    const d = self.C3;
    d.SVGRasterImage = class {
        constructor(b, a) {
            this._manager = b;
            this._dataSource = a;
            this._baseHeight = this._baseWidth = this._refCount = 0;
            this._getBaseSizePromise = this._manager.GetBaseSize(a).then(f => {
                this._baseWidth = f[0];
                this._baseHeight = f[1];
                this._manager.Redraw()
            }).catch(f => {
                console.error("[SVG] Error loading SVG: ", f);
                this._hadError = !0;
                this._manager.Redraw()
            });
            this._rasterImageHeight = this._rasterImageWidth = this._rasterSurfaceHeight = this._rasterSurfaceWidth = 0;
            this._isRasterizing = !1;
            this._rasterizedResult =
                null;
            this._hadError = this._forceRaster = !1
        }
        Release() {
            if (0 >= this._refCount) throw Error("already released");
            this._refCount--;
            0 === this._refCount && this._Release()
        }
        ReleaseRasterizedResult() {
            this._rasterizedResult && (this._manager.ReleaseResult(this._rasterizedResult), this._rasterizedResult = null)
        }
        _Release() {
            this.ReleaseRasterizedResult();
            this._manager._RemoveImage(this);
            this._manager = null
        }
        GetDataSource() {
            return this._dataSource
        }
        IncReference() {
            this._refCount++
        }
        HasReferences() {
            return 0 < this._refCount
        }
        GetRasterizedResult() {
            return this._rasterizedResult
        }
        ForceRasterAgain() {
            this._forceRaster = !0
        }
        async StartRasterForSize(b, a, f) {
            if (0 !== a && 0 !== f && !this._hadError && !this._isRasterizing) {
                var c = d.nextHighestPowerOfTwo(Math.ceil(a)),
                    e = d.nextHighestPowerOfTwo(Math.ceil(f)),
                    g = Math.max(c, e);
                2048 < g && (g = 2048 / g, a *= g, f *= g, c = Math.min(Math.ceil(c * g), 2048), e = Math.min(Math.ceil(e * g), 2048));
                a < c && f < e && (f = a / f, c / e > f ? (a = e * f, f = e) : (a = c, f = c / f));
                this._manager.IsNpotSurfaceAllowed() && (c = Math.ceil(a), e = Math.ceil(f));
                c <= this._rasterSurfaceWidth && e <= this._rasterSurfaceHeight && !this._forceRaster || (this._isRasterizing = !0, this._rasterSurfaceWidth = c, this._rasterSurfaceHeight = e, b = await this._manager.RasterAtSize(this._dataSource, b, this._rasterSurfaceWidth, this._rasterSurfaceHeight, a, f), this._manager && (this.ReleaseRasterizedResult(), this._rasterizedResult = b, this._rasterImageWidth = a, this._rasterImageHeight = f, this._forceRaster = this._isRasterizing = !1, this._manager.Redraw()))
            }
        }
        WhenBaseSizeReady() {
            return this._getBaseSizePromise
        }
        GetBaseWidth() {
            return this._baseWidth
        }
        GetBaseHeight() {
            return this._baseHeight
        }
        GetRasterWidth() {
            return this._rasterImageWidth
        }
        GetRasterHeight() {
            return this._rasterImageHeight
        }
        HadError() {
            return this._hadError
        }
    }
}
"use strict";
{
    const d = self.C3;
    d.UTF8_BOM = "\ufeff";
    const b = new Set([..."0123456789"]);
    d.IsNumericChar = function(m) {
        return b.has(m)
    };
    const a = new Set([..." \t\n\r\u00a0\u0085\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u200b\u2028\u2029\u202f\u205f\u3000"]);
    d.IsWhitespaceChar = function(m) {
        return a.has(m)
    };
    d.FilterWhitespace = function(m) {
        return [...m].filter(p => !d.IsWhitespaceChar(p)).join("")
    };
    d.IsStringAllWhitespace = function(m) {
        for (const p of m)
            if (!d.IsWhitespaceChar(p)) return !1;
        return !0
    };
    d.IsUnprintableChar =
        function(m) {
            return 1 === m.length && 32 > m.charCodeAt(0)
        };
    d.FilterUnprintableChars = function(m) {
        return [...m].filter(p => !d.IsUnprintableChar(p)).join("")
    };
    const f = new Set([..."0123456789.+-e"]);
    d.IsStringNumber = function(m) {
        m = m.trim();
        if (!m.length) return !1;
        let p = m.charAt(0);
        if ("-" !== p && !b.has(p)) return !1;
        for (let t of m)
            if (!f.has(t)) return !1;
        return !0
    };
    d.RemoveTrailingDigits = function(m) {
        let p = m.length;
        for (; 0 < p;) {
            let t = m.charAt(p - 1);
            if (!d.IsNumericChar(t)) break;
            --p
        }
        return m.substr(0, p)
    };
    d.IncrementNumberAtEndOf =
        function(m) {
            let p = d.RemoveTrailingDigits(m);
            m = (m = m.substr(p.length)) ? (parseInt(m, 10) + 1).toString() : "2";
            return p + m
        };
    const c = new Map([
        ["&", "&amp;"],
        ["<", "&lt;"],
        [">", "&gt;"],
        ['"', "&quot;"],
        ["'", "&#39;"]
    ]);

    function e(m) {
        return c.get(m)
    }
    const g = /[&<>"']/g;
    d.EscapeHTML = function(m) {
        return m.replace(g, e)
    };
    d.EscapeJS = function(m) {
        m = d.ReplaceAll(m, "\\", "\\\\");
        m = d.ReplaceAll(m, '"', '\\"');
        m = d.ReplaceAll(m, "\t", "\\t");
        m = d.ReplaceAll(m, "\r", "");
        return d.ReplaceAll(m, "\n", "\\n")
    };
    d.EscapeXML = function(m) {
        m = d.ReplaceAll(m,
            "&", "&amp;");
        m = d.ReplaceAll(m, "<", "&lt;");
        m = d.ReplaceAll(m, ">", "&gt;");
        return d.ReplaceAll(m, '"', "&quot;")
    };
    const h = /[-[\]{}()*+?.,\\^$|#\s]/g;
    d.EscapeRegex = function(m) {
        return m.replace(h, "\\$&")
    };
    d.FindAll = function(m, p, t = !1) {
        if (!p) return [];
        t || (m = m.toLowerCase(), p = p.toLowerCase());
        t = p.length;
        var q = 0;
        let r = [];
        for (; - 1 < (q = m.indexOf(p, q));) r.push(q), q += t;
        return r
    };
    d.ReplaceAll = function(m, p, t) {
        return m.replaceAll(p, () => t)
    };
    d.ReplaceAllCaseInsensitive = function(m, p, t) {
        return m.replace(new RegExp(d.EscapeRegex(p),
            "gi"), () => t)
    };
    d.SetElementContent = function(m, p) {
        "string" === typeof p ? m.textContent = p : p.isPlainText() ? m.textContent = p.toString() : (m.innerHTML = p.toHTML(), p instanceof d.BBString && p.attachLinkHandlers(m))
    };
    d.StringLikeEquals = function(m, p) {
        return m instanceof d.HtmlString || m instanceof d.BBString ? m.equals(p) : p instanceof d.HtmlString || p instanceof d.BBString ? p.equals(m) : m === p
    };
    d.StringSubstitute = function(m, ...p) {
        let t = m;
        for (let q = 0, r = p.length; q < r; ++q) {
            const u = `{${q}}`;
            if (!m.includes(u)) throw Error(`missing placeholder '${u}' in string substitution`);
            t = t.replace(u, p[q].toString())
        }
        return t
    };
    d.StringSubstituteAllowMissing = function(m, ...p) {
        let t = m,
            q = -1,
            r = -1;
        for (let u = 0, x = p.length; u < x; ++u) {
            const y = `{${u}}`;
            m.includes(y) ? (r = u, t = t.replace(y, p[u].toString())) : -1 === q && (q = u)
        }
        if (0 <= q && 0 <= r && q < r) throw Error(`missing placeholder '${q}' in string substitution`);
        return t
    };
    d.StringSubstituteMap = function(m, p) {
        for (let [t, q] of Object.entries(p)) m = m.replaceAll(t, q.toString());
        return m
    };
    d.SortAZCaseInsensitive = function(m, p) {
        m = m.toLowerCase();
        p = p.toLowerCase();
        return m >
            p ? 1 : m < p ? -1 : 0
    };
    d.FormatDataSize = function(m, p) {
        p = "common." + (p ? "dataRates" : "dataSizes") + ".";
        const t = self.langSub;
        if (1024 > m) return t(p + "bytes", m);
        if (1048576 > m) return m /= 1024, m = 10 > m ? Math.round(10 * m) / 10 : Math.round(m), t(p + "kilobytes", m);
        if (1073741824 > m) return m /= 1048576, m = 10 > m ? Math.round(10 * m) / 10 : Math.round(m), t(p + "megabytes", m);
        if (1099511627776 > m) return m /= 1073741824, m = 10 > m ? Math.round(10 * m) / 10 : Math.round(m), t(p + "gigabytes", m);
        m /= 1099511627776;
        m = 10 > m ? Math.round(10 * m) / 10 : Math.round(m);
        return t(p + "terabytes",
            m)
    };
    const l = {
        approximate: !1,
        days: !0,
        hours: !0,
        minutes: !0,
        seconds: !0
    };
    d.FormatTime = function(m, p) {
        p = Object.assign({}, l, p);
        d.Lang.PushContext("common.time");
        const t = [],
            q = self.lang,
            r = self.langPluralSub;
        if (p.days) {
            var u = Math.floor(m / 86400);
            0 < u && (m -= 86400 * u, t.push(r(".days", null, u)))
        }
        p.hours && (u = Math.floor(m / 3600), 0 < u || t.length) && (m -= 3600 * u, t.push(r(".hours", null, u)));
        p.minutes && (u = Math.floor(m / 60), 0 < u || t.length || !p.seconds) && (m -= 60 * u, t.push(r(".minutes", null, u)));
        p.seconds && t.push(r(".seconds", null, Math.floor(m %
            60)));
        m = (p.approximate ? q(".approx-prefix") : "") + t.join(q(".separator"));
        d.Lang.PopContext();
        return m
    };
    d.ZeroPad = function(m, p) {
        let t = 0 > m ? "-" : "";
        m = Math.abs(m);
        m = m.toString();
        p -= m.length;
        for (let q = 0; q < p; ++q) t += "0";
        return t + m
    };
    d.StringToTitleCase = function(m) {
        return m.toLowerCase().replace(/\b\w/g, p => p.toUpperCase())
    };
    d.CompareVersionStrings = function(m, p) {
        m = m.split(".").map(t => t.trim());
        p = p.split(".").map(t => t.trim());
        d.resizeArray(m, 4, "0");
        d.resizeArray(p, 4, "0");
        m = m.map(t => parseInt(t, 10));
        p = p.map(t => parseInt(t,
            10));
        for (let t = 0; 4 > t; ++t) {
            const q = m[t] - p[t];
            if (0 !== q) return 0 > q ? -1 : 1
        }
        return 0
    };
    d.CreateGUID = function() {
        return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, m => {
            const p = Math.floor(16 * Math.random());
            return ("x" === m ? p : p & 3 | 8).toString(16)
        })
    };
    d.StringHammingDistance = function(m, p) {
        if (m.length !== p.length) throw Error("strings must be same length");
        let t = 0;
        for (let q = 0, r = m.length; q < r; ++q) m.charAt(q) !== p.charAt(q) && ++t;
        return t
    };
    d.StringLevenshteinDistance = function(m, p) {
        if (0 === m.length) return p.length;
        if (0 === p.length) return m.length;
        let t, q, r, u;
        if (m.length > p.length) {
            var x = m;
            m = p;
            p = x
        }
        u = Array(m.length + 1);
        for (x = 0; x <= m.length; x++) u[x] = x;
        for (x = 1; x <= p.length; x++) {
            q = x;
            for (t = 1; t <= m.length; t++) r = p[x - 1] === m[t - 1] ? u[t - 1] : Math.min(u[t - 1] + 1, Math.min(q + 1, u[t] + 1)), u[t - 1] = q, q = r;
            u[m.length] = q
        }
        return u[m.length]
    }
}
"use strict";
{
    const d = self.C3,
        b = new Map([
            ["b", "strong"],
            ["i", "em"],
            ["s", "s"],
            ["u", "u"],
            ["sub", "sub"],
            ["sup", "sup"],
            ["small", "small"],
            ["mark", "mark"],
            ["a1", "a"],
            ["a2", "a"],
            ["a3", "a"],
            ["a4", "a"],
            ["a5", "a"],
            ["a6", "a"],
            ["a7", "a"],
            ["a8", "a"],
            ["a9", "a"],
            ["bad", ["span", "bbCodeBad"]],
            ["good", ["span", "bbCodeGood"]],
            ["info", ["span", "bbCodeInfo"]],
            ["h1", ["span", "bbCodeH1"]],
            ["h2", ["span", "bbCodeH2"]],
            ["h3", ["span", "bbCodeH3"]],
            ["h4", ["span", "bbCodeH4"]],
            ["item", ["span", "bbCodeItem"]]
        ]),
        a = /\[(\/?)([a-zA-Z0-9]+)\]/g,
        f = /\[(\/?)([^\[]*?)\]/g;
    let c = null,
        e = 0;

    function g(l, m, p) {
        var t = b.get(p);
        if (t) {
            if ("string" === typeof t) {
                if ("a" !== t || m) return "<" + m + t + ">";
                m = parseInt(p.substring(1), 10) - 1;
                if (0 > m || m >= c.length) throw Error("invalid bbcode link substitution");
                t = c[m];
                if ("string" === typeof t) return `<a href="${c[m]}">`;
                if ("function" === typeof t) return `<a class="bblink${m}">`;
                throw new TypeError("invalid bbcode link action");
            }
            if (Array.isArray(t)) return l = t[0], t = t[1], m ? "</" + l + ">" : `<${l} class="${t}">`
        } else return "class" === p ? m ? "</span>" : `<span class="bbclass${e++}">` :
            l
    }
    const h = /\n/g;
    d.BBString = class {
        constructor(l, m) {
            this._bbstr = m && m.noEscape ? l : d.EscapeHTML(l);
            this._htmlstr = "";
            this._convertLineBreaks = !1;
            this._linkActions = [];
            if (m && (this._convertLineBreaks = !!m.convertLineBreaks, m.links)) {
                if (9 < m.links.length) throw Error("too many links");
                this._linkActions = m.links
            }
            this._hasAnyBBtags = this._bbstr.includes("[");
            this._needsLineBreakConversion = this._convertLineBreaks && this._bbstr.includes("\n");
            this._isPlain = !this._hasAnyBBtags && !this._needsLineBreakConversion && !this._bbstr.includes("&");
            this._hasParsedFragments = !1;
            this._fragments = []
        }
        toString() {
            return this._bbstr
        }
        valueOf() {
            return this._bbstr
        }
        isPlainText() {
            return this._isPlain
        }
        toPlainText() {
            return this._hasAnyBBtags ? this._bbstr.replace(a, "") : this._bbstr
        }
        toHTML() {
            if (this._isPlain) return this._bbstr;
            if (!this._htmlstr && this._bbstr) {
                let l = this._bbstr;
                this._hasAnyBBtags && (e = 0, c = this._linkActions, l = l.replace(a, g), c = null);
                this._needsLineBreakConversion && (l = l.replace(h, "<br>"));
                this._htmlstr = l
            }
            return this._htmlstr
        }
        attachLinkHandlers(l) {
            if (this._linkActions.length)
                for (let m =
                        0, p = this._linkActions.length; m < p; ++m) {
                    const t = this._linkActions[m];
                    if ("function" !== typeof t) continue;
                    const q = l.querySelector(".bblink" + m);
                    if (!q) throw Error("unable to attach BBString link handler");
                    q.onclick = t
                }
        }
        equals(l) {
            return l instanceof d.HtmlString ? this.toHTML() === l.toHTML() : l instanceof d.BBString ? this._bbstr === l._bbstr : this._bbstr === l
        }
        toFragmentList() {
            if (this._hasParsedFragments) return this._fragments;
            const l = this._bbstr,
                m = [];
            let p = f.lastIndex = 0;
            for (var t; null !== (t = f.exec(l));) {
                var q = t.index;
                if (0 < q && "\\" === l.charAt(q - 1)) continue;
                var r = t[0],
                    u = t[1];
                t = t[2];
                const x = l.substring(p, q);
                p = q + r.length;
                x && this._fragments.push({
                    text: x,
                    styles: m.slice(0)
                });
                if (t)
                    if (u)
                        for (t = t.toLowerCase(), q = m.length - 1; 0 <= q; --q) {
                            if (m[q].tag === t) {
                                m.splice(q, 1);
                                break
                            }
                        } else q = t, r = null, u = t.indexOf("="), -1 !== u ? (q = t.substring(0, u).toLowerCase(), r = t.substring(u + 1)) : q = q.toLowerCase(), m.push({
                            tag: q,
                            param: r
                        })
            }
            p < l.length && this._fragments.push({
                text: l.substring(p),
                styles: m.slice(0)
            });
            for (const x of this._fragments) x.text = this._ProcessBBCodeEscapeSequences(x.text);
            this._hasParsedFragments = !0;
            return this._fragments
        }
        _ProcessBBCodeEscapeSequences(l) {
            l = d.ReplaceAll(l, "\\[", "[");
            return d.ReplaceAll(l, "\\\\", "\\")
        }
        static StripTags(l) {
            return d.New(d.BBString, l, {
                noEscape: !0
            }).toPlainText()
        }
        static StripAnyTags(l) {
            return l.replace(f, "")
        }
    }
}
"use strict";
{
    const d = self.C3;
    d.WordWrap = class {
        constructor() {
            this._lines = []
        }
        GetLines() {
            return this._lines
        }
        GetLineCount() {
            return this._lines.length
        }
        _MeasureLine(b, a) {
            let f = 0,
                c = 0,
                e = 0,
                g = 0;
            for (const h of b) - 1 === h.width && (b = a(h.text, h.styles), h.width = b.width, h.height = b.height, h.fontBoundingBoxAscent = b.fontBoundingBoxAscent || 0, h.fontBoundingBoxDescent = b.fontBoundingBoxDescent || 0), f += h.width, c = Math.max(c, h.height), e = Math.max(e, h.fontBoundingBoxAscent), g = Math.max(g, h.fontBoundingBoxDescent);
            return {
                width: f,
                height: c,
                fontBoundingBoxAscent: e,
                fontBoundingBoxDescent: g
            }
        }
        _AddLine(b, a, f, c, e) {
            this._lines.push({
                fragments: b,
                width: a,
                height: f,
                fontBoundingBoxAscent: c,
                fontBoundingBoxDescent: e
            })
        }
        WordWrap(b, a, f, c, e) {
            "string" === typeof b && (b = [{
                text: b,
                styles: []
            }]);
            d.clearArray(this._lines);
            if (!(!b.length || 1 === b.length && !b[0].text.length || 2 > f)) {
                if (1 === b.length) {
                    var g = b[0];
                    const h = g.text;
                    g = g.styles;
                    if (100 >= h.length && !h.includes("\n")) {
                        let {
                            width: l,
                            height: m,
                            fontBoundingBoxAscent: p,
                            fontBoundingBoxDescent: t
                        } = a(h, g);
                        l += e;
                        p = p || 0;
                        t = t || 0;
                        if (l <= f) {
                            this._AddLine([{
                                text: h,
                                styles: g,
                                width: l,
                                height: m,
                                fontBoundingBoxAscent: p,
                                fontBoundingBoxDescent: t
                            }], l, m, p, t);
                            return
                        }
                    }
                }
                if ("word" === c) c = this._TokeniseWords(b);
                else {
                    c = [];
                    for (const h of b) d.appendArray(c, [...h.text].map(l => [{
                        text: l,
                        styles: h.styles
                    }]))
                }
                this._WrapText(c, a, f, e)
            }
        }
        _TokeniseWords(b) {
            const a = [];
            let f = [],
                c = !1;
            for (const g of b) {
                var e = g.text;
                b = g.styles;
                for (const h of e) "\n" === h ? (0 < f.length && a.push(f), a.push([{
                    text: "\n",
                    styles: b
                }]), f = []) : 0 === f.length ? (f.push({
                    text: h,
                    styles: b
                }), c = d.IsWhitespaceChar(h)) : (e = d.IsWhitespaceChar(h),
                    e === c ? (e = f[f.length - 1], e.styles === b ? e.text += h : f.push({
                        text: h,
                        styles: b
                    })) : (a.push(f), f = [], f.push({
                        text: h,
                        styles: b
                    }), c = e))
            }
            0 < f.length && a.push(f);
            return a
        }
        _CopyLine(b) {
            return b.map(a => ({
                text: a.text,
                styles: a.styles,
                width: a.width,
                height: a.height,
                fontBoundingBoxAscent: a.fontBoundingBoxAscent,
                fontBoundingBoxDescent: a.fontBoundingBoxDescent
            }))
        }
        _AddWordToLine(b, a) {
            var f = b.length ? b[b.length - 1] : null;
            let c = 0;
            f && a[0].styles === f.styles && (f.text += a[0].text, f.width = -1, f.height = -1, f.fontBoundingBoxAscent = -1, f.fontBoundingBoxDescent = -1, c = 1);
            for (f = a.length; c < f; ++c) {
                const e = a[c];
                b.push({
                    text: e.text,
                    styles: e.styles,
                    width: -1,
                    height: -1,
                    fontBoundingBoxAscent: -1,
                    fontBoundingBoxDescent: -1
                })
            }
        }
        _WrapText(b, a, f, c) {
            let e = [],
                g = 0,
                h = 0,
                l = 0;
            var m = 0;
            for (const p of b) {
                if (1 === p.length && "\n" === p[0].text) {
                    0 === h && (m = a(" ", p[0].styles), h = m.height, l = m.fontBoundingBoxAscent || 0, m = m.fontBoundingBoxDescent || 0);
                    this._AddLine(e, g, h, l, m);
                    e = [];
                    m = l = h = g = 0;
                    continue
                }
                b = this._CopyLine(e);
                this._AddWordToLine(b, p);
                const t = this._MeasureLine(b, a),
                    q = t.width;
                q >= f ? (0 < e.length &&
                    this._AddLine(e, g, h, l, m), e = [], d.IsStringAllWhitespace(p[0].text) ? m = l = h = g = 0 : (this._AddWordToLine(e, p), m = this._MeasureLine(e, a), g = m.width, h = m.height, l = m.fontBoundingBoxAscent, m = m.fontBoundingBoxDescent)) : (e = b, g = q, h = t.height, l = t.fontBoundingBoxAscent, m = t.fontBoundingBoxDescent)
            }
            0 < e.length && this._AddLine(e, g, h, l, m);
            this._TrimLinesTrailingWhitespace(a, c)
        }
        _TrimLinesTrailingWhitespace(b, a) {
            for (const c of this._lines) {
                const e = c.fragments;
                if (!e.length) continue;
                let g = e[e.length - 1];
                var f = g.text;
                const h = f.trimEnd();
                if (!h) c.width -= g.width, e.pop();
                else if (h.length < f.length) {
                    f = b(h, g.styles).width;
                    const l = g.width - f;
                    g.width = f;
                    g.text = h;
                    c.width -= l
                }
                0 !== a && 0 < e.length && (g = e[e.length - 1], g.width += a, c.width += a)
            }
        }
        Clear() {
            d.clearArray(this._lines)
        }
        GetMaxLineWidth() {
            return this._lines.reduce((b, a) => Math.max(b, a.width), 0)
        }
        GetTotalLineHeight() {
            return this._lines.reduce((b, a) => b + a.height, 0)
        }
    }
}
"use strict";
self.C3.Gfx = {
    AreMat4sEqual(d, b) {
        return d[0] === b[0] && d[1] === b[1] && d[2] === b[2] && d[3] === b[3] && d[4] === b[4] && d[5] === b[5] && d[6] === b[6] && d[7] === b[7] && d[8] === b[8] && d[9] === b[9] && d[10] === b[10] && d[11] === b[11] && d[12] === b[12] && d[13] === b[13] && d[14] === b[14] && d[15] === b[15]
    }
};
"use strict";
{
    const d = self.C3,
        b = [0, 0, 0, 0, 0, 0, 0, 0],
        a = self.glMatrix,
        f = a.vec3,
        c = a.mat4,
        e = f.fromValues(0, 0, 0);
    d.Gfx.RendererBase = class {
        constructor() {
            this._height = this._width = 0;
            this._cam = f.fromValues(0, 0, 100);
            this._look = f.fromValues(0, 0, 0);
            this._up = f.fromValues(0, 1, 0);
            this._worldScale = f.fromValues(1, 1, 1);
            this._matP = c.create();
            this._matMV = c.create();
            this._lastMV = c.create();
            this._allShaderPrograms = [];
            this._shaderProgramsByName = new Map;
            this._spSmoothLineFill = this._spSmoothEllipseOutline = this._spSmoothEllipseFill = this._spHardEllipseOutline =
                this._spHardEllipseFill = this._spLinearGradientFill = this._spColorFill = this._spTilemapFill = this._spPoints = this._spTextureFill = null;
            this._stateGroups = new Map;
            this._currentStateGroup = null;
            this._blendModeTable = [];
            this._namedBlendModeMap = new Map;
            this._frameNumber = this._currentZ = this._baseZ = 0;
            this._enableMipmaps = !0
        }
        FillIndexBufferData(g) {
            let h = 0,
                l = g.length,
                m = 0;
            for (; h < l;) g[h++] = m, g[h++] = m + 1, g[h++] = m + 2, g[h++] = m, g[h++] = m + 2, g[h++] = m + 3, m += 4
        }
        _ClearState() {
            this._currentZ = this._baseZ = 0;
            this._spSmoothLineFill = this._spSmoothEllipseOutline =
                this._spSmoothEllipseFill = this._spHardEllipseOutline = this._spHardEllipseFill = this._spLinearGradientFill = this._spColorFill = this._spTilemapFill = this._spPoints = this._spTextureFill = null;
            this._ClearAllShaderPrograms()
        }
        InitState() {
            this._ClearState();
            this._currentStateGroup = null
        }
        OnDeviceOrContextLost() {
            for (const g of this._allShaderPrograms) g.Release();
            this._ClearState()
        }
        Project(g, h, l, m, p) {
            const t = this._matMV,
                q = this._matP;
            for (let r = 0, u = b.length; r < u; ++r) b[r] = 0;
            b[0] = t[0] * g + t[4] * h + t[12];
            b[1] = t[1] * g + t[5] * h +
                t[13];
            b[2] = t[2] * g + t[6] * h + t[14];
            b[3] = t[3] * g + t[7] * h + t[15];
            b[4] = q[0] * b[0] + q[4] * b[1] + q[8] * b[2] + q[12] * b[3];
            b[5] = q[1] * b[0] + q[5] * b[1] + q[9] * b[2] + q[13] * b[3];
            b[6] = q[2] * b[0] + q[6] * b[1] + q[10] * b[2] + q[14] * b[3];
            b[7] = -b[2];
            0 !== b[7] && (b[7] = 1 / b[7], b[4] *= b[7], b[5] *= b[7], b[6] *= b[7], p[0] = (.5 * b[4] + .5) * l, p[1] = (.5 * b[5] + .5) * m)
        }
        GetWidth() {
            return this._width
        }
        GetHeight() {
            return this._height
        }
        GetNearZ() {
            return 1
        }
        GetFarZ() {
            return 1E4
        }
        SetCameraXYZ(g, h, l) {
            this._cam[0] = g * this._worldScale[0];
            this._cam[1] = h * this._worldScale[1];
            this._cam[2] =
                l
        }
        SetLookXYZ(g, h, l) {
            this._look[0] = g * this._worldScale[0];
            this._look[1] = h * this._worldScale[1];
            this._look[2] = l
        }
        ResetModelView(g) {
            c.lookAt(this._matMV, this._cam, this._look, g || this._up);
            c.scale(this._matMV, this._matMV, this._worldScale)
        }
        Translate(g, h) {
            if (0 !== g || 0 !== h) e[0] = g, e[1] = h, e[2] = 0, c.translate(this._matMV, this._matMV, e)
        }
        Scale(g, h) {
            if (1 !== g || 1 !== h) e[0] = g, e[1] = h, e[2] = 1, c.scale(this._matMV, this._matMV, e)
        }
        RotateZ(g) {
            0 !== g && c.rotateZ(this._matMV, this._matMV, g)
        }
        _AddShaderProgram(g) {
            this._allShaderPrograms.push(g);
            this._shaderProgramsByName.set(g.GetName(), g)
        }
        _RemoveShaderProgram(g) {
            const h = this._allShaderPrograms.indexOf(g); - 1 !== h && this._allShaderPrograms.splice(h, 1);
            this._shaderProgramsByName.delete(g.GetName())
        }
        _ClearAllShaderPrograms() {
            d.clearArray(this._allShaderPrograms);
            this._shaderProgramsByName.clear()
        }
        GetShaderProgramByName(g) {
            return this._shaderProgramsByName.get(g) || null
        }
        GetTextureFillShaderProgram() {
            return this._spTextureFill
        }
        SetTextureFillMode() {
            this.SetProgram(this._spTextureFill)
        }
        GetPointsRenderingProgram() {
            return this._spPoints
        }
        SetPointsRenderingProgram() {
            this.SetProgram(this._spPoints)
        }
        SetTilemapFillMode() {
            this.SetProgram(this._spTilemapFill)
        }
        SetColorFillMode() {
            this.SetProgram(this._spColorFill)
        }
        SetLinearGradientFillMode() {
            this.SetProgram(this._spLinearGradientFill)
        }
        SetHardEllipseFillMode() {
            this.SetProgram(this._spHardEllipseFill)
        }
        SetHardEllipseOutlineMode() {
            this.SetProgram(this._spHardEllipseOutline)
        }
        SetSmoothEllipseFillMode() {
            this.SetProgram(this._spSmoothEllipseFill)
        }
        SetSmoothEllipseOutlineMode() {
            this.SetProgram(this._spSmoothEllipseOutline)
        }
        SetSmoothLineFillMode() {
            this.SetProgram(this._spSmoothLineFill)
        }
        _SetCurrentStateGroup(g) {
            this._currentStateGroup =
                g
        }
        GetCurrentStateGroup() {
            return this._currentStateGroup
        }
        AcquireStateGroup(g, h, l, m) {
            const p = d.Gfx.StateGroup.MakeKey(g, h, l, m);
            let t = this._stateGroups.get(p);
            t || (t = d.New(d.Gfx.StateGroup, this, g, h, l, m), this._stateGroups.set(p, t));
            t.AddRef();
            return t
        }
        ReleaseStateGroup(g) {
            g.DecRef();
            0 === g._GetRefCount() && (this._currentStateGroup === g && (this._currentStateGroup = null), this._stateGroups.delete(g.GetKey()), g.Release())
        }
        _InitBlendModeData(g) {
            d.clearArray(this._blendModeTable);
            this._namedBlendModeMap.clear();
            for (const h of g) {
                g = h[0];
                const l = h[1],
                    m = h[2];
                this._blendModeTable.push([l, m]);
                this._namedBlendModeMap.set(g, {
                    srcBlend: l,
                    destBlend: m
                })
            }
        }
        _GetBlendByIndex(g) {
            return this._blendModeTable[g]
        }
        GetSrcBlendByIndex(g) {
            return this._GetBlendByIndex(g)[0]
        }
        GetDestBlendByIndex(g) {
            return this._GetBlendByIndex(g)[1]
        }
        GetNamedBlend(g) {
            g = this._namedBlendModeMap.get(g);
            if ("undefined" === typeof g) throw Error("invalid blend name");
            return g
        }
        SetBaseZ(g) {
            this._baseZ = g
        }
        GetBaseZ() {
            return this._baseZ
        }
        SetCurrentZ(g) {
            this._currentZ =
                g;
            this._currentStateGroup = null
        }
        GetCurrentZ() {
            return this._currentZ
        }
        ClearRect(g, h, l, m) {
            this.ClearRect4(g, h, l, m, 0, 0, 0, 0)
        }
        ClearRect2(g) {
            this.ClearRect4(g.getLeft(), g.getTop(), g.width(), g.height(), 0, 0, 0, 0)
        }
        ClearRect3(g, h) {
            this.ClearRect4(g.getLeft(), g.getTop(), g.width(), g.height(), h.getR(), h.getG(), h.getB(), h.getA())
        }
        GetNumVertexComponents() {
            return 3
        }
        Finish() {
            this.EndBatch(!0);
            this._frameNumber++
        }
        GetFrameNumber() {
            return this._frameNumber
        }
        IncrementFrameNumber() {
            this._frameNumber++
        }
        SetMipmapsEnabled(g) {
            this._enableMipmaps = !!g
        }
        AreMipmapsEnabled() {
            return this._enableMipmaps
        }
        IsWebGL() {
            return !1
        }
        IsWebGPU() {
            return !1
        }
    }
}
"use strict";
{
    const d = self.C3;
    d.Gfx.StateGroup = class {
        constructor(b, a, f, c, e) {
            this._renderer = b;
            this._refCount = 0;
            this._shaderProgram = null;
            this._shaderProgramName = "";
            this._blendMode = f;
            this._color = d.New(d.Color);
            this._color.set(c);
            this._zElevation = e;
            "string" === typeof a ? this._shaderProgramName = a : (this._shaderProgram = a, this._shaderProgramName = this._shaderProgram.GetName())
        }
        Release() {
            if (0 < this._refCount) throw Error("releasing state group still in use");
            this._shaderProgram = this._renderer = null;
            this._shaderProgramName = ""
        }
        Apply() {
            const b =
                this._renderer;
            b.SetProgram(this._shaderProgram);
            b.SetBlendMode(this._blendMode);
            b.SetColor(this._color);
            b.SetCurrentZ(this._zElevation);
            b._SetCurrentStateGroup(this)
        }
        GetKey() {
            return d.Gfx.StateGroup.MakeKey(this._shaderProgramName, this._blendMode, this._color, this._zElevation)
        }
        AddRef() {
            ++this._refCount
        }
        DecRef() {
            --this._refCount
        }
        _GetRefCount() {
            return this._refCount
        }
        OnContextLost() {
            this._shaderProgram = null
        }
        OnContextRestored(b) {
            this._shaderProgram = b.GetShaderProgramByName(this._shaderProgramName);
            if (!this._shaderProgram) throw Error("failed to restore shader program");
        }
        static MakeKey(b, a, f, c) {
            return ("string" === typeof b ? b : b.GetName()) + "," + a + "," + f.getR() + "," + f.getG() + "," + f.getB() + "," + f.getA() + "," + c
        }
    }
}
"use strict";
{
    const d = self.C3,
        b = d.New(d.Quad),
        a = d.New(d.Quad);

    function f(e, g, h) {
        const l = h.getTlx(),
            m = h.getTly(),
            p = h.getTrx() - l,
            t = h.getTry() - m,
            q = h.getBlx() - l;
        h = h.getBly() - m;
        return [l + p * e + q * g, m + t * e + h * g]
    }
    class c {
        constructor(e) {
            this._mesh = e;
            this._v = this._u = this._y = this._x = 0
        }
        _Init(e, g, h, l) {
            this._x = e;
            this._y = g;
            this._u = h;
            this._v = l
        }
        GetX() {
            return this._x
        }
        SetX(e) {
            this._x !== e && (this._x = e, this._mesh._SetPointsChanged())
        }
        GetY() {
            return this._y
        }
        SetY(e) {
            this._y !== e && (this._y = e, this._mesh._SetPointsChanged())
        }
        GetU() {
            return this._u
        }
        SetU(e) {
            this._u =
                e
        }
        GetV() {
            return this._v
        }
        SetV(e) {
            this._v = e
        }
        _Interpolate_TexRect(e, g, h) {
            [this._x, this._y] = f(e._x, e._y, g);
            this._u = d.lerp(h.getLeft(), h.getRight(), e._u);
            this._v = d.lerp(h.getTop(), h.getBottom(), e._v)
        }
        _Interpolate_TexQuad(e, g, h) {
            [this._x, this._y] = f(e._x, e._y, g);
            [this._u, this._v] = f(e._u, e._v, h)
        }
        SaveToJson() {
            return {
                x: this.GetX(),
                y: this.GetY(),
                u: this.GetU(),
                v: this.GetV()
            }
        }
        LoadFromJson(e) {
            this.SetX(e.x);
            this.SetY(e.y);
            this.SetU(e.u);
            this.SetV(e.v)
        }
    }
    d.Gfx.Mesh = class {
        constructor(e, g) {
            if (2 > e || 2 > g) throw Error("invalid mesh size");
            this._hsize = e;
            this._vsize = g;
            this._pts = [];
            this._minY = this._minX = 0;
            this._maxY = this._maxX = 1;
            this._pointsChanged = !1;
            const h = e - 1,
                l = g - 1;
            for (let m = 0; m < g; ++m) {
                const p = [];
                for (let t = 0; t < e; ++t) {
                    const q = d.New(c, this),
                        r = t / h,
                        u = m / l;
                    q._Init(r, u, r, u);
                    p.push(q)
                }
                this._pts.push(p)
            }
        }
        Release() {
            // console.log("IDDQD" + this._pts)
            d.clearArray(this._pts)
        }
        GetHSize() {
            return this._hsize
        }
        GetVSize() {
            return this._vsize
        }
        _GetPoints() {
            // console.log("IDDQD" + this._pts)
            return this._pts
        }
        _SetPointsChanged() {
            this._pointsChanged = !0
        }
        _MaybeComputeBounds() {
            if (this._pointsChanged) {
                var e = Infinity,
                    g = Infinity,
                    h = -Infinity,
                    l = -Infinity;
                for (const m of this._pts)
                    for (const p of m) {
                        const t = p.GetX(),
                            q = p.GetY();
                        e = Math.min(e, t);
                        g = Math.min(g, q);
                        h = Math.max(h, t);
                        l = Math.max(l, q)
                    }
                this._minX = e;
                this._minY = g;
                this._maxX = h;
                this._maxY = l;
                this._pointsChanged = !1
            }
        }
        GetMinX() {
            this._MaybeComputeBounds();
            return this._minX
        }
        GetMinY() {
            this._MaybeComputeBounds();
            return this._minY
        }
        GetMaxX() {
            this._MaybeComputeBounds();
            return this._maxX
        }
        GetMaxY() {
            this._MaybeComputeBounds();
            return this._maxY
        }
        GetMeshPointAt(e, g) {
            e = Math.floor(e);
            g = Math.floor(g);
            return 0 > e || e >= this._hsize || 0 > g || g >= this._vsize ? null : this._pts[g][e]
        }
        CalculateTransformedMesh(e, g, h) {
            const l = h instanceof d.Rect;
            if (e.GetHSize() !== this.GetHSize() || e.GetVSize() !== this.GetVSize()) throw Error("source mesh wrong size");
            e = e._pts;
            const m = this._pts;
            for (let p = 0, t = m.length; p < t; ++p) {
                const q = e[p],
                    r = m[p];
                for (let u = 0, x = r.length; u < x; ++u) {
                    const y = q[u],
                        C = r[u];
                    l ? C._Interpolate_TexRect(y, g, h) : C._Interpolate_TexQuad(y, g, h)
                }
            }
        }
        Draw(e) {
            const g = this._pts;
            let h = g[0];
            for (let l = 1, m = g.length; l < m; ++l) {
                const p =
                    g[l];
                let t = h[0],
                    q = p[0];
                for (let r = 1, u = p.length; r < u; ++r) {
                    const x = h[r],
                        y = p[r];
                    b.set(t.GetX(), t.GetY(), x.GetX(), x.GetY(), y.GetX(), y.GetY(), q.GetX(), q.GetY());
                    a.set(t.GetU(), t.GetV(), x.GetU(), x.GetV(), y.GetU(), y.GetV(), q.GetU(), q.GetV());
                    e.Quad4(b, a);
                    t = x;
                    q = y
                }
                h = p
            }
        }
        Outline(e, g) {
            g || (g = (m, p) => [m, p]);
            const h = this._pts;
            let l = h[0];
            for (let m = 1, p = h.length; m < p; ++m) {
                const t = h[m];
                let q = l[0],
                    r = t[0];
                for (let u = 1, x = t.length; u < x; ++u) {
                    const y = l[u],
                        C = t[u],
                        [w, A] = g(q.GetX(), q.GetY()),
                        [E, K] = g(y.GetX(), y.GetY()),
                        [O, G] = g(C.GetX(),
                            C.GetY()),
                        [J, P] = g(r.GetX(), r.GetY());
                    e.Line(w, A, E, K);
                    e.Line(w, A, O, G);
                    e.Line(w, A, J, P);
                    u === x - 1 && e.Line(E, K, O, G);
                    m === p - 1 && e.Line(J, P, O, G);
                    q = y;
                    r = C
                }
                l = t
            }
        }
        InsertPolyMeshVertices(e) {
            e = e.pointsArr();
            const g = [],
                h = this.GetHSize() - 1,
                l = this.GetVSize() - 1,
                m = 1 / h,
                p = 1 / l,
                t = h - 1,
                q = l - 1;
            let r = e[0],
                u = e[1],
                x = d.clamp(Math.floor(r * h), 0, t),
                y = d.clamp(Math.floor(u * l), 0, q),
                C = 0,
                w = 0,
                A = 0;
            var E = -1;
            const K = () => {
                r = d.clamp(d.lerp(r, C, A), 0, 1);
                u = d.clamp(d.lerp(u, w, A), 0, 1);
                g.push(r, u)
            };
            for (let O = 0, G = e.length; O < G; O += 2)
                for (r = e[O], u = e[O + 1],
                    g.push(r, u), x = d.clamp(Math.floor(r * h), 0, t), y = d.clamp(Math.floor(u * l), 0, q), E = (O + 2) % G, C = e[E], w = e[E + 1], E = -1;;) {
                    if (1E6 < g.length) throw Error("Too many mesh poly points");
                    const J = x * m,
                        P = y * p,
                        R = (x + 1) * m,
                        T = (y + 1) * p;
                    d.isPointInTriangleInclusive(r, u, J, P, R, P, R, T);
                    if (0 !== E && (A = d.rayIntersectExtended(r, u, C, w, J, P, R, T, -.001), 0 <= A && .99999999 >= A)) {
                        K();
                        E = 0;
                        continue
                    }
                    if (0 < y && 2 !== E && (A = d.rayIntersectExtended(r, u, C, w, J, P, R, P, .001), 0 <= A && .99999999 >= A)) {
                        K();
                        y--;
                        E = 4;
                        continue
                    }
                    if (x < t && 3 !== E && (A = d.rayIntersectExtended(r, u, C, w, R,
                            P, R, T, .001), 0 <= A && .99999999 >= A)) {
                        K();
                        x++;
                        E = 1;
                        continue
                    }
                    if (0 < x && 1 !== E && (A = d.rayIntersectExtended(r, u, C, w, J, P, J, T, .001), 0 <= A && .99999999 >= A)) {
                        K();
                        x--;
                        E = 3;
                        continue
                    }
                    if (y < q && 4 !== E && (A = d.rayIntersectExtended(r, u, C, w, J, T, R, T, .001), 0 <= A && .99999999 >= A)) {
                        K();
                        y++;
                        E = 2;
                        continue
                    }
                    break
                }
            return d.New(d.CollisionPoly, g)
        }
        TransformCollisionPoly(e, g) {
            e = this._TransformPolyPoints(e);
            this._SimplifyPoly(e);
            g.setPoints(e)
        }
        _TransformPolyPoints(e) {
            const g = [];
            e = e.pointsArr();
            for (let h = 0, l = e.length; h < l; h += 2) {
                const [m, p] = this.TransformPoint(e[h],
                    e[h + 1]);
                g.push(m, p)
            }
            return g
        }
        TransformPoint(e, g) {
            var h = this.GetHSize() - 1,
                l = this.GetVSize() - 1,
                m = 1 / h,
                p = 1 / l;
            h = d.clamp(Math.floor(e * h), 0, h - 1);
            const t = d.clamp(Math.floor(g * l), 0, l - 1);
            l = h * m;
            const q = t * p,
                r = (h + 1) * m,
                u = (t + 1) * p,
                x = this.GetMeshPointAt(h, t),
                y = this.GetMeshPointAt(h + 1, t + 1),
                C = d.isPointInTriangleInclusive(e, g, l, q, r, q, r, u);
            m = C ? l + m : l;
            p = C ? q : q + p;
            h = this.GetMeshPointAt(h + (C ? 1 : 0), t + (C ? 0 : 1));
            const [w, A, E] = d.triangleCartesianToBarycentric(e, g, l, q, m, p, r, u);
            return d.triangleBarycentricToCartesian(w, A, E, x.GetX(),
                x.GetY(), h.GetX(), h.GetY(), y.GetX(), y.GetY())
        }
        _SimplifyPoly(e) {
            const g = [];
            let h = e[0],
                l = e[1],
                m = h - e[e.length - 2],
                p = l - e[e.length - 1];
            for (let q = 0, r = e.length; q < r; q += 2) {
                var t = (q + 2) % r;
                const u = e[t];
                t = e[t + 1];
                const x = u - h,
                    y = t - l,
                    C = 1E-7 > Math.abs(y) && 1E-7 > Math.abs(p) && Math.sign(x) === Math.sign(m);
                (!(1E-7 > Math.abs(x) && 1E-7 > Math.abs(m) && Math.sign(y) === Math.sign(p) || C) && 1E-7 < Math.abs(x / m - y / p) || 0 == x && 0 === y) && g.push(h, l);
                h = u;
                l = t;
                m = x;
                p = y
            }
            6 <= g.length && g.length < e.length && d.shallowAssignArray(e, g)
        }
        SaveToJson() {
            return {
                cols: this.GetHSize(),
                rows: this.GetVSize(),
                points: this._pts.map(e => e.map(g => g.SaveToJson()))
            }
        }
        LoadFromJson(e) {
            const g = this.GetHSize(),
                h = this.GetVSize();
            if (e.cols !== g || e.rows !== h) throw Error("mesh data wrong size");
            e = e.points;
            for (let l = 0; l < h; ++l) {
                const m = e[l];
                for (let p = 0; p < g; ++p) this.GetMeshPointAt(p, l).LoadFromJson(m[p])
            }
        }
    }
}
"use strict";
{
    const d = self.C3,
        b = new Set(["rgba8", "rgb8", "rgba4", "rgb5_a1", "rgb565"]),
        a = new Set(["nearest", "bilinear", "trilinear"]),
        f = new Set(["default", "low", "high"]),
        c = new Set(["clamp-to-edge", "repeat", "mirror-repeat"]);

    function e(m, p) {
        let t, q;
        switch (m) {
            case "rgba8":
                m = p.RGBA8;
                q = t = p.RGBA;
                p = p.UNSIGNED_BYTE;
                break;
            case "rgb8":
                m = p.RGB8;
                q = t = p.RGB;
                p = p.UNSIGNED_BYTE;
                break;
            case "rgba4":
                m = p.RGBA4;
                q = t = p.RGBA;
                p = p.UNSIGNED_SHORT_4_4_4_4;
                break;
            case "rgb5_a1":
                m = p.RGB5_A1;
                q = t = p.RGBA;
                p = p.UNSIGNED_SHORT_5_5_5_1;
                break;
            case "rgb565":
                m =
                    p.RGB565;
                q = t = p.RGB;
                p = p.UNSIGNED_SHORT_5_6_5;
                break;
            default:
                throw Error("invalid pixel format");
        }
        return {
            sizedinternalformat: m,
            internalformat: t,
            format: q,
            type: p
        }
    }
    const g = {
            wrapX: "clamp-to-edge",
            wrapY: "clamp-to-edge",
            sampling: "trilinear",
            pixelFormat: "rgba8",
            mipMap: !0,
            mipMapQuality: "default",
            premultiplyAlpha: !0,
            isSvg: !1,
            width: -1,
            height: -1
        },
        h = {
            premultiplyAlpha: !0,
            flipY: !1
        },
        l = new Set;
    d.Gfx.WebGLRendererTexture = class {
        constructor(m) {
            this._renderer = m;
            this._texture = null;
            this._height = this._width = 0;
            this._isStatic = !0;
            this._wrapY = this._wrapX = "clamp-to-edge";
            this._sampling = "trilinear";
            this._pixelFormat = "rgba8";
            this._isMipMapped = !1;
            this._mipMapQuality = "default";
            this._refCount = 0
        }
        _CreateStatic(m, p) {
            if (!("undefined" !== typeof HTMLImageElement && m instanceof HTMLImageElement || "undefined" !== typeof HTMLCanvasElement && m instanceof HTMLCanvasElement || "undefined" !== typeof ImageBitmap && m instanceof ImageBitmap || "undefined" !== typeof OffscreenCanvas && m instanceof OffscreenCanvas || m instanceof ImageData || m instanceof ArrayBuffer) &&
                null !== m) throw Error("invalid texture source");
            p = Object.assign({}, g, p);
            if (this._texture) throw Error("already created texture");
            this._wrapX = p.wrapX;
            this._wrapY = p.wrapY;
            this._sampling = p.sampling;
            this._pixelFormat = p.pixelFormat;
            this._isMipMapped = !!p.mipMap && this._renderer.AreMipmapsEnabled();
            this._mipMapQuality = p.mipMapQuality;
            if (!c.has(this._wrapX) || !c.has(this._wrapY)) throw Error("invalid wrap mode");
            if (!a.has(this._sampling)) throw Error("invalid sampling");
            if (!b.has(this._pixelFormat)) throw Error("invalid pixel format");
            if (!f.has(this._mipMapQuality)) throw Error("invalid mipmap quality");
            this._isStatic = !0;
            if (m instanceof ArrayBuffer || null === m || p.isSvg) {
                if (this._width = p.width, this._height = p.height, m instanceof ArrayBuffer && m.byteLength !== this._width * this._height * 4) throw Error("ArrayBuffer wrong size");
            } else this._width = m.width, this._height = m.height;
            if (0 >= this._width || 0 >= this._height) throw Error("invalid texture data size");
            if (p.isSvg) {
                var t = d.CreateCanvas(this._width, this._height);
                t.getContext("2d").drawImage(m, 0,
                    0, this._width, this._height);
                m = t
            }
            var q = d.isPOT(this._width) && d.isPOT(this._height);
            t = this._renderer.GetMaxTextureSize();
            if (this._width > t || this._height > t) throw Error("texture data exceeds maximum texture size");
            t = this._renderer.GetContext();
            var r = this._renderer.GetWebGLVersionNumber();
            this._texture = t.createTexture();
            t.bindTexture(t.TEXTURE_2D, this._texture);
            t.pixelStorei(t.UNPACK_PREMULTIPLY_ALPHA_WEBGL, p.premultiplyAlpha);
            p = e(this._pixelFormat, t);
            if (this._renderer.SupportsNPOTTextures() || q || !this._IsTiled()) 2 <=
                r ? (t.texStorage2D(t.TEXTURE_2D, this._isMipMapped ? Math.floor(Math.log2(Math.max(this._width, this._height)) + 1) : 1, p.sizedinternalformat, this._width, this._height), m instanceof ArrayBuffer ? t.texSubImage2D(t.TEXTURE_2D, 0, 0, 0, this._width, this._height, p.format, p.type, new Uint8Array(m)) : null !== m && t.texSubImage2D(t.TEXTURE_2D, 0, 0, 0, p.format, p.type, m)) : m instanceof ArrayBuffer ? t.texImage2D(t.TEXTURE_2D, 0, p.internalformat, this._width, this._height, 0, p.format, p.type, new Uint8Array(m)) : null === m ? t.texImage2D(t.TEXTURE_2D,
                    0, p.internalformat, this._width, this._height, 0, p.format, p.type, null) : t.texImage2D(t.TEXTURE_2D, 0, p.internalformat, p.format, p.type, m);
            else {
                if (null === m) throw Error("cannot pass null data when creating a NPOT tiled texture without NPOT support");
                m instanceof ArrayBuffer && (m = new ImageData(new Uint8ClampedArray(m), this._width, this._height));
                m instanceof ImageData && (q = d.CreateCanvas(this._width, this._height), q.getContext("2d").putImageData(m, 0, 0), m = q);
                q = d.CreateCanvas(d.nextHighestPowerOfTwo(this._width),
                    d.nextHighestPowerOfTwo(this._height));
                r = q.getContext("2d");
                r.imageSmoothingEnabled = "nearest" !== this._sampling;
                r.drawImage(m, 0, 0, this._width, this._height, 0, 0, q.width, q.height);
                t.texImage2D(t.TEXTURE_2D, 0, p.internalformat, p.format, p.type, q)
            }
            null !== m && this._SetTextureParameters(t);
            t.bindTexture(t.TEXTURE_2D, null);
            this._renderer._ResetLastTexture();
            this._refCount = 1;
            l.add(this)
        }
        _CreateDynamic(m, p, t) {
            t = Object.assign({}, g, t);
            if (this._texture) throw Error("already created texture");
            this._wrapX = t.wrapX;
            this._wrapY =
                t.wrapY;
            this._sampling = t.sampling;
            this._pixelFormat = t.pixelFormat;
            this._isMipMapped = !!t.mipMap && this._renderer.AreMipmapsEnabled();
            this._mipMapQuality = t.mipMapQuality;
            if (!c.has(this._wrapX) || !c.has(this._wrapY)) throw Error("invalid wrap mode");
            if (!a.has(this._sampling)) throw Error("invalid sampling");
            if (!b.has(this._pixelFormat)) throw Error("invalid pixel format");
            if (!f.has(this._mipMapQuality)) throw Error("invalid mipmap quality");
            this._isStatic = !1;
            this._width = Math.floor(m);
            this._height = Math.floor(p);
            m = d.isPOT(this._width) && d.isPOT(this._height);
            p = this._renderer.GetMaxTextureSize();
            if (0 >= this._width || 0 >= this._height) throw Error("invalid texture size");
            if (this._width > p || this._height > p) throw Error("texture exceeds maximum texture size");
            if (!this._renderer.SupportsNPOTTextures() && this._IsTiled() && !m) throw Error("non-power-of-two tiled textures not supported");
            m = this._renderer.GetContext();
            p = this._renderer.GetWebGLVersionNumber();
            this._texture = m.createTexture();
            m.bindTexture(m.TEXTURE_2D, this._texture);
            m.pixelStorei(m.UNPACK_PREMULTIPLY_ALPHA_WEBGL, t.premultiplyAlpha);
            t = e(this._pixelFormat, m);
            m.texImage2D(m.TEXTURE_2D, 0, 2 <= p ? t.sizedinternalformat : t.internalformat, this._width, this._height, 0, t.format, t.type, null);
            this._SetTextureParameters(m);
            m.bindTexture(m.TEXTURE_2D, null);
            this._renderer._ResetLastTexture();
            this._refCount = 1;
            l.add(this)
        }
        _GetMipMapHint(m) {
            if ("default" === this._mipMapQuality) return this._isStatic ? m.NICEST : m.FASTEST;
            if ("low" === this._mipMapQuality) return m.FASTEST;
            if ("high" === this._mipMapQuality) return m.NICEST;
            throw Error("invalid mipmap quality");
        }
        _IsTiled() {
            return "clamp-to-edge" !== this._wrapX || "clamp-to-edge" !== this._wrapY
        }
        _GetTextureWrapMode(m, p) {
            if ("clamp-to-edge" === p) return m.CLAMP_TO_EDGE;
            if ("repeat" === p) return m.REPEAT;
            if ("mirror-repeat" === p) return m.MIRRORED_REPEAT;
            throw Error("invalid wrap mode");
        }
        _SetTextureParameters(m) {
            var p = d.isPOT(this._width) && d.isPOT(this._height);
            m.texParameteri(m.TEXTURE_2D, m.TEXTURE_WRAP_S, this._GetTextureWrapMode(m, this._wrapX));
            m.texParameteri(m.TEXTURE_2D, m.TEXTURE_WRAP_T,
                this._GetTextureWrapMode(m, this._wrapY));
            "nearest" === this._sampling ? (m.texParameteri(m.TEXTURE_2D, m.TEXTURE_MAG_FILTER, m.NEAREST), m.texParameteri(m.TEXTURE_2D, m.TEXTURE_MIN_FILTER, m.NEAREST), this._isMipMapped = !1) : (m.texParameteri(m.TEXTURE_2D, m.TEXTURE_MAG_FILTER, m.LINEAR), (p || this._renderer.SupportsNPOTTextures()) && this._isMipMapped ? (m.hint(m.GENERATE_MIPMAP_HINT, this._GetMipMapHint(m)), m.generateMipmap(m.TEXTURE_2D), p = "trilinear" === this._sampling && !this._renderer.HasMajorPerformanceCaveat(), m.texParameteri(m.TEXTURE_2D,
                m.TEXTURE_MIN_FILTER, p ? m.LINEAR_MIPMAP_LINEAR : m.LINEAR_MIPMAP_NEAREST)) : (m.texParameteri(m.TEXTURE_2D, m.TEXTURE_MIN_FILTER, m.LINEAR), this._isMipMapped = !1))
        }
        _Update(m, p) {
            if (!("undefined" !== typeof HTMLImageElement && m instanceof HTMLImageElement || "undefined" !== typeof HTMLVideoElement && m instanceof HTMLVideoElement || "undefined" !== typeof HTMLCanvasElement && m instanceof HTMLCanvasElement || "undefined" !== typeof ImageBitmap && m instanceof ImageBitmap || "undefined" !== typeof OffscreenCanvas && m instanceof OffscreenCanvas ||
                    m instanceof ImageData)) throw Error("invalid texture source");
            if (!this._texture || 0 >= this._refCount) throw Error("texture not created");
            if (this._isStatic) throw Error("cannot update static texture");
            p = Object.assign({}, h, p);
            const t = m.width || m.videoWidth,
                q = m.height || m.videoHeight;
            var r = this._renderer.GetWebGLVersionNumber();
            const u = this._renderer.GetContext();
            u.bindTexture(u.TEXTURE_2D, this._texture);
            u.pixelStorei(u.UNPACK_PREMULTIPLY_ALPHA_WEBGL, p.premultiplyAlpha);
            u.pixelStorei(u.UNPACK_FLIP_Y_WEBGL,
                !!p.flipY);
            p = e(this._pixelFormat, u);
            r = 2 <= r ? p.sizedinternalformat : p.internalformat;
            try {
                if (this._width === t && this._height === q) {
                    const x = d.isPOT(this._width) && d.isPOT(this._height);
                    u.texSubImage2D(u.TEXTURE_2D, 0, 0, 0, p.format, p.type, m);
                    (x || this._renderer.SupportsNPOTTextures()) && this._isMipMapped && (u.hint(u.GENERATE_MIPMAP_HINT, this._GetMipMapHint(u)), u.generateMipmap(u.TEXTURE_2D))
                } else {
                    this._width = t;
                    this._height = q;
                    const x = d.isPOT(this._width) && d.isPOT(this._height);
                    if (!this._renderer.SupportsNPOTTextures() &&
                        this._IsTiled() && !x) throw Error("non-power-of-two tiled textures not supported");
                    u.texImage2D(u.TEXTURE_2D, 0, r, p.format, p.type, m);
                    (x || this._renderer.SupportsNPOTTextures()) && this._isMipMapped && (u.hint(u.GENERATE_MIPMAP_HINT, this._GetMipMapHint(u)), u.generateMipmap(u.TEXTURE_2D))
                }
            } catch (x) {
                console.error("Error updating WebGL texture: ", x)
            }
            u.bindTexture(u.TEXTURE_2D, null);
            this._renderer._ResetLastTexture()
        }
        _Delete() {
            if (0 < this._refCount) throw Error("texture still has references");
            if (!this._texture) throw Error("already deleted texture");
            l.delete(this);
            this._renderer.GetContext().deleteTexture(this._texture);
            this._texture = null
        }
        IsValid() {
            return !!this._texture
        }
        _GetTexture() {
            return this._texture
        }
        GetRenderer() {
            return this._renderer
        }
        AddReference() {
            this._refCount++
        }
        SubtractReference() {
            if (0 >= this._refCount) throw Error("no more references");
            this._refCount--
        }
        GetReferenceCount() {
            return this._refCount
        }
        GetWidth() {
            return this._width
        }
        GetHeight() {
            return this._height
        }
        IsStatic() {
            return this._isStatic
        }
        GetEstimatedMemoryUsage() {
            let m = this._width * this._height;
            switch (this._pixelFormat) {
                case "rgba8":
                    m *= 4;
                    break;
                case "rgb8":
                    m *= 3;
                    break;
                case "rgba4":
                case "rgb5_a1":
                case "rgb565":
                    m *= 2
            }
            this._isMipMapped && (m += Math.floor(m / 3));
            return m
        }
        static OnContextLost() {
            l.clear()
        }
        static allTextures() {
            return l.values()
        }
    }
}
"use strict";
{
    const d = self.C3,
        b = new Set(["nearest", "bilinear", "trilinear"]),
        a = {
            sampling: "trilinear",
            alpha: !0,
            readback: !0,
            isDefaultSize: !0,
            multisampling: 0
        },
        f = new Set;
    d.Gfx.WebGLRenderTarget = class {
        constructor(c) {
            this._renderer = c;
            this._renderBuffer = this._texture = this._frameBuffer = null;
            this._height = this._width = 0;
            this._isDefaultSize = !0;
            this._sampling = "trilinear";
            this._readback = this._alpha = !0;
            this._multisampling = 0
        }
        _Create(c, e, g) {
            g = Object.assign({}, a, g);
            const h = this._renderer.GetWebGLVersionNumber();
            if (this._texture ||
                this._renderBuffer) throw Error("already created render target");
            this._sampling = g.sampling;
            this._alpha = !!g.alpha;
            this._readback = !!g.readback;
            this._isDefaultSize = !!g.isDefaultSize;
            this._multisampling = g.multisampling;
            if (!b.has(this._sampling)) throw Error("invalid sampling");
            if (0 < this._multisampling && (2 > h || this._readback)) throw Error("invalid use of multisampling");
            2 > h && (this._readback = !0);
            this._width = c;
            this._height = e;
            if (0 >= this._width || 0 >= this._height) throw Error("invalid render target size");
            c = this._renderer.GetContext();
            this._frameBuffer = c.createFramebuffer();
            c.bindFramebuffer(c.FRAMEBUFFER, this._frameBuffer);
            this._readback ? (this._texture = this._renderer.CreateDynamicTexture(this._width, this._height, {
                sampling: this._sampling,
                pixelFormat: this._alpha ? "rgba8" : "rgb8",
                mipMap: !1
            }), e = this._texture._GetTexture(), c.framebufferTexture2D(c.FRAMEBUFFER, c.COLOR_ATTACHMENT0, c.TEXTURE_2D, e, 0)) : (this._renderBuffer = c.createRenderbuffer(), c.bindRenderbuffer(c.RENDERBUFFER, this._renderBuffer), e = this._alpha ? c.RGBA8 : c.RGB8, 0 < this._multisampling &&
                ((g = c.getInternalformatParameter(c.RENDERBUFFER, e, c.SAMPLES)) && g[0] ? (g = g[0], this._multisampling > g && (this._multisampling = g)) : this._multisampling = 0), 0 === this._multisampling ? c.renderbufferStorage(c.RENDERBUFFER, e, this._width, this._height) : c.renderbufferStorageMultisample(c.RENDERBUFFER, this._multisampling, e, this._width, this._height), c.framebufferRenderbuffer(c.FRAMEBUFFER, c.COLOR_ATTACHMENT0, c.RENDERBUFFER, this._renderBuffer), c.bindRenderbuffer(c.RENDERBUFFER, null));
            c.bindFramebuffer(c.FRAMEBUFFER, null);
            f.add(this)
        }
        _Resize(c, e) {
            if (this._width !== c || this._height !== e) this._width = c, this._height = e, c = this._renderer.GetContext(), c.bindFramebuffer(c.FRAMEBUFFER, this._frameBuffer), this._texture ? this._texture._Update(new ImageData(this._width, this._height)) : (c.bindRenderbuffer(c.RENDERBUFFER, this._renderBuffer), c.renderbufferStorage(c.RENDERBUFFER, this._alpha ? c.RGBA8 : c.RGB8, this._width, this._height), c.bindRenderbuffer(c.RENDERBUFFER, null)), c.bindFramebuffer(c.FRAMEBUFFER, null)
        }
        _Delete() {
            if (!this._texture &&
                !this._renderBuffer) throw Error("already deleted render target");
            f.delete(this);
            const c = this._renderer.GetContext();
            c.bindFramebuffer(c.FRAMEBUFFER, this._frameBuffer);
            this._texture ? (c.framebufferTexture2D(c.FRAMEBUFFER, c.COLOR_ATTACHMENT0, c.TEXTURE_2D, null, 0), this._renderer.DeleteTexture(this._texture), this._texture = null) : this._renderBuffer && (c.framebufferRenderbuffer(c.FRAMEBUFFER, c.COLOR_ATTACHMENT0, c.RENDERBUFFER, null), c.deleteRenderbuffer(this._renderBuffer), this._renderBuffer = null);
            c.bindFramebuffer(c.FRAMEBUFFER,
                null);
            2 <= this._renderer.GetWebGLVersionNumber() && (c.bindFramebuffer(c.READ_FRAMEBUFFER, null), c.bindFramebuffer(c.DRAW_FRAMEBUFFER, null));
            c.deleteFramebuffer(this._frameBuffer);
            this._frameBuffer = this._renderer.GetBatchState().currentFramebuffer = null
        }
        _GetFramebuffer() {
            return this._frameBuffer
        }
        GetWebGLRenderer() {
            return this._renderer
        }
        GetTexture() {
            return this._texture
        }
        IsLinearSampling() {
            return "nearest" !== this._sampling
        }
        HasAlpha() {
            return this._alpha
        }
        IsReadback() {
            return this._readback
        }
        GetWidth() {
            return this._width
        }
        GetHeight() {
            return this._height
        }
        IsDefaultSize() {
            return this._isDefaultSize
        }
        GetMultisampling() {
            return this._multisampling
        }
        GetOptions() {
            const c = {
                sampling: this._sampling,
                alpha: this._alpha,
                readback: this._readback
            };
            this._isDefaultSize || (c.width = this._width, c.height = this._height);
            return c
        }
        IsCompatibleWithOptions(c) {
            c = Object.assign({}, a, c);
            return "nearest" !== c.sampling !== this.IsLinearSampling() || !!c.alpha !== this.HasAlpha() || 2 <= this._renderer.GetWebGLVersionNumber() && !!c.readback !== this.IsReadback() ? !1 : "number" === typeof c.width || "number" === typeof c.height ? !this.IsDefaultSize() && this.GetWidth() === c.width && this.GetHeight() === c.height : this.IsDefaultSize()
        }
        _GetWebGLTexture() {
            return this._texture ?
                this._texture._GetTexture() : null
        }
        GetEstimatedMemoryUsage() {
            return this._texture ? this._texture.GetEstimatedMemoryUsage() : this._width * this._height * (this._alpha ? 4 : 3)
        }
        static async DebugReadPixelsToBlob(c, e) {
            c = await c.ReadBackRenderTargetToImageData(e, !0);
            return await d.ImageDataToBlob(c)
        }
        static OnContextLost() {
            f.clear()
        }
        static allRenderTargets() {
            return f.values()
        }
        static ResizeAll(c, e) {
            for (const g of f) g.IsDefaultSize() && g._Resize(c, e)
        }
    }
}
"use strict";
{
    const d = self.C3,
        b = self.glMatrix,
        a = b.vec3,
        f = b.mat4,
        c = new Set("aPos aTex aPoints matP matMV samplerFront samplerBack destStart destEnd srcStart srcEnd srcOriginStart srcOriginEnd pixelSize seconds layerScale layerAngle layoutStart layoutEnd color color2_ pointTexStart pointTexEnd zElevation tileSize tileSpacing outlineThickness".split(" "));
    d.Gfx.WebGLShaderProgram = class {
        static async Compile(e, g, h, l) {
            const m = e.GetContext(),
                p = m.createShader(m.FRAGMENT_SHADER);
            m.shaderSource(p, g);
            m.compileShader(p);
            g = m.createShader(m.VERTEX_SHADER);
            m.shaderSource(g, h);
            m.compileShader(g);
            const t = m.createProgram();
            m.attachShader(t, p);
            m.attachShader(t, g);
            m.bindAttribLocation(t, 0, "aPos");
            m.bindAttribLocation(t, 1, "aTex");
            m.bindAttribLocation(t, 2, "aPoints");
            m.linkProgram(t);
            const q = e._GetParallelShaderCompileExtension();
            q ? await e._WaitForObjectReady(() => m.getProgramParameter(t, q.COMPLETION_STATUS_KHR)) : await d.Wait(5);
            if (!m.getShaderParameter(p, m.COMPILE_STATUS)) throw l = m.getShaderInfoLog(p), m.deleteShader(p), m.deleteShader(g),
                m.deleteProgram(t), Error("Error compiling fragment shader: " + l);
            if (!m.getShaderParameter(g, m.COMPILE_STATUS)) throw l = m.getShaderInfoLog(g), m.deleteShader(p), m.deleteShader(g), m.deleteProgram(t), Error("Error compiling vertex shader: " + l);
            if (!m.getProgramParameter(t, m.LINK_STATUS)) throw l = m.getProgramInfoLog(t), m.deleteShader(p), m.deleteShader(g), m.deleteProgram(t), Error("Error linking shader program: " + l);
            (e = d.FilterUnprintableChars(m.getProgramInfoLog(t) || "").trim()) && !d.IsStringAllWhitespace(e) &&
                console.info(`[WebGL] Shader program '${l}' compilation log: `, e);
            m.deleteShader(p);
            m.deleteShader(g);
            return t
        }
        static async Create(e, g, h, l) {
            h = await d.Gfx.WebGLShaderProgram.Compile(e, g.src, h, l);
            return new d.Gfx.WebGLShaderProgram(e, h, g, l)
        }
        constructor(e, g, h, l) {
            const m = e.GetContext();
            var p = e.GetBatchState();
            e.EndBatch();
            m.useProgram(g);
            this._gl = m;
            this._renderer = e;
            this._name = l;
            this._shaderProgram = g;
            this._isDeviceTransform = "<default-device-transform>" === l;
            l = m.getAttribLocation(g, "aPos");
            const t = m.getAttribLocation(g,
                "aTex");
            g = m.getAttribLocation(g, "aPoints"); - 1 !== l && (m.bindBuffer(m.ARRAY_BUFFER, e._vertexBuffer), m.vertexAttribPointer(l, e.GetNumVertexComponents(), m.FLOAT, !1, 0, 0), m.enableVertexAttribArray(l)); - 1 !== t && (m.bindBuffer(m.ARRAY_BUFFER, e._texcoordBuffer), m.vertexAttribPointer(t, 2, m.FLOAT, !1, 0, 0), m.enableVertexAttribArray(t)); - 1 !== g && (m.bindBuffer(m.ARRAY_BUFFER, e._pointBuffer), m.vertexAttribPointer(g, 4, m.FLOAT, !1, 0, 0), m.enableVertexAttribArray(g));
            m.bindBuffer(m.ARRAY_BUFFER, null);
            this._uMatP = new d.Gfx.WebGLShaderUniform(this,
                "matP", "mat4");
            this._uMatMV = new d.Gfx.WebGLShaderUniform(this, "matMV", "mat4");
            this._uColor = new d.Gfx.WebGLShaderUniform(this, "color", "vec4");
            this._uSamplerFront = new d.Gfx.WebGLShaderUniform(this, "samplerFront", "sampler");
            this._uPointTexStart = new d.Gfx.WebGLShaderUniform(this, "pointTexStart", "vec2");
            this._uPointTexEnd = new d.Gfx.WebGLShaderUniform(this, "pointTexEnd", "vec2");
            this._uZElevation = new d.Gfx.WebGLShaderUniform(this, "zElevation", "float");
            this._uTileSize = new d.Gfx.WebGLShaderUniform(this, "tileSize",
                "vec2");
            this._uTileSpacing = new d.Gfx.WebGLShaderUniform(this, "tileSpacing", "vec2");
            this._uColor2 = new d.Gfx.WebGLShaderUniform(this, "color2_", "vec4");
            this._uOutlineThickness = new d.Gfx.WebGLShaderUniform(this, "outlineThickness", "float");
            this._uSamplerBack = new d.Gfx.WebGLShaderUniform(this, "samplerBack", "sampler");
            this._uDestStart = new d.Gfx.WebGLShaderUniform(this, "destStart", "vec2");
            this._uDestEnd = new d.Gfx.WebGLShaderUniform(this, "destEnd", "vec2");
            this._uSrcStart = new d.Gfx.WebGLShaderUniform(this,
                "srcStart", "vec2");
            this._uSrcEnd = new d.Gfx.WebGLShaderUniform(this, "srcEnd", "vec2");
            this._uSrcOriginStart = new d.Gfx.WebGLShaderUniform(this, "srcOriginStart", "vec2");
            this._uSrcOriginEnd = new d.Gfx.WebGLShaderUniform(this, "srcOriginEnd", "vec2");
            this._uPixelSize = new d.Gfx.WebGLShaderUniform(this, "pixelSize", "vec2");
            this._uSeconds = new d.Gfx.WebGLShaderUniform(this, "seconds", "float");
            this._uLayerScale = new d.Gfx.WebGLShaderUniform(this, "layerScale", "float");
            this._uLayerAngle = new d.Gfx.WebGLShaderUniform(this,
                "layerAngle", "float");
            this._uLayoutStart = new d.Gfx.WebGLShaderUniform(this, "layoutStart", "vec2");
            this._uLayoutEnd = new d.Gfx.WebGLShaderUniform(this, "layoutEnd", "vec2");
            this._hasAnyOptionalUniforms = !!(this._uPixelSize.IsUsed() || this._uSeconds.IsUsed() || this._uSamplerBack.IsUsed() || this._uDestStart.IsUsed() || this._uDestEnd.IsUsed() || this._uSrcStart.IsUsed() || this._uSrcEnd.IsUsed() || this._uSrcOriginStart.IsUsed() || this._uSrcOriginEnd.IsUsed() || this._uLayerScale.IsUsed() || this._uLayerAngle.IsUsed() ||
                this._uLayoutStart.IsUsed() || this._uLayoutEnd.IsUsed());
            this._extendBoxHorizontal = h.extendBoxHorizontal || 0;
            this._extendBoxVertical = h.extendBoxVertical || 0;
            this._crossSampling = !!h.crossSampling;
            this._mustPreDraw = !!h.mustPreDraw;
            this._preservesOpaqueness = !!h.preservesOpaqueness;
            this._animated = !!h.animated;
            e = h.parameters || [];
            this._uCustomParameters = [];
            this._usesDest = this._uDestStart.IsUsed() || this._uDestEnd.IsUsed();
            this._usesAnySrcRectOrPixelSize = this._uPixelSize.IsUsed() || this._uSrcStart.IsUsed() ||
                this._uSrcEnd.IsUsed() || this._uSrcOriginStart.IsUsed() || this._uSrcOriginEnd.IsUsed();
            this._needsPostDrawOrExtendBox = this._crossSampling || this._usesDest || 0 !== this._extendBoxHorizontal || 0 !== this._extendBoxVertical;
            this._hasCurrentMatMV = this._hasCurrentMatP = !1;
            this._uColor.Init4f(1, 1, 1, 1);
            this._uColor2.Init4f(1, 1, 1, 1);
            this._uSamplerFront.Init1i(0);
            this._uSamplerBack.Init1i(1);
            this._uPointTexStart.Init2f(0, 0);
            this._uPointTexEnd.Init2f(1, 1);
            this._uZElevation.Init1f(0);
            this._uTileSize.Init2f(0, 0);
            this._uTileSpacing.Init2f(0,
                0);
            this._uDestStart.Init2f(0, 0);
            this._uDestEnd.Init2f(1, 1);
            this._uSrcStart.Init2f(0, 0);
            this._uSrcEnd.Init2f(0, 0);
            this._uSrcOriginStart.Init2f(0, 0);
            this._uSrcOriginEnd.Init2f(0, 0);
            this._uPixelSize.Init2f(0, 0);
            this._uLayerScale.Init1f(1);
            this._uLayerAngle.Init1f(0);
            this._uSeconds.Init1f(0);
            this._uLayoutStart.Init2f(0, 0);
            this._uLayoutEnd.Init2f(0, 0);
            this._uOutlineThickness.Init1f(1);
            for (const q of e) e = q[2], h = new d.Gfx.WebGLShaderUniform(this, q[0], e), "color" === e ? h.Init3f(0, 0, 0) : h.Init1f(0), this._uCustomParameters.push(h);
            this._isDeviceTransform ? this._UpdateDeviceTransformUniforms(p.currentMatP) : (this.UpdateMatP(p.currentMatP, !0), this.UpdateMatMV(p.currentMV, !0));
            p = p.currentShader;
            m.useProgram(p ? p._shaderProgram : null)
        }
        Release() {
            this._gl.deleteProgram(this._shaderProgram);
            this._shaderProgram = null;
            this._renderer._RemoveShaderProgram(this);
            this._renderer = this._gl = null
        }
        GetName() {
            return this._name
        }
        GetWebGLContext() {
            return this._gl
        }
        GetShaderProgram() {
            return this._shaderProgram
        }
        UsesDest() {
            return this._usesDest
        }
        UsesCrossSampling() {
            return this._crossSampling
        }
        MustPreDraw() {
            return this._mustPreDraw
        }
        PreservesOpaqueness() {
            return this._preservesOpaqueness
        }
        ExtendsBox() {
            return 0 !==
                this._extendBoxHorizontal || 0 !== this._extendBoxVertical
        }
        GetBoxExtendHorizontal() {
            return this._extendBoxHorizontal
        }
        GetBoxExtendVertical() {
            return this._extendBoxVertical
        }
        UsesAnySrcRectOrPixelSize() {
            return this._usesAnySrcRectOrPixelSize
        }
        NeedsPostDrawOrExtendsBox() {
            return this._needsPostDrawOrExtendBox
        }
        GetParameterCount() {
            return this._uCustomParameters.length
        }
        GetParameterType(e) {
            return this._uCustomParameters[e].GetType()
        }
        AreCustomParametersAlreadySetInBatch(e) {
            for (let g = 0, h = e.length; g < h; ++g)
                if (!this._uCustomParameters[g].IsSetToCustomInBatch(e[g])) return !1;
            return !0
        }
        SetCustomParametersInBatch(e) {
            for (let g = 0, h = e.length; g < h; ++g) this._uCustomParameters[g].SetBatchValueCustom(e[g])
        }
        AreOptionalUniformsAlreadySetInBatch(e, g, h, l, m, p, t, q, r) {
            return this._uSamplerBack.IsUsed() || this._uPixelSize.IsUsed() && !this._uPixelSize.IsSetTo2InBatch(m, p) || this._uDestStart.IsUsed() && !this._uDestStart.IsSetTo2InBatch(e.getLeft(), e.getTop()) || this._uDestEnd.IsUsed() && !this._uDestEnd.IsSetTo2InBatch(e.getRight(), e.getBottom()) || this._uLayerScale.IsUsed() && !this._uLayerScale.IsSetTo1InBatch(t) ||
                this._uLayerAngle.IsUsed() && !this._uLayerAngle.IsSetTo1InBatch(q) || this._uSrcStart.IsUsed() && !this._uSrcStart.IsSetTo2InBatch(g.getLeft(), g.getTop()) || this._uSrcEnd.IsUsed() && !this._uSrcEnd.IsSetTo2InBatch(g.getRight(), g.getBottom()) || this._uSrcOriginStart.IsUsed() && !this._uSrcOriginStart.IsSetTo2InBatch(h.getLeft(), h.getTop()) || this._uSrcOriginEnd.IsUsed() && !this._uSrcOriginEnd.IsSetTo2InBatch(h.getRight(), h.getBottom()) || this._uLayoutStart.IsUsed() && !this._uLayoutStart.IsSetTo2InBatch(l.getLeft(),
                    l.getTop()) || this._uLayoutEnd.IsUsed() && !this._uLayoutEnd.IsSetTo2InBatch(l.getTop(), l.getBottom()) || this._uSeconds.IsUsed() && !this._uSeconds.IsSetTo1InBatch(r) ? !1 : !0
        }
        SetOptionalUniformsInBatch(e, g, h, l, m, p, t, q, r) {
            this._uSamplerBack.IsUsed() || (this._uPixelSize.IsUsed() && this._uPixelSize.SetBatch2(m, p), this._uDestStart.IsUsed() && this._uDestStart.SetBatch2(e.getLeft(), e.getTop()), this._uDestEnd.IsUsed() && this._uDestEnd.SetBatch2(e.getRight(), e.getBottom()), this._uLayerScale.IsUsed() && this._uLayerScale.SetBatch1(t),
                this._uLayerAngle.IsUsed() && this._uLayerAngle.SetBatch1(q), this._uSrcStart.IsUsed() && this._uSrcStart.SetBatch2(g.getLeft(), g.getTop()), this._uSrcEnd.IsUsed() && this._uSrcEnd.SetBatch2(g.getRight(), g.getBottom()), this._uSrcOriginStart.IsUsed() && this._uSrcOriginStart.SetBatch2(h.getLeft(), h.getTop()), this._uSrcOriginEnd.IsUsed() && this._uSrcOriginEnd.SetBatch2(h.getRight(), h.getBottom()), this._uLayoutStart.IsUsed() && this._uLayoutStart.SetBatch2(l.getLeft(), l.getTop()), this._uLayoutEnd.IsUsed() && this._uLayoutEnd.SetBatch2(l.getTop(),
                    l.getBottom()), this._uSeconds.IsUsed() && this._uSeconds.SetBatch1(r))
        }
        IsAnimated() {
            return this._animated
        }
        UpdateMatP(e, g) {
            this._hasCurrentMatP && !g || this._isDeviceTransform || (this._uMatP.IsUsed() && this._uMatP.UpdateMatrix4fv(e), this._hasCurrentMatP = !0)
        }
        SetMatPStale() {
            this._hasCurrentMatP = !1
        }
        UpdateMatMV(e, g) {
            this._hasCurrentMatMV && !g || this._isDeviceTransform || (this._uMatMV.IsUsed() && this._uMatMV.UpdateMatrix4fv(e), this._hasCurrentMatMV = !0)
        }
        SetMatMVStale() {
            this._hasCurrentMatMV = !1
        }
        _UpdateDeviceTransformUniforms(e) {
            if (!this._isDeviceTransform) throw Error("not device transform shader");
            this._uMatP.UpdateMatrix4fv(e);
            e = this._renderer;
            var g = e.GetWidth() / 2,
                h = e.GetHeight() / 2;
            const l = e._worldScale,
                m = a.fromValues(g * l[0], h * l[1], 100 * self.devicePixelRatio);
            g = a.fromValues(g * l[0], h * l[1], 0);
            h = f.create();
            f.lookAt(h, m, g, e._up);
            f.scale(h, h, l);
            this._uMatMV.UpdateMatrix4fv(h)
        }
        UpdateColor(e) {
            this._uColor.IsUsed() && this._uColor.Update4f(e[0], e[1], e[2], e[3])
        }
        static GetReservedUniformNames() {
            return c
        }
        static GetDefaultVertexShaderSource(e) {
            e = e ? "highmedp" : "mediump";
            return ["#ifdef GL_FRAGMENT_PRECISION_HIGH\n#define highmedp highp\n#else\n#define highmedp mediump\n#endif\nattribute highp vec3 aPos;",
                `attribute ${e} vec2 aTex;`, `varying ${e} vec2 vTex;`, "uniform highp mat4 matP;\nuniform highp mat4 matMV;\nvoid main(void) {\n\tgl_Position = matP * matMV * vec4(aPos, 1.0);\n\tvTex = aTex;\n}"
            ].join("\n")
        }
        static GetTextureFillFragmentShaderSource() {
            return "varying mediump vec2 vTex;\nuniform lowp vec4 color;\nuniform lowp sampler2D samplerFront;\nvoid main(void) {\n\tgl_FragColor = texture2D(samplerFront, vTex) * color;\n}"
        }
        static GetTilemapFragmentShaderSource() {
            return "#ifdef GL_FRAGMENT_PRECISION_HIGH\n#define highmedp highp\n#else\n#define highmedp mediump\n#endif\nvarying highmedp vec2 vTex;\nuniform lowp vec4 color;\nuniform lowp sampler2D samplerFront;\nuniform highmedp vec2 srcStart;\nuniform highmedp vec2 pixelSize;\nuniform highmedp vec2 tileSize;\nuniform highmedp vec2 tileSpacing;\nvoid main(void) {\n\thighmedp vec2 tile = floor(vTex);\n\thighmedp vec2 tex = fract(vTex);\n\thighmedp vec2 tileOrigin = srcStart + tile * (tileSize + tileSpacing);\n\thighmedp vec2 lowerBound = tileOrigin + pixelSize / 2.0;\n\thighmedp vec2 upperBound = tileOrigin + tileSize - pixelSize / 2.0;\n\tgl_FragColor = texture2D(samplerFront, clamp(tex, lowerBound, upperBound), -16.0) * color;\n}"
        }
        static GetPointVertexShaderSource() {
            return "attribute vec4 aPoints;\nvarying float pointOpacity;\nuniform float zElevation;\nuniform mat4 matP;\nuniform mat4 matMV;\nvoid main(void) {\n\tgl_Position = matP * matMV * vec4(aPoints.xy, zElevation, 1.0);\n\tgl_PointSize = aPoints.z;\n\tpointOpacity = aPoints.w;\n}"
        }
        static GetPointFragmentShaderSource() {
            return "uniform lowp sampler2D samplerFront;\nvarying lowp float pointOpacity;\nuniform mediump vec2 pointTexStart;\nuniform mediump vec2 pointTexEnd;\nuniform lowp vec4 color;\nvoid main(void) {\n\tgl_FragColor = texture2D(samplerFront, mix(pointTexStart, pointTexEnd, gl_PointCoord)) * color * pointOpacity;\n}"
        }
        static GetColorFillFragmentShaderSource() {
            return "uniform lowp vec4 color;\nvoid main(void) {\n\tgl_FragColor = color;\n}"
        }
        static GetLinearGradientFillFragmentShaderSource() {
            return "precision lowp float;\nvarying mediump vec2 vTex;\nuniform vec4 color;\nuniform vec4 color2_;\nvec3 fromLinear(vec3 linearRGB)\n{\n\tbvec3 cutoff = lessThan(linearRGB, vec3(0.0031308));\n\tvec3 higher = vec3(1.055) * pow(abs(linearRGB), vec3(1.0/2.4)) - vec3(0.055);\n\tvec3 lower = linearRGB * vec3(12.92);\n\treturn mix(higher, lower, vec3(cutoff));\n}\nvec3 toLinear(vec3 sRGB)\n{\n\tbvec3 cutoff = lessThan(sRGB, vec3(0.04045));\n\tvec3 higher = pow(abs((sRGB + vec3(0.055))/vec3(1.055)), vec3(2.4));\n\tvec3 lower = sRGB/vec3(12.92);\n\treturn mix(higher, lower, vec3(cutoff));\n}\nvoid main(void) {\n\tvec3 linearGrad = mix(toLinear(color.rgb), toLinear(color2_.rgb), vTex.x);\n\tfloat a = mix(color.a, color2_.a, vTex.x);\n\tgl_FragColor = vec4(fromLinear(linearGrad) * a, a);\n}"
        }
        static GetSmoothLineFillFragmentShaderSource() {
            return "varying mediump vec2 vTex;\nuniform lowp vec4 color;\nvoid main(void) {\n\tlowp float f = 1.0 - abs(vTex.y - 0.5) * 2.0;\n\tgl_FragColor = color * f;\n}"
        }
        static GetHardEllipseFillFragmentShaderSource() {
            return "varying mediump vec2 vTex;\nuniform lowp vec4 color;\nvoid main(void) {\n\tmediump vec2 diff = vTex - vec2(0.5, 0.5);\n\tmediump vec2 diffSq = diff * diff;\n\tmediump float f = step(diffSq.x + diffSq.y, 0.25);\n\tgl_FragColor = color * f;\n}"
        }
        static GetHardEllipseOutlineFragmentShaderSource() {
            return "varying mediump vec2 vTex;\nuniform lowp vec4 color;\nuniform mediump vec2 pixelSize;\nuniform mediump float outlineThickness;\nvoid main(void) {\n\tmediump vec2 diff = vTex - vec2(0.5, 0.5);\n\tmediump vec2 diffSq = diff * diff;\n\tmediump float distSq = diffSq.x + diffSq.y;\n\tmediump vec2 norm = normalize(diff);\n\tmediump vec2 halfNorm = norm * 0.5;\n\tmediump float innerF = step(distSq, 0.25);\n\tmediump vec2 innerEdge = halfNorm - pixelSize * norm * outlineThickness;\n\tmediump vec2 innerEdgeSq = innerEdge * innerEdge;\n\tmediump float outerF = step(innerEdgeSq.x + innerEdgeSq.y, distSq);\n\tgl_FragColor = color * innerF * outerF;\n}"
        }
        static GetSmoothEllipseFillFragmentShaderSource() {
            return "varying mediump vec2 vTex;\nuniform lowp vec4 color;\nuniform mediump vec2 pixelSize;\nvoid main(void) {\n\tmediump vec2 diff = vTex - vec2(0.5, 0.5);\n\tmediump vec2 diffSq = diff * diff;\n\tmediump vec2 norm = normalize(diff);\n\tmediump vec2 halfNorm = norm * 0.5;\n\tmediump vec2 halfNormSq = halfNorm * halfNorm;\n\tmediump vec2 innerEdge = halfNorm - pixelSize * norm;\n\tmediump vec2 innerEdgeSq = innerEdge * innerEdge;\n\tmediump float f = smoothstep(halfNormSq.x + halfNormSq.y, innerEdgeSq.x + innerEdgeSq.y, diffSq.x + diffSq.y);\n\tgl_FragColor = color * f;\n}"
        }
        static GetSmoothEllipseOutlineFragmentShaderSource() {
            return "varying mediump vec2 vTex;\nuniform lowp vec4 color;\nuniform mediump vec2 pixelSize;\nuniform mediump float outlineThickness;\nvoid main(void) {\n\tmediump vec2 diff = vTex - vec2(0.5, 0.5);\n\tmediump vec2 diffSq = diff * diff;\n\tmediump float distSq = diffSq.x + diffSq.y;\n\tmediump vec2 norm = normalize(diff);\n\tmediump vec2 halfNorm = norm * 0.5;\n\tmediump vec2 halfNormSq = halfNorm * halfNorm;\n\tmediump vec2 pxNorm = pixelSize * norm;\n\tmediump vec2 innerEdge1 = halfNorm - pxNorm;\n\tmediump vec2 innerEdge1Sq = innerEdge1 * innerEdge1;\n\tmediump float innerF = smoothstep(halfNormSq.x + halfNormSq.y, innerEdge1Sq.x + innerEdge1Sq.y, distSq);\n\tmediump vec2 innerEdge2 = halfNorm - pxNorm * outlineThickness;\n\tmediump vec2 innerEdge2Sq = innerEdge2 * innerEdge2;\n\tmediump vec2 innerEdge3 = halfNorm - pxNorm * (outlineThickness + 1.0);\n\tmediump vec2 innerEdge3Sq = innerEdge3 * innerEdge3;\n\tmediump float outerF = smoothstep(innerEdge3Sq.x + innerEdge3Sq.y, innerEdge2Sq.x + innerEdge2Sq.y, distSq);\n\tgl_FragColor = color * innerF * outerF;\n}"
        }
    }
}
"use strict";
{
    const d = self.C3,
        b = new Map([
            ["float", 1],
            ["percent", 1],
            ["sampler", 1],
            ["vec2", 2],
            ["vec3", 3],
            ["color", 3],
            ["vec4", 4],
            ["mat4", 16]
        ]);
    d.Gfx.WebGLShaderUniform = class {
        constructor(a, f, c) {
            if (!b.has(c)) throw Error("invalid uniform type");
            this._owner = a;
            this._gl = this._owner.GetWebGLContext();
            this._name = f;
            this._type = c;
            this._isColorType = "color" === this._type;
            this._location = this._gl.getUniformLocation(this._owner.GetShaderProgram(), f);
            this._isUsed = !!this._location;
            a = b.get(c);
            this._lastValue = new Float32Array(a);
            this._lastBatchValue =
                new Float32Array(a)
        }
        Release() {
            this._location = this._gl = this._owner = null
        }
        IsUsed() {
            return this._isUsed
        }
        GetType() {
            return this._type
        }
        IsColorType() {
            return this._isColorType
        }
        Init1f(a) {
            this.IsUsed() && (this._lastValue[0] = a, this._lastBatchValue.set(this._lastValue), this._gl.uniform1f(this._location, a))
        }
        Init1i(a) {
            this.IsUsed() && (this._lastValue[0] = a, this._lastBatchValue.set(this._lastValue), this._gl.uniform1i(this._location, a))
        }
        Init2f(a, f) {
            this.IsUsed() && (this._lastValue[0] = a, this._lastValue[1] = f, this._lastBatchValue.set(this._lastValue),
                this._gl.uniform2f(this._location, a, f))
        }
        Init3f(a, f, c) {
            this.IsUsed() && (this._lastValue[0] = a, this._lastValue[1] = f, this._lastValue[2] = c, this._lastBatchValue.set(this._lastValue), this._gl.uniform3f(this._location, a, f, c))
        }
        Init4f(a, f, c, e) {
            this.IsUsed() && (this._lastValue[0] = a, this._lastValue[1] = f, this._lastValue[2] = c, this._lastValue[3] = e, this._lastBatchValue.set(this._lastValue), this._gl.uniform4f(this._location, a, f, c, e))
        }
        Update1f(a) {
            a = Math.fround(a);
            const f = this._lastValue;
            f[0] !== a && (f[0] = a, this._gl.uniform1f(this._location,
                a))
        }
        Update1i(a) {
            const f = this._lastValue;
            f[0] !== a && (f[0] = a, this._gl.uniform1i(this._location, a))
        }
        Update2f(a, f) {
            a = Math.fround(a);
            f = Math.fround(f);
            const c = this._lastValue;
            if (c[0] !== a || c[1] !== f) c[0] = a, c[1] = f, this._gl.uniform2f(this._location, a, f)
        }
        Update3f(a, f, c) {
            a = Math.fround(a);
            f = Math.fround(f);
            c = Math.fround(c);
            const e = this._lastValue;
            if (e[0] !== a || e[1] !== f || e[2] !== c) e[0] = a, e[1] = f, e[2] = c, this._gl.uniform3f(this._location, a, f, c)
        }
        Update4f(a, f, c, e) {
            a = Math.fround(a);
            f = Math.fround(f);
            c = Math.fround(c);
            e = Math.fround(e);
            const g = this._lastValue;
            if (g[0] !== a || g[1] !== f || g[2] !== c || g[3] !== e) g[0] = a, g[1] = f, g[2] = c, g[3] = e, this._gl.uniform4f(this._location, a, f, c, e)
        }
        UpdateMatrix4fv(a) {
            const f = this._lastValue;
            d.Gfx.AreMat4sEqual(f, a) || (d.typedArraySet16(f, a, 0), this._gl.uniformMatrix4fv(this._location, !1, a))
        }
        IsSetToCustomInBatch(a) {
            const f = this._lastBatchValue;
            return this.IsColorType() ? f[0] === Math.fround(a.getR()) && f[1] === Math.fround(a.getG()) && f[2] === Math.fround(a.getB()) : f[0] === Math.fround(a)
        }
        SetBatchValueCustom(a) {
            const f =
                this._lastBatchValue;
            this.IsColorType() ? (f[0] = a.getR(), f[1] = a.getG(), f[2] = a.getB()) : f[0] = a
        }
        IsSetTo1InBatch(a) {
            return this._lastBatchValue[0] === Math.fround(a)
        }
        IsSetTo2InBatch(a, f) {
            const c = this._lastBatchValue;
            return c[0] === Math.fround(a) && c[1] === Math.fround(f)
        }
        SetBatch1(a) {
            this._lastBatchValue[0] = a
        }
        SetBatch2(a, f) {
            const c = this._lastBatchValue;
            c[0] = a;
            c[1] = f
        }
    }
}
"use strict";
{
    const d = self.C3,
        b = self.glMatrix,
        a = b.vec4,
        f = b.mat4;
    d.Gfx.BatchState = class {
        constructor(c) {
            this.renderer = c;
            this.currentMV = f.create();
            this.currentMatP = f.create();
            this.currentFramebuffer = null;
            this.currentColor = a.fromValues(1, 1, 1, 1);
            this.currentShader = null;
            this.pointTexCoords = new d.Rect;
            this.clearColor = d.New(d.Color, 0, 0, 0, 0)
        }
    };
    d.Gfx.WebGLBatchJob = class {
        constructor(c) {
            const e = new ArrayBuffer(96);
            this._type = 0;
            this._batchState = c;
            this._gl = c.renderer.GetContext();
            this._indexCount = this._startIndex = 0;
            this._texParam =
                null;
            this._mat4param = new Float32Array(e, 0, 16);
            this._colorParam = new Float32Array(e, 64, 4);
            this._srcOriginRect = new Float32Array(e, 80, 4);
            this._shaderParams = []
        }
        InitQuad(c, e) {
            this._type = 1;
            this._startIndex = c;
            this._indexCount = e
        }
        DoQuad() {
            const c = this._gl;
            c.drawElements(c.TRIANGLES, this._indexCount, c.UNSIGNED_SHORT, this._startIndex)
        }
        InitSetTexture(c) {
            this._type = 2;
            this._texParam = c
        }
        DoSetTexture() {
            const c = this._gl,
                e = this._texParam;
            c.bindTexture(c.TEXTURE_2D, e ? e._GetTexture() : null)
        }
        InitSetColor(c) {
            this._type = 3;
            c.writeToTypedArray(this._colorParam, 0)
        }
        DoSetColor() {
            const c = this._colorParam,
                e = this._batchState;
            a.copy(e.currentColor, c);
            e.currentShader.UpdateColor(c)
        }
        InitSetGradientColor(c) {
            this._type = 19;
            c.writeToTypedArray(this._colorParam, 0)
        }
        DoSetGradientColor() {
            const c = this._colorParam,
                e = this._batchState.currentShader;
            e._uColor2.IsUsed() && e._uColor2.Update4f(c[0], c[1], c[2], c[3])
        }
        InitSetBlend(c, e) {
            this._type = 4;
            this._startIndex = c;
            this._indexCount = e
        }
        DoSetBlend() {
            this._gl.blendFunc(this._startIndex, this._indexCount)
        }
        InitUpdateModelView(c) {
            this._type =
                5;
            f.copy(this._mat4param, c)
        }
        DoUpdateModelView() {
            const c = this._batchState,
                e = c.renderer._allShaderPrograms,
                g = c.currentShader,
                h = this._mat4param;
            for (let l = 0, m = e.length; l < m; ++l) {
                const p = e[l];
                p === g ? p.UpdateMatMV(h, !0) : p.SetMatMVStale()
            }
            f.copy(c.currentMV, h)
        }
        InitSetRenderTarget(c, e, g) {
            this._type = 6;
            this._texParam = c;
            this._startIndex = e ? 1 : 0;
            e && f.copy(this._mat4param, g)
        }
        DoSetRenderTarget() {
            var c = this._gl,
                e = this._texParam;
            const g = 0 !== this._startIndex,
                h = this._mat4param,
                l = this._batchState,
                m = l.renderer;
            if (e) {
                const p =
                    e._GetFramebuffer();
                l.currentFramebuffer = p;
                c.bindFramebuffer(c.FRAMEBUFFER, p);
                c = e.GetWidth();
                e = e.GetHeight()
            } else l.currentFramebuffer = null, c.bindFramebuffer(c.FRAMEBUFFER, null), c = m.GetScissoredViewportWidth(), e = m.GetScissoredViewportHeight();
            g && m._UpdateViewportBatch(c, e, h)
        }
        InitClearSurface(c) {
            this._type = 7;
            c.writeToTypedArray(this._mat4param, 0)
        }
        InitClearSurface2(c, e, g, h) {
            this._type = 7;
            const l = this._mat4param;
            l[0] = c;
            l[1] = e;
            l[2] = g;
            l[3] = h
        }
        DoClearSurface() {
            const c = this._gl;
            var e = this._mat4param,
                g = this._batchState;
            const h = g.clearColor;
            (g = g.renderer._isScissorViewport && d.isDebug) && c.disable(c.SCISSOR_TEST);
            const l = e[0],
                m = e[1],
                p = e[2];
            e = e[3];
            h.equalsRgba(l, m, p, e) || (c.clearColor(l, m, p, e), h.setRgba(l, m, p, e));
            c.clear(c.COLOR_BUFFER_BIT);
            g && c.enable(c.SCISSOR_TEST)
        }
        InitClearRect(c, e, g, h, l, m, p, t) {
            this._type = 8;
            const q = this._mat4param;
            q[0] = c;
            q[1] = e;
            q[2] = g;
            q[3] = h;
            q[4] = l;
            q[5] = m;
            q[6] = p;
            q[7] = t
        }
        DoClearRectangle() {
            const c = this._gl;
            var e = this._mat4param,
                g = this._batchState;
            const h = g.renderer;
            g = g.clearColor;
            h._isScissorViewport ||
                c.enable(c.SCISSOR_TEST);
            c.scissor(e[0], e[1], e[2], e[3]);
            const l = e[4],
                m = e[5],
                p = e[6];
            e = e[7];
            g.equalsRgba(l, m, p, e) || (c.clearColor(l, m, p, e), g.setRgba(l, m, p, e));
            c.clear(c.COLOR_BUFFER_BIT);
            h._isScissorViewport ? c.scissor(0, 0, h._viewportScissorWidth, h._viewportScissorHeight) : c.disable(c.SCISSOR_TEST)
        }
        InitSetPointTexCoords(c) {
            this._type = 13;
            c.writeToTypedArray(this._mat4param, 0)
        }
        DoSetPointTextureCoords() {
            const c = this._mat4param;
            this._batchState.pointTexCoords.set(c[0], c[1], c[2], c[3])
        }
        InitPoints(c, e) {
            // console.log("IDDQD3 initp " + c + " " + e)
            this._type =
                9;
            this._startIndex = c;
            this._indexCount = 1;
            this._mat4param[0] = e
        }
        DoPoints() {
            const c = this._gl,
                e = this._batchState,
                g = e.renderer._spPoints;
            c.useProgram(g._shaderProgram);
            g.UpdateMatP(e.currentMatP, !1);
            g.UpdateMatMV(e.currentMV, !1);
            var h = e.pointTexCoords;
            g._uPointTexStart.IsUsed() && g._uPointTexStart.Update2f(h.getLeft(), h.getTop());
            g._uPointTexEnd.IsUsed() && g._uPointTexEnd.Update2f(h.getRight(), h.getBottom());
            h = this._mat4param[0];
            g._uZElevation.IsUsed() && g._uZElevation.Update1f(h);
            g._uColor.IsUsed() && (h = e.currentColor,
                g._uColor.Update4f(h[0], h[1], h[2], h[3]));
            c.drawArrays(c.POINTS, this._startIndex / 4, this._indexCount);
            c.useProgram(e.currentShader._shaderProgram)
            // console.log("IDDQD " + c.POINTS)
        }
        InitSetProgram(c) {
            this._type = 10;
            this._texParam = c
        }
        DoSetProgram() {
            var c = this._gl;
            const e = this._batchState,
                g = this._texParam;
            e.currentShader = g;
            c.useProgram(g._shaderProgram);
            g.UpdateMatP(e.currentMatP, !1);
            g.UpdateMatMV(e.currentMV, !1);
            g._uColor.IsUsed() && (c = e.currentColor, g._uColor.Update4f(c[0], c[1], c[2], c[3]))
        }
        InitSetProgramParameters() {
            this._type = 11
        }
        DoSetProgramParameters() {
            const c =
                this._batchState.currentShader;
            c._hasAnyOptionalUniforms && this._DoSetOptionalUniformProgramParameters(c);
            c._uCustomParameters.length && this._DoUpdateCustomProgramParameters(c)
        }
        _DoSetOptionalUniformProgramParameters(c) {
            const e = this._gl,
                g = this._mat4param,
                h = this._colorParam,
                l = this._srcOriginRect;
            if (c._uSamplerBack.IsUsed()) {
                const m = this._batchState.renderer,
                    p = this._texParam;
                m._lastTexture1 !== p && (e.activeTexture(e.TEXTURE1), e.bindTexture(e.TEXTURE_2D, p ? p._GetTexture() : null), m._lastTexture1 = p, e.activeTexture(e.TEXTURE0))
            }
            c._uPixelSize.IsUsed() &&
                c._uPixelSize.Update2f(g[0], g[1]);
            c._uDestStart.IsUsed() && c._uDestStart.Update2f(g[2], g[3]);
            c._uDestEnd.IsUsed() && c._uDestEnd.Update2f(g[4], g[5]);
            c._uLayerScale.IsUsed() && c._uLayerScale.Update1f(g[6]);
            c._uLayerAngle.IsUsed() && c._uLayerAngle.Update1f(g[7]);
            c._uSrcStart.IsUsed() && c._uSrcStart.Update2f(g[12], g[13]);
            c._uSrcEnd.IsUsed() && c._uSrcEnd.Update2f(g[14], g[15]);
            c._uSrcOriginStart.IsUsed() && c._uSrcOriginStart.Update2f(l[0], l[1]);
            c._uSrcOriginEnd.IsUsed() && c._uSrcOriginEnd.Update2f(l[2], l[3]);
            c._uLayoutStart.IsUsed() &&
                c._uLayoutStart.Update2f(h[0], h[1]);
            c._uLayoutEnd.IsUsed() && c._uLayoutEnd.Update2f(h[2], h[3]);
            c._uSeconds.IsUsed() && c._uSeconds.Update1f(this._startIndex)
        }
        _DoUpdateCustomProgramParameters(c) {
            c = c._uCustomParameters;
            const e = this._shaderParams;
            for (let g = 0, h = c.length; g < h; ++g) {
                const l = c[g],
                    m = e[g];
                l.IsColorType() ? l.Update3f(m.getR(), m.getG(), m.getB()) : l.Update1f(m)
            }
        }
        InitInvalidateFramebuffer(c) {
            this._type = 12;
            this._texParam = c
        }
        DoInvalidateFramebuffer() {
            const c = this._gl,
                e = this._texParam,
                g = this._batchState.currentFramebuffer;
            e !== g && c.bindFramebuffer(c.FRAMEBUFFER, e);
            c.invalidateFramebuffer(c.FRAMEBUFFER, [c.COLOR_ATTACHMENT0]);
            e !== g && c.bindFramebuffer(c.FRAMEBUFFER, g)
        }
        InitBlitFramebuffer(c, e, g) {
            this._type = 15;
            const h = this._mat4param,
                l = this._batchState.renderer;
            h[0] = c.GetWidth();
            h[1] = c.GetHeight();
            h[2] = e ? e.GetWidth() : l.GetWidth();
            h[3] = e ? e.GetHeight() : l.GetHeight();
            h[4] = c.IsLinearSampling() ? 1 : 0;
            h[5] = "stretch" === g;
            g = this._shaderParams;
            d.clearArray(g);
            g.push(c._GetFramebuffer());
            g.push(e ? e._GetFramebuffer() : null)
        }
        DoBlitFramebuffer() {
            var c =
                this._mat4param,
                e = this._shaderParams;
            const g = this._gl;
            var h = c[0],
                l = c[1],
                m = c[2];
            const p = c[3],
                t = 0 !== c[4];
            c = 0 !== c[5];
            const q = e[1];
            g.bindFramebuffer(g.READ_FRAMEBUFFER, e[0]);
            g.bindFramebuffer(g.DRAW_FRAMEBUFFER, q);
            c ? g.blitFramebuffer(0, 0, h, l, 0, 0, m, p, g.COLOR_BUFFER_BIT, t ? g.LINEAR : g.NEAREST) : (e = Math.min(h, m), h = Math.min(l, p), m = Math.max(l - p, 0), l = Math.max(p - l, 0), g.blitFramebuffer(0, m, e, h + m, 0, l, e, h + l, g.COLOR_BUFFER_BIT, g.NEAREST))
        }
        InitStartQuery(c) {
            this._type = 16;
            this._texParam = c
        }
        DoStartQuery() {
            this._texParam.BeginTimeElapsed();
            this._texParam = null
        }
        InitEndQuery(c) {
            // console.log("IDDQD InitEndQuery c" + c)
            this._type = 17;
            this._texParam = c
        }
        DoEndQuery() {
            // console.log("IDDQD3 doendquery")
            this._texParam.EndTimeElapsed();
            this._texParam = null
        }
        InitSetEllipseParams(c, e, g) {
            this._type = 18;
            const h = this._mat4param;
            h[0] = c;
            h[1] = e;
            h[2] = g
        }
        DoSetEllipseParams() {
            const c = this._batchState.currentShader,
                e = this._mat4param;
            c._uPixelSize.IsUsed() && c._uPixelSize.Update2f(e[0], e[1]);
            c._uOutlineThickness.IsUsed() && c._uOutlineThickness.Update1f(e[2])
        }
        InitSetTilemapInfo(c, e, g, h, l, m, p) {
            this._type = 14;
            const t = this._mat4param;
            c.writeToTypedArray(t,
                0);
            t[4] = 1 / e;
            t[5] = 1 / g;
            t[6] = h / e;
            t[7] = l / g;
            t[8] = m / e;
            t[9] = p / g
        }
        DoSetTilemapInfo() {
            const c = this._batchState.currentShader,
                e = this._mat4param;
            c._uSrcStart.IsUsed() && c._uSrcStart.Update2f(e[0], e[1]);
            c._uPixelSize.IsUsed() && c._uPixelSize.Update2f(e[4], e[5]);
            c._uTileSize.IsUsed() && c._uTileSize.Update2f(e[6], e[7]);
            c._uTileSpacing.IsUsed() && c._uTileSpacing.Update2f(e[8], e[9])
        }
        Run() {
            // console.log("IDDQD run type " + this._type)
            switch (this._type) {
                case 1:
                    this.DoQuad();
                    break;
                case 2:
                    this.DoSetTexture();
                    break;
                case 3:
                    this.DoSetColor();
                    break;
                case 4:
                    this.DoSetBlend();
                    break;
                case 5:
                    this.DoUpdateModelView();
                    break;
                case 6:
                    this.DoSetRenderTarget();
                    break;
                case 7:
                    this.DoClearSurface();
                    break;
                case 8:
                    this.DoClearRectangle();
                    break;
                case 9:
                    this.DoPoints();
                    break;
                case 10:
                    this.DoSetProgram();
                    break;
                case 11:
                    this.DoSetProgramParameters();
                    break;
                case 12:
                    this.DoInvalidateFramebuffer();
                    break;
                case 13:
                    this.DoSetPointTextureCoords();
                    break;
                case 14:
                    this.DoSetTilemapInfo();
                    break;
                case 15:
                    this.DoBlitFramebuffer();
                    break;
                case 16:
                    this.DoStartQuery();
                    break;
                case 17:
                    this.DoEndQuery();
                    break;
                case 18:
                    this.DoSetEllipseParams();
                    break;
                case 19:
                    this.DoSetGradientColor()
            }
        }
    }
}
"use strict";
{
    const d = self.C3,
        b = {
            timeout: 60
        },
        a = new d.Color(0, 0, 0, 1),
        f = new Set(["left", "center", "right"]),
        c = new Set(["top", "center", "bottom"]),
        e = new Set(["word", "character"]),
        g = new Set;
    d.FontManager && d.FontManager.addEventListener("fontload", q => {
        q = q.font.GetName();
        for (const r of g)(r.IsBBCodeEnabled() || d.equalsNoCase(r.GetFontName(), q)) && r._SetTextChanged()
    });

    function h(q, r, u, x, y, C) {
        r ? "Gecko" === d.Platform.BrowserEngine ? q.strokeText(u, x, y, C) : q.strokeText(u, x, y) : "Gecko" === d.Platform.BrowserEngine ? q.fillText(u, x,
            y, C) : q.fillText(u, x, y)
    }

    function l(q, r, u, x, y, C) {
        r ? q.strokeRect(u, x, y, C) : q.fillRect(u, x, y, C)
    }

    function m(q) {
        return 4 / 3 * q
    }
    let p = !1,
        t = !1;
    d.Gfx.RendererText = class {
        constructor(q, r) {
            r = Object.assign({}, b, r);
            this._renderer = q;
            this._fontName = "Arial";
            this._fontSize = 16;
            this._lineHeight = 0;
            this._isItalic = this._isBold = !1;
            this._colorStr = "black";
            this._isBBcodeEnabled = !1;
            this.onloadfont = null;
            this._alreadyLoadedFonts = new Set;
            this._horizontalAlign = "left";
            this._verticalAlign = "top";
            this._text = "";
            this._bbString = null;
            this._wrappedText =
                d.New(d.WordWrap);
            this._wrapMode = "word";
            this._isUpdating = this._textChanged = !1;
            this._isAsync = !0;
            this._drawMaxCharCount = -1;
            this._height = this._width = this._cssHeight = this._cssWidth = this._drawCharCount = 0;
            this._zoom = 1;
            this._changed = !1;
            this._measureContext = this._textContext = this._textCanvas = null;
            this._lastCanvasHeight = this._lastCanvasWidth = -1;
            this._lastTextCanvasFillStyle = this._lastMeasureCanvasFont = this._lastTextCanvasFont = "";
            this._lastTextCanvasLineWidth = this._lastTextCanvasOpacity = 1;
            this._measureTextCallback =
                (u, x) => this._MeasureText(u, x);
            this._texture = null;
            this._textureHeight = this._textureWidth = 0;
            this._rcTex = new d.Rect;
            this._scaleFactor = 1;
            this._needToRecreateTexture = !1;
            this._textureTimeout = new d.IdleTimeout(() => {
                this.ReleaseTexture();
                this._SetTextCanvasSize(8, 8)
            }, r.timeout);
            this.ontextureupdate = null;
            this._wasReleased = !1;
            g.add(this)
        }
        Release() {
            this.onloadfont = null;
            this._alreadyLoadedFonts.clear();
            this._measureTextCallback = this._measureContext = this._textContext = this._textCanvas = this._bbString = null;
            this._textureTimeout.Release();
            this.ontextureupdate = null;
            this.ReleaseTexture();
            this._wrappedText.Clear();
            this._renderer = this._wrappedText = null;
            this._wasReleased = !0;
            g.delete(this)
        }
        _SetChanged() {
            this._changed = !0
        }
        _SetTextChanged() {
            this._SetChanged();
            this._wrappedText.Clear();
            this._textChanged = !0
        }
        SetIsAsync(q) {
            this._isAsync = !!q
        }
        IsAsync() {
            return this._isAsync
        }
        SetBBCodeEnabled(q) {
            q = !!q;
            this._isBBcodeEnabled !== q && (q = (this._isBBcodeEnabled = q) ? "alphabetic" : "top", this._textContext && (this._textContext.textBaseline = q), this._measureContext &&
                (this._measureContext.textBaseline = q), this._SetTextChanged())
        }
        IsBBCodeEnabled() {
            return this._isBBcodeEnabled
        }
        SetFontName(q) {
            q || (q = "serif");
            this._fontName !== q && (this._fontName = q, this._SetTextChanged())
        }
        GetFontName() {
            return this._fontName
        }
        SetFontSize(q) {
            .1 > q && (q = .1);
            this._fontSize !== q && (this._fontSize = q, this._SetTextChanged())
        }
        SetLineHeight(q) {
            this._lineHeight !== q && (this._lineHeight = q, this._SetChanged())
        }
        SetBold(q) {
            q = !!q;
            this._isBold !== q && (this._isBold = q, this._SetTextChanged())
        }
        SetItalic(q) {
            q = !!q;
            this._isItalic !==
                q && (this._isItalic = q, this._SetTextChanged())
        }
        SetDrawMaxCharacterCount(q) {
            q = Math.floor(q);
            this._drawMaxCharCount !== q && (this._drawMaxCharCount = q, this._SetChanged())
        }
        GetDrawMaxCharacterCount() {
            return this._drawMaxCharCount
        }
        _GetStyleTag(q, r) {
            for (let u = q.length - 1; 0 <= u; --u) {
                const x = q[u];
                if (x.tag === r) return x
            }
            return null
        }
        _HasStyleTag(q, r) {
            return !!this._GetStyleTag(q, r)
        }
        _GetFontString(q, r) {
            let u = "";
            if (this._isBold || this._HasStyleTag(r, "b")) u += "bold";
            if (this._isItalic || this._HasStyleTag(r, "i")) u += " italic";
            var x = this._GetStyleTag(r, "size");
            x = x ? parseFloat(x.param) : this._fontSize;
            u = q ? u + (" " + x + "pt") : u + (" " + x * this._scaleFactor * this._zoom * self.devicePixelRatio + "pt");
            q = this._fontName;
            (r = this._GetStyleTag(r, "font")) && r.param && (q = r.param, this.onloadfont && !this._alreadyLoadedFonts.has(q) && (this.onloadfont(q), this._alreadyLoadedFonts.add(q)));
            q && (u += ' "' + q + '"');
            return u
        }
        SetColor(q) {
            q instanceof d.Color && (q = q.getCssRgb());
            this._colorStr !== q && (this._colorStr = q, this._SetChanged())
        }
        SetColorRgb(q, r, u) {
            a.setRgb(q,
                r, u);
            this.SetColor(a)
        }
        SetHorizontalAlignment(q) {
            if (!f.has(q)) throw Error("invalid horizontal alignment");
            this._horizontalAlign !== q && (this._horizontalAlign = q, this._SetChanged())
        }
        SetVerticalAlignment(q) {
            if (!c.has(q)) throw Error("invalid vertical alignment");
            this._verticalAlign !== q && (this._verticalAlign = q, this._SetChanged())
        }
        SetWordWrapMode(q) {
            if (!e.has(q)) throw Error("invalid word wrap mode");
            this._wrapMode !== q && (this._wrapMode = q, this._SetTextChanged())
        }
        SetText(q) {
            // console.log("IDDQD _SetTextChanged" + q)
            this._text !== q && (this._text = q, this._SetTextChanged())
        }
        SetSize(q,
            r, u) {
            "undefined" === typeof u && (u = 1);
            if (!(0 >= q || 0 >= q || this._cssWidth === q && this._cssHeight === r && this._zoom === u)) {
                1 === this._zoom !== (1 === u) && (this._needToRecreateTexture = !0);
                var x = this._cssWidth,
                    y = this._zoom;
                this._cssWidth = q;
                this._cssHeight = r;
                this._zoom = u;
                q = self.devicePixelRatio;
                this._width = this._cssWidth * this._zoom * q;
                this._height = this._cssHeight * this._zoom * q;
                q = Math.max(this._width, this._height);
                r = Math.min(this._renderer.GetMaxTextureSize(), 2048);
                u = 1;
                q > r && (u = r / q, this._width = Math.min(this._width * u, r), this._height =
                    Math.min(this._height * u, r));
                this._scaleFactor = u;
                0 < this._textureWidth && 0 < this._textureHeight && this._zoom === y && this._rcTex.set(0, 0, this._width / this._textureWidth, this._height / this._textureHeight);
                this._cssWidth !== x ? this._SetTextChanged() : this._SetChanged()
            }
        }
        GetWidth() {
            return this._width
        }
        GetHeight() {
            return this._height
        }
        GetTextWidth() {
            this._MaybeWrapText();
            return this._wrappedText.GetMaxLineWidth()
        }
        GetTextHeight() {
            this._MaybeWrapText();
            return this._wrappedText.GetTotalLineHeight() + this._wrappedText.GetLineCount() *
                (this._lineHeight + 4) - this._lineHeight
        }
        GetTexture() {
            this._textureTimeout.Reset();
            this._MaybeUpdate();
            return this._texture
        }
        _MaybeUpdate() {
            this._texture && !this._changed && !this._textChanged || this._isUpdating || 0 >= this._width || 0 >= this._height || (this._changed = !1, this._isUpdating = !0, this._isAsync ? d.Asyncify(() => this._DoUpdate()) : this._DoUpdate())
        }
        _DoUpdate() {
            this._wasReleased || (this._SetTextCanvasSize(Math.ceil(this._width), Math.ceil(this._height)), this._MaybeWrapText(), this._DrawTextToCanvas(), this._UpdateTexture(),
                this._textureTimeout.Reset(), this._isUpdating = !1)
        }
        _SetTextCanvasSize(q, r) {
            this._textCanvas || (this._textCanvas = d.CreateCanvas(16, 16));
            let u = !1;
            if (this._lastCanvasWidth !== q || this._lastCanvasHeight !== r) this._lastCanvasWidth = q, this._lastCanvasHeight = r, this._textCanvas.width = q, this._textCanvas.height = r, u = !0;
            this._textContext || (this._textContext = this._textCanvas.getContext("2d"), u = !0);
            u ? (this._textContext.textBaseline = this._isBBcodeEnabled ? "alphabetic" : "top", this._textContext.font = this._lastTextCanvasFont,
                this._textContext.fillStyle = this._lastTextCanvasFillStyle, this._textContext.strokeStyle = this._lastTextCanvasFillStyle, this._textContext.globalAlpha = this._lastTextCanvasOpacity, this._textContext.lineWidth = this._lastTextCanvasLineWidth) : this._textContext.clearRect(0, 0, q, r)
        }
        _MaybeCreateMeasureContext() {
            this._measureContext || (this._measureContext = d.CreateCanvas(16, 16).getContext("2d"), this._measureContext.textBaseline = this._isBBcodeEnabled ? "alphabetic" : "top")
        }
        _SetMeasureFontString(q) {
            this._lastMeasureCanvasFont !==
                q && (this._lastMeasureCanvasFont = q, this._measureContext.font = q)
        }
        _SupportsFontBoundingBoxMeasurements() {
            if (!p) {
                p = !0;
                this._MaybeCreateMeasureContext();
                const q = this._measureContext.measureText("test");
                t = "number" === typeof q.fontBoundingBoxAscent && "number" === typeof q.fontBoundingBoxDescent
            }
            return t
        }
        _MaybeWrapText() {
            this._textChanged && (this._MaybeCreateMeasureContext(), !this._isBBcodeEnabled || this._bbString && this._bbString.toString() === this._text || (this._bbString = new d.BBString(this._text, {
                    noEscape: !0
                })),
                this._wrappedText.WordWrap(this._isBBcodeEnabled ? this._bbString.toFragmentList() : this._text, this._measureTextCallback, this._cssWidth, this._wrapMode, 0), this._textChanged = !1)
        }
        _MeasureText(q, r) {
            this._SetMeasureFontString(this._GetFontString(!0, r));
            r = (r = this._GetStyleTag(r, "size")) ? parseFloat(r.param) : this._fontSize;
            q = this._measureContext.measureText(q);
            return {
                width: q.width,
                height: m(r),
                fontBoundingBoxAscent: q.fontBoundingBoxAscent || 0,
                fontBoundingBoxDescent: q.fontBoundingBoxDescent || 0
            }
        }
        _SetDrawFontString(q) {
            this._lastTextCanvasFont !==
                q && (this._lastTextCanvasFont = q, this._textContext.font = q)
        }
        _SetDrawCanvasColor(q) {
            this._lastTextCanvasFillStyle !== q && (this._lastTextCanvasFillStyle = q, this._textContext.fillStyle = q, this._textContext.strokeStyle = q)
        }
        _SetDrawCanvasOpacity(q) {
            this._lastTextCanvasOpacity !== q && (this._lastTextCanvasOpacity = q, this._textContext.globalAlpha = q)
        }
        _SetDrawCanvasLineWith(q) {
            this._lastTextCanvasLineWidth !== q && (this._lastTextCanvasLineWidth = q, this._textContext.lineWidth = q)
        }
        _DrawTextToCanvas() {
            this._drawCharCount = 0;
            const q =
                this._scaleFactor * this._zoom * self.devicePixelRatio,
                r = (4 + this._lineHeight) * q;
            let u = 0;
            const x = this._wrappedText.GetLines();
            if (0 !== x.length) {
                var y = x.reduce((w, A) => w + A.height * q + r, 0) - this._lineHeight * q,
                    C = this._isBBcodeEnabled && this._SupportsFontBoundingBoxMeasurements();
                "center" === this._verticalAlign ? u = Math.max(this._height / 2 - y / 2 - (C ? x[0].fontBoundingBoxDescent * q : 0), 0) : "bottom" === this._verticalAlign && (u = this._height - y - (C ? x[x.length - 1].fontBoundingBoxDescent * q : 0) - 2);
                for (let w = 0, A = x.length; w < A; ++w) {
                    y = x[w];
                    C = y.height * q;
                    const E = u;
                    if (this._isBBcodeEnabled) {
                        if (u += C, 0 < w && u > this._height - 4 * q) break
                    } else if (0 < w && u >= this._height - C) break;
                    0 <= E && this._DrawTextLine(y, u, q);
                    this._isBBcodeEnabled || (u += C);
                    u += r
                }
            }
        }
        _DrawTextLine(q, r, u) {
            let x = 0;
            "center" === this._horizontalAlign ? x = (this._width - q.width * u) / 2 : "right" === this._horizontalAlign && (x = this._width - q.width * u);
            for (const y of q.fragments) this._DrawTextFragment(y, x, r, u, q.height), x += y.width * u
        }
        _DrawTextFragment(q, r, u, x, y) {
            const C = this._textContext,
                w = y / 16;
            y = q.width * x;
            const A =
                q.height * x,
                E = q.height / 16;
            var K = (4 + this._lineHeight) * x;
            const O = q.styles;
            q = q.text;
            if (-1 !== this._drawMaxCharCount) {
                if (this._drawCharCount >= this._drawMaxCharCount) return;
                this._drawCharCount + q.length > this._drawMaxCharCount && (q = q.substr(0, this._drawMaxCharCount - this._drawCharCount), y = this._MeasureText(q, O).width * x);
                this._drawCharCount += q.length
            }
            const G = this._GetStyleTag(O, "background"),
                J = this._HasStyleTag(O, "u"),
                P = this._HasStyleTag(O, "s");
            if ((!d.IsStringAllWhitespace(q) || G || J || P) && !this._HasStyleTag(O,
                    "hide")) {
                var R = this._GetStyleTag(O, "offsetx");
                r += R ? parseFloat(R.param) * x : 0;
                R = this._GetStyleTag(O, "offsety");
                u += R ? parseFloat(R.param) * x : 0;
                G && (this._SetDrawCanvasColor(G.param), C.fillRect(r, u - A, y, A + K));
                K = this._GetStyleTag(O, "color");
                this._SetDrawCanvasColor(K ? K.param : this._colorStr);
                K = this._GetStyleTag(O, "opacity");
                this._SetDrawCanvasOpacity(K ? parseFloat(K.param) / 100 : 1);
                (K = this._HasStyleTag(O, "stroke")) && this._SetDrawCanvasLineWith(E * this._scaleFactor * this._zoom);
                J && l(C, K, r, u + x * w, y, x * w);
                P && l(C, K, r,
                    u - A / 4, y, x * E);
                this._SetDrawFontString(this._GetFontString(!1, O));
                h(C, K, q, r, u, y);
                !K && (this._SetDrawCanvasLineWith(E * this._scaleFactor * this._zoom), x = this._GetStyleTag(O, "outline")) && (this._SetDrawCanvasColor(x.param), h(C, !0, q, r, u, y))
            }
        }
        _UpdateTexture() {
            if (!this._renderer.IsContextLost() && (this._textureWidth = Math.ceil(this._width), this._textureHeight = Math.ceil(this._height), this._rcTex.set(0, 0, this._width / this._textureWidth, this._height / this._textureHeight), this._needToRecreateTexture && (this.ReleaseTexture(),
                    this._needToRecreateTexture = !1), this._texture || (this._texture = this._renderer.CreateDynamicTexture(this._textureWidth, this._textureHeight, {
                    mipMap: 1 === this._zoom,
                    mipMapQuality: "high"
                })), this._renderer.UpdateTexture(this._textCanvas, this._texture), this.ontextureupdate)) this.ontextureupdate()
        }
        GetTexRect() {
            return this._rcTex
        }
        ReleaseTexture() {
            this._texture && (this._renderer.IsContextLost() || this._renderer.DeleteTexture(this._texture), this._texture = null)
        }
        static OnContextLost() {
            for (const q of g) q.ReleaseTexture()
        }
        static GetAll() {
            return g.values()
        }
    }
}
"use strict";
{
    const d = self.C3;
    class b {
        constructor(a) {
            this._gl = a.GetContext();
            this._version = a.GetWebGLVersionNumber();
            this._timerExt = a._GetDisjointTimerQueryExtension();
            this._query = null;
            this._hasResult = this._isActive = !1;
            this._result = 0;
            this._query = 1 === this._version ? this._timerExt.createQueryEXT() : this._gl.createQuery()
        }
        Release() {
            this._DeleteQueryObject();
            this._timerExt = this._gl = null;
            this._hasResult = !1
        }
        _DeleteQueryObject() {
            this._query && (1 === this._version ? this._timerExt.deleteQueryEXT(this._query) : this._gl.deleteQuery(this._query),
                this._query = null)
        }
        BeginTimeElapsed() {
            if (this._isActive) throw Error("query already active");
            1 === this._version ? this._timerExt.beginQueryEXT(this._timerExt.TIME_ELAPSED_EXT, this._query) : this._gl.beginQuery(this._timerExt.TIME_ELAPSED_EXT, this._query);
            this._isActive = !0
        }
        EndTimeElapsed() {
            if (!this._isActive) throw Error("query not active");
            1 === this._version ? this._timerExt.endQueryEXT(this._timerExt.TIME_ELAPSED_EXT) : this._gl.endQuery(this._timerExt.TIME_ELAPSED_EXT);
            this._isActive = !1
        }
        CheckForResult() {
            if (this._query &&
                !this._hasResult && !this._isActive) {
                var a = 1 === this._version ? this._timerExt.getQueryObjectEXT(this._query, this._timerExt.QUERY_RESULT_AVAILABLE_EXT) : this._gl.getQueryParameter(this._query, this._gl.QUERY_RESULT_AVAILABLE);
                var f = this._gl.getParameter(this._timerExt.GPU_DISJOINT_EXT);
                a && !f && (this._result = 1 === this._version ? this._timerExt.getQueryObjectEXT(this._query, this._timerExt.QUERY_RESULT_EXT) : this._gl.getQueryParameter(this._query, this._gl.QUERY_RESULT), this._result /= 1E9, this._hasResult = !0);
                (a ||
                    f) && this._DeleteQueryObject()
            }
        }
        HasResult() {
            return this._hasResult
        }
        GetResult() {
            if (!this._hasResult) throw Error("no result available");
            return this._result
        }
    }
    d.Gfx.WebGLTimeElapsedQuery = class {
        constructor(a) {
            this._renderer = a;
            this._frameNumber = a.GetFrameNumber();
            this._isActive = !1;
            this._parentQuery = null;
            this._isNested = !1;
            this._realQuery = null;
            this._queries = []
        }
        Release() {
            for (const a of this._queries) a instanceof b && a.Release();
            d.clearArray(this._queries);
            this._renderer = this._realQuery = this._parentQuery = null
        }
        BeginTimeElapsed() {
            if (this._isActive) throw Error("query already active");
            const a = this._renderer._GetTimeQueryStack();
            0 < a.length ? (this._isNested = !0, this._parentQuery = a[a.length - 1], this._parentQuery._EndReal(), this._parentQuery._queries.push(this)) : (this._isNested = !1, this._parentQuery = null);
            this._isActive = !0;
            a.push(this);
            this._StartReal()
        }
        EndTimeElapsed() {
            if (!this._isActive) throw Error("query not active");
            if (this._renderer._GetTimeQueryStack().pop() !== this) throw Error("can only end most nested query");
            this._isActive = !1;
            this._EndReal();
            this._parentQuery && (this._parentQuery._StartReal(),
                this._parentQuery = null)
        }
        _StartReal() {
            this._realQuery = d.New(b, this._renderer);
            this._queries.push(this._realQuery);
            this._realQuery.BeginTimeElapsed()
        }
        _EndReal() {
            this._realQuery.EndTimeElapsed();
            this._realQuery = null
        }
        CheckForResult() {
            for (const a of this._queries) a.CheckForResult()
        }
        IsNested() {
            return this._isNested
        }
        HasResult() {
            return this._queries.every(a => a.HasResult())
        }
        GetResult() {
            return this._queries.reduce((a, f) => a + f.GetResult(), 0)
        }
        GetFrameNumber() {
            return this._frameNumber
        }
    }
}
"use strict";
{
    const d = self.C3;
    d.Gfx.WebGLQueryResultBuffer = class {
        constructor(b, a = 1E3) {
            this._renderer = b;
            this._maxQueries = a;
            this._buffer = [];
            this._renderer._AddQueryResultBuffer(this)
        }
        Release() {
            this.Clear();
            this._renderer._RemoveQueryResultBuffer(this);
            this._renderer = null
        }
        Clear() {
            for (const b of this._buffer) b.Release();
            d.clearArray(this._buffer)
        }
        AddTimeElapsedQuery() {
            const b = new d.Gfx.WebGLTimeElapsedQuery(this._renderer);
            this._buffer.push(b);
            this._buffer.length > this._maxQueries && this._buffer.shift().Release();
            return b
        }
        CheckForResults(b) {
            for (const a of this._buffer) {
                if (a.GetFrameNumber() >=
                    b) break;
                if (a.IsNested()) break;
                a.CheckForResult()
            }
        }
        GetFrameRangeResultSum(b, a) {
            if (a <= b) return NaN;
            let f = 0;
            for (const c of this._buffer) {
                if (c.GetFrameNumber() >= a) break;
                if (!(c.GetFrameNumber() < b))
                    if (c.HasResult()) f += c.GetResult();
                    else return NaN
            }
            return f
        }
        DeleteAllBeforeFrameNumber(b) {
            for (let a = 0, f = this._buffer.length; a < f; ++a) {
                const c = this._buffer[a];
                if (c.GetFrameNumber() < b) c.Release();
                else {
                    0 < a && this._buffer.splice(0, a);
                    break
                }
            }
        }
    }
}
"use strict";
{
    const d = self.C3,
        b = self.glMatrix,
        a = b.vec3,
        f = b.vec4,
        c = b.mat4,
        e = {
            powerPreference: "default",
            enableGpuProfiling: !0,
            alpha: !1,
            lowLatency: !1,
            maxWebGLVersion: 2
        },
        g = new Set(["default", "low-power", "high-performance"]),
        h = new d.Quad(0, 0, 1, 0, 1, 1, 0, 1),
        l = a.fromValues(0, 0, 0),
        m = a.fromValues(0, 0, 0),
        p = c.create(),
        t = new d.Quad,
        q = new d.Rect;
    let r = null;
    d.isDebug && (self.debug_lose_context = function() {
        r ? r.loseContext() : console.warn("WEBGL_lose_context not supported")
    }, self.debug_restore_context = function() {
        r ? r.restoreContext() :
            console.warn("WEBGL_lose_context not supported")
    });
    const u = new Set;
    let x = -1;

    function y() {
        x = -1;
        for (const w of u) w.checkFunc() && (w.resolve(), u.delete(w));
        0 < u.size && (x = self.requestAnimationFrame(y))
    }

    function C(w, A, E) {
        if (2 <= E && (E = w.getContext("webgl2", A))) return {
            gl: E,
            version: 2
        };
        E = w.getContext("webgl", A);
        if (!E) try {
            E = w.getContext("experimental-webgl", A)
        } catch (K) {
            console.warn("Error requesting 'experimental-webgl' context: ", K)
        }
        return {
            gl: E,
            version: 1
        }
    }
    d.Gfx.WebGLRenderer = class extends d.Gfx.RendererBase {
        constructor(w,
            A) {
            super();
            A = Object.assign({}, e, A);
            if (!g.has(A.powerPreference)) throw Error("invalid power preference");
            let E = !1;
            const K = {
                alpha: !!A.alpha,
                depth: !1,
                antialias: !1,
                powerPreference: A.powerPreference,
                failIfMajorPerformanceCaveat: !0
            };
            A.lowLatency && (K.desynchronized = !0, K.preserveDrawingBuffer = !0);
            let O = C(w, K, A.maxWebGLVersion);
            O.gl || (E = !0, K.failIfMajorPerformanceCaveat = !1, O = C(w, K, A.maxWebGLVersion));
            if (!O.gl) throw Error("failed to initialise WebGL context");
            this._gl = w = O.gl;
            this._attribs = w.getContextAttributes();
            A.lowLatency && !this._attribs.desynchronized && console.info("[WebGLRenderer] Low-latency mode specified but is not supported here");
            this._versionString = w.getParameter(w.VERSION);
            this._version = O.version;
            this._lastBackbufferHeight = this._lastBackbufferWidth = 0;
            this._pointBuffer = this._indexBuffer = this._texcoordBuffer = this._vertexBuffer = null;
            this._vertexData = new Float32Array(8E3 * this.GetNumVertexComponents());
            this._indexData = new Uint16Array(12E3);
            this._texcoordData = new Float32Array(16E3);
            this._pointData =
                new Float32Array(32E3);
            this._lastVertexPtr = this._pointPtr = this._texPtr = this._vertexPtr = 0;
            this._spDeviceTransformTextureFill = this._lastProgram = null;
            this._batch = [];
            this._topOfBatch = this._batchPtr = 0;
            this._currentRenderTarget = null;
            this._lastPointZ = 0;
            this._batchState = d.New(d.Gfx.BatchState, this);
            this._lastColor = d.New(d.Color, 1, 1, 1, 1);
            this._lastTexture1 = this._lastTexture0 = null;
            this._lastDestBlend = this._lastSrcBlend = 0;
            this._lineWidth = 1;
            this._lineWidthStack = [this._lineWidth];
            this._lineCap = 1;
            this._lineCapStack = [this._lineCap];
            this._lineOffset = .5;
            this._lineOffsetStack = [this._lineOffset];
            this._isScissorViewport = !1;
            this._viewportScissorHeight = this._viewportScissorWidth = -1;
            this._lastPointTexCoords = new d.Rect;
            this._maxTextureSize = -1;
            this._highpPrecision = this._maxPointSize = this._minPointSize = 0;
            this._unmaskedRenderer = this._unmaskedVendor = "(unavailable)";
            this._extensions = [];
            this._hasMajorPerformanceCaveat = E;
            this._isInitialisingAfterContextRestored = !1;
            this._parallelShaderCompileExt = null;
            this._isGpuProfilingEnabled = !!A.enableGpuProfiling;
            this._timerExt = null;
            this._allQueryResultBuffers = new Set;
            this._timeQueryStack = [];
            this.FillIndexBufferData(this._indexData)
        }
        IsWebGL() {
            return !0
        }
        async InitState() {
            super.InitState();
            var w = this._gl,
                A = this.GetNumVertexComponents();
            this._lastColor.setRgba(1, 1, 1, 1);
            this._lastTexture1 = this._lastTexture0 = null;
            this._pointPtr = this._vertexPtr = 0;
            this._lastVertexPtr = 8E3 * A - 4 * A;
            d.clearArray(this._batch);
            this._topOfBatch = this._batchPtr = 0;
            this._currentRenderTarget = this._lastProgram = null;
            this._lastPointTexCoords.set(0,
                0, 1, 1);
            this._lastPointZ = 0;
            A = this._batchState;
            A.currentShader = null;
            A.currentFramebuffer = null;
            f.set(A.currentColor, 1, 1, 1, 1);
            A.clearColor.setRgba(0, 0, 0, 0);
            A.pointTexCoords.set(0, 0, 1, 1);
            w.clearColor(0, 0, 0, 0);
            w.clear(w.COLOR_BUFFER_BIT);
            w.enable(w.BLEND);
            w.blendFunc(w.ONE, w.ONE_MINUS_SRC_ALPHA);
            this._lastSrcBlend = w.ONE;
            this._lastDestBlend = w.ONE_MINUS_SRC_ALPHA;
            this._InitBlendModes(w);
            w.disable(w.CULL_FACE);
            w.disable(w.STENCIL_TEST);
            w.disable(w.DITHER);
            w.disable(w.DEPTH_TEST);
            this._pointBuffer = w.createBuffer();
            w.bindBuffer(w.ARRAY_BUFFER, this._pointBuffer);
            w.bufferData(w.ARRAY_BUFFER, this._pointData.byteLength, w.DYNAMIC_DRAW);
            this._vertexBuffer = w.createBuffer();
            w.bindBuffer(w.ARRAY_BUFFER, this._vertexBuffer);
            w.bufferData(w.ARRAY_BUFFER, this._vertexData.byteLength, w.DYNAMIC_DRAW);
            this._texcoordBuffer = w.createBuffer();
            w.bindBuffer(w.ARRAY_BUFFER, this._texcoordBuffer);
            w.bufferData(w.ARRAY_BUFFER, this._texcoordData.byteLength, w.DYNAMIC_DRAW);
            this._indexBuffer = w.createBuffer();
            w.bindBuffer(w.ELEMENT_ARRAY_BUFFER,
                this._indexBuffer);
            w.bufferData(w.ELEMENT_ARRAY_BUFFER, this._indexData, w.STATIC_DRAW);
            w.activeTexture(w.TEXTURE0);
            w.bindTexture(w.TEXTURE_2D, null);
            this._maxTextureSize = w.getParameter(w.MAX_TEXTURE_SIZE);
            A = w.getParameter(w.ALIASED_POINT_SIZE_RANGE);
            this._minPointSize = A[0];
            this._maxPointSize = A[1];
            A = w.getShaderPrecisionFormat(w.VERTEX_SHADER, w.HIGH_FLOAT);
            const E = w.getShaderPrecisionFormat(w.FRAGMENT_SHADER, w.HIGH_FLOAT);
            this._highpPrecision = A && E ? Math.min(A.precision, E.precision) : 0;
            2048 < this._maxPointSize &&
                (this._maxPointSize = 2048);
            this._extensions = w.getSupportedExtensions();
            if (A = w.getExtension("WEBGL_debug_renderer_info")) this._unmaskedVendor = w.getParameter(A.UNMASKED_VENDOR_WEBGL), this._unmaskedRenderer = w.getParameter(A.UNMASKED_RENDERER_WEBGL);
            this._parallelShaderCompileExt = w.getExtension("KHR_parallel_shader_compile");
            d.isDebug && (r = w.getExtension("WEBGL_lose_context"));
            if (this._isGpuProfilingEnabled)
                if (1 === this.GetWebGLVersionNumber()) {
                    if ("Chromium" !== d.Platform.BrowserEngine || 81 <= d.Platform.BrowserVersionNumber ||
                        "undefined" !== typeof document) this._timerExt = w.getExtension("EXT_disjoint_timer_query")
                } else this._timerExt = w.getExtension("EXT_disjoint_timer_query_webgl2") || w.getExtension("EXT_disjoint_timer_query");
            w = d.Gfx.WebGLShaderProgram;
            A = w.GetDefaultVertexShaderSource(!1);
            w = [
                [w.GetTextureFillFragmentShaderSource(), A, "<default>"],
                [w.GetTextureFillFragmentShaderSource(), A, "<default-device-transform>"],
                [w.GetPointFragmentShaderSource(), w.GetPointVertexShaderSource(), "<point>"],
                [w.GetColorFillFragmentShaderSource(),
                    A, "<fill>"
                ],
                [w.GetLinearGradientFillFragmentShaderSource(), A, "<lineargradient>"],
                [w.GetHardEllipseFillFragmentShaderSource(), A, "<hardellipse>"],
                [w.GetHardEllipseOutlineFragmentShaderSource(), A, "<hardellipseoutline>"],
                [w.GetSmoothEllipseFillFragmentShaderSource(), A, "<smoothellipse>"],
                [w.GetSmoothEllipseOutlineFragmentShaderSource(), A, "<smoothellipseoutline>"],
                [w.GetSmoothLineFillFragmentShaderSource(), A, "<smoothline>"],
                [w.GetTilemapFragmentShaderSource(), w.GetDefaultVertexShaderSource(!0), "<tilemap>"]
            ];
            w = await Promise.all(w.map(K => this.CreateShaderProgram({
                src: K[0]
            }, K[1], K[2])));
            this._spTextureFill = w[0];
            this._spDeviceTransformTextureFill = w[1];
            this._spPoints = w[2];
            this._spColorFill = w[3];
            this._spLinearGradientFill = w[4];
            this._spHardEllipseFill = w[5];
            this._spHardEllipseOutline = w[6];
            this._spSmoothEllipseFill = w[7];
            this._spSmoothEllipseOutline = w[8];
            this._spSmoothLineFill = w[9];
            this._spTilemapFill = w[10];
            this.SetTextureFillMode()
        }
        async CreateShaderProgram(w, A, E) {
            w = await d.Gfx.WebGLShaderProgram.Create(this,
                w, A, E);
            this._AddShaderProgram(w);
            return w
        }
        ResetLastProgram() {
            this._lastProgram = null
        }
        SetSize(w, A, E) {
            if (this._width !== w || this._height !== A || E) {
                this.EndBatch();
                E = this._gl;
                var K = this._batchState;
                this._width = w;
                this._height = A;
                w = this.GetScissoredViewportWidth();
                A = this.GetScissoredViewportHeight();
                this._UpdateViewportRenderer(w, A, this._width, this._height);
                this._UpdateViewportBatch(w, A, this._matP);
                this._spDeviceTransformTextureFill && (E.useProgram(this._spDeviceTransformTextureFill.GetShaderProgram()), this._spDeviceTransformTextureFill._UpdateDeviceTransformUniforms(this._matP),
                    this._lastProgram = this._spDeviceTransformTextureFill, this._batchState.currentShader = this._spDeviceTransformTextureFill);
                E.bindTexture(E.TEXTURE_2D, null);
                E.activeTexture(E.TEXTURE1);
                E.bindTexture(E.TEXTURE_2D, null);
                E.activeTexture(E.TEXTURE0);
                this._lastTexture1 = this._lastTexture0 = null;
                this._currentRenderTarget && this._currentRenderTarget._Resize(this._width, this._height);
                E.bindFramebuffer(E.FRAMEBUFFER, null);
                this._currentRenderTarget = null;
                K.currentFramebuffer = null
            }
        }
        _UpdateViewportRenderer(w, A, E, K) {
            this._cam[2] =
                100;
            c.lookAt(this._matMV, this._cam, this._look, this._up);
            c.perspective(this._matP, 45, w / A, this.GetNearZ(), this.GetFarZ());
            const O = [0, 0],
                G = [0, 0],
                J = self.devicePixelRatio;
            this.Project(0, 0, w, A, O);
            this.Project(1, 1, w, A, G);
            this._worldScale[0] = J / (G[0] - O[0]);
            this._worldScale[1] = -J / (G[1] - O[1]);
            this._lastBackbufferWidth = E;
            this._lastBackbufferHeight = K
        }
        _UpdateViewportBatch(w, A, E) {
            const K = this._batchState;
            this._gl.viewport(0, 0, w, A);
            w = this._allShaderPrograms;
            A = K.currentShader;
            for (let O = 0, G = w.length; O < G; ++O) {
                const J =
                    w[O];
                J === A ? J.UpdateMatP(E, !0) : J.SetMatPStale()
            }
            c.copy(K.currentMatP, E)
        }
        SetViewportScissor(w, A) {
            const E = this._gl;
            if (this._width === w && this._height === A) this._isScissorViewport && (this.EndBatch(), E.disable(E.SCISSOR_TEST), this._isScissorViewport = !1, this._viewportScissorHeight = this._viewportScissorWidth = -1, this.SetSize(this._width, this._height, !0));
            else if (this._isScissorViewport || (this.EndBatch(), E.enable(E.SCISSOR_TEST), this._isScissorViewport = !0), this._viewportScissorWidth !== w || this._viewportScissorHeight !==
                A) this.EndBatch(), E.scissor(0, 0, w, A), this._viewportScissorWidth = w, this._viewportScissorHeight = A, this.SetSize(this._width, this._height, !0)
        }
        RemoveViewportScissor() {
            const w = this._gl;
            this._isScissorViewport && (this.EndBatch(), w.disable(w.SCISSOR_TEST), this._isScissorViewport = !1);
            this._viewportScissorHeight = this._viewportScissorWidth = -1
        }
        GetScissoredViewportWidth() {
            return this._isScissorViewport ? this._viewportScissorWidth : this.GetWidth()
        }
        GetScissoredViewportHeight() {
            return this._isScissorViewport ? this._viewportScissorHeight :
                this.GetHeight()
        }
        UpdateModelView() {
            d.Gfx.AreMat4sEqual(this._lastMV, this._matMV) || (this.PushBatch().InitUpdateModelView(this._matMV), c.copy(this._lastMV, this._matMV), this._topOfBatch = 0)
        }
        GetBatchState() {
            return this._batchState
        }
        PushBatch() {
            const w = this._batch;
            this._batchPtr === w.length && w.push(new d.Gfx.WebGLBatchJob(this._batchState));
            return w[this._batchPtr++]
        }
        EndBatch() {
            0 === this._batchPtr || this.IsContextLost() || (this._WriteBuffers(), this._ExecuteBatch(), this._topOfBatch = this._pointPtr = this._texPtr =
                this._vertexPtr = this._batchPtr = 0)
        }
        _WriteBuffers() {
            const w = this._gl;
            0 < this._pointPtr && (w.bindBuffer(w.ARRAY_BUFFER, this._pointBuffer), w.bufferSubData(w.ARRAY_BUFFER, 0, this._pointData.subarray(0, this._pointPtr)));
            0 < this._vertexPtr && (w.bindBuffer(w.ARRAY_BUFFER, this._vertexBuffer), w.bufferSubData(w.ARRAY_BUFFER, 0, this._vertexData.subarray(0, this._vertexPtr)), w.bindBuffer(w.ARRAY_BUFFER, this._texcoordBuffer), w.bufferSubData(w.ARRAY_BUFFER, 0, this._texcoordData.subarray(0, this._texPtr)))
        }
        _ExecuteBatch() {
            const w =
                this._batch;
            for (let A = 0, E = this._batchPtr; A < E; ++A) w[A].Run()
        }
        GetOpacity() {
            return this._lastColor.getA()
        }
        SetColorRgba(w, A, E, K) {
            const O = this._lastColor;
            O.equalsRgba(w, A, E, K) || (O.setRgba(w, A, E, K), this.PushBatch().InitSetColor(O), this._topOfBatch = 0, this._currentStateGroup = null)
        }
        SetOpacity(w) {
            const A = this._lastColor;
            A.getA() !== w && (A.setA(w), this.PushBatch().InitSetColor(A), this._topOfBatch = 0, this._currentStateGroup = null)
        }
        SetColor(w) {
            const A = this._lastColor;
            A.equals(w) || (A.set(w), this.PushBatch().InitSetColor(A),
                this._topOfBatch = 0, this._currentStateGroup = null)
        }
        ResetColor() {
            this.SetColorRgba(1, 1, 1, 1)
        }
        GetColor() {
            return this._lastColor
        }
        SetTexture(w) {
            w !== this._lastTexture0 && (this.PushBatch().InitSetTexture(w), this._lastTexture0 = w, this._topOfBatch = 0)
        }
        _ResetLastTexture() {
            this._lastTexture0 = null
        }
        SetBlendMode(w) {
            w = this._GetBlendByIndex(w);
            this._SetBlend(w[0], w[1])
        }
        SetNamedBlendMode(w) {
            w = this.GetNamedBlend(w);
            this._SetBlend(w.srcBlend, w.destBlend)
        }
        _SetBlend(w, A) {
            if (w !== this._lastSrcBlend || A !== this._lastDestBlend) this.PushBatch().InitSetBlend(w,
                A), this._lastSrcBlend = w, this._lastDestBlend = A, this._topOfBatch = 0, this._currentStateGroup = null
        }
        IsPremultipliedAlphaBlend() {
            return this._lastSrcBlend === this._gl.ONE && this._lastDestBlend === this._gl.ONE_MINUS_SRC_ALPHA
        }
        SetAlphaBlend() {
            this._SetBlend(this._gl.ONE, this._gl.ONE_MINUS_SRC_ALPHA)
        }
        SetNoPremultiplyAlphaBlend() {
            this._SetBlend(this._gl.SRC_ALPHA, this._gl.ONE_MINUS_SRC_ALPHA)
        }
        SetCopyBlend() {
            this._SetBlend(this._gl.ONE, this._gl.ZERO)
        }
        Rect(w) {
            this.Rect2(w.getLeft(), w.getTop(), w.getRight(), w.getBottom())
        }
        Rect2(w,
            A, E, K) {
            this.Quad2(w, A, E, A, E, K, w, K)
        }
        _ExtendQuadBatch() {
            let w = this._vertexPtr;
            w >= this._lastVertexPtr && (this.EndBatch(), w = 0);
            1 === this._topOfBatch ? this._batch[this._batchPtr - 1]._indexCount += 6 : (this.PushBatch().InitQuad(w, 6), this._topOfBatch = 1)
        }
        _WriteQuadToVertexBuffer(w) {
            w.writeToTypedArray3D(this._vertexData, this._vertexPtr, this._baseZ + this._currentZ);
            this._vertexPtr += 12
        }
        Quad(w) {
            this._ExtendQuadBatch();
            this._WriteQuadToVertexBuffer(w);
            h.writeToTypedArray(this._texcoordData, this._texPtr);
            this._texPtr +=
                8
        }
        Quad2(w, A, E, K, O, G, J, P) {
            this._ExtendQuadBatch();
            const R = this._vertexData;
            let T = this._vertexPtr;
            const X = this._baseZ + this._currentZ;
            R[T++] = w;
            R[T++] = A;
            R[T++] = X;
            R[T++] = E;
            R[T++] = K;
            R[T++] = X;
            R[T++] = O;
            R[T++] = G;
            R[T++] = X;
            R[T++] = J;
            R[T++] = P;
            R[T++] = X;
            this._vertexPtr = T;
            h.writeToTypedArray(this._texcoordData, this._texPtr);
            this._texPtr += 8
        }
        Quad3(w, A) {
            this._ExtendQuadBatch();
            this._WriteQuadToVertexBuffer(w);
            A.writeAsQuadToTypedArray(this._texcoordData, this._texPtr);
            this._texPtr += 8
        }
        Quad4(w, A) {
            this._ExtendQuadBatch();
            this._WriteQuadToVertexBuffer(w);
            A.writeToTypedArray(this._texcoordData, this._texPtr);
            this._texPtr += 8
        }
        FullscreenQuad(w, A) {
            c.copy(p, this._lastMV);
            a.copy(l, this._cam);
            a.copy(m, this._look);
            this._cam[0] = 0;
            this._cam[1] = 0;
            this._cam[2] = 100 * self.devicePixelRatio;
            this._look[0] = 0;
            this._look[1] = 0;
            this._look[2] = 0;
            this.ResetModelView();
            this.UpdateModelView();
            if (this._isScissorViewport) {
                w = this._viewportScissorWidth / 2;
                var E = this._viewportScissorHeight / 2;
                q.set(-w, E, -w + this._viewportScissorWidth, E - this._viewportScissorHeight);
                t.setFromRect(q);
                q.set(0, 0, this._viewportScissorWidth / this._width, this._viewportScissorHeight / this._height);
                this.Quad3(t, q)
            } else if ("crop" === w && this._currentRenderTarget && A) {
                w = this._width / 2;
                E = this._height / 2;
                const G = A.GetWidth();
                A = A.GetHeight();
                var K = this._currentRenderTarget.GetWidth(),
                    O = this._currentRenderTarget.GetHeight();
                K = Math.min(K, G);
                const J = Math.min(O, A),
                    P = Math.max(A - O, 0);
                O = Math.max(O - A, 0);
                q.set(-w, E - O, -w + K, E - J - O);
                t.setFromRect(q);
                q.set(0, P, K, J + P);
                q.divide(G, A);
                this.Quad3(t, q)
            } else {
                let [G,
                    J
                ] = this.GetRenderTargetSize(this._currentRenderTarget);
                w = G / 2;
                E = J / 2;
                this.Rect2(-w, E, w, -E)
            }
            c.copy(this._matMV, p);
            a.copy(this._cam, l);
            a.copy(this._look, m);
            this.UpdateModelView()
        }
        ConvexPoly(w) {
            var A = w.length / 2;
            if (3 > A) throw Error("need at least 3 points");
            A -= 2;
            const E = A - 1,
                K = w[0],
                O = w[1];
            for (let G = 0; G < A; G += 2) {
                const J = 2 * G,
                    P = w[J + 2],
                    R = w[J + 3],
                    T = w[J + 4],
                    X = w[J + 5];
                G === E ? this.Quad2(K, O, P, R, T, X, T, X) : this.Quad2(K, O, P, R, T, X, w[J + 6], w[J + 7])
            }
        }
        Line(w, A, E, K) {
            var O = d.angleTo(w, A, E, K),
                G = .5 * this._lineWidth;
            const J = Math.sin(O) *
                G;
            O = Math.cos(O) * G;
            G = this._lineCap;
            2 === G ? this.LinePreCalc_LineCap2(w, A, E, K, J, O) : 1 === G ? this.LinePreCalc_LineCap1(w, A, E, K, J, O) : this.LinePreCalc_LineCap0(w, A, E, K, J, O)
        }
        LinePreCalc_LineCap2(w, A, E, K, O, G) {
            var J = this._lineOffset;
            w = w + J - G;
            A = A + J - O;
            E = E + J + G;
            K = K + J + O;
            J = 2 * G;
            const P = 2 * O;
            this.Quad2(w + O, A - G, E + O, K - G, E - O - J, K + G - P, w - O + J, A + G + P)
        }
        LinePreCalc_LineCap1(w, A, E, K, O, G) {
            const J = this._lineOffset;
            w = w + J - G;
            A = A + J - O;
            E = E + J + G;
            K = K + J + O;
            this.Quad2(w + O, A - G, E + O, K - G, E - O, K + G, w - O, A + G)
        }
        LinePreCalc_LineCap0(w, A, E, K, O, G) {
            const J = this._lineOffset;
            w += J;
            A += J;
            E += J;
            K += J;
            this.Quad2(w + O, A - G, E + O, K - G, E - O, K + G, w - O, A + G)
        }
        TexturedLine(w, A, E, K, O, G) {
            var J = d.angleTo(w, A, E, K),
                P = .5 * this._lineWidth;
            const R = Math.sin(J) * P;
            J = Math.cos(J) * P;
            P = this._lineCap;
            2 === P ? this.TexturedLinePreCalc_LineCap2(w, A, E, K, R, J, O, G) : 1 === P ? this.TexturedLinePreCalc_LineCap1(w, A, E, K, R, J, O, G) : this.TexturedLinePreCalc_LineCap0(w, A, E, K, R, J, O, G)
        }
        TexturedLinePreCalc_LineCap2(w, A, E, K, O, G, J, P) {
            var R = this._lineOffset;
            w = w + R - G;
            A = A + R - O;
            E = E + R + G;
            K = K + R + O;
            R = 2 * G;
            const T = 2 * O;
            t.set(w + O, A - G, E + O, K - G, E - O - R,
                K + G - T, w - O + R, A + G + T);
            q.set(J, 0, P, 0);
            this.Quad3(t, q)
        }
        TexturedLinePreCalc_LineCap1(w, A, E, K, O, G, J, P) {
            const R = this._lineOffset;
            w = w + R - G;
            A = A + R - O;
            E = E + R + G;
            K = K + R + O;
            t.set(w + O, A - G, E + O, K - G, E - O, K + G, w - O, A + G);
            q.set(J, 0, P, 0);
            this.Quad3(t, q)
        }
        TexturedLinePreCalc_LineCap0(w, A, E, K, O, G, J, P) {
            const R = this._lineOffset;
            w += R;
            A += R;
            E += R;
            K += R;
            t.set(w + O, A - G, E + O, K - G, E - O, K + G, w - O, A + G);
            q.set(J, 0, P, 0);
            this.Quad3(t, q)
        }
        LineRect(w, A, E, K) {
            const O = .5 * this._lineWidth,
                G = this._lineCap;
            2 === G ? this._LineRectPreCalc_LineCap2(w, A, E, K, O) : 1 === G ? this._LineRectPreCalc_LineCap1(w,
                A, E, K, O) : this._LineRectPreCalc_LineCap0(w, A, E, K, O)
        }
        _LineRectPreCalc_LineCap2(w, A, E, K, O) {
            this.LinePreCalc_LineCap2(w, A, E, A, 0, O);
            this.LinePreCalc_LineCap2(E, A, E, K, O, 0);
            this.LinePreCalc_LineCap2(E, K, w, K, 0, -O);
            this.LinePreCalc_LineCap2(w, K, w, A, -O, 0)
        }
        _LineRectPreCalc_LineCap1(w, A, E, K, O) {
            this.LinePreCalc_LineCap1(w, A, E, A, 0, O);
            this.LinePreCalc_LineCap1(E, A, E, K, O, 0);
            this.LinePreCalc_LineCap1(E, K, w, K, 0, -O);
            this.LinePreCalc_LineCap1(w, K, w, A, -O, 0)
        }
        _LineRectPreCalc_LineCap0(w, A, E, K, O) {
            this.LinePreCalc_LineCap0(w,
                A, E, A, 0, O);
            this.LinePreCalc_LineCap0(E, A, E, K, O, 0);
            this.LinePreCalc_LineCap0(E, K, w, K, 0, -O);
            this.LinePreCalc_LineCap0(w, K, w, A, -O, 0)
        }
        LineRect2(w) {
            this.LineRect(w.getLeft(), w.getTop(), w.getRight(), w.getBottom())
        }
        LineQuad(w) {
            var A = d.angleTo(w.getTlx(), w.getTly(), w.getTrx(), w.getTry()),
                E = .5 * this._lineWidth;
            const K = Math.sin(A) * E;
            A = Math.cos(A) * E;
            E = this._lineCap;
            2 === E ? this._LineQuadPreCalc_LineCap2(w, K, A) : 1 === E ? this._LineQuadPreCalc_LineCap1(w, K, A) : this._LineQuadPreCalc_LineCap0(w, K, A)
        }
        _LineQuadPreCalc_LineCap2(w,
            A, E) {
            this.LinePreCalc_LineCap2(w.getTlx(), w.getTly(), w.getTrx(), w.getTry(), A, E);
            this.LinePreCalc_LineCap2(w.getTrx(), w.getTry(), w.getBrx(), w.getBry(), E, -A);
            this.LinePreCalc_LineCap2(w.getBrx(), w.getBry(), w.getBlx(), w.getBly(), -A, -E);
            this.LinePreCalc_LineCap2(w.getBlx(), w.getBly(), w.getTlx(), w.getTly(), -E, A)
        }
        _LineQuadPreCalc_LineCap1(w, A, E) {
            this.LinePreCalc_LineCap1(w.getTlx(), w.getTly(), w.getTrx(), w.getTry(), A, E);
            this.LinePreCalc_LineCap1(w.getTrx(), w.getTry(), w.getBrx(), w.getBry(), E, -A);
            this.LinePreCalc_LineCap1(w.getBrx(),
                w.getBry(), w.getBlx(), w.getBly(), -A, -E);
            this.LinePreCalc_LineCap1(w.getBlx(), w.getBly(), w.getTlx(), w.getTly(), -E, A)
        }
        _LineQuadPreCalc_LineCap0(w, A, E) {
            this.LinePreCalc_LineCap0(w.getTlx(), w.getTly(), w.getTrx(), w.getTry(), A, E);
            this.LinePreCalc_LineCap0(w.getTrx(), w.getTry(), w.getBrx(), w.getBry(), E, -A);
            this.LinePreCalc_LineCap0(w.getBrx(), w.getBry(), w.getBlx(), w.getBly(), -A, -E);
            this.LinePreCalc_LineCap0(w.getBlx(), w.getBly(), w.getTlx(), w.getTly(), -E, A)
        }
        SetLineWidth(w) {
            this._lineWidth = w;
            this._lineWidthStack[this._lineWidthStack.length -
                1] = w
        }
        GetLineWidth() {
            return this._lineWidth
        }
        PushLineWidth(w) {
            if (100 <= this._lineWidthStack.length) throw Error("pushed too many line widths - check push/pop pairs");
            this._lineWidthStack.push(w);
            this._lineWidth = w
        }
        PopLineWidth() {
            if (1 >= this._lineWidthStack.length) throw Error("cannot pop last line width - check push/pop pairs");
            this._lineWidthStack.pop();
            this._lineWidth = this._lineWidthStack[this._lineWidthStack.length - 1]
        }
        SetLineCapButt() {
            this._lineCap = 0;
            this._lineCapStack[this._lineCapStack.length - 1] = 0
        }
        SetLineCapSquare() {
            this._lineCap =
                1;
            this._lineCapStack[this._lineCapStack.length - 1] = 0
        }
        SetLineCapZag() {
            this._lineCap = 2;
            this._lineCapStack[this._lineCapStack.length - 1] = 0
        }
        PushLineCap(w) {
            if ("butt" === w) this.PushLineCapButt();
            else if ("square" === w) this.PushLineCapSquare();
            else if ("zag" === w) this.PushLineCapZag();
            else throw Error("invalid line cap");
        }
        PushLineCapButt() {
            if (100 <= this._lineCapStack.length) throw Error("pushed too many line caps - check push/pop pairs");
            this._lineCapStack.push(0);
            this._lineCap = 0
        }
        PushLineCapSquare() {
            if (100 <= this._lineCapStack.length) throw Error("pushed too many line caps - check push/pop pairs");
            this._lineCapStack.push(1);
            this._lineCap = 1
        }
        PushLineCapZag() {
            if (100 <= this._lineCapStack.length) throw Error("pushed too many line caps - check push/pop pairs");
            this._lineCapStack.push(2);
            this._lineCap = 2
        }
        PopLineCap() {
            if (1 >= this._lineCapStack.length) throw Error("cannot pop last line cap - check push/pop pairs");
            this._lineCapStack.pop();
            this._lineCap = this._lineCapStack[this._lineCapStack.length - 1]
        }
        SetLineOffset(w) {
            this._lineOffset = w;
            this._lineOffsetStack[this._lineOffsetStack.length - 1] = w
        }
        GetLineOffset() {
            return this._lineOffset
        }
        PushLineOffset(w) {
            if (100 <=
                this._lineOffsetStack.length) throw Error("pushed too many line offsets - check push/pop pairs");
            this._lineOffsetStack.push(w);
            this._lineOffset = w
        }
        PopLineOffset() {
            if (1 >= this._lineOffsetStack.length) throw Error("cannot pop last line offset - check push/pop pairs");
            this._lineOffsetStack.pop();
            this._lineOffset = this._lineOffsetStack[this._lineOffsetStack.length - 1]
        }
        StartRenderingPoints(w) {
            this._lastPointTexCoords.equals(w) || (this._lastPointTexCoords.copy(w), this.PushBatch().InitSetPointTexCoords(w), this._topOfBatch =
                0)
        }
        FinishRenderingPoints() {}
        Point(w, A, E, K) {
            7996 <= this._pointPtr && this.EndBatch();
            let O = this._pointPtr;
            var G = this._baseZ + this._currentZ;
            2 === this._topOfBatch && this._lastPointZ === G ? this._batch[this._batchPtr - 1]._indexCount++ : (this.PushBatch().InitPoints(O, G), this._topOfBatch = 2, this._lastPointZ = G);
            G = this._pointData;
            G[O++] = w;
            G[O++] = A;
            G[O++] = E;
            G[O++] = K;
            this._pointPtr = O
        }
        SetProgram(w) {
            this._lastProgram !== w && (this.PushBatch().InitSetProgram(w), this._lastProgram = w, this._topOfBatch = 0, this._currentStateGroup =
                null)
        }
        SetDeviceTransformTextureFillMode() {
            this.SetProgram(this._spDeviceTransformTextureFill)
        }
        SetGradientColor(w) {
            this.PushBatch().InitSetGradientColor(w);
            this._topOfBatch = 0
        }
        SetEllipseParams(w, A, E = 1) {
            this.PushBatch().InitSetEllipseParams(w, A, E);
            this._topOfBatch = 0
        }
        SetTilemapInfo(w, A, E, K, O, G, J) {
            if (this._lastProgram !== this._spTilemapFill) throw Error("must set tilemap fill mode first");
            this.PushBatch().InitSetTilemapInfo(w, A, E, K, O, G, J);
            this._topOfBatch = 0
        }
        SetProgramParameters(w, A, E, K, O, G, J, P, R, T, X) {
            const aa =
                this._lastProgram;
            var ea = aa._hasAnyOptionalUniforms;
            const sa = !!X.length;
            if (ea && !aa.AreOptionalUniformsAlreadySetInBatch(A, E, K, O, G, J, P, R, T) || sa && !aa.AreCustomParametersAlreadySetInBatch(X)) {
                var ia = this.PushBatch();
                ia.InitSetProgramParameters();
                ea && (aa.SetOptionalUniformsInBatch(A, E, K, O, G, J, P, R, T), ea = ia._mat4param, ea[0] = G, ea[1] = J, A.writeToTypedArray(ea, 2), ea[6] = P, ea[7] = R, E.writeToTypedArray(ea, 12), A = ia._colorParam, O.writeToTypedArray(A, 0), O = A[1], A[1] = A[3], A[3] = O, K.writeToTypedArray(ia._srcOriginRect,
                    0), ia._startIndex = T, aa._uSamplerBack.IsUsed() ? ia._texParam = w ? w.GetTexture() : null : ia._texParam = null);
                sa && (aa.SetCustomParametersInBatch(X), d.shallowAssignArray(ia._shaderParams, X));
                this._topOfBatch = 0
            }
        }
        ClearRgba(w, A, E, K) {
            this.PushBatch().InitClearSurface2(w, A, E, K);
            this._topOfBatch = 0
        }
        Clear(w) {
            this.PushBatch().InitClearSurface(w);
            this._topOfBatch = 0
        }
        ClearRect4(w, A, E, K, O, G, J, P) {
            0 > E || 0 > K || (this.PushBatch().InitClearRect(w, A, E, K, O, G, J, P), this._topOfBatch = 0)
        }
        Start() {}
        Finish() {
            super.Finish();
            this._gl.flush()
        }
        CheckForQueryResults() {
            for (const w of this._allQueryResultBuffers) w.CheckForResults(this._frameNumber)
        }
        IsContextLost() {
            return !this._gl ||
                this._gl.isContextLost() || this._isInitialisingAfterContextRestored
        }
        OnContextLost() {
            super.OnDeviceOrContextLost();
            d.Gfx.WebGLRendererTexture.OnContextLost();
            d.Gfx.WebGLRenderTarget.OnContextLost();
            d.Gfx.RendererText.OnContextLost();
            for (const w of this._allQueryResultBuffers) w.Clear();
            this._extensions = [];
            this._parallelShaderCompileExt = this._timerExt = null;
            this._unmaskedRenderer = this._unmaskedVendor = "(unavailable)";
            this._spDeviceTransformTextureFill = this._lastProgram = null;
            for (const w of this._stateGroups.values()) w.OnContextLost()
        }
        async OnContextRestored() {
            this._isInitialisingAfterContextRestored = !0;
            await this.InitState();
            this._isInitialisingAfterContextRestored = !1;
            for (const w of this._stateGroups.values()) w.OnContextRestored(this);
            this.SetSize(this._width, this._height, !0)
        }
        CreateStaticTexture(w, A) {
            if (this.IsContextLost()) throw Error("context lost");
            this.EndBatch();
            const E = d.New(d.Gfx.WebGLRendererTexture, this);
            E._CreateStatic(w, A);
            return E
        }
        CreateStaticTextureAsync(w, A) {
            if (this.IsContextLost()) return Promise.reject("context lost");
            A = Object.assign({}, A);
            const E = A.wrapX && "clamp-to-edge" !== A.wrapX ||
                A.wrapY && "clamp-to-edge" !== A.wrapY;
            if (!d.Supports.ImageBitmapOptions || !this.SupportsNPOTTextures() && E) return d.Supports.ImageBitmap ? createImageBitmap(w).then(K => d.Asyncify(() => this.CreateStaticTexture(K, A))) : w instanceof Blob ? d.BlobToImage(w, !0).then(K => this.CreateStaticTextureAsync(K, A)) : "undefined" !== typeof HTMLImageElement && w instanceof HTMLImageElement && "function" === typeof w.decode ? w.decode().then(() => d.Asyncify(() => this.CreateStaticTexture(w, A))) : d.Asyncify(() => this.CreateStaticTexture(w, A));
            A.premultiplyAlpha = !1;
            return createImageBitmap(w, {
                premultiplyAlpha: "premultiply"
            }).then(K => d.Asyncify(() => this.CreateStaticTexture(K, A)))
        }
        CreateDynamicTexture(w, A, E) {
            this.EndBatch();
            const K = d.New(d.Gfx.WebGLRendererTexture, this);
            K._CreateDynamic(w, A, E);
            return K
        }
        UpdateTexture(w, A, E) {
            this.EndBatch();
            A._Update(w, E)
        }
        DeleteTexture(w) {
            w && (w.SubtractReference(), 0 < w.GetReferenceCount() || (this.EndBatch(), w === this._lastTexture0 && (this._gl.bindTexture(this._gl.TEXTURE_2D, null), this._lastTexture0 = null), w === this._lastTexture1 &&
                (this._gl.activeTexture(this._gl.TEXTURE1), this._gl.bindTexture(this._gl.TEXTURE_2D, null), this._gl.activeTexture(this._gl.TEXTURE0), this._lastTexture1 = null), w._Delete()))
        }
        CreateRenderTarget(w) {
            let A = this._width,
                E = this._height,
                K = !0;
            w && ("number" === typeof w.width && (A = w.width, K = !1), "number" === typeof w.height && (E = w.height, K = !1));
            if (0 >= A || 0 >= E) throw Error("invalid size");
            this.EndBatch();
            const O = d.New(d.Gfx.WebGLRenderTarget, this);
            O._Create(A, E, Object.assign({
                isDefaultSize: K
            }, w));
            this._currentRenderTarget =
                null;
            this._batchState.currentFramebuffer = null;
            return O
        }
        SetRenderTarget(w) {
            if (w !== this._currentRenderTarget) {
                if (w) {
                    w.IsDefaultSize() && w._Resize(this._width, this._height);
                    var A = w.GetWidth();
                    var E = w.GetHeight();
                    var K = A;
                    var O = E
                } else A = this._width, E = this._height, K = this.GetScissoredViewportWidth(), O = this.GetScissoredViewportHeight();
                var G = this._lastBackbufferWidth !== A || this._lastBackbufferHeight !== E;
                G && this._UpdateViewportRenderer(K, O, A, E);
                this.PushBatch().InitSetRenderTarget(w, G, this._matP);
                this._currentRenderTarget =
                    w;
                this._topOfBatch = 0
            }
        }
        GetRenderTarget() {
            return this._currentRenderTarget
        }
        GetRenderTargetSize(w) {
            return w ? [w.GetWidth(), w.GetHeight()] : [this._width, this._height]
        }
        CopyRenderTarget(w, A = "stretch") {
            2 > this._version || this._currentRenderTarget && 0 < this._currentRenderTarget.GetMultisampling() ? (this.SetCopyBlend(), this.ResetColor(), this.DrawRenderTarget(w, A)) : (this.PushBatch().InitBlitFramebuffer(w, this._currentRenderTarget, A), this._topOfBatch = 0)
        }
        DrawRenderTarget(w, A = "stretch") {
            w = w.GetTexture();
            if (!w) throw Error("not a texture-backed render target");
            this.SetTexture(w);
            this.FullscreenQuad(A, w)
        }
        InvalidateRenderTarget(w) {
            2 > this._version || (this.PushBatch().InitInvalidateFramebuffer(w._GetFramebuffer()), this._topOfBatch = 0)
        }
        DeleteRenderTarget(w) {
            this.SetRenderTarget(null);
            this.EndBatch();
            const A = w.GetTexture();
            A === this._lastTexture0 && (this._gl.bindTexture(this._gl.TEXTURE_2D, null), this._lastTexture0 = null);
            A === this._lastTexture1 && (this._gl.activeTexture(this._gl.TEXTURE1), this._gl.bindTexture(this._gl.TEXTURE_2D, null), this._gl.activeTexture(this._gl.TEXTURE0),
                this._lastTexture1 = null);
            w._Delete()
        }
        async ReadBackRenderTargetToImageData(w, A, E) {
            this.EndBatch();
            const K = this._currentRenderTarget;
            if (w) {
                var O = w.GetWidth();
                var G = w.GetHeight();
                var J = w._GetFramebuffer()
            } else O = this.GetWidth(), G = this.GetHeight(), J = null;
            let P = w = 0;
            var R = O,
                T = G;
            E && (w = d.clamp(Math.floor(E.getLeft()), 0, O - 1), P = d.clamp(Math.floor(E.getTop()), 0, G - 1), R = E.width(), R = 0 === R ? O - w : d.clamp(Math.floor(R), 0, O - w), T = E.height(), T = 0 === T ? G - P : d.clamp(Math.floor(T), 0, G - P), P = G - (P + T));
            const X = this._gl;
            X.bindFramebuffer(X.FRAMEBUFFER,
                J);
            G = () => {
                X.bindFramebuffer(X.FRAMEBUFFER, null);
                this._currentRenderTarget = null;
                this._batchState.currentFramebuffer = null;
                this.SetRenderTarget(K)
            };
            if (!A && 2 <= this.GetWebGLVersionNumber()) {
                X.bindFramebuffer(X.READ_FRAMEBUFFER, J);
                J = X.createBuffer();
                E = R * T * 4;
                O = X.PIXEL_PACK_BUFFER;
                X.bindBuffer(O, J);
                X.bufferData(O, E, X.STREAM_READ);
                X.readPixels(w, P, R, T, X.RGBA, X.UNSIGNED_BYTE, 0);
                X.bindFramebuffer(X.READ_FRAMEBUFFER, null);
                X.bindBuffer(O, null);
                G();
                const aa = X.fenceSync(X.SYNC_GPU_COMMANDS_COMPLETE, 0);
                await this._WaitForObjectReady(() =>
                    X.getSyncParameter(aa, X.SYNC_STATUS) === X.SIGNALED);
                X.deleteSync(aa);
                A = new ImageData(R, T);
                X.bindBuffer(O, J);
                X.getBufferSubData(O, 0, new Uint8Array(A.data.buffer), 0, E);
                X.bindBuffer(O, null);
                X.deleteBuffer(J)
            } else A = new ImageData(R, T), X.readPixels(w, P, R, T, X.RGBA, X.UNSIGNED_BYTE, new Uint8Array(A.data.buffer)), G();
            return A
        }
        StartQuery(w) {
            this.SupportsGPUProfiling() && (this.PushBatch().InitStartQuery(w), this._topOfBatch = 0)
        }
        EndQuery(w) {
            this.SupportsGPUProfiling() && (this.PushBatch().InitEndQuery(w), this._topOfBatch =
                0)
        }
        _WaitForObjectReady(w) {
            const A = new Promise(E => u.add({
                resolve: E,
                checkFunc: w
            })); - 1 === x && (x = self.requestAnimationFrame(y));
            return A
        }
        IsDesynchronized() {
            return !!this._attribs.desynchronized
        }
        GetEstimatedBackBufferMemoryUsage() {
            return this._width * this._height * (this._attribs.alpha ? 4 : 3)
        }
        GetEstimatedRenderBufferMemoryUsage() {
            let w = 0;
            for (const A of d.Gfx.WebGLRenderTarget.allRenderTargets()) A.GetTexture() || (w += A.GetEstimatedMemoryUsage());
            return w
        }
        GetEstimatedTextureMemoryUsage() {
            let w = 0;
            for (const A of d.Gfx.WebGLRendererTexture.allTextures()) w +=
                A.GetEstimatedMemoryUsage();
            return w
        }
        GetEstimatedTotalMemoryUsage() {
            return this.GetEstimatedBackBufferMemoryUsage() + this.GetEstimatedRenderBufferMemoryUsage() + this.GetEstimatedTextureMemoryUsage()
        }
        GetWebGLVersionString() {
            return this._versionString
        }
        GetWebGLVersionNumber() {
            return this._version
        }
        GetDisplayName() {
            return "webgl" + this.GetWebGLVersionNumber()
        }
        SupportsNPOTTextures() {
            return 2 <= this.GetWebGLVersionNumber()
        }
        GetMaxTextureSize() {
            return this._maxTextureSize
        }
        GetMinPointSize() {
            return this._minPointSize
        }
        GetMaxPointSize() {
            return this._maxPointSize
        }
        SupportsHighP() {
            return 0 !==
                this._highpPrecision
        }
        GetHighPPrecision() {
            return this._highpPrecision
        }
        GetUnmaskedVendor() {
            return this._unmaskedVendor
        }
        GetUnmaskedRenderer() {
            return this._unmaskedRenderer
        }
        GetExtensions() {
            return this._extensions
        }
        HasMajorPerformanceCaveat() {
            return this._hasMajorPerformanceCaveat
        }
        SupportsGPUProfiling() {
            return !!this._timerExt
        }
        _GetDisjointTimerQueryExtension() {
            return this._timerExt
        }
        _GetParallelShaderCompileExtension() {
            return this._parallelShaderCompileExt
        }
        _AddQueryResultBuffer(w) {
            this._allQueryResultBuffers.add(w)
        }
        _RemoveQueryResultBuffer(w) {
            this._allQueryResultBuffers.delete(w)
        }
        _GetTimeQueryStack() {
            return this._timeQueryStack
        }
        GetContext() {
            return this._gl
        }
        _InitBlendModes(w) {
            this._InitBlendModeData([
                ["normal",
                    w.ONE, w.ONE_MINUS_SRC_ALPHA
                ],
                ["additive", w.ONE, w.ONE],
                ["xor", w.ONE, w.ONE_MINUS_SRC_ALPHA],
                ["copy", w.ONE, w.ZERO],
                ["destination-over", w.ONE_MINUS_DST_ALPHA, w.ONE],
                ["source-in", w.DST_ALPHA, w.ZERO],
                ["destination-in", w.ZERO, w.SRC_ALPHA],
                ["source-out", w.ONE_MINUS_DST_ALPHA, w.ZERO],
                ["destination-out", w.ZERO, w.ONE_MINUS_SRC_ALPHA],
                ["source-atop", w.DST_ALPHA, w.ONE_MINUS_SRC_ALPHA],
                ["destination-atop", w.ONE_MINUS_DST_ALPHA, w.SRC_ALPHA]
            ])
        }
        CreateRendererText() {
            return d.New(d.Gfx.RendererText, this)
        }
        CreateWebGLText() {
            return this.CreateRendererText()
        }
    }
}
"use strict";
{
    const d = self.C3;
    let b = null;
    const a = new Set;

    function f(h, l) {
        const m = h[0] - l[0];
        return 0 !== m ? m : h[1] - l[1]
    }
    const c = [],
        e = [];
    let g = !1;
    self.IRuntime = class {
        constructor(h, l) {
            b = h;
            Object.defineProperties(this, {
                assets: {
                    value: b.GetAssetManager().GetIAssetManager(),
                    writable: !1
                },
                objects: {
                    value: l,
                    writable: !1
                },
                globalVars: {
                    value: {},
                    writable: !1
                },
                projectName: {
                    value: b.GetProjectName(),
                    writable: !1
                },
                projectVersion: {
                    value: b.GetProjectVersion(),
                    writable: !1
                },
                storage: {
                    value: new self.IStorage(b),
                    writable: !1
                },
                isInWorker: {
                    value: b.IsInWorker(),
                    writable: !1
                }
            });
            b.UserScriptDispatcher().addEventListener("keydown", m => {
                a.has(m.key) ? m.stopPropagation() : a.add(m.key)
            });
            b.UserScriptDispatcher().addEventListener("keyup", m => a.delete(m.key));
            b.Dispatcher().addEventListener("window-blur", () => a.clear());
            b.IsInWorker() && (self.alert = m => {
                g || (g = !0, console.warn("[Construct 3] alert() was called from a Web Worker, because the project 'Use worker' setting is enabled. This method is not normally available in a Web Worker. Construct has implemented the alert for you, but note that other features may be missing in worker mode. You may wish to disable 'Use worker', or use a more convenient function like console.log(). For more information please refer to the scripting section of the manual."));
                return this.alert(m)
            })
        }
        _InitGlobalVars(h) {
            Object.defineProperties(this.globalVars, h)
        }
        addEventListener(h, l) {
            b.UserScriptDispatcher().addEventListener(h, l)
        }
        removeEventListener(h, l) {
            b.UserScriptDispatcher().removeEventListener(h, l)
        }
        callFunction(h, ...l) {
            const m = b.GetEventSheetManager(),
                p = m.GetFunctionBlockByName(h);
            if (!p) throw Error(`cannot find function name '${h}'`);
            if (!p.IsEnabled()) return p.GetDefaultReturnValue();
            if (l.length < p.GetFunctionParameterCount()) throw Error(`not enough function parameters passed for '${h}' (${l.length} passed, ${p.GetFunctionParameterCount()} expected)`);
            const t = p.GetEventBlock();
            h = null;
            var q = m.GetCurrentEvent();
            q && (q = q.GetSolModifiersIncludingParents(), 0 < q.length && (h = q, m.PushCleanSol(q)));
            l = t.RunAsExpressionFunctionCall(t.GetSolModifiersIncludingParents(), p.GetReturnType(), p.GetDefaultReturnValue(), ...l);
            h && m.PopSol(h);
            return l
        }
        setReturnValue(h) {
            const l = b.GetEventStack().GetCurrentExpFuncStackFrame();
            if (!l) throw Error("not in a function which returns a value");
            switch (l.GetFunctionReturnType()) {
                case 1:
                    "number" === typeof h && l.SetFunctionReturnValue(h);
                    break;
                case 2:
                    "string" === typeof h && l.SetFunctionReturnValue(h);
                    break;
                case 3:
                    "number" !== typeof h && "string" !== typeof h || l.SetFunctionReturnValue(h)
            }
        }
        get dt() {
            return b.GetDt()
        }
        get gameTime() {
            return b.GetGameTime()
        }
        get wallTime() {
            return b.GetWallTime()
        }
        random() {
            return b.Random()
        }
        get layout() {
            return b.GetMainRunningLayout().GetILayout()
        }
        getLayout(h) {
            const l = b.GetLayoutManager();
            if ("number" === typeof h || "string" === typeof h) h = l.GetLayout(h);
            else throw new TypeError("expected string or number");
            if (!h) throw Error("invalid layout");
            return h.GetILayout()
        }
        getAllLayouts() {
            return b.GetLayoutManager().GetAllLayouts().map(h => h.GetILayout())
        }
        goToLayout(h) {
            const l = b.GetLayoutManager();
            if ("number" === typeof h || "string" === typeof h) h = l.GetLayout(h);
            else throw new TypeError("expected string or number");
            if (!h) throw Error("invalid layout");
            l.IsPendingChangeMainLayout() || l.ChangeMainLayout(h)
        }
        get keyboard() {
            const h = b._GetCommonScriptInterfaces().keyboard;
            if (!h) throw Error("runtime.keyboard used but Keyboard object missing - add it to your project first");
            return h
        }
        get mouse() {
            const h = b._GetCommonScriptInterfaces().mouse;
            if (!h) throw Error("runtime.mouse used but Mouse object missing - add it to your project first");
            return h
        }
        get touch() {
            const h = b._GetCommonScriptInterfaces().touch;
            if (!h) throw Error("runtime.touch used but Touch object missing - add it to your project first");
            return h
        }
        invokeDownload(h, l) {
            b.InvokeDownload(h, l)
        }
        getInstanceByUid(h) {
            return (h = b.GetInstanceByUID(h)) ? h.GetInterfaceClass() : null
        }
        sortZOrder(h, l) {
            const m = b.GetCurrentLayout();
            for (var p of h) {
                h =
                    b._UnwrapScriptInterface(p);
                if (!h || !h.GetWorldInfo()) throw Error("invalid instance");
                var t = h.GetWorldInfo();
                c.push([t.GetLayer().GetIndex(), t.GetZIndex()]);
                e.push(h)
            }
            if (0 !== c.length) {
                c.sort(f);
                e.sort((q, r) => l(q.GetInterfaceClass(), r.GetInterfaceClass()));
                p = !1;
                for (let q = 0, r = c.length; q < r; ++q) {
                    h = e[q];
                    t = m.GetLayerByIndex(c[q][0]);
                    const u = c[q][1],
                        x = t._GetInstances();
                    x[u] !== h && (x[u] = h, h.GetWorldInfo()._SetLayer(t), t.SetZIndicesChanged(), p = !0)
                }
                p && b.UpdateRender();
                d.clearArray(c);
                d.clearArray(e)
            }
        }
        alert(h) {
            return b.PostComponentMessageToDOMAsync("runtime",
                "alert", {
                    message: h + (b.IsInWorker() ? " [via Web Worker]" : "")
                })
        }
    }
}
"use strict";
{
    const d = self.C3;
    let b = null;
    self.IAssetManager = class {
        constructor(a) {
            b = a;
            Object.defineProperties(this, {
                isWebMOpusSupported: {
                    value: b.IsAudioFormatSupported("audio/webm; codecs=opus"),
                    writable: !1
                }
            })
        }
        fetchText(a) {
            return b.FetchText(a)
        }
        fetchJson(a) {
            return b.FetchJson(a)
        }
        fetchBlob(a) {
            return b.FetchBlob(a)
        }
        fetchArrayBuffer(a) {
            return b.FetchArrayBuffer(a)
        }
        getProjectFileUrl(a) {
            return b.GetProjectFileUrl(a)
        }
        getMediaFileUrl(a) {
            d.IsRelativeURL(a) && (a = a.toLowerCase());
            return b.GetMediaFileUrl(a, b.GetMediaSubfolder())
        }
        get mediaFolder() {
            return b.GetMediaSubfolder()
        }
        async decodeWebMOpus(a,
            f) {
            if (this.isWebMOpusSupported) throw Error("decodeWebMOpus(): not supported because WebM Opus is supported by the platform");
            f = await b.GetRuntime()._WasmDecodeWebMOpus(f);
            f = new Float32Array(f);
            a = a.createBuffer(1, f.length, 48E3);
            a.getChannelData(0).set(f);
            return a
        }
        loadScripts(...a) {
            return b.LoadScripts(...a)
        }
        compileWebAssembly(a) {
            return b.CompileWebAssembly(a)
        }
        loadStyleSheet(a) {
            return b.LoadStyleSheet(a)
        }
    }
}
"use strict";
self.IStorage = class {
    constructor(d) {
        this._storage = d._GetProjectStorage()
    }
    getItem(d) {
        return this._storage.getItem(d)
    }
    setItem(d, b) {
        return this._storage.setItem(d, b)
    }
    removeItem(d) {
        return this._storage.removeItem(d)
    }
    clear() {
        return this._storage.clear()
    }
    keys() {
        return this._storage.keys()
    }
};
"use strict";
{
    const d = new WeakMap;
    self.IObjectClass = class {
        constructor(b) {
            d.set(this, b);
            Object.defineProperties(this, {
                name: {
                    value: b.GetName(),
                    writable: !1
                }
            });
            b.GetRuntime()._MapScriptInterface(this, b)
        }
        addEventListener(b, a) {
            d.get(this).UserScriptDispatcher().addEventListener(b, a)
        }
        removeEventListener(b, a) {
            d.get(this).UserScriptDispatcher().removeEventListener(b, a)
        }
        getAllInstances() {
            return d.get(this).GetInstances().map(b => b.GetInterfaceClass())
        }
        getFirstInstance() {
            const b = d.get(this).GetInstances();
            return 0 < b.length ?
                b[0].GetInterfaceClass() : null
        }
        getPickedInstances() {
            return d.get(this).GetCurrentSol().GetInstances().map(b => b.GetInterfaceClass())
        }
        getFirstPickedInstance() {
            const b = d.get(this).GetCurrentSol().GetInstances();
            return 0 < b.length ? b[0].GetInterfaceClass() : null
        }* instances() {
            for (const b of d.get(this).GetInstances()) yield b.GetInterfaceClass()
        }* pickedInstances() {
            for (const b of d.get(this).GetCurrentSol().GetInstances()) yield b.GetInterfaceClass()
        }
        setInstanceClass(b) {
            if (0 < d.get(this).GetInstanceCount()) throw Error("setInstanceClass() called too late, because instances have already been created - call in runOnStartup");
            d.get(this)._SetUserScriptInstanceClass(b)
        }
        createInstance(b, a, f, c) {
            if ("number" !== typeof b && "string" !== typeof b) throw new TypeError("invalid layer parameter");
            const e = d.get(this),
                g = e.GetRuntime();
            b = g.GetMainRunningLayout().GetLayer(b);
            if (!b) throw Error("invalid layer");
            a = g.CreateInstance(e, b, a, f, c);
            c && b.SortAndAddSceneGraphInstancesByZIndex(a);
            c = g.GetEventSheetManager();
            c.BlockFlushingInstances(!0);
            a._TriggerOnCreatedOnSelfAndRelated();
            c.BlockFlushingInstances(!1);
            return a.GetInterfaceClass()
        }
    }
}
"use strict";
{
    const d = new WeakMap;
    self.ILayout = class {
        constructor(b) {
            d.set(this, b);
            const a = [],
                f = b.GetEffectList(),
                c = f.GetAllEffectTypes().length;
            for (let e = 0; e < c; ++e) a.push(new self.IEffectInstance(f, e));
            Object.defineProperties(this, {
                name: {
                    value: b.GetName(),
                    writable: !1
                },
                index: {
                    value: b.GetIndex(),
                    writable: !1
                },
                effects: {
                    value: a,
                    writable: !1
                }
            })
        }
        addEventListener(b, a) {
            d.get(this).UserScriptDispatcher().addEventListener(b, a)
        }
        removeEventListener(b, a) {
            d.get(this).UserScriptDispatcher().removeEventListener(b, a)
        }
        get width() {
            return d.get(this).GetWidth()
        }
        set width(b) {
            d.get(this).SetWidth(b)
        }
        get height() {
            return d.get(this).GetHeight()
        }
        set height(b) {
            d.get(this).SetHeight(b)
        }
        scrollTo(b,
            a) {
            const f = d.get(this);
            f.SetScrollX(b);
            f.SetScrollY(a)
        }
        getLayer(b) {
            const a = d.get(this);
            if ("number" === typeof b || "string" === typeof b) b = a.GetLayer(b);
            else throw new TypeError("expected string or number");
            if (!b) throw Error("invalid layer");
            return b.GetILayer()
        }
        getAllLayers() {
            return d.get(this).GetLayers().map(b => b.GetILayer())
        }
    }
}
"use strict";
{
    const d = self.C3,
        b = new WeakMap;
    self.ILayer = class {
        constructor(a) {
            b.set(this, a);
            const f = [],
                c = a.GetEffectList(),
                e = c.GetAllEffectTypes().length;
            for (let g = 0; g < e; ++g) f.push(new self.IEffectInstance(c, g));
            Object.defineProperties(this, {
                name: {
                    value: a.GetName(),
                    writable: !1
                },
                index: {
                    value: a.GetIndex(),
                    writable: !1
                },
                layout: {
                    value: a.GetLayout().GetILayout(),
                    writable: !1
                },
                effects: {
                    value: f,
                    writable: !1
                }
            })
        }
        static _Unwrap(a) {
            return b.get(a)
        }
        get isVisible() {
            return b.get(this).IsVisible()
        }
        set isVisible(a) {
            b.get(this).SetVisible(a)
        }
        get opacity() {
            return b.get(this).GetOpacity()
        }
        set opacity(a) {
            a =
                d.clamp(+a, 0, 1);
            isNaN(a) || b.get(this).SetOpacity(a)
        }
        getViewport() {
            return b.get(this).GetViewport().toDOMRect()
        }
        cssPxToLayer(a, f, c = 0) {
            const e = b.get(this),
                g = e.GetRuntime();
            return e.CanvasCssToLayer(a - g.GetCanvasClientX(), f - g.GetCanvasClientY(), c)
        }
        layerToCssPx(a, f, c = 0) {
            const e = b.get(this),
                g = e.GetRuntime(),
                [h, l] = e.LayerToCanvasCss(a, f, c);
            return [h + g.GetCanvasClientX(), l + g.GetCanvasClientY()]
        }
    }
}
"use strict";
{
    const d = self.C3,
        b = new WeakMap,
        a = new WeakMap;

    function f(e) {
        let g = a.get(e);
        if (g) return g;
        g = d.New(d.Event.Dispatcher);
        a.set(e, g);
        return g
    }
    let c = null;
    self.IInstance = class {
        constructor() {
            b.set(this, c);
            const e = {
                runtime: {
                    value: c.GetRuntime().GetIRuntime(),
                    writable: !1
                },
                objectType: {
                    value: c.GetObjectClass().GetIObjectClass(),
                    writable: !1
                },
                uid: {
                    value: c.GetUID(),
                    writable: !1
                }
            };
            c._GetInstVarsScriptDescriptor(e);
            c._GetBehaviorsScriptDescriptor(e);
            Object.defineProperties(this, e);
            c.GetRuntime()._MapScriptInterface(this,
                c)
        }
        static _Init(e) {
            c = e
        }
        static _GetInitInst() {
            return c
        }
        _Release() {
            const e = a.get(this);
            e && (e.Release(), a.delete(this));
            b.delete(this)
        }
        addEventListener(e, g, h) {
            f(this).addEventListener(e, g, h)
        }
        removeEventListener(e, g, h) {
            f(this).removeEventListener(e, g, h)
        }
        dispatchEvent(e) {
            f(this).dispatchEvent(e)
        }
        destroy() {
            const e = b.get(this);
            e.GetRuntime().DestroyInstance(e)
        }
    }
}
"use strict";
{
    const d = self.C3,
        b = self.IInstance,
        a = self.ILayer,
        f = new WeakMap,
        c = new Map([
            ["normal", 0],
            ["additive", 1],
            ["copy", 3],
            ["destination-over", 4],
            ["source-in", 5],
            ["destination-in", 6],
            ["source-out", 7],
            ["destination-out", 8],
            ["source-atop", 9],
            ["destination-atop", 10]
        ]),
        e = new Map([...c.entries()].map(h => [h[1], h[0]])),
        g = d.New(d.Color);
    self.IWorldInstance = class extends b {
        constructor() {
            super();
            var h = b._GetInitInst();
            f.set(this, h);
            const l = [];
            var m = h.GetWorldInfo();
            if (h = m.GetInstanceEffectList()) {
                m = m.GetObjectClass().GetEffectList().GetAllEffectTypes().length;
                for (let p = 0; p < m; ++p) l.push(new self.IEffectInstance(h, p))
            }
            Object.defineProperties(this, {
                effects: {
                    value: l,
                    writable: !1
                }
            })
        }
        get layout() {
            return f.get(this).GetWorldInfo().GetLayout().GetILayout()
        }
        get layer() {
            return f.get(this).GetWorldInfo().GetLayer().GetILayer()
        }
        get x() {
            return f.get(this).GetWorldInfo().GetX()
        }
        set x(h) {
            h = +h;
            const l = f.get(this).GetWorldInfo();
            isNaN(h) || l.GetX() === h || (l.SetX(h), l.SetBboxChanged())
        }
        get y() {
            return f.get(this).GetWorldInfo().GetY()
        }
        set y(h) {
            h = +h;
            const l = f.get(this).GetWorldInfo();
            isNaN(h) || l.GetY() === h || (l.SetY(h), l.SetBboxChanged())
        }
        get zElevation() {
            return f.get(this).GetWorldInfo().GetZElevation()
        }
        set zElevation(h) {
            h = +h;
            const l = f.get(this),
                m = l.GetWorldInfo();
            m.GetZElevation() !== h && (m.SetZElevation(h), l.GetRuntime().UpdateRender())
        }
        get totalZElevation() {
            return f.get(this).GetWorldInfo().GetTotalZElevation()
        }
        get width() {
            return f.get(this).GetWorldInfo().GetWidth()
        }
        set width(h) {
            h = +h;
            const l = f.get(this).GetWorldInfo();
            isNaN(h) || l.GetWidth() === h || (l.SetWidth(h), l.SetBboxChanged())
        }
        get height() {
            return f.get(this).GetWorldInfo().GetHeight()
        }
        set height(h) {
            h = +h;
            const l = f.get(this).GetWorldInfo();
            isNaN(h) || l.GetHeight() === h || (l.SetHeight(h), l.SetBboxChanged())
        }
        get angle() {
            return f.get(this).GetWorldInfo().GetAngle()
        }
        set angle(h) {
            h = d.clampAngle(+h);
            const l = f.get(this).GetWorldInfo();
            isNaN(h) || l.GetAngle() === h || (l.SetAngle(h), l.SetBboxChanged())
        }
        get angleDegrees() {
            return d.toDegrees(this.angle)
        }
        set angleDegrees(h) {
            this.angle = d.toRadians(h)
        }
        getBoundingBox() {
            return f.get(this).GetWorldInfo().GetBoundingBox().toDOMRect()
        }
        getBoundingQuad() {
            return f.get(this).GetWorldInfo().GetBoundingQuad().toDOMQuad()
        }
        get isVisible() {
            return f.get(this).GetWorldInfo().IsVisible()
        }
        set isVisible(h) {
            h = !!h;
            const l = f.get(this),
                m = l.GetWorldInfo();
            m.IsVisible() !== h && (m.SetVisible(h), l.GetRuntime().UpdateRender())
        }
        get opacity() {
            return f.get(this).GetWorldInfo().GetOpacity()
        }
        set opacity(h) {
            h = d.clamp(+h, 0, 1);
            const l = f.get(this),
                m = l.GetWorldInfo();
            isNaN(h) || m.GetOpacity() === h || (m.SetOpacity(h), l.GetRuntime().UpdateRender())
        }
        set colorRgb(h) {
            if (3 > h.length) throw Error("expected 3 elements");
            g.setRgb(h[0], h[1], h[2]);
            h = f.get(this);
            const l = h.GetWorldInfo();
            l.GetUnpremultipliedColor().equalsIgnoringAlpha(g) ||
                (l.SetUnpremultipliedColor(g), h.GetRuntime().UpdateRender())
        }
        get colorRgb() {
            const h = f.get(this).GetWorldInfo().GetUnpremultipliedColor();
            return [h.getR(), h.getG(), h.getB()]
        }
        set blendMode(h) {
            h = c.get(h);
            if ("number" !== typeof h) throw Error("invalid blend mode");
            const l = f.get(this);
            l.GetWorldInfo().SetBlendMode(h);
            l.GetRuntime().UpdateRender()
        }
        get blendMode() {
            return e.get(f.get(this).GetWorldInfo().GetBlendMode())
        }
        moveToTop() {
            f.get(this).GetWorldInfo().ZOrderMoveToTop()
        }
        moveToBottom() {
            f.get(this).GetWorldInfo().ZOrderMoveToBottom()
        }
        moveToLayer(h) {
            h =
                a._Unwrap(h);
            if (!h) throw Error("invalid layer");
            f.get(this).GetWorldInfo().ZOrderMoveToLayer(h)
        }
        moveAdjacentToInstance(h, l) {
            f.get(this).GetWorldInfo().ZOrderMoveAdjacentToInstance(f.get(h), l)
        }
        containsPoint(h, l) {
            return f.get(this).GetWorldInfo().ContainsPoint(+h, +l)
        }
        testOverlap(h) {
            const l = f.get(this);
            h = f.get(h);
            return l.GetRuntime().GetCollisionEngine().TestOverlap(l, h)
        }
        testOverlapSolid() {
            var h = f.get(this);
            return (h = h.GetRuntime().GetCollisionEngine().TestOverlapSolid(h)) ? h.GetInterfaceClass() : null
        }
        getParent() {
            const h =
                f.get(this).GetParent();
            return h ? h.GetInterfaceClass() : null
        }
        getTopParent() {
            const h = f.get(this).GetTopParent();
            return h ? h.GetInterfaceClass() : null
        }* parents() {
            for (const h of f.get(this).parents()) yield h.GetInterfaceClass()
        }
        getChildCount() {
            return f.get(this).GetChildCount()
        }
        getChildAt(h) {
            return (h = f.get(this).GetChildAt(h)) ? h.GetInterfaceClass() : null
        }* children() {
            for (const h of f.get(this).children()) yield h.GetInterfaceClass()
        }* allChildren() {
            for (const h of f.get(this).allChildren()) yield h.GetInterfaceClass()
        }
        addChild(h,
            l) {
            l || (l = {});
            const m = f.get(this);
            h = f.get(h);
            m.AddChild(h, l)
        }
        removeChild(h) {
            const l = f.get(this);
            h = f.get(h);
            l.RemoveChild(h)
        }
        removeFromParent() {
            const h = f.get(this);
            h.HasParent() && h.GetParent().RemoveChild(h)
        }
        createMesh(h, l) {
            f.get(this).GetWorldInfo().CreateMesh(h, l)
        }
        releaseMesh() {
            const h = f.get(this).GetWorldInfo();
            h.ReleaseMesh();
            h.SetBboxChanged()
        }
        setMeshPoint(h, l, m) {
            const p = f.get(this).GetWorldInfo();
            p.SetMeshPoint(h, l, m) && p.SetBboxChanged()
        }
        getMeshSize() {
            var h = f.get(this).GetWorldInfo();
            if (!h.HasMesh()) return [0,
                0
            ];
            h = h.GetSourceMesh();
            return [h.GetHSize(), h.GetVSize()]
        }
    }
}
"use strict";
{
    const d = new WeakMap;
    self.IDOMInstance = class extends self.IWorldInstance {
        constructor() {
            super();
            d.set(this, self.IInstance._GetInitInst())
        }
        getElement() {
            return d.get(this).GetSdkInstance()._GetElementInDOMMode()
        }
        focus() {
            d.get(this).GetSdkInstance().FocusElement()
        }
        blur() {
            d.get(this).GetSdkInstance().BlurElement()
        }
        setCssStyle(b, a) {
            d.get(this).GetSdkInstance().SetElementCSSStyle(b, a)
        }
    }
}
"use strict";
{
    const d = self.C3,
        b = new WeakMap,
        a = new WeakMap;

    function f(e) {
        let g = a.get(e);
        if (g) return g;
        g = d.New(d.Event.Dispatcher);
        a.set(e, g);
        return g
    }
    let c = null;
    self.IBehaviorInstance = class {
        constructor() {
            b.set(this, c);
            const e = {
                runtime: {
                    value: c.GetRuntime().GetIRuntime(),
                    writable: !1
                },
                behavior: {
                    value: c.GetBehavior().GetIBehavior(),
                    writable: !1
                }
            };
            Object.defineProperties(this, e)
        }
        static _Init(e) {
            c = e
        }
        static _GetInitInst() {
            return c
        }
        get instance() {
            return b.get(this).GetObjectInstance().GetInterfaceClass()
        }
        _Release() {
            const e =
                a.get(this);
            e && (e.Release(), a.delete(this));
            b.delete(this)
        }
        addEventListener(e, g, h) {
            f(this).addEventListener(e, g, h)
        }
        removeEventListener(e, g, h) {
            f(this).removeEventListener(e, g, h)
        }
        dispatchEvent(e) {
            f(this).dispatchEvent(e)
        }
    }
}
"use strict";
{
    const d = new WeakMap;
    self.IBehavior = class {
        constructor(b) {
            d.set(this, b);
            b = {
                runtime: {
                    value: b.GetRuntime().GetIRuntime(),
                    writable: !1
                }
            };
            Object.defineProperties(this, b)
        }
        getAllInstances() {
            return d.get(this).GetInstances().map(b => b.GetInterfaceClass())
        }
    }
}
"use strict";
{
    const d = self.C3,
        b = new WeakMap;
    self.IEffectInstance = class {
        constructor(a, f) {
            b.set(this, a);
            Object.defineProperties(this, {
                index: {
                    value: f,
                    writable: !1
                }
            })
        }
        get name() {
            return b.get(this).GetAllEffectTypes()[this.index].GetName()
        }
        get isActive() {
            return b.get(this).IsEffectIndexActive(this.index)
        }
        set isActive(a) {
            a = !!a;
            const f = b.get(this);
            f.IsEffectIndexActive(this.index) !== a && (f.SetEffectIndexActive(this.index, a), f.UpdateActiveEffects(), f.GetRuntime().UpdateRender())
        }
        setParameter(a, f) {
            a = Math.floor(+a);
            const c =
                b.get(this);
            var e = c.GetEffectParametersForIndex(this.index);
            if (0 > a || a >= e.length) throw new RangeError("invalid effect parameter index");
            const g = e[a];
            if (g instanceof d.Color) {
                if (!Array.isArray(f) || 3 > f.length) throw new TypeError("expected array with 3 elements");
                a = f[0];
                e = f[1];
                f = f[2];
                if (g.equalsRgb(a, e, f)) return;
                g.setRgb(a, e, f)
            } else {
                if ("number" !== typeof f) throw new TypeError("expected number");
                if (g === f) return;
                e[a] = f
            }
            c.IsEffectIndexActive(this.index) && c.GetRuntime().UpdateRender()
        }
        getParameter(a) {
            a = Math.floor(+a);
            const f = b.get(this).GetEffectParametersForIndex(this.index);
            if (0 > a || a >= f.length) throw new RangeError("invalid effect parameter index");
            a = f[a];
            return a instanceof d.Color ? [a.getR(), a.getG(), a.getB()] : a
        }
    }
}
"use strict";
{
    const d = self.C3,
        b = new Set(["local", "remote"]),
        a = new Map([
            ["mp4", "video/mp4"],
            ["webm", "video/webm"],
            ["m4a", "audio/mp4"],
            ["mp3", "audio/mpeg"],
            ["js", "application/javascript"],
            ["wasm", "application/wasm"],
            ["svg", "image/svg+xml"],
            ["html", "text/html"]
        ]);

    function f(e) {
        if (!e) return "";
        e = e.split(".");
        if (2 > e.length) return "";
        e = e[e.length - 1].toLowerCase();
        return a.get(e) || ""
    }

    function c(e, g) {
        return new Promise((h, l) => {
            const m = document.createElement("script");
            m.onload = h;
            m.onerror = l;
            m.async = !1;
            "module" === g && (m.type =
                "module");
            m.src = e;
            document.head.appendChild(m)
        })
    }
    d.AssetManager = class extends d.DefendedBase {
        constructor(e, g) {
            super();
            var h = g.exportType;
            this._runtime = e;
            this._scriptsType = g.scriptsType;
            this._localUrlBlobs = new Map;
            this._localBlobUrlCache = new Map;
            this._localBlobSWUrls = new Map;
            this._isCordova = "cordova" === h;
            this._isiOSCordova = !!g.isiOSCordova;
            this._isFileProtocol = "file:" === location.protocol;
            this._swClientId = g.swClientId;
            this._supportedAudioFormats = g.supportedAudioFormats || {};
            this._audioFiles = new Map;
            this._preloadSounds = !1;
            this._iconsSubfolder = this._fontsSubfolder = this._mediaSubfolder = "";
            this._defaultLoadPolicy = "html5" === h || "scirra-arcade" === h || "instant-games" === h ? "remote" : "local";
            this._allAssets = [];
            this._assetsByUrl = new Map;
            this._webFonts = [];
            this._loadPromises = [];
            this._hasFinishedInitialLoad = !1;
            this._lastLoadProgress = this._assetSizeLoaded = this._totalAssetSizeToLoad = 0;
            this._hasHadErrorLoading = !1;
            this._loadingRateLimiter = d.New(d.RateLimiter, () => this._FireLoadingProgressEvent(), 50);
            this._promiseThrottle =
                new d.PromiseThrottle(Math.max(d.hardwareConcurrency, 8));
            if (e = g.previewImageBlobs) {
                (h = g.previewProjectFileBlobs) && Object.assign(e, h);
                (h = g.projectData) && (e["data.json"] = h);
                for (const [l, m] of Object.entries(e)) this._localUrlBlobs.set(l.toLowerCase(), m)
            }
            if (g = g.previewProjectFileSWUrls)
                for (const [l, m] of Object.entries(g)) this._localBlobSWUrls.set(l, m);
            this._iAssetManager = new self.IAssetManager(this)
        }
        Release() {
            this._localUrlBlobs.clear();
            for (const e of this._localBlobUrlCache.values()) e.startsWith("blob:") &&
                URL.revokeObjectURL(e);
            this._localBlobUrlCache.clear();
            for (const e of this._allAssets) e.Release();
            d.clearArray(this._allAssets);
            this._assetsByUrl.clear();
            d.clearArray(this._loadPromises);
            this._runtime = null
        }
        GetRuntime() {
            return this._runtime
        }
        _SetMediaSubfolder(e) {
            this._mediaSubfolder = e
        }
        GetMediaSubfolder() {
            return this._mediaSubfolder
        }
        _SetFontsSubfolder(e) {
            this._fontsSubfolder = e
        }
        GetFontsSubfolder() {
            return this._fontsSubfolder
        }
        _SetIconsSubfolder(e) {
            this._iconsSubfolder = e
        }
        GetIconsSubfolder() {
            return this._iconsSubfolder
        }
        _HasLocalUrlBlob(e) {
            return this._localUrlBlobs.has(e.toLowerCase())
        }
        _GetLocalUrlBlob(e) {
            return this._localUrlBlobs.get(e.toLowerCase()) ||
                null
        }
        GetLocalUrlAsBlobUrl(e) {
            if (!this._HasLocalUrlBlob(e)) return e;
            e = e.toLowerCase();
            var g = this._localBlobUrlCache.get(e);
            g || (g = this._GetLocalUrlBlob(e), g = URL.createObjectURL(g), this._localBlobUrlCache.set(e, g));
            return g
        }
        FetchBlob(e, g) {
            g = g || this._defaultLoadPolicy;
            const h = this._GetLocalUrlBlob(e);
            if (h) return Promise.resolve(h);
            if (d.IsRelativeURL(e)) {
                const l = e.toLowerCase();
                return this._isCordova && this._isFileProtocol ? this.CordovaFetchLocalFileAsBlob(l) : "local" === g ? this._promiseThrottle.Add(() => d.FetchBlob(l)) :
                    d.FetchBlob(l)
            }
            return d.FetchBlob(e)
        }
        FetchArrayBuffer(e) {
            const g = this._GetLocalUrlBlob(e);
            if (g) return d.BlobToArrayBuffer(g);
            if (d.IsRelativeURL(e)) {
                const h = e.toLowerCase();
                return this._isCordova && this._isFileProtocol ? this.CordovaFetchLocalFileAsArrayBuffer(h) : "local" === this._defaultLoadPolicy ? this._promiseThrottle.Add(() => d.FetchArrayBuffer(h)) : d.FetchArrayBuffer(h)
            }
            return d.FetchArrayBuffer(e)
        }
        FetchText(e) {
            const g = this._GetLocalUrlBlob(e);
            if (g) return d.BlobToString(g);
            if (d.IsRelativeURL(e)) {
                const h =
                    e.toLowerCase();
                return this._isCordova && this._isFileProtocol ? this.CordovaFetchLocalFileAsText(h) : "local" === this._defaultLoadPolicy ? this._promiseThrottle.Add(() => d.FetchText(h)) : d.FetchText(h)
            }
            return d.FetchText(e)
        }
        async FetchJson(e) {
            e = await this.FetchText(e);
            return JSON.parse(e)
        }
        _CordovaFetchLocalFileAs(e, g) {
            return this._runtime.PostComponentMessageToDOMAsync("runtime", "cordova-fetch-local-file", {
                filename: e,
                as: g
            })
        }
        CordovaFetchLocalFileAsText(e) {
            return this._CordovaFetchLocalFileAs(e, "text")
        }
        async CordovaFetchLocalFileAsBlob(e) {
            const g =
                await this._CordovaFetchLocalFileAs(e, "buffer");
            e = f(e);
            return new Blob([g], {
                type: e
            })
        }
        async CordovaFetchLocalFileAsBlobURL(e) {
            e = e.toLowerCase();
            var g = this._localBlobUrlCache.get(e);
            if (g) return g;
            g = await this.CordovaFetchLocalFileAsBlob(e);
            g = URL.createObjectURL(g);
            this._localBlobUrlCache.set(e, g);
            return g
        }
        CordovaFetchLocalFileAsArrayBuffer(e) {
            return this._CordovaFetchLocalFileAs(e, "buffer")
        }
        GetMediaFileUrl(e) {
            return this._HasLocalUrlBlob(e) ? this.GetLocalUrlAsBlobUrl(e) : this._mediaSubfolder + e.toLowerCase()
        }
        GetProjectFileUrl(e,
            g = "") {
            if (d.IsAbsoluteURL(e)) {
                if (g) throw Error("cannot specify subfolder with remote URL");
                return Promise.resolve(e)
            }
            return this._HasLocalUrlBlob(e) ? Promise.resolve(this.GetLocalUrlAsBlobUrl(e)) : this._isCordova && this._isFileProtocol ? this.CordovaFetchLocalFileAsBlobURL(g + e) : Promise.resolve(g + e.toLowerCase())
        }
        GetProjectFileIframeUrl(e) {
            if (d.IsAbsoluteURL(e)) return Promise.resolve(e);
            var g = e.indexOf("?"),
                h = -1 === g ? "" : e.substr(g);
            g = -1 === g ? e : e.substr(0, g);
            return this._HasLocalUrlBlob(g) ? (e = this._localBlobSWUrls.get(g) ||
                this.GetLocalUrlAsBlobUrl(g), !e.startsWith("blob:") && this._swClientId && (e = new URL(e), h = new URLSearchParams(h), h.set("__c3_client_id", this._swClientId), e.search = h.toString(), e = e.toString()), Promise.resolve(e)) : this._isCordova && this._isFileProtocol ? this.CordovaFetchLocalFileAsBlobURL(g) : Promise.resolve(e.toLowerCase())
        }
        LoadProjectFileUrl(e) {
            return this.GetProjectFileUrl(e)
        }
        LoadImage(e) {
            if (e.loadPolicy && !b.has(e.loadPolicy)) throw Error("invalid load policy");
            let g = this._assetsByUrl.get(e.url);
            if (g) return g;
            g = d.New(d.ImageAsset, this, {
                url: e.url,
                size: e.size || 0,
                loadPolicy: e.loadPolicy || this._defaultLoadPolicy
            });
            this._allAssets.push(g);
            this._assetsByUrl.set(g.GetURL(), g);
            this._hasFinishedInitialLoad || (this._totalAssetSizeToLoad += g.GetSize(), this._loadPromises.push(g.Load().then(() => this._AddLoadedSize(g.GetSize()))));
            return g
        }
        async WaitForAllToLoad() {
            try {
                await Promise.all(this._loadPromises), this._lastLoadProgress = 1
            } catch (e) {
                console.error("Error loading: ", e), this._hasHadErrorLoading = !0, this._FireLoadingProgressEvent()
            }
        }
        SetInitialLoadFinished() {
            this._hasFinishedInitialLoad = !0
        }
        HasHadErrorLoading() {
            return this._hasHadErrorLoading
        }
        _AddLoadedSize(e) {
            this._assetSizeLoaded += e;
            this._loadingRateLimiter.Call()
        }
        _FireLoadingProgressEvent() {
            const e = d.New(d.Event, "loadingprogress");
            this._lastLoadProgress = d.clamp(this._assetSizeLoaded / this._totalAssetSizeToLoad, 0, 1);
            e.progress = this._lastLoadProgress;
            this._runtime.Dispatcher().dispatchEvent(e)
        }
        GetLoadProgress() {
            return this._lastLoadProgress
        }
        _SetWebFonts(e) {
            d.shallowAssignArray(this._webFonts, e);
            this._webFonts.length && this._loadPromises.push(this._LoadWebFonts())
        }
        _LoadWebFonts() {
            if ("undefined" ===
                typeof FontFace) return Promise.resolve();
            const e = [];
            for (const [g, h, l] of this._webFonts) this._totalAssetSizeToLoad += l, e.push(this._LoadWebFont(g, h).then(() => this._AddLoadedSize(l)));
            return Promise.all(e)
        }
        async _LoadWebFont(e, g) {
            try {
                const h = await this.GetProjectFileUrl(g, this._fontsSubfolder),
                    l = new FontFace(e, `url('${h}')`);
                this._runtime.IsInWorker() ? self.fonts.add(l) : document.fonts.add(l);
                await l.load()
            } catch (h) {
                console.warn(`[C3 runtime] Failed to load web font '${e}': `, h)
            }
        }
        IsAudioFormatSupported(e) {
            return !!this._supportedAudioFormats[e]
        }
        _SetAudioFiles(e,
            g) {
            this._preloadSounds = !!g;
            for (const [h, l, m] of e) this._audioFiles.set(h, {
                fileName: h,
                formats: l.map(p => ({
                    type: p[0],
                    fileExtension: p[1],
                    fullName: h + p[1],
                    fileSize: p[2]
                })),
                isMusic: m
            })
        }
        GetPreferredAudioFile(e) {
            e = this._audioFiles.get(e.toLowerCase());
            if (!e) return null;
            let g = null;
            for (const h of e.formats)
                if (g || "audio/webm; codecs=opus" !== h.type || (g = h), this.IsAudioFormatSupported(h.type)) return h;
            return g
        }
        GetProjectAudioFileUrl(e) {
            return (e = this.GetPreferredAudioFile(e)) ? {
                url: this.GetMediaFileUrl(e.fullName),
                type: e.type
            } : null
        }
        GetAudioToPreload() {
            if (this._preloadSounds) {
                const e = [];
                for (const g of this._audioFiles.values()) {
                    if (g.isMusic) continue;
                    const h = this.GetPreferredAudioFile(g.fileName);
                    h && e.push({
                        originalUrl: g.fileName,
                        url: this.GetMediaFileUrl(h.fullName),
                        type: h.type,
                        fileSize: h.fileSize
                    })
                }
                return e
            }
            return []
        }
        GetIAssetManager() {
            return this._iAssetManager
        }
        GetScriptsType() {
            return this._scriptsType
        }
        async LoadScripts(...e) {
            const g = await Promise.all(e.map(h => this.GetProjectFileUrl(h)));
            this._runtime.IsInWorker() ?
                "classic" === this._scriptsType ? importScripts(...g) : 1 === e.length ? (e = e[0], await self.c3_import((d.IsRelativeURL(e) ? "./" : "") + e)) : (e = e.map(h => `import "${d.IsRelativeURL(h) ? "./" : ""}${h}";`).join("\n"), e = URL.createObjectURL(new Blob([e], {
                    type: "application/javascript"
                })), await self.c3_import(e)) : await Promise.all(g.map(h => c(h, this._scriptsType)))
        }
        async CompileWebAssembly(e) {
            if (WebAssembly.compileStreaming) return e = await this.GetProjectFileUrl(e), await WebAssembly.compileStreaming(fetch(e));
            e = await d.FetchArrayBuffer(e);
            return await WebAssembly.compile(e)
        }
        async LoadStyleSheet(e) {
            e = await this.GetProjectFileUrl(e);
            return await this._runtime.PostComponentMessageToDOMAsync("runtime", "add-stylesheet", {
                url: e
            })
        }
    }
}
"use strict";
{
    const d = self.C3;
    d.Asset = class extends d.DefendedBase {
        constructor(b, a) {
            super();
            this._assetManager = b;
            this._runtime = b.GetRuntime();
            this._url = a.url;
            this._size = a.size;
            this._loadPolicy = a.loadPolicy;
            this._blob = null;
            this._isLoaded = !1;
            this._loadPromise = null
        }
        Release() {
            this._blob = this._runtime = this._assetManager = this._loadPromise = null
        }
        GetURL() {
            return this._url
        }
        GetSize() {
            return this._size
        }
        Load() {
            return "local" === this._loadPolicy || this._blob ? (this._isLoaded = !0, Promise.resolve()) : this._loadPromise ? this._loadPromise :
                this._loadPromise = this._assetManager.FetchBlob(this._url, this._loadPolicy).then(b => {
                    this._isLoaded = !0;
                    this._loadPromise = null;
                    return this._blob = b
                }).catch(b => console.error("Error loading resource: ", b))
        }
        IsLoaded() {
            return this._isLoaded
        }
        GetBlob() {
            return this._blob ? Promise.resolve(this._blob) : this._loadPromise ? this._loadPromise : this._assetManager.FetchBlob(this._url, this._loadPolicy)
        }
    }
}
"use strict";
{
    const d = self.C3,
        b = new d.PromiseThrottle,
        a = new Set;
    d.ImageAsset = class extends d.Asset {
        constructor(f, c) {
            super(f, c);
            this._webglTexture = this._texturePromise = null;
            this._refCount = 0;
            this._imageHeight = this._imageWidth = -1;
            a.add(this)
        }
        Release() {
            this.ReleaseTexture();
            if (0 !== this._refCount) throw Error("released image asset which still has texture references");
            this._texturePromise = null;
            a.delete(this);
            super.Release()
        }
        static OnWebGLContextLost() {
            for (const f of a) f._texturePromise = null, f._webglTexture = null, f._refCount =
                0
        }
        LoadStaticTexture(f, c) {
            this._refCount++;
            return this._webglTexture ? Promise.resolve(this._webglTexture) : this._texturePromise ? this._texturePromise : this._texturePromise = this.GetBlob().then(e => b.Add(() => f.CreateStaticTextureAsync(e, c).then(g => {
                this._texturePromise = null;
                if (0 === this._refCount) return f.DeleteTexture(g), null;
                this._webglTexture = g;
                this._imageWidth = g.GetWidth();
                this._imageHeight = g.GetHeight();
                return this._webglTexture
            }))).catch(e => {
                console.error("Failed to load texture: ", e);
                throw e;
            })
        }
        ReleaseTexture() {
            if (0 >=
                this._refCount) throw Error("texture released too many times");
            this._refCount--;
            0 === this._refCount && this._webglTexture && (this._webglTexture.GetRenderer().DeleteTexture(this._webglTexture), this._webglTexture = null)
        }
        GetTexture() {
            return this._webglTexture
        }
        GetWidth() {
            return this._imageWidth
        }
        GetHeight() {
            return this._imageHeight
        }
        async LoadToDrawable() {
            const f = await this.GetBlob();
            return d.Supports.ImageBitmapOptions ? await createImageBitmap(f, {
                    premultiplyAlpha: "none"
                }) : d.Supports.ImageBitmap ? await createImageBitmap(f) :
                await d.BlobToImage(f)
        }
    }
}
"use strict";
{
    const d = self.C3;

    function b(a, f) {
        return a.GetWorldInfo()._GetLastCachedZIndex() - f.GetWorldInfo()._GetLastCachedZIndex()
    }
    d.RenderCell = class extends d.DefendedBase {
        constructor(a, f, c) {
            super();
            this._grid = a;
            this._x = f;
            this._y = c;
            this._instances = [];
            this._isSorted = !0;
            this._pendingRemoval = new Set;
            this._isAnyPendingRemoval = !1
        }
        Release() {
            d.clearArray(this._instances);
            this._pendingRemoval.clear();
            this._grid = null
        }
        Reset() {
            d.clearArray(this._instances);
            this._isSorted = !0;
            this._pendingRemoval.clear();
            this._isAnyPendingRemoval = !1
        }
        SetChanged() {
            this._isSorted = !1
        }
        IsEmpty() {
            if (!this._instances.length) return !0;
            if (this._instances.length > this._pendingRemoval.size) return !1;
            this._FlushPending();
            return !0
        }
        Insert(a) {
            this._pendingRemoval.has(a) ? (this._pendingRemoval.delete(a), 0 === this._pendingRemoval.size && (this._isAnyPendingRemoval = !1)) : (this._instances.push(a), this._isSorted = 1 === this._instances.length)
        }
        Remove(a) {
            this._pendingRemoval.add(a);
            this._isAnyPendingRemoval = !0;
            50 <= this._pendingRemoval.size && this._FlushPending()
        }
        _FlushPending() {
            this._isAnyPendingRemoval &&
                (this._instances.length === this._pendingRemoval.size ? this.Reset() : (d.arrayRemoveAllInSet(this._instances, this._pendingRemoval), this._pendingRemoval.clear(), this._isAnyPendingRemoval = !1))
        }
        _EnsureSorted() {
            this._isSorted || (this._instances.sort(b), this._isSorted = !0)
        }
        Dump(a) {
            this._FlushPending();
            this._EnsureSorted();
            this._instances.length && a.push(this._instances)
        }
    }
}
"use strict";
{
    const d = self.C3;
    d.RenderGrid = class extends d.DefendedBase {
        constructor(b, a) {
            super();
            this._cellWidth = b;
            this._cellHeight = a;
            this._cells = d.New(d.PairMap)
        }
        Release() {
            this._cells.Release();
            this._cells = null
        }
        GetCell(b, a, f) {
            let c = this._cells.Get(b, a);
            return c ? c : f ? (c = d.New(d.RenderCell, this, b, a), this._cells.Set(b, a, c), c) : null
        }
        XToCell(b) {
            return Math.floor(b / this._cellWidth)
        }
        YToCell(b) {
            return Math.floor(b / this._cellHeight)
        }
        Update(b, a, f) {
            if (a)
                for (let c = a.getLeft(), e = a.getRight(); c <= e; ++c)
                    for (let g = a.getTop(), h =
                            a.getBottom(); g <= h; ++g) {
                        if (f && f.containsPoint(c, g)) continue;
                        const l = this.GetCell(c, g, !1);
                        l && (l.Remove(b), l.IsEmpty() && this._cells.Delete(c, g))
                    }
            if (f)
                for (let c = f.getLeft(), e = f.getRight(); c <= e; ++c)
                    for (let g = f.getTop(), h = f.getBottom(); g <= h; ++g) a && a.containsPoint(c, g) || this.GetCell(c, g, !0).Insert(b)
        }
        QueryRange(b, a) {
            let f = this.XToCell(b.getLeft());
            const c = this.YToCell(b.getTop()),
                e = this.XToCell(b.getRight());
            for (b = this.YToCell(b.getBottom()); f <= e; ++f)
                for (let g = c; g <= b; ++g) {
                    const h = this.GetCell(f, g, !1);
                    h &&
                        h.Dump(a)
                }
        }
        MarkRangeChanged(b) {
            let a = b.getLeft();
            const f = b.getTop(),
                c = b.getRight();
            for (b = b.getBottom(); a <= c; ++a)
                for (let e = f; e <= b; ++e) {
                    const g = this.GetCell(a, e, !1);
                    g && g.SetChanged()
                }
        }
    }
}
"use strict";
{
    const d = self.C3,
        b = new d.Rect,
        a = new d.Quad,
        f = [],
        c = new d.Rect,
        e = new d.Rect,
        g = self.glMatrix.vec3,
        h = g.fromValues(0, 1, 0);

    function l(p, t) {
        return p.GetWorldInfo()._GetLastCachedZIndex() - t.GetWorldInfo()._GetLastCachedZIndex()
    }

    function m(p, t) {
        return p.GetWorldInfo().GetZElevation() - t.GetWorldInfo().GetZElevation()
    }
    d.Layer = class extends d.DefendedBase {
        constructor(p, t, q) {
            super();
            this._layout = p;
            this._runtime = p.GetRuntime();
            this._name = q[0];
            this._index = t;
            this._sid = q[2];
            this._isVisible = !!q[3];
            this._backgroundColor =
                d.New(d.Color);
            this._backgroundColor.setFromJSON(q[4].map(r => r / 255));
            this._isTransparent = !!q[5];
            this._parallaxX = q[6];
            this._parallaxY = q[7];
            this._color = d.New(d.Color, 1, 1, 1, q[8]);
            this._premultipliedColor = d.New(d.Color);
            this._isForceOwnTexture = q[9];
            this._useRenderCells = q[10];
            this._scaleRate = q[11];
            this._blendMode = q[12];
            this._curRenderTarget = null;
            this._scale = 1;
            this._zElevation = q[16];
            this._angle = 0;
            this._isAngleEnabled = !0;
            this._viewport = d.New(d.Rect);
            this._viewportZ0 = d.New(d.Rect);
            this._startupInitialInstances = [];
            this._initialInstances = [];
            this._createdGlobalUids = [];
            this._initialUIDsToInstanceData = new Map;
            this._instances = [];
            this._anyInstanceZElevated = this._zIndicesUpToDate = !1;
            this._effectList = d.New(d.EffectList, this, q[15]);
            this._renderGrid = null;
            this._lastRenderList = [];
            this._isRenderListUpToDate = !1;
            this._lastRenderCells = d.New(d.Rect, 0, 0, -1, -1);
            this._curRenderCells = d.New(d.Rect, 0, 0, -1, -1);
            this._iLayer = new self.ILayer(this);
            this._UpdatePremultipliedColor();
            this._useRenderCells && (this._renderGrid = d.New(d.RenderGrid,
                this._runtime.GetOriginalViewportWidth(), this._runtime.GetOriginalViewportHeight()));
            for (const r of q[14]) p = this._runtime.GetObjectClassByIndex(r[1]), this._layout._AddInitialObjectClass(p), p.GetDefaultInstanceData() || (p.SetDefaultInstanceData(r), p._SetDefaultLayerIndex(this._index)), this._initialInstances.push(r), this._initialUIDsToInstanceData.set(r[2], r);
            d.shallowAssignArray(this._startupInitialInstances, this._initialInstances)
        }
        static Create(p, t, q) {
            return d.New(d.Layer, p, t, q)
        }
        Release() {
            this._runtime =
                this._layout = null
        }
        GetInitialInstanceData(p) {
            return this._initialUIDsToInstanceData.get(p)
        }
        CreateInitialInstances(p) {
            const t = this._layout.IsFirstVisit();
            let q = 0;
            const r = this._initialInstances;
            for (let x = 0, y = r.length; x < y; ++x) {
                var u = r[x];
                const C = this._runtime.GetObjectClassByIndex(u[1]);
                let w = !0;
                if (!C.HasPersistBehavior() || t) u = this._runtime.CreateInstanceFromData(u, this, !0), p.push(u), C.IsGlobal() && (w = !1, this._createdGlobalUids.push(u.GetUID()));
                w && (r[q] = r[x], ++q)
            }
            d.truncateArray(r, q);
            this._runtime.FlushPendingInstances();
            this.SetZIndicesChanged()
        }
        _AddInstance(p, t) {
            const q = p.GetWorldInfo();
            if (q.GetLayer() !== this) throw Error("instance added to wrong layer");
            this._instances.push(p);
            0 !== q.GetZElevation() && (this._anyInstanceZElevated = !0);
            t && this._useRenderCells && p.GetWorldInfo().SetBboxChanged();
            this.SetZIndicesChanged()
        }
        _MaybeAddInstance(p) {
            this._instances.includes(p) || (this._instances.push(p), 0 !== p.GetWorldInfo().GetZElevation() && (this._anyInstanceZElevated = !0), this.SetZIndicesChanged())
        }
        _PrependInstance(p, t) {
            const q =
                p.GetWorldInfo();
            if (q.GetLayer() !== this) throw Error("instance added to wrong layer");
            this._instances.unshift(p);
            0 !== q.GetZElevation() && (this._anyInstanceZElevated = !0);
            this.SetZIndicesChanged();
            t && this._useRenderCells && p.GetWorldInfo().SetBboxChanged()
        }
        _RemoveInstance(p, t) {
            const q = this._instances.indexOf(p);
            0 > q || (t && this._useRenderCells && p.GetWorldInfo()._RemoveFromRenderCells(), this._instances.splice(q, 1), this.SetZIndicesChanged(), this._MaybeResetAnyInstanceZElevatedFlag())
        }
        _SetAnyInstanceZElevated() {
            this._anyInstanceZElevated = !0
        }
        _MaybeResetAnyInstanceZElevatedFlag() {
            0 === this._instances.length && (this._anyInstanceZElevated = !1)
        }
        _SortInstancesByLastCachedZIndex(p) {
            if (p) {
                p = new Set;
                for (var t of this._instances) {
                    var q = t.GetWorldInfo()._GetLastCachedZIndex();
                    0 <= q && p.add(q)
                }
                t = -1;
                for (const r of this._instances)
                    if (q = r.GetWorldInfo(), !(0 <= q._GetLastCachedZIndex())) {
                        for (++t; p.has(t);) ++t;
                        q._SetZIndex(t)
                    }
            }
            this._instances.sort(l)
        }
        _Start() {}
        _End() {
            for (const p of this._instances) p.GetObjectClass().IsGlobal() || this._runtime.DestroyInstance(p);
            this._runtime.FlushPendingInstances();
            d.clearArray(this._instances);
            this._anyInstanceZElevated = !1;
            this.SetZIndicesChanged()
        }
        RecreateInitialObjects(p, t, q, r, u) {
            const x = this._runtime.GetEventSheetManager(),
                y = this._runtime.GetAllObjectClasses(),
                C = p.IsFamily(),
                w = [];
            for (const K of this._initialInstances) {
                var A = K[0];
                if (t.containsPoint(A[0], A[1])) {
                    A = y[K[1]];
                    if (A !== p)
                        if (C) {
                            if (!p.FamilyHasMember(A)) continue
                        } else continue;
                    A = this;
                    var E = this._runtime.GetCurrentLayout();
                    this.GetLayout() !== E && ((A = E.GetLayerByName(this.GetName())) ||
                        (A = E.GetLayerByIndex(this.GetIndex())));
                    E = this._runtime.CreateInstanceFromData(K, A, !1, void 0, void 0, !1, u);
                    A.SortAndAddSceneGraphInstancesByZIndex(E);
                    A = E.GetWorldInfo();
                    A.OffsetXY(q, r);
                    A.SetBboxChanged();
                    x.BlockFlushingInstances(!0);
                    E._TriggerOnCreatedOnSelfAndRelated();
                    x.BlockFlushingInstances(!1);
                    w.push(E)
                }
            }
            return w
        }
        GetInstanceCount() {
            return this._instances.length
        }
        GetLayout() {
            return this._layout
        }
        GetName() {
            return this._name
        }
        GetIndex() {
            return this._index
        }
        GetSID() {
            return this._sid
        }
        GetRuntime() {
            return this._runtime
        }
        GetDevicePixelRatio() {
            return this._runtime.GetDevicePixelRatio()
        }
        GetEffectList() {
            return this._effectList
        }
        UsesRenderCells() {
            return this._useRenderCells
        }
        GetRenderGrid() {
            return this._renderGrid
        }
        SetRenderListStale() {
            this._isRenderListUpToDate = !1
        }
        IsVisible() {
            return this._isVisible
        }
        SetVisible(p) {
            p = !!p;
            this._isVisible !== p && (this._isVisible = p, this._runtime.UpdateRender())
        }
        GetViewport() {
            return this._viewport
        }
        GetViewportForZ(p, t) {
            var q = this._viewportZ0;
            if (0 === p) t.copy(q);
            else {
                const r = this.Get2DScaleFactorToZ(p);
                p = q.midX();
                const u = q.midY(),
                    x = .5 * q.width() / r;
                q = .5 * q.height() / r;
                t.set(p - x, u - q, p + x, u + q)
            }
        }
        GetOpacity() {
            return this._color.getA()
        }
        SetOpacity(p) {
            p = d.clamp(p, 0, 1);
            this._color.getA() !== p && (this._color.setA(p), this._UpdatePremultipliedColor(),
                this._runtime.UpdateRender())
        }
        _UpdatePremultipliedColor() {
            this._premultipliedColor.copy(this._color);
            this._premultipliedColor.premultiply()
        }
        GetPremultipliedColor() {
            return this._premultipliedColor
        }
        HasDefaultColor() {
            return this._color.equalsRgba(1, 1, 1, 1)
        }
        GetScaleRate() {
            return this._scaleRate
        }
        SetScaleRate(p) {
            this._scaleRate !== p && (this._scaleRate = p, this._runtime.UpdateRender())
        }
        GetParallaxX() {
            return this._parallaxX
        }
        GetParallaxY() {
            return this._parallaxY
        }
        SetParallax(p, t) {
            if (this._parallaxX !== p || this._parallaxY !==
                t)
                if (this._parallaxX = p, this._parallaxY = t, this._runtime.UpdateRender(), 1 !== this._parallaxX || 1 !== this._parallaxY)
                    for (const q of this._instances) q.GetObjectClass()._SetAnyInstanceParallaxed(!0)
        }
        SetParallaxX(p) {
            this.SetParallax(p, this.GetParallaxY())
        }
        SetParallaxY(p) {
            this.SetParallax(this.GetParallaxX(), p)
        }
        SetZElevation(p) {
            p = +p;
            this._zElevation !== p && (this._zElevation = p, this._runtime.UpdateRender())
        }
        GetZElevation() {
            return this._zElevation
        }
        SetAngle(p) {
            this._angle = d.clampAngle(p)
        }
        GetAngle() {
            return this._isAngleEnabled ?
                d.clampAngle(this._layout.GetAngle() + this._angle) : 0
        }
        GetOwnAngle() {
            return this._angle
        }
        HasInstances() {
            return 0 < this._instances.length
        }
        _GetInstances() {
            return this._instances
        }
        GetBackgroundColor() {
            return this._backgroundColor
        }
        IsTransparent() {
            return this._isTransparent
        }
        SetTransparent(p) {
            this._isTransparent = !!p
        }
        IsForceOwnTexture() {
            return this._isForceOwnTexture
        }
        SetForceOwnTexture(p) {
            this._isForceOwnTexture = !!p
        }
        SetBlendMode(p) {
            this._blendMode !== p && (this._blendMode = p, this._runtime.UpdateRender())
        }
        GetBlendMode() {
            return this._blendMode
        }
        IsTransformCompatibleWith(p) {
            return this ===
                p || this._parallaxX === p._parallaxX && this._parallaxY === p._parallaxY && this._scale === p._scale && this._scaleRate === p._scaleRate && this._angle === p._angle
        }
        _RemoveAllInstancesInSet(p) {
            0 !== p.size && 0 < d.arrayRemoveAllInSet(this._instances, p) && (this._MaybeResetAnyInstanceZElevatedFlag(), this.SetZIndicesChanged())
        }
        SetZIndicesChanged() {
            this._isRenderListUpToDate = this._zIndicesUpToDate = !1
        }
        _UpdateZIndices() {
            if (!this._zIndicesUpToDate) {
                this._instances.sort(m);
                if (this._useRenderCells)
                    for (let p = 0, t = this._instances.length; p <
                        t; ++p) {
                        const q = this._instances[p].GetWorldInfo();
                        q._SetZIndex(p);
                        this._renderGrid.MarkRangeChanged(q.GetRenderCellRange())
                    } else
                        for (let p = 0, t = this._instances.length; p < t; ++p) this._instances[p].GetWorldInfo()._SetZIndex(p);
                this._zIndicesUpToDate = !0
            }
        }
        MoveInstanceAdjacent(p, t, q) {
            var r = p.GetWorldInfo();
            t = t.GetWorldInfo();
            if (r.GetLayer() !== this || t.GetLayer() !== this) throw Error("can't arrange Z order unless both objects on this layer");
            r = r.GetZIndex();
            t = t.GetZIndex();
            if (r === t + (q ? 1 : -1)) return !1;
            d.arrayRemove(this._instances,
                r);
            r < t && t--;
            q && t++;
            t === this._instances.length ? this._instances.push(p) : this._instances.splice(t, 0, p);
            this.SetZIndicesChanged();
            return !0
        }
        _MergeSortedZArrays(p, t) {
            const q = [];
            let r = 0,
                u = 0,
                x = p.length,
                y = t.length;
            for (; r < x && u < y;) {
                const C = p[r],
                    w = t[u];
                C.GetWorldInfo()._GetLastCachedZIndex() < w.GetWorldInfo()._GetLastCachedZIndex() ? (q.push(C), ++r) : (q.push(w), ++u)
            }
            for (; r < x; ++r) q.push(p[r]);
            for (; u < y; ++u) q.push(t[u]);
            return q
        }
        _MergeAllSortedZArrays_pass(p) {
            const t = [],
                q = p.length;
            for (let r = 0; r < q - 1; r += 2) t.push(this._MergeSortedZArrays(p[r],
                p[r + 1]));
            1 === q % 2 && t.push(p[q - 1]);
            return t
        }
        _MergeAllSortedZArrays(p) {
            for (; 1 < p.length;) p = this._MergeAllSortedZArrays_pass(p);
            return p[0]
        }
        _GetRenderCellInstancesToDraw() {
            this._UpdateZIndices();
            d.clearArray(f);
            this._renderGrid.QueryRange(this._viewport, f);
            return f.length ? 1 === f.length ? f[0] : this._MergeAllSortedZArrays(f) : []
        }
        _IsOpaque() {
            return !this.UsesOwnTexture() && !this.IsTransparent()
        }
        ShouldDraw() {
            return this.IsVisible() && 0 < this.GetOpacity() && (this.HasInstances() || !this.IsTransparent())
        }
        UsesOwnTexture() {
            return this.IsForceOwnTexture() ||
                !this.HasDefaultColor() || 0 !== this.GetBlendMode() || this._effectList.HasAnyActiveEffect()
        }
        GetRenderTarget() {
            return this._curRenderTarget
        }
        _CanFastPathDrawLayer(p) {
            if (0 === p.length) return !0;
            if (2 <= p.length) return !1;
            p = p[0].GetShaderProgram();
            return !p.MustPreDraw() && !p.UsesDest() && !p.UsesCrossSampling() && this.HasDefaultColor()
        }
        Get2DScaleFactorToZ(p) {
            const t = this.GetCameraZ();
            return t / (t - p)
        }
        GetCameraZ() {
            return 100 / this.GetNormalScale()
        }
        _SetTransform(p, t = 0, q = 0) {
            const r = this._runtime.GetRenderScale();
            t = (this._viewport.midX() +
                t) * r;
            q = (this._viewport.midY() + q) * r;
            const u = this.GetCameraZ();
            p.SetCameraXYZ(t, q, u);
            p.SetLookXYZ(t, q, u - 100);
            t = this.GetAngle();
            0 === t ? g.set(h, 0, 1, 0) : g.set(h, Math.sin(t), Math.cos(t), 0);
            p.ResetModelView(h);
            p.Scale(r, r);
            p.UpdateModelView()
        }
        Draw(p, t, q) {
            const r = this._runtime.GetCanvasManager(),
                u = this.UsesOwnTexture();
            var x = null;
            let y = null;
            if (this._runtime.IsGPUProfiling() && p.SupportsGPUProfiling()) {
                const C = r.GetLayerTimingsBuffer(this);
                C && (y = C.AddTimeElapsedQuery(), p.StartQuery(y))
            }
            u ? (x = {
                    sampling: this._runtime.GetSampling()
                },
                "low" === r.GetCurrentFullscreenScalingQuality() && (x.width = r.GetDrawWidth(), x.height = r.GetDrawHeight()), x = this._runtime.GetAdditionalRenderTarget(x), p.SetRenderTarget(x), this.IsTransparent() && p.ClearRgba(0, 0, 0, 0)) : p.SetRenderTarget(t);
            this.IsTransparent() || p.Clear(this._backgroundColor);
            this._curRenderTarget = x || t;
            this._SetTransform(p);
            p.SetBaseZ(this.GetZElevation());
            this.GetNormalScale() > Number.EPSILON && (this._UpdateZIndices(), this._useRenderCells && 0 === this.GetZElevation() && !this._anyInstanceZElevated ?
                this._DrawInstances_RenderCells(p) : this._DrawInstances(p, this._instances));
            p.SetBaseZ(0);
            p.SetCurrentZ(0);
            p.SetCameraXYZ(0, 0, 100);
            p.SetLookXYZ(0, 0, 0);
            u && this._DrawLayerOwnTextureToRenderTarget(p, x, t, q);
            y && p.EndQuery(y);
            this._curRenderTarget = null
        }
        _DrawInstances(p, t) {
            const q = this._viewport,
                r = this._curRenderTarget;
            let u = null;
            for (let x = 0, y = t.length; x < y; ++x) {
                const C = t[x];
                if (C === u) continue;
                u = C;
                const w = C.GetWorldInfo();
                w.IsVisible() && w.IsInViewport(q) && (w.HasAnyActiveEffect() ? this._DrawInstanceWithEffectsAndRestore(C,
                    w, p, r) : this._DrawInstance(C, w, p))
            }
        }
        _DrawInstances_RenderCells(p) {
            var t = this._renderGrid;
            const q = this._curRenderCells,
                r = this._lastRenderCells,
                u = this._viewport;
            q.set(t.XToCell(u.getLeft()), t.YToCell(u.getTop()), t.XToCell(u.getRight()), t.YToCell(u.getBottom()));
            this._isRenderListUpToDate && q.equals(r) ? t = this._lastRenderList : (t = this._GetRenderCellInstancesToDraw(), this._isRenderListUpToDate = !0, r.copy(q));
            this._DrawInstances(p, t);
            t !== this._lastRenderList && d.shallowAssignArray(this._lastRenderList, t)
        }
        _DrawInstance(p,
            t, q) {
            t = t.GetRendererStateGroup();
            q.GetCurrentStateGroup() !== t && t.Apply();
            p.Draw(q)
        }
        _DrawInstanceWithEffectsAndRestore(p, t, q, r) {
            this._DrawInstanceWithEffects(p, t, q, r, null) && this._SetTransform(q)
        }
        _DrawInstanceWithEffects(p, t, q, r, u) {
            const x = t.GetInstanceEffectList().GetActiveEffectTypes();
            if (1 === x.length) {
                const y = x[0],
                    C = y.GetShaderProgram();
                if (!C.NeedsPostDrawOrExtendsBox() && t.HasDefaultColor() && !p.MustPreDraw()) return this._DrawInstanceWithEffects_FastPath(p, t, y, C, q), !1
            }
            p = d.RenderEffectChain(q, this._runtime,
                p, r, x, u);
            q.SetBaseZ(this.GetZElevation());
            return p
        }
        _DrawInstanceWithEffects_FastPath(p, t, q, r, u) {
            u.SetProgram(r);
            u.SetBlendMode(t.GetBlendMode());
            r.IsAnimated() && this._runtime.UpdateRender();
            let x = 0,
                y = 0;
            if (r.UsesAnySrcRectOrPixelSize()) {
                const [C, w] = p.GetCurrentSurfaceSize();
                x = 1 / C;
                y = 1 / w;
                (r = p.GetCurrentTexRect()) ? e.copy(r): e.set(0, 0, 0, 0)
            }
            q = t.GetInstanceEffectList().GetEffectParametersForIndex(q.GetIndex());
            u.SetCurrentZ(t.GetZElevation());
            u.SetProgramParameters(null, c, e, e, t.GetBoundingBox(), x, y, this.GetOwnScale(),
                this.GetAngle(), this._runtime.GetGameTime(), q);
            p.Draw(u)
        }
        _DrawLayerOwnTextureToRenderTarget(p, t, q, r) {
            const u = this._effectList.GetActiveEffectTypes(),
                x = this._runtime;
            if (this._CanFastPathDrawLayer(u)) {
                p.SetRenderTarget(q);
                if (1 === u.length) {
                    var y = u[0];
                    q = y.GetShaderProgram();
                    p.SetProgram(q);
                    e.set(0, 0, 1, 1);
                    y = this._effectList.GetEffectParametersForIndex(y.GetIndex());
                    p.SetProgramParameters(null, c, e, e, this._viewport, 1 / x.GetDrawWidth(), 1 / x.GetDrawHeight(), this.GetNormalScale(), this.GetAngle(), x.GetGameTime(),
                        y);
                    q.IsAnimated() && x.UpdateRender()
                } else p.SetTextureFillMode();
                r && 0 === this._blendMode && this.HasDefaultColor() && 0 === u.length ? p.CopyRenderTarget(t) : (p.SetBlendMode(this._blendMode), p.SetColor(this._premultipliedColor), p.DrawRenderTarget(t));
                p.InvalidateRenderTarget(t);
                x.ReleaseAdditionalRenderTarget(t)
            } else d.RenderEffectChain(p, x, this, q, u)
        }
        GetOwnScale() {
            return this._scale
        }
        SetOwnScale(p) {
            this._scale !== p && (this._scale = p, this._layout.BoundScrolling(), this._runtime.UpdateRender())
        }
        GetRenderScale() {
            return this.GetNormalScale() *
                this._runtime.GetRenderScale()
        }
        GetDisplayScale() {
            return this.GetNormalScale() * this._runtime.GetDisplayScale()
        }
        GetNormalScale() {
            return (this._scale * this._layout.GetScale() - 1) * this._scaleRate + 1
        }
        UpdateViewport() {
            this._isAngleEnabled = !1;
            let [p, t] = this.CanvasCssToLayer(0, 0);
            this._isAngleEnabled = !0;
            this._runtime.IsPixelRoundingEnabled() && (p = Math.round(p), t = Math.round(t));
            var q = 1 / this.GetNormalScale();
            const r = this._viewportZ0;
            r.set(p, t, p + this._runtime.GetViewportWidth() * q, t + this._runtime.GetViewportHeight() *
                q);
            q = this.GetAngle();
            0 !== q && (b.copy(r), b.offset(-r.midX(), -r.midY()), a.setFromRotatedRect(b, q), a.getBoundingBox(b), b.offset(r.midX(), r.midY()), r.copy(b));
            this.GetViewportForZ(this._zElevation, this._viewport)
        }
        CanvasCssToLayer(p, t, q = 0) {
            return this._CanvasToLayer(p, t, q, this.GetDisplayScale())
        }
        DrawSurfaceToLayer(p, t, q = 0) {
            return this._CanvasToLayer(p, t, q, this.GetRenderScale() * this.GetDevicePixelRatio())
        }
        _CanvasToLayer(p, t, q, r) {
            var u = this._runtime.GetParallaxXOrigin(),
                x = this._runtime.GetParallaxYOrigin();
            u = (this._layout.GetScrollX() - u) * this._parallaxX + u;
            x = (this._layout.GetScrollY() - x) * this._parallaxY + x;
            var y = this.GetNormalScale(),
                C = this._runtime.GetViewportWidth() / y;
            y = this._runtime.GetViewportHeight() / y;
            p = u - C / 2 + p / r;
            t = x - y / 2 + t / r;
            C = this.GetAngle();
            0 !== C && (p -= u, t -= x, r = Math.cos(C), C = Math.sin(C), y = p * r - t * C, t = t * r + p * C, p = y, p += u, t += x);
            0 !== q && (u = this._viewportZ0.midX(), x = this._viewportZ0.midY(), q = this.Get2DScaleFactorToZ(q), p = (p - u) / q + u, t = (t - x) / q + x);
            return [p, t]
        }
        CanvasCssToLayer_DefaultTransform(p, t) {
            const q = this._scale,
                r = this._scaleRate,
                u = this._parallaxX,
                x = this._parallaxY,
                y = this._angle;
            this._parallaxY = this._parallaxX = this._scaleRate = this._scale = 1;
            this._angle = 0;
            p = this.CanvasCssToLayer(p, t);
            this._scale = q;
            this._scaleRate = r;
            this._parallaxX = u;
            this._parallaxY = x;
            this._angle = y;
            return p
        }
        LayerToCanvasCss(p, t, q = 0) {
            return this._LayerToCanvas(p, t, q, this.GetDisplayScale())
        }
        LayerToDrawSurface(p, t, q = 0) {
            return this._LayerToCanvas(p, t, q, this.GetRenderScale() * this.GetDevicePixelRatio())
        }
        _LayerToCanvas(p, t, q, r) {
            var u = this._runtime,
                x = this._layout;
            if (0 !== q) {
                var y = this._viewportZ0.midX(),
                    C = this._viewportZ0.midY();
                q = this.Get2DScaleFactorToZ(q);
                p = (p - y) * q + y;
                t = (t - C) * q + C
            }
            y = u.GetParallaxXOrigin();
            C = u.GetParallaxYOrigin();
            y = (x.GetScrollX() - y) * this._parallaxX + y;
            x = (x.GetScrollY() - C) * this._parallaxY + C;
            q = this.GetAngle();
            if (0 !== q) {
                p -= y;
                t -= x;
                C = Math.cos(-q);
                q = Math.sin(-q);
                const w = p * C - t * q;
                t = t * C + p * q;
                p = w;
                p += y;
                t += x
            }
            q = this.GetNormalScale();
            C = u.GetViewportWidth() / q;
            u = u.GetViewportHeight() / q;
            return [(p - (y - C / 2)) * r, (t - (x - u / 2)) * r]
        }
        _GetLayerToDrawSurfaceScale(p,
            t) {
            p *= this.GetRenderScale() * this.GetDevicePixelRatio();
            0 !== t && (p *= this.Get2DScaleFactorToZ(t));
            return p
        }
        _SaveToJson() {
            return {
                s: this.GetOwnScale(),
                a: this.GetOwnAngle(),
                vl: this._viewport.getLeft(),
                vt: this._viewport.getTop(),
                vr: this._viewport.getRight(),
                vb: this._viewport.getBottom(),
                v: this.IsVisible(),
                bc: this._backgroundColor.toJSON(),
                t: this.IsTransparent(),
                px: this.GetParallaxX(),
                py: this.GetParallaxY(),
                c: this._color.toJSON(),
                sr: this.GetScaleRate(),
                fx: this._effectList.SaveToJson(),
                cg: this._createdGlobalUids
            }
        }
        _LoadFromJson(p) {
            this._scale =
                p.s;
            this._angle = p.a;
            this._viewport.set(p.vl, p.vt, p.vr, p.vb);
            this._isVisible = !!p.v;
            this._backgroundColor.setFromJSON(p.bc);
            this._isTransparent = !!p.t;
            this._parallaxX = p.px;
            this._parallaxY = p.py;
            this._color.setFromJSON(p.c);
            this._scaleRate = p.sr;
            d.shallowAssignArray(this._createdGlobalUids, p.cg);
            d.shallowAssignArray(this._initialInstances, this._startupInitialInstances);
            const t = new Set(this._createdGlobalUids);
            let q = 0;
            for (let r = 0, u = this._initialInstances.length; r < u; ++r) t.has(this._initialInstances[r][2]) ||
                (this._initialInstances[q] = this._initialInstances[r], ++q);
            d.truncateArray(this._initialInstances, q);
            this._effectList.LoadFromJson(p.fx);
            this._SortInstancesByLastCachedZIndex(!1);
            this.SetZIndicesChanged()
        }
        GetILayer() {
            return this._iLayer
        }
        SortAndAddSceneGraphInstancesByZIndex(p) {
            if (!this._instances.includes(p))
                if (p.HasChildren()) {
                    const t = [...p.allChildren()];
                    t.push(p);
                    t.sort((q, r) => {
                        q = q.GetWorldInfo().GetSceneGraphZIndex();
                        r = r.GetWorldInfo().GetSceneGraphZIndex();
                        return q - r
                    });
                    for (const q of t) this._AddInstance(q,
                        !0)
                } else this._AddInstance(p, !0)
        }
    }
}
"use strict";
{
    const d = self.C3,
        b = self.C3Debugger,
        a = d.New(d.Rect),
        f = d.New(d.Rect),
        c = d.New(d.Rect);
    d.Layout = class extends d.DefendedBase {
        constructor(e, g, h) {
            super();
            this._layoutManager = e;
            this._runtime = e.GetRuntime();
            this._name = h[0];
            this._originalWidth = h[1];
            this._originalHeight = h[2];
            this._width = h[1];
            this._height = h[2];
            this._isUnboundedScrolling = !!h[3];
            this._eventSheetName = h[4];
            this._eventSheet = null;
            this._sid = h[5];
            this._index = g;
            this._scrollY = this._scrollX = 0;
            this._scale = 1;
            this._angle = 0;
            this._initialObjectClasses = new Set;
            this._textureLoadedTypes = new Set;
            this._textureLoadPendingPromises = new Set;
            this._createdInstances = [];
            this._initialNonWorld = [];
            this._layers = [];
            this._layersByName = new Map;
            this._layersBySid = new Map;
            this._effectList = d.New(d.EffectList, this, h[8]);
            this._curRenderTarget = null;
            this._persistData = {};
            this._isFirstVisit = !0;
            this._iLayout = new self.ILayout(this);
            this._userScriptDispatcher = d.New(d.Event.Dispatcher);
            for (const l of h[6]) e = d.Layer.Create(this, this._layers.length, l), this._layers.push(e), this._layersByName.set(e.GetName().toLowerCase(),
                e), this._layersBySid.set(e.GetSID(), e);
            for (const l of h[7]) {
                h = this._runtime.GetObjectClassByIndex(l[1]);
                if (!h) throw Error("missing nonworld object class");
                h.GetDefaultInstanceData() || h.SetDefaultInstanceData(l);
                this._initialNonWorld.push(l);
                this._AddInitialObjectClass(h)
            }
        }
        Release() {
            for (const e of this._layers) e.Release();
            d.clearArray(this._layers);
            this._textureLoadPendingPromises.clear();
            this._runtime = this._layoutManager = this._eventSheet = null
        }
        GetRuntime() {
            return this._runtime
        }
        GetName() {
            return this._name
        }
        GetSID() {
            return this._sid
        }
        GetIndex() {
            return this._index
        }
        GetEffectList() {
            return this._effectList
        }
        GetMinLayerScale() {
            let e =
                this._layers[0].GetNormalScale();
            for (let g = 1, h = this._layers.length; g < h; ++g) {
                const l = this._layers[g];
                if (0 !== l.GetParallaxX() || 0 !== l.GetParallaxY()) e = Math.min(e, l.GetNormalScale())
            }
            return e
        }
        SetScrollX(e) {
            if (!this._isUnboundedScrolling) {
                const g = this._runtime.GetViewportWidth() * (1 / this.GetMinLayerScale()) / 2;
                e > this._width - g && (e = this._width - g);
                e < g && (e = g)
            }
            this._scrollX !== e && (this._scrollX = e, this._runtime.UpdateRender())
        }
        GetScrollX() {
            return this._scrollX
        }
        SetScrollY(e) {
            if (!this._isUnboundedScrolling) {
                const g =
                    this._runtime.GetViewportHeight() * (1 / this.GetMinLayerScale()) / 2;
                e > this._height - g && (e = this._height - g);
                e < g && (e = g)
            }
            this._scrollY !== e && (this._scrollY = e, this._runtime.UpdateRender())
        }
        GetScrollY() {
            return this._scrollY
        }
        BoundScrolling() {
            this.SetScrollX(this.GetScrollX());
            this.SetScrollY(this.GetScrollY())
        }
        GetScale() {
            return this._scale
        }
        SetScale(e) {
            e = +e;
            this._scale !== e && (this._scale = e, this.BoundScrolling())
        }
        SetAngle(e) {
            this._angle = d.clampAngle(e)
        }
        GetAngle() {
            return this._angle
        }
        GetWidth() {
            return this._width
        }
        SetWidth(e) {
            !isFinite(e) ||
                1 > e || (this._width = e)
        }
        GetHeight() {
            return this._height
        }
        SetHeight(e) {
            !isFinite(e) || 1 > e || (this._height = e)
        }
        GetEventSheet() {
            return this._eventSheet
        }
        GetLayers() {
            return this._layers
        }
        GetLayerCount() {
            return this._layers.length
        }
        GetLayer(e) {
            return "number" === typeof e ? this.GetLayerByIndex(e) : this.GetLayerByName(e.toString())
        }
        GetLayerByIndex(e) {
            e = d.clamp(Math.floor(e), 0, this._layers.length - 1);
            return this._layers[e]
        }
        GetLayerByName(e) {
            return this._layersByName.get(e.toLowerCase()) || null
        }
        GetLayerBySID(e) {
            return this._layersBySid.get(e) ||
                null
        }
        HasOpaqueBottomLayer() {
            for (const e of this._layers)
                if (e.ShouldDraw()) return e._IsOpaque();
            return !1
        }
        IsFirstVisit() {
            return this._isFirstVisit
        }
        _GetInitialObjectClasses() {
            return [...this._initialObjectClasses]
        }
        _AddInitialObjectClass(e) {
            if (e.IsInContainer())
                for (const g of e.GetContainer().GetObjectTypes()) this._initialObjectClasses.add(g);
            else this._initialObjectClasses.add(e)
        }
        _GetTextureLoadedObjectTypes() {
            return [...this._textureLoadedTypes]
        }
        _Load(e, g) {
            if (e === this || !g) return Promise.resolve();
            e &&
                (d.CopySet(this._textureLoadedTypes, e._textureLoadedTypes), e._textureLoadedTypes.clear());
            e = [];
            for (const h of this._initialObjectClasses) this._textureLoadedTypes.has(h) || (e.push(h.LoadTextures(g)), this._textureLoadedTypes.add(h));
            return Promise.all(e)
        }
        async MaybeLoadTexturesFor(e) {
            if (e.IsFamily()) throw Error("cannot load textures for family");
            var g = this._runtime.GetWebGLRenderer();
            !g || g.IsContextLost() || this._textureLoadedTypes.has(e) || (this._textureLoadedTypes.add(e), g = e.LoadTextures(g), this._AddPendingTextureLoadPromise(g),
                await g, e.OnDynamicTextureLoadComplete(), this._runtime.UpdateRender())
        }
        _AddPendingTextureLoadPromise(e) {
            this._textureLoadPendingPromises.add(e);
            e.then(() => this._textureLoadPendingPromises.delete(e)).catch(() => this._textureLoadPendingPromises.delete(e))
        }
        WaitForPendingTextureLoadsToComplete() {
            return Promise.all([...this._textureLoadPendingPromises])
        }
        MaybeUnloadTexturesFor(e) {
            if (e.IsFamily() || 0 < e.GetInstanceCount()) throw Error("cannot unload textures");
            const g = this._runtime.GetWebGLRenderer();
            g && this._textureLoadedTypes.has(e) &&
                (this._textureLoadedTypes.delete(e), e.ReleaseTextures(g))
        }
        _Unload(e, g) {
            if (e !== this && g)
                for (const h of this._textureLoadedTypes) h.IsGlobal() || e._initialObjectClasses.has(h) || (h.ReleaseTextures(), this._textureLoadedTypes.delete(h))
        }
        _OnWebGLContextLost() {
            this._textureLoadedTypes.clear()
        }
        async _StartRunning(e) {
            const g = this._runtime,
                h = this._layoutManager,
                l = g.GetEventSheetManager();
            this._eventSheetName && (this._eventSheet = l.GetEventSheetByName(this._eventSheetName), this._eventSheet._UpdateDeepIncludes());
            h._SetMainRunningLayout(this);
            this._width = this._originalWidth;
            this._height = this._originalHeight;
            this._scrollX = g.GetOriginalViewportWidth() / 2;
            this._scrollY = g.GetOriginalViewportHeight() / 2;
            this.BoundScrolling();
            this._MoveGlobalObjectsToThisLayout(e);
            this._runtime.SetUsingCreatePromises(!0);
            this._CreateInitialInstances();
            this._isFirstVisit || this._CreatePersistedInstances();
            this._CreateAndLinkContainerInstances(this._createdInstances);
            this._CreateInitialNonWorldInstances();
            h.ClearPendingChangeLayout();
            g.FlushPendingInstances();
            this._runtime.SetUsingCreatePromises(!1);
            const m = this._runtime.GetCreatePromises();
            await Promise.all(m);
            d.clearArray(m);
            if (!g.IsLoadingState()) {
                for (const p of this._createdInstances) p.SetupInitialSceneGraphConnections();
                for (const p of this._createdInstances) p._TriggerOnCreated()
            }
            d.clearArray(this._createdInstances);
            await Promise.all([...this._initialObjectClasses].map(p => p.PreloadTexturesWithInstances(this._runtime.GetWebGLRenderer())));
            e && (g.Dispatcher().dispatchEvent(new d.Event("beforefirstlayoutstart")),
                await g.DispatchUserScriptEventAsyncWait(new d.Event("beforeprojectstart")));
            await this.DispatchUserScriptEventAsyncWait(new d.Event("beforelayoutstart"));
            g.IsLoadingState() || await g.TriggerAsync(d.Plugins.System.Cnds.OnLayoutStart, null, null);
            await this.DispatchUserScriptEventAsyncWait(new d.Event("afterlayoutstart"));
            e && (g.Dispatcher().dispatchEvent(new d.Event("afterfirstlayoutstart")), await g.DispatchUserScriptEventAsyncWait(new d.Event("afterprojectstart")));
            l._RunQueuedTriggers(h);
            await this.WaitForPendingTextureLoadsToComplete();
            this._isFirstVisit = !1
        }
        _MoveGlobalObjectsToThisLayout(e) {
            for (const h of this._runtime.GetAllObjectClasses())
                if (!h.IsFamily() && h.IsWorldType())
                    for (const l of h.GetInstances()) {
                        const m = l.GetWorldInfo();
                        var g = m.GetLayer();
                        g = d.clamp(g.GetIndex(), 0, this._layers.length - 1);
                        g = this._layers[g];
                        m._SetLayer(g);
                        g._MaybeAddInstance(l)
                    }
            if (!e)
                for (const h of this._layers) h._SortInstancesByLastCachedZIndex(!1)
        }
        _CreateInitialInstances() {
            for (const e of this._layers) e.CreateInitialInstances(this._createdInstances), e.UpdateViewport(),
                e._Start()
        }
        _CreatePersistedInstances() {
            let e = !1;
            for (const [h, l] of Object.entries(this._persistData)) {
                const m = this._runtime.GetObjectClassBySID(parseInt(h, 10));
                if (m && !m.IsFamily() && m.HasPersistBehavior()) {
                    for (const p of l) {
                        var g = null;
                        if (m.IsWorldType() && (g = this.GetLayerBySID(p.w.l), !g)) continue;
                        g = this._runtime.CreateInstanceFromData(m, g, !1, 0, 0, !0);
                        g.LoadFromJson(p);
                        e = !0;
                        this._createdInstances.push(g)
                    }
                    d.clearArray(l)
                }
            }
            for (const h of this._layers) h._SortInstancesByLastCachedZIndex(!0), h.SetZIndicesChanged();
            e && (this._runtime.FlushPendingInstances(), this._runtime._RefreshUidMap())
        }
        _CreateAndLinkContainerInstances(e) {
            for (const h of e) {
                if (!h.IsInContainer()) continue;
                const l = h.GetWorldInfo(),
                    m = h.GetIID();
                for (const p of h.GetObjectClass().GetContainer().objectTypes())
                    if (p !== h.GetObjectClass()) {
                        var g = p.GetInstances();
                        g.length > m ? h._AddSibling(g[m]) : (g = l ? this._runtime.CreateInstanceFromData(p, l.GetLayer(), !0, l.GetX(), l.GetY(), !0) : this._runtime.CreateInstanceFromData(p, null, !0, 0, 0, !0), this._runtime.FlushPendingInstances(),
                            p._UpdateIIDs(), h._AddSibling(g), e.push(g))
                    }
            }
        }
        _CreateInitialNonWorldInstances() {
            for (const e of this._initialNonWorld) this._runtime.GetObjectClassByIndex(e[1]).IsInContainer() || this._runtime.CreateInstanceFromData(e, null, !0)
        }
        _CreateGlobalNonWorlds() {
            const e = [],
                g = this._initialNonWorld;
            let h = 0;
            for (let l = 0, m = g.length; l < m; ++l) {
                const p = g[l],
                    t = this._runtime.GetObjectClassByIndex(p[1]);
                t.IsGlobal() ? t.IsInContainer() && t.GetContainer().HasAnyWorldType() || e.push(this._runtime.CreateInstanceFromData(p, null, !0)) :
                    (g[h] = p, ++h)
            }
            d.truncateArray(g, h);
            this._runtime.FlushPendingInstances();
            this._CreateAndLinkContainerInstances(e)
        }
        RecreateInitialObjects(e, g, h, l, m, p) {
            if (h) return h.RecreateInitialObjects(e, g, l, m, p);
            h = [];
            for (const t of this._layers) h.push(t.RecreateInitialObjects(e, g, l, m, p));
            return h.flat()
        }
        async _StopRunning() {
            const e = this._layoutManager;
            this._runtime.IsLoadingState() || await this._runtime.TriggerAsync(d.Plugins.System.Cnds.OnLayoutEnd, null, null);
            e.SetIsEndingLayout(!0);
            this._runtime.GetEventSheetManager().ClearAllScheduledWaits();
            this._isFirstVisit || this._SavePersistData();
            for (const g of this._layers) g._End();
            for (const g of this._runtime.GetAllObjectClasses())
                if (!(g.IsGlobal() || g.IsWorldType() || g.GetPlugin().IsSingleGlobal() || g.IsFamily())) {
                    for (const h of g.GetInstances()) this._runtime.DestroyInstance(h);
                    this._runtime.FlushPendingInstances()
                } e.SetIsEndingLayout(!1);
            e.GetMainRunningLayout() === this && e._SetMainRunningLayout(null)
        }
        _SaveInstanceToPersist(e) {
            const g = e.GetObjectClass().GetSID().toString();
            this._persistData.hasOwnProperty(g) ||
                (this._persistData[g] = []);
            this._persistData[g].push(e.SaveToJson())
        }
        _SavePersistData() {
            for (const e of this._layers) {
                e._UpdateZIndices();
                for (const g of e._GetInstances()) {
                    const h = g.GetObjectClass();
                    !h.IsGlobal() && h.HasPersistBehavior() && this._SaveInstanceToPersist(g)
                }
            }
        }
        ResetPersistData() {
            this._persistData = {};
            this._isFirstVisit = !0
        }
        GetRenderTarget() {
            return this._curRenderTarget
        }
        UsesOwnTexture() {
            return "low" === this._runtime.GetCanvasManager().GetCurrentFullscreenScalingQuality() || this._runtime.UsesAnyBackgroundBlending() ||
                "low-latency" === this._runtime.GetCompositingMode() || this._effectList.HasAnyActiveEffect()
        }
        _CanFastPathDrawLayout(e) {
            return 0 === e.length ? !0 : 2 <= e.length ? !1 : !e[0].GetShaderProgram().MustPreDraw()
        }
        Draw(e) {
            var g = this._runtime.GetCanvasManager();
            const h = this.UsesOwnTexture();
            var l = null;
            h ? ("low-latency" !== this._runtime.GetCompositingMode() && (e.SetRenderTarget(null), e.ClearRgba(0, 0, 0, 0)), l = {
                    sampling: this._runtime.GetSampling(),
                    readback: this._runtime.UsesAnyBackgroundBlending() || this._effectList.HasAnyActiveEffect()
                },
                "low" === g.GetCurrentFullscreenScalingQuality() && (l.width = g.GetDrawWidth(), l.height = g.GetDrawHeight()), l = this._runtime.GetAdditionalRenderTarget(l), e.SetRenderTarget(l)) : e.SetRenderTarget(null);
            this.HasOpaqueBottomLayer() || e.ClearRgba(0, 0, 0, 0);
            this._curRenderTarget = l;
            g = !0;
            for (const m of this._layers) m.UpdateViewport(), m.ShouldDraw() && (m.Draw(e, l, g), g = !1);
            h && this._DrawLayoutOwnTextureToRenderTarget(e, l);
            this._curRenderTarget = null
        }
        _DrawLayoutOwnTextureToRenderTarget(e, g) {
            const h = this._effectList.GetActiveEffectTypes(),
                l = this._runtime;
            if (this._CanFastPathDrawLayout(h)) {
                e.SetRenderTarget(null);
                if (1 === h.length) {
                    var m = h[0];
                    const p = m.GetShaderProgram();
                    e.SetProgram(p);
                    f.set(0, 0, 1, 1);
                    c.set(0, 0, l.GetViewportWidth(), l.GetViewportHeight());
                    m = this._effectList.GetEffectParametersForIndex(m.GetIndex());
                    e.SetProgramParameters(null, a, f, f, c, 1 / l.GetDrawWidth(), 1 / l.GetDrawHeight(), this.GetScale(), this.GetAngle(), l.GetGameTime(), m);
                    p.IsAnimated() && l.UpdateRender()
                } else e.SetTextureFillMode();
                0 === h.length ? e.CopyRenderTarget(g) : (e.SetAlphaBlend(),
                    e.ResetColor(), e.DrawRenderTarget(g));
                e.InvalidateRenderTarget(g);
                l.ReleaseAdditionalRenderTarget(g)
            } else d.RenderEffectChain(e, l, this, null, h)
        }
        _SaveToJson() {
            const e = {
                sx: this.GetScrollX(),
                sy: this.GetScrollY(),
                s: this.GetScale(),
                a: this.GetAngle(),
                w: this.GetWidth(),
                h: this.GetHeight(),
                fv: this._isFirstVisit,
                persist: this._persistData,
                fx: this._effectList.SaveToJson(),
                layers: {}
            };
            for (const g of this._layers) e.layers[g.GetSID().toString()] = g._SaveToJson();
            return e
        }
        _LoadFromJson(e) {
            this._scrollX = e.sx;
            this._scrollY =
                e.sy;
            this._scale = e.s;
            this._angle = e.a;
            this._width = e.w;
            this._height = e.h;
            this._isFirstVisit = !!e.fv;
            this._persistData = e.persist;
            this._effectList.LoadFromJson(e.fx);
            for (const [g, h] of Object.entries(e.layers)) e = parseInt(g, 10), (e = this.GetLayerBySID(e)) && e._LoadFromJson(h)
        }
        GetILayout() {
            return this._iLayout
        }
        UserScriptDispatcher() {
            return this._userScriptDispatcher
        }
        DispatchUserScriptEvent(e) {
            e.layout = this.GetILayout();
            var g = this._runtime;
            (g = g.IsDebug() && !g.GetEventSheetManager().IsInEventEngine()) && b.StartMeasuringScriptTime();
            this._userScriptDispatcher.dispatchEvent(e);
            g && b.AddScriptTime()
        }
        DispatchUserScriptEventAsyncWait(e) {
            e.layout = this.GetILayout();
            return this._userScriptDispatcher.dispatchEventAndWaitAsync(e)
        }
    }
}
"use strict";
{
    const d = self.C3;
    d.LayoutManager = class extends d.DefendedBase {
        constructor(b) {
            super();
            this._runtime = b;
            this._allLayouts = [];
            this._layoutsByName = new Map;
            this._layoutsBySid = new Map;
            this._mainRunningLayout = null;
            this._runningSubLayouts = [];
            this._firstLayout = null;
            this._isEndingLayout = 0;
            this._pendingChangeLayout = null
        }
        Release() {
            this._pendingChangeLayout = this._firstLayout = this._mainRunningLayout = this._runtime = null;
            d.clearArray(this._allLayouts);
            this._layoutsByName.clear();
            this._layoutsBySid.clear();
            d.clearArray(this._runningSubLayouts)
        }
        Create(b) {
            b =
                d.New(d.Layout, this, this._allLayouts.length, b);
            this._allLayouts.push(b);
            this._layoutsByName.set(b.GetName().toLowerCase(), b);
            this._layoutsBySid.set(b.GetSID(), b)
        }
        GetRuntime() {
            return this._runtime
        }
        SetFirstLayout(b) {
            this._firstLayout = b
        }
        GetFirstLayout() {
            if (this._firstLayout) return this._firstLayout;
            if (this._allLayouts.length) return this._allLayouts[0];
            throw Error("no first layout");
        }
        GetLayoutByName(b) {
            return this._layoutsByName.get(b.toLowerCase()) || null
        }
        GetLayoutBySID(b) {
            return this._layoutsBySid.get(b) ||
                null
        }
        GetLayoutByIndex(b) {
            b = d.clamp(Math.floor(b), 0, this._allLayouts.length - 1);
            return this._allLayouts[b]
        }
        GetLayout(b) {
            return "number" === typeof b ? this.GetLayoutByIndex(b) : this.GetLayoutByName(b.toString())
        }
        GetAllLayouts() {
            return this._allLayouts
        }
        _SetMainRunningLayout(b) {
            this._mainRunningLayout = b
        }
        GetMainRunningLayout() {
            return this._mainRunningLayout
        }
        _AddRunningSubLayout(b) {
            if (this._runningSubLayouts.includes(b)) throw Error("layout already running");
            this._runningSubLayouts.push(b)
        }
        _RemoveRunningSubLayout(b) {
            b =
                this._runningSubLayouts.indexOf(b);
            if (-1 === b) throw Error("layout not running");
            this._runningSubLayouts.splice(b, 1)
        }* runningLayouts() {
            this._mainRunningLayout && (yield this._mainRunningLayout);
            this._runningSubLayouts.length && (yield* this._runningSubLayouts)
        }
        IsLayoutRunning(b) {
            return this._mainRunningLayout === b || this._runningSubLayouts.includes(b)
        }
        SetIsEndingLayout(b) {
            if (b) this._isEndingLayout++;
            else {
                if (0 >= this._isEndingLayout) throw Error("already unset");
                this._isEndingLayout--
            }
        }
        IsEndingLayout() {
            return 0 <
                this._isEndingLayout
        }
        ChangeMainLayout(b) {
            this._pendingChangeLayout = b
        }
        ClearPendingChangeLayout() {
            this._pendingChangeLayout = null
        }
        IsPendingChangeMainLayout() {
            return !!this._pendingChangeLayout
        }
        GetPendingChangeMainLayout() {
            return this._pendingChangeLayout
        }
    }
}
"use strict";
{
    const d = self.C3;
    class b {
        constructor() {
            this.runtime = this.renderer = null;
            this.surfaceHeight = this.surfaceWidth = this.drawHeight = this.drawWidth = 0;
            this.layoutRect = new d.Rect;
            this.rcTexBounce = new d.Rect;
            this.rcTexDest = new d.Rect;
            this.rcTexOrigin = new d.Rect;
            this.screenRect = new d.Rect;
            this.clearRect = new d.Rect;
            this.srcRect = new d.Rect;
            this.fxTex = [null, null];
            this.fxIndex = 0;
            this.otherFxIndex = 1;
            this.layerAngle = this.layerScale = this.boxExtendVertical = this.boxExtendHorizontal = 0;
            this.renderTarget = this.wi = this.inst =
                this.layer = this.layout = null;
            this.didChangeTransform = this.postDraw = this.preDraw = !1;
            this.opts = null
        }
        Clear() {
            this.opts = this.renderTarget = this.wi = this.inst = this.layer = this.layout = this.runtime = this.renderer = null
        }
        ShouldPreDraw(u) {
            u = u.GetShaderProgram();
            if (u.MustPreDraw()) return !0;
            if (this.inst) return u.UsesDest() && (0 !== this.wi.GetAngle() || 0 > this.wi.GetWidth() || 0 > this.wi.GetHeight()) || 0 !== this.boxExtendHorizontal || 0 !== this.boxExtendVertical || !this.wi.HasDefaultColor() || this.inst.MustPreDraw();
            if (this.layer) return !this.layer.HasDefaultColor()
        }
        ShouldPostDraw(u) {
            u =
                u.GetShaderProgram();
            return u.UsesDest() || u.UsesCrossSampling() || this.layout && "low" === this.runtime.GetCanvasManager().GetCurrentFullscreenScalingQuality()
        }
        GetEffectRenderTarget(u) {
            if (0 !== u && 1 !== u) throw Error("invalid effect target");
            const x = this.fxTex;
            if (!x[u]) {
                var y = this.runtime;
                const C = y.GetCanvasManager();
                y = {
                    sampling: y.GetSampling()
                };
                "low" === C.GetCurrentFullscreenScalingQuality() && (y.width = C.GetDrawWidth(), y.height = C.GetDrawHeight());
                x[u] = C.GetAdditionalRenderTarget(y)
            }
            return x[u]
        }
        ReleaseEffectRenderTargets() {
            const u =
                this.fxTex,
                x = this.runtime.GetCanvasManager();
            u[0] && (x.ReleaseAdditionalRenderTarget(u[0]), u[0] = null);
            u[1] && (x.ReleaseAdditionalRenderTarget(u[1]), u[1] = null)
        }
    }
    const a = [];
    let f = 0;

    function c() {
        f === a.length && a.push(new b);
        return a[f++]
    }

    function e(u) {
        u.ReleaseEffectRenderTargets();
        u.Clear();
        f--
    }
    const g = new d.Quad;
    let h = !1;
    async function l(u, x, y) {
        x = await d.Gfx.WebGLRenderTarget.DebugReadPixelsToBlob(x, y);
        x = URL.createObjectURL(x);
        console.log("[FX] " + u + " " + (y ? "" : " [to display]") + ": ", x)
    }
    d.RenderEffectChain =
        function(u, x, y, C, w, A) {
            const E = c();
            E.renderer = u;
            E.runtime = x;
            if (y instanceof d.Instance) E.inst = y, E.wi = E.inst.GetWorldInfo();
            else if (y instanceof d.Layer) E.layer = y;
            else if (y instanceof d.Layout) E.layout = y;
            else throw Error("invalid effects object");
            y = x.GetCanvasManager();
            E.renderTarget = C;
            E.drawWidth = y.GetDrawWidth();
            E.drawHeight = y.GetDrawHeight();
            E.surfaceWidth = E.drawWidth;
            E.surfaceHeight = E.drawHeight;
            E.fxIndex = 0;
            E.otherFxIndex = 1;
            E.boxExtendHorizontal = 0;
            E.boxExtendVertical = 0;
            E.screenRect.set(0, 0, E.drawWidth,
                E.drawHeight);
            E.clearRect.set(0, 0, E.drawWidth, E.drawHeight);
            E.didChangeTransform = !1;
            E.opts = A;
            E.inst ? (C = E.wi, E.layerScale = C.GetLayer().GetRenderScale(), E.layerAngle = C.GetLayer().GetAngle(), E.layoutRect.copy(C.GetBoundingBox())) : E.layer ? (C = E.layer, E.layerScale = C.GetRenderScale(), E.layerAngle = C.GetAngle(), E.layoutRect.copy(C.GetViewport())) : (C = E.layout, E.layerScale = C.GetScale(), E.layerAngle = C.GetAngle(), E.layoutRect.set(0, 0, E.drawWidth, E.drawHeight));
            E.inst ? m(E, w) : (E.rcTexBounce.set(0, 0, E.drawWidth /
                E.surfaceWidth, E.drawHeight / E.surfaceHeight), E.rcTexDest.copy(E.rcTexBounce), E.rcTexOrigin.copy(E.rcTexBounce), E.rcTexBounce.swapTopBottom(), E.rcTexDest.swapTopBottom(), E.rcTexOrigin.swapTopBottom());
            u.SetAlphaBlend();
            u.ResetColor();
            u.SetBaseZ(0);
            u.SetCurrentZ(0);
            E.preDraw = E.ShouldPreDraw(w[0]);
            E.preDraw && p(E);
            u.ResetColor();
            C = w.length - 1;
            E.postDraw = E.ShouldPostDraw(w[C]);
            for (let K = 0, O = w.length; K < O; ++K) A = w[K], y = A.GetShaderProgram(), u.SetProgram(y), y.IsAnimated() && x.UpdateRender(), 0 !== K || E.preDraw ?
                (u.SetCopyBlend(), q(E, A, K === C && !E.postDraw, K)) : t(E, A), 0 === E.fxIndex ? (E.fxIndex = 1, E.otherFxIndex = 0) : (E.fxIndex = 0, E.otherFxIndex = 1);
            E.postDraw && r(E, w);
            u = E.didChangeTransform;
            e(E);
            h = !1;
            return u
        };

    function m(u, x) {
        for (let J = 0, P = x.length; J < P; ++J) {
            var y = x[J].GetShaderProgram();
            u.boxExtendHorizontal += y.GetBoxExtendHorizontal();
            u.boxExtendVertical += y.GetBoxExtendVertical()
        }
        var C = u.wi;
        x = C.GetLayer();
        y = x.GetAngle();
        var w = C.GetBoundingBox();
        C = C.GetTotalZElevation();
        let [A, E] = x.LayerToDrawSurface(w.getLeft(), w.getTop(),
            C), [K, O] = x.LayerToDrawSurface(w.getRight(), w.getBottom(), C);
        if (0 !== y) {
            const [J, P] = x.LayerToDrawSurface(w.getRight(), w.getTop(), C), [R, T] = x.LayerToDrawSurface(w.getLeft(), w.getBottom(), C);
            x = Math.min(A, K, J, R);
            K = Math.max(A, K, J, R);
            A = x;
            x = Math.min(E, O, P, T);
            O = Math.max(E, O, P, T);
            E = x
        }
        x = u.screenRect;
        y = u.rcTexOrigin;
        w = u.rcTexDest;
        C = u.clearRect;
        const G = u.rcTexBounce;
        x.set(A, E, K, O);
        x.shuntY(u.drawHeight);
        y.copy(x);
        y.divide(u.surfaceWidth, u.surfaceHeight);
        y.swapTopBottom();
        x.inflate(u.boxExtendHorizontal, u.boxExtendVertical);
        w.copy(x);
        w.divide(u.surfaceWidth, u.surfaceHeight);
        w.swapTopBottom();
        C.copy(x);
        C.roundOuter();
        C.inflate(u.boxExtendHorizontal + 1, u.boxExtendVertical + 1);
        x.clamp(0, 0, u.drawWidth, u.drawHeight);
        C.clamp(0, 0, u.drawWidth, u.drawHeight);
        G.copy(x);
        G.divide(u.surfaceWidth, u.surfaceHeight);
        G.swapTopBottom()
    }

    function p(u) {
        const x = u.renderer;
        x.SetTextureFillMode();
        const y = u.GetEffectRenderTarget(u.fxIndex);
        x.SetRenderTarget(y);
        var C = u.opts;
        C && C.preTransform && C.preTransform();
        x.ClearRect2(u.clearRect);
        u.inst ? (x.SetColor(u.wi.GetPremultipliedColor()),
            x.SetCurrentZ(u.wi.GetTotalZElevation()), u.inst.Draw(x), x.SetCurrentZ(0)) : (C = (u.layer || u.layout).GetRenderTarget(), u.layer ? x.SetColor(u.layer.GetPremultipliedColor()) : x.ResetColor(), x.DrawRenderTarget(C), x.InvalidateRenderTarget(C), u.runtime.GetCanvasManager().ReleaseAdditionalRenderTarget(C));
        u.rcTexDest.clampFlipped(0, 1, 1, 0);
        u.fxIndex = 1;
        u.otherFxIndex = 0;
        h && l("Pre-draw", x, y)
    }

    function t(u, x) {
        const y = u.renderer,
            C = u.runtime,
            w = u.GetEffectRenderTarget(u.fxIndex);
        y.SetRenderTarget(w);
        var A = u.opts;
        A && A.preTransform &&
            A.preTransform();
        y.ClearRect2(u.clearRect);
        if (u.inst) {
            const [E, K] = u.inst.GetCurrentSurfaceSize();
            (A = u.inst.GetCurrentTexRect()) ? u.srcRect.copy(A): u.srcRect.set(0, 0, 0, 0);
            x = u.wi.GetInstanceEffectList().GetEffectParametersForIndex(x.GetIndex());
            y.SetProgramParameters(u.renderTarget, u.rcTexDest, u.srcRect, u.srcRect, u.layoutRect, 1 / E, 1 / K, u.layerScale, u.layerAngle, C.GetGameTime(), x);
            y.SetCurrentZ(u.wi.GetTotalZElevation());
            u.inst.Draw(y);
            y.SetCurrentZ(0);
            u.rcTexDest.clampFlipped(0, 1, 1, 0);
            u.screenRect.shuntY(u.drawHeight)
        } else x =
            (u.layer || u.layout).GetEffectList().GetEffectParametersForIndex(x.GetIndex()), y.SetProgramParameters(u.renderTarget, u.rcTexDest, u.rcTexBounce, u.rcTexOrigin, u.layoutRect, 1 / u.drawWidth, 1 / u.drawHeight, u.layerScale, u.layerAngle, C.GetGameTime(), x), u = (u.layer || u.layout).GetRenderTarget(), h && l("Layer target", y, u), y.DrawRenderTarget(u), y.InvalidateRenderTarget(u), C.GetCanvasManager().ReleaseAdditionalRenderTarget(u);
        h && l("First bounce", y, w)
    }

    function q(u, x, y, C) {
        const w = u.renderer,
            A = u.runtime;
        0 === C && u.preDraw &&
            u.inst && u.screenRect.shuntY(u.drawHeight);
        y ? (u.inst ? w.SetBlendMode(u.wi.GetBlendMode()) : u.layer && w.SetBlendMode(u.layer.GetBlendMode()), y = u.renderTarget, w.SetRenderTarget(y)) : (y = u.GetEffectRenderTarget(u.fxIndex), w.SetRenderTarget(y), w.ClearRect2(u.clearRect));
        x = u.inst ? u.wi.GetInstanceEffectList().GetEffectParametersForIndex(x.GetIndex()) : (u.layer || u.layout).GetEffectList().GetEffectParametersForIndex(x.GetIndex());
        w.SetProgramParameters(u.renderTarget, u.rcTexDest, u.rcTexBounce, u.rcTexOrigin, u.layoutRect,
            1 / u.surfaceWidth, 1 / u.surfaceHeight, u.layerScale, u.layerAngle, A.GetGameTime(), x);
        x = u.GetEffectRenderTarget(u.otherFxIndex);
        w.SetTexture(x.GetTexture());
        A.GetCanvasManager().SetDeviceTransform(w);
        u.didChangeTransform = !0;
        g.setFromRect(u.screenRect);
        w.Quad3(g, u.rcTexBounce);
        u.inst || w.InvalidateRenderTarget(x);
        h && l("Bounce " + C, w, y)
    }

    function r(u, x) {
        x = u.renderer;
        if (u.layout) x.SetTextureFillMode(), x.SetRenderTarget(u.renderTarget), u = u.GetEffectRenderTarget(u.otherFxIndex), x.CopyRenderTarget(u), x.InvalidateRenderTarget(u);
        else {
            var y = u.runtime.GetCanvasManager();
            "low" === y.GetCurrentFullscreenScalingQuality() ? (x.SetTextureFillMode(), y.SetDeviceTransform(x, y.GetDrawWidth(), y.GetDrawHeight()), u.didChangeTransform = !0) : x.SetDeviceTransformTextureFillMode();
            u.inst ? x.SetBlendMode(u.wi.GetBlendMode()) : u.layer && x.SetBlendMode(u.layer.GetBlendMode());
            x.SetRenderTarget(u.renderTarget);
            y = u.GetEffectRenderTarget(u.otherFxIndex);
            x.SetTexture(y.GetTexture());
            g.setFromRect(u.screenRect);
            x.Quad3(g, u.rcTexBounce);
            u.inst || x.InvalidateRenderTarget(y);
            h && l("Post-draw", x, u.renderTarget)
        }
    }
}
"use strict";
{
    const d = self.C3,
        b = /<(.+?)>/g;
    d.TimelineManager = class extends d.DefendedBase {
        constructor(a) {
            super();
            this._runtime = a;
            this._timelineDataManager = d.New(d.TimelineDataManager);
            this._pluginInstance = null;
            this._timelines = [];
            this._timelinesByName = new Map;
            this._objectClassToTimelineMap = new Map;
            this._timelinesCreatedByTemplate = new Map;
            this._scheduledTimelines = [];
            this._playingTimelines = [];
            this._isTickingTimelines = this._changingLayout = this._hasRuntimeListeners = !1;
            this._tickFunc = () => this._OnTick();
            this._tick2Func =
                () => this._OnTick2();
            this._beforeLayoutChange = () => this._OnBeforeChangeLayout();
            this._layoutChange = () => this._OnAfterChangeLayout();
            this._instanceDestroy = f => this._OnInstanceDestroy(f.instance);
            this._afterLoad = f => this._OnAfterLoad();
            this._destroyedWhileLoadingState = []
        }
        Release() {
            this.RemoveRuntimeListeners();
            this._afterLoad = this._instanceDestroy = this._layoutChange = this._beforeLayoutChange = this._tick2Func = this._tickFunc = null;
            for (const a of this._timelines) a.Stop(), a.Release();
            d.clearArray(this._timelines);
            this._timelines = null;
            this._timelineDataManager.Release();
            this._timelineDataManager = null;
            d.clearArray(this._scheduledTimelines);
            this._scheduledTimelines = null;
            d.clearArray(this._playingTimelines);
            this._playingTimelines = null;
            this._timelinesByName.clear();
            this._timelinesByName = null;
            this._objectClassToTimelineMap.clear();
            this._objectClassToTimelineMap = null;
            this._timelinesCreatedByTemplate.clear();
            this._timelinesCreatedByTemplate = null;
            d.clearArray(this._destroyedWhileLoadingState);
            this._runtime = this._destroyedWhileLoadingState =
                null
        }
        AddRuntimeListeners() {
            const a = this._runtime.Dispatcher();
            a.addEventListener("pretick", this._tickFunc);
            a.addEventListener("tick2", this._tick2Func);
            a.addEventListener("beforelayoutchange", this._beforeLayoutChange);
            a.addEventListener("layoutchange", this._layoutChange);
            a.addEventListener("instancedestroy", this._instanceDestroy);
            a.addEventListener("afterload", this._afterLoad)
        }
        RemoveRuntimeListeners() {
            const a = this._runtime.Dispatcher();
            a.removeEventListener("pretick", this._tickFunc);
            a.removeEventListener("tick2",
                this._tick2Func);
            a.removeEventListener("beforelayoutchange", this._beforeLayoutChange);
            a.removeEventListener("layoutchange", this._layoutChange);
            a.removeEventListener("instancedestroy", this._instanceDestroy);
            a.removeEventListener("afterload", this._afterLoad)
        }
        Create(a) {
            this._timelineDataManager.Add(a);
            a = d.TimelineState.CreateInitial(a, this);
            this.Add(a);
            this.SetTimelineObjectClassesToMap(a);
            this._timelinesCreatedByTemplate.set(a.GetName(), 0)
        }
        CreateFromTemplate(a) {
            var f = this.GetTimelineDataManager();
            a =
                a.GetTemplateName();
            f = f.Get(a);
            f = d.TimelineState.CreateFromTemplate(`${a}:${this._timelinesCreatedByTemplate.get(a)}`, f, this);
            this._IncreaseTemplateTimelinesCount(a);
            this.Add(f);
            return f
        }
        _IncreaseTemplateTimelinesCount(a) {
            this._timelinesCreatedByTemplate.set(a, this._timelinesCreatedByTemplate.get(a) + 1)
        }
        _SetCreatedTemplateTimelinesCount() {
            for (const a of this._timelines) {
                if (a.IsTemplate()) continue;
                const f = a.GetTemplateName();
                this._IncreaseTemplateTimelinesCount(f)
            }
        }
        _ClearCreatedTemplateTimelinesCount() {
            for (const a of this._timelinesCreatedByTemplate.keys()) this._timelinesCreatedByTemplate.set(a,
                0)
        }
        Add(a) {
            this._timelines.push(a);
            this._timelinesByName.set(a.GetName().toLowerCase(), a)
        }
        Remove(a) {
            a.IsTemplate() || (d.arrayFindRemove(this._timelines, a), d.arrayFindRemove(this._scheduledTimelines, a), d.arrayFindRemove(this._playingTimelines, a), this._timelinesByName.delete(a.GetName().toLowerCase()), this.RemoveTimelineFromObjectClassMap(a), a.IsReleased() || a.Release())
        }
        Trigger(a) {
            this._runtime.Trigger(a, this._pluginInstance, null)
        }
        GetRuntime() {
            return this._runtime
        }
        GetTimelineDataManager() {
            return this._timelineDataManager
        }
        SetPluginInstance(a) {
            this._pluginInstance =
                a
        }
        GetPluginInstance() {
            return this._pluginInstance
        }* GetTimelines() {
            for (const a of this._timelines) yield a
        }
        SetTimelineObjectClassToMap(a, f) {
            this._objectClassToTimelineMap.has(a) || this._objectClassToTimelineMap.set(a, new Set);
            this._objectClassToTimelineMap.get(a).add(f)
        }
        SetTimelineObjectClassesToMap(a) {
            for (const f of a.GetObjectClasses()) this.SetTimelineObjectClassToMap(f, a)
        }
        RemoveTimelineFromObjectClassMap(a) {
            for (const [f, c] of this._objectClassToTimelineMap.entries()) c.has(a) && (c.delete(a), 0 === c.size &&
                this._objectClassToTimelineMap.delete(f))
        }
        GetTimelinesForObjectClass(a) {
            if (this._objectClassToTimelineMap.has(a)) return this._objectClassToTimelineMap.get(a)
        }
        GetTimelineOfTemplateForInstances(a, f) {
            if (f)
                for (const c of this._timelines)
                    if (f.every(e => c.HasTrackInstance(e.instance, e.trackId)) && c.GetName().includes(a.GetName())) return c
        }
        GetTimelineByName(a) {
            return this._timelinesByName.get(a.toLowerCase()) || null
        }
        GetScheduledOrPlayingTimelineByName(a) {
            for (const f of this._scheduledTimelines)
                if (f.GetName() ===
                    a) return f;
            for (const f of this._playingTimelines)
                if (f.GetName() === a) return f;
            return null
        }* GetTimelinesByName(a) {
            if (b.test(a)) {
                b.lastIndex = 0;
                let c;
                var f = new Set;
                do
                    if (c = b.exec(a)) {
                        const e = c[1].split(",");
                        for (const g of e) f.add(g)
                    } while (c);
                for (const e of f.values())(a = this.GetTimelineByName(e)) && (yield a);
                f.clear()
            } else(f = this.GetTimelineByName(a)) && (yield f)
        }* GetTimelinesByTags(a) {
            for (const f of this._timelines) f.HasTags(a) && (yield f)
        }
        AddScheduledTimeline(a) {
            this._scheduledTimelines.includes(a) || this._scheduledTimelines.push(a);
            this._MaybeEnableRuntimeListeners()
        }
        RemovePlayingTimeline(a) {
            d.arrayFindRemove(this._playingTimelines, a);
            this._MaybeDisableRuntimeListeners()
        }
        ScheduleTimeline(a) {
            this._playingTimelines.includes(a) ? (a.SetPlaying(!0), a.SetScheduled(!1), a.SetMarkedForRemoval(!1)) : (a.SetPlaying(!1), a.SetScheduled(!0), a.SetMarkedForRemoval(!1), this._scheduledTimelines.includes(a) || this._scheduledTimelines.push(a));
            this._MaybeEnableRuntimeListeners()
        }
        DeScheduleTimeline(a) {
            a.SetPlaying(!1);
            a.SetScheduled(!1);
            a.ResolvePlayPromise();
            d.arrayFindRemove(this._scheduledTimelines, a);
            this._MaybeDisableRuntimeListeners()
        }
        CompleteTimeline(a) {
            a.SetPlaying(!1);
            a.SetScheduled(!1);
            a.SetMarkedForRemoval(!0)
        }
        CompleteTimelineAndResolve(a) {
            this.CompleteTimeline(a);
            a.ResolvePlayPromise()
        }
        _OnTick() {
            if (!this.GetRuntime().IsLoadingState() && this._hasRuntimeListeners && !this._changingLayout) {
                var a = !1;
                for (this._isTickingTimelines = !0; this._scheduledTimelines.length;) {
                    var f = this._scheduledTimelines.pop();
                    f.SetInitialState();
                    this._playingTimelines.push(f)
                }
                f =
                    this._runtime.GetDt();
                var c = this._runtime.GetTimeScale();
                for (const e of this._playingTimelines) {
                    if (e.IsMarkedForRemoval()) continue;
                    const g = e.Tick(f, c);
                    !a && g && (a = !0)
                }
                this._isTickingTimelines = !1;
                a && this.GetRuntime().UpdateRender()
            }
        }
        _OnTick2() {
            if (!this.GetRuntime().IsLoadingState() && this._hasRuntimeListeners && !this._changingLayout) {
                var a;
                for (const f of this._playingTimelines) f.IsMarkedForRemoval() && (a || (a = new Set), this._MaybeExecuteTimelineFinishTriggers(f), a.add(f));
                a && d.arrayRemoveAllInSet(this._playingTimelines,
                    a);
                this._MaybeDisableRuntimeListeners()
            }
        }
        _MaybeExecuteTimelineFinishTriggers(a) {
            a.IsReleased() || a.HasValidTracks() && a.IsComplete() && a.InitialStateSet() && a.FinishTriggers()
        }
        _MaybeEnableRuntimeListeners() {
            this._hasRuntimeListeners || (this._hasRuntimeListeners = !0)
        }
        _MaybeDisableRuntimeListeners() {
            this._playingTimelines.length || this._scheduledTimelines.length || this._isTickingTimelines || (this._hasRuntimeListeners = !1)
        }
        _OnBeforeChangeLayout() {
            for (this._changingLayout = !0; this._scheduledTimelines.length;) this.DeScheduleTimeline(this._scheduledTimelines.pop());
            const a = new Set;
            for (const f of this._playingTimelines) f._OnBeforeChangeLayout() && a.add(f);
            d.arrayRemoveAllInSet(this._playingTimelines, a);
            this._MaybeDisableRuntimeListeners();
            for (const f of this._timelines) f.CleanCaches()
        }
        _OnAfterChangeLayout() {
            this._changingLayout = !1
        }
        _OnInstanceDestroy(a) {
            var f = a.GetObjectClass();
            if (f = this.GetTimelinesForObjectClass(f))
                if (this._runtime.IsLoadingState()) this._destroyedWhileLoadingState.push(a);
                else
                    for (const c of f) c.IsTemplate() || (c.IsReleased() ? this.Remove(c) : c.HasValidTracks() ||
                        (this._MaybeExecuteTimelineFinishTriggers(c), this.Remove(c)))
        }
        _OnAfterLoad() {
            for (const a of this._destroyedWhileLoadingState) this._OnInstanceDestroy(a);
            d.clearArray(this._destroyedWhileLoadingState)
        }
        _SaveToJson() {
            return {
                timelinesJson: this._SaveTimelinesToJson(),
                scheduledTimelinesJson: this._SaveScheduledTimelinesToJson(),
                playingTimelinesJson: this._SavePlayingTimelinesToJson(),
                hasRuntimeListeners: this._hasRuntimeListeners,
                changingLayout: this._changingLayout,
                isTickingTimelines: this._isTickingTimelines
            }
        }
        _LoadFromJson(a) {
            a &&
                (this._ClearCreatedTemplateTimelinesCount(), this._LoadTimelinesFromJson(a.timelinesJson), this._LoadScheduledTimelinesFromJson(a.scheduledTimelinesJson), this._LoadPlayingTimelinesFromJson(a.playingTimelinesJson), this._hasRuntimeListeners = !a.hasRuntimeListeners, this._changingLayout = !!a.changingLayout, this._isTickingTimelines = !!a.isTickingTimelines, this._SetCreatedTemplateTimelinesCount(), this._MaybeEnableRuntimeListeners(), this._MaybeDisableRuntimeListeners())
        }
        _SaveTimelinesToJson() {
            return this._timelines.map(a =>
                a._SaveToJson())
        }
        _LoadTimelinesFromJson(a) {
            for (const f of a) {
                a = this.GetTimelineByName(f.name);
                if (!a) {
                    a = this._GetTemplateNameFromJson(f);
                    if (!a) continue;
                    a = this.GetTimelineByName(a);
                    a = this.CreateFromTemplate(a)
                }
                a._LoadFromJson(f);
                a.HasTracks() || this.Remove(a)
            }
        }
        _GetTemplateNameFromJson(a) {
            return (a = a.name.split(":")) && 2 === a.length ? a[0] : null
        }
        _SaveScheduledTimelinesToJson() {
            return this._SaveTimelines(this._scheduledTimelines)
        }
        _LoadScheduledTimelinesFromJson(a) {
            this._LoadTimelines(a, this._scheduledTimelines)
        }
        _SavePlayingTimelinesToJson() {
            return this._SaveTimelines(this._playingTimelines)
        }
        _LoadPlayingTimelinesFromJson(a) {
            this._LoadTimelines(a,
                this._playingTimelines)
        }
        _IsTimelineInJson(a, f) {
            for (const c of f)
                if (c === a.GetName()) return !0;
            return !1
        }
        _SaveTimelines(a) {
            return a.map(f => f.GetName())
        }
        _LoadTimelines(a, f) {
            var c = new Set;
            for (const e of f) this._IsTimelineInJson(e, a) || c.add(e);
            d.arrayRemoveAllInSet(f, c);
            c = e => g => g.GetName() === e;
            for (const e of a)(a = this.GetTimelineByName(e)) && (f.find(c(e)) || f.push(a))
        }
    }
}
"use strict";
{
    const d = self.C3;
    d.TimelineState = class extends d.DefendedBase {
        constructor(b, a, f) {
            super();
            this._runtime = f.GetRuntime();
            this._timelineManager = f;
            this._timelineDataItem = a;
            this._name = b;
            this._tracks = [];
            for (const c of this._timelineDataItem.GetTrackData().trackDataItems()) this._tracks.push(d.TrackState.Create(this, c));
            this._playResolve = this._playPromise = null;
            this._playheadTime = d.New(d.KahanSum);
            this._playheadTime.Set(0);
            this._playbackRate = 1;
            this._pingPongState = 0;
            this._currentRepeatCount = 1;
            this._initialStateSet =
                this._isScheduled = this._isPlaying = !1;
            this._complete = !0;
            this._markedForRemoval = this._released = !1;
            this._completedTick = -1;
            this._firstTick = this._finishedTriggers = this._isTemplate = this._implicitPause = !1;
            this._lastDelta = NaN;
            this._tags = [""];
            this._stringTags = "";
            this._tagsChanged = !1
        }
        static CreateInitial(b, a) {
            var f = a.GetTimelineDataManager();
            const c = f.GetNameId();
            f = f.Get(b[c]);
            b = d.New(d.TimelineState, b[c], f, a);
            b.SetIsTemplate(!0);
            return b
        }
        static CreateFromTemplate(b, a, f) {
            return d.New(d.TimelineState, b, a, f)
        }
        static get WORLD_INSTANCE_BOX_CHANGE() {
            return 1
        }
        static get LAYOUT_RENDER_CHANGE() {
            return d.nextHighestPowerOfTwo(1)
        }
        Release() {
            if (!this.IsReleased()) {
                this._timelineManager.DeScheduleTimeline(this);
                this._timelineManager.CompleteTimelineAndResolve(this);
                for (const b of this._tracks) b.Release();
                d.clearArray(this._tracks);
                this._tracks = null;
                this._playheadTime.Release();
                this._timelineDataItem = this._timelineManager = this._runtime = this._playheadTime = null;
                this._released = !0;
                this._playResolve = this._playPromise = null
            }
        }
        GetTimelineManager() {
            return this._timelineManager
        }
        GetRuntime() {
            return this._runtime
        }
        GetTracks() {
            return this._tracks
        }
        GetSimilarPropertyTracks(b, a, f) {
            const c = [];
            for (const e of this._tracks) {
                if (b !==
                    e.GetInstance()) continue;
                const g = e.GetPropertyTrack(f);
                g && a.constructor === g.GetSourceAdapter().constructor && c.push(g)
            }
            return c
        }
        HasTracks() {
            return !!this._tracks.length
        }
        GetTrackById(b) {
            for (const a of this._tracks)
                if (d.equalsNoCase(a.GetId(), b)) return a;
            return null
        }
        SetName(b) {
            this._name = b
        }
        GetName() {
            return this._name
        }
        GetTimelineDataItem() {
            return this._timelineDataItem
        }
        GetTemplateName() {
            return this._timelineDataItem.GetName()
        }
        GetTotalTime() {
            return this._timelineDataItem.GetTotalTime()
        }
        SetTotalTime(b) {
            this._timelineDataItem.SetTotalTime(b)
        }
        GetStep() {
            return this._timelineDataItem.GetStep()
        }
        SetStep(b) {
            this._timelineDataItem.SetStep(b)
        }
        GetInterpolationMode() {
            return this._timelineDataItem.GetInterpolationMode()
        }
        SetInterpolationMode(b) {
            this._timelineDataItem.SetInterpolationMode(b)
        }
        GetResultMode() {
            return this._timelineDataItem.GetResultMode()
        }
        SetResultMode(b) {
            this._timelineDataItem.GetResultMode(b)
        }
        SetEase(b) {
            for (const a of this.GetTracks()) a.SetEase(b)
        }
        GetLoop() {
            return this._timelineDataItem.GetLoop()
        }
        SetLoop(b) {
            return this._timelineDataItem.SetLoop(b)
        }
        GetPingPong() {
            return this._timelineDataItem.GetPingPong()
        }
        SetPingPong(b) {
            return this._timelineDataItem.SetPingPong(b)
        }
        GetRepeatCount() {
            return this._timelineDataItem.GetRepeatCount()
        }
        SetPlaybackRate(b) {
            return this._playbackRate =
                b
        }
        GetPlaybackRate() {
            return this._playbackRate
        }
        IsForwardPlayBack() {
            return this.IsPlaying() ? 0 < this._playbackRate : !0
        }
        GetPlayPromise() {
            return this._playPromise ? this._playPromise : this._playPromise = new Promise(b => {
                this._playResolve = b
            })
        }
        ResolvePlayPromise() {
            this._playPromise && (this._playResolve(), this._playResolve = this._playPromise = null)
        }
        SetTags(b) {
            this._tags = d.TimelineState._GetTagArray(b);
            this._tagsChanged = !0
        }
        GetTags() {
            return this._tags
        }
        GetStringTags() {
            this._tagsChanged && (this._stringTags = this._tags.join(" "));
            this._tagsChanged = !1;
            return this._stringTags
        }
        HasTags(b) {
            return this._tags && this._tags.length ? (b = d.TimelineState._GetTagArray(b)) && b.length ? b.every(d.TimelineState._HasTag, this) : !1 : !1
        }
        OnStarted() {
            d.Plugins.Timeline.Cnds.SetTriggerTimeline(this);
            this._timelineManager.Trigger(d.Plugins.Timeline.Cnds.OnTimelineStarted);
            this._timelineManager.Trigger(d.Plugins.Timeline.Cnds.OnTimelineStartedByName);
            this._timelineManager.Trigger(d.Plugins.Timeline.Cnds.OnTimelineStartedByTags);
            this._timelineManager.Trigger(d.Plugins.Timeline.Cnds.OnAnyTimelineStarted);
            d.Plugins.Timeline.Cnds.SetTriggerTimeline(null)
        }
        OnCompleted() {
            this._completedTick = this._runtime.GetTickCount()
        }
        FinishTriggers() {
            this._finishedTriggers || (this._finishedTriggers = !0, d.Plugins.Timeline.Cnds.SetTriggerTimeline(this), this._timelineManager.Trigger(d.Plugins.Timeline.Cnds.OnTimelineFinished), this._timelineManager.Trigger(d.Plugins.Timeline.Cnds.OnTimelineFinishedByName), this._timelineManager.Trigger(d.Plugins.Timeline.Cnds.OnTimelineFinishedByTags), this._timelineManager.Trigger(d.Plugins.Timeline.Cnds.OnAnyTimelineFinished),
                d.Plugins.Timeline.Cnds.SetTriggerTimeline(null))
        }
        SetPlaying(b) {
            this._isPlaying = b
        }
        IsCompletedTick() {
            return this._completedTick === this._runtime.GetTickCount()
        }
        IsPlaying(b = !1) {
            return this.IsCompletedTick() || this.IsScheduled() && !b ? !0 : this._isPlaying
        }
        _IsPlaying() {
            return this.IsPlaying(!0)
        }
        IsPaused() {
            return this._IsPaused()
        }
        _IsPaused() {
            return this.IsReleased() || this.IsScheduled() || this._IsPlaying() || this.IsComplete() ? !1 : !0
        }
        SetScheduled(b) {
            this._isScheduled = b
        }
        IsScheduled() {
            return this._isScheduled
        }
        SetComplete(b) {
            this._complete =
                b;
            b = this.GetTime();
            if (0 >= b || b >= this.GetTotalTime()) this._complete = !0
        }
        IsComplete() {
            return this._complete
        }
        IsReleased() {
            return this._released
        }
        SetMarkedForRemoval(b) {
            this._markedForRemoval = b
        }
        IsMarkedForRemoval() {
            return this._markedForRemoval
        }
        SetImplicitPause(b) {
            this._implicitPause = b
        }
        IsImplicitPause() {
            return this._implicitPause
        }
        SetIsTemplate(b) {
            this._isTemplate = !!b
        }
        IsTemplate() {
            return this._isTemplate
        }
        InitialStateSet() {
            return this._initialStateSet
        }
        GetTime() {
            return this._playheadTime.Get()
        }
        SetTime(b) {
            const a =
                this.GetTime();
            this._SetTime(b);
            this.SetComplete(!1);
            this.IsComplete() || this.SetImplicitPause(!0);
            if (this._IsPlaying() || this.IsScheduled() || !this._initialStateSet) this._IsPlaying() || this.IsScheduled() || this._initialStateSet ? this._IsPlaying() ? this.Stop() : this.IsScheduled() && (this._timelineManager.DeScheduleTimeline(this), this.SetInitialStateFromSetTime()) : this.SetInitialStateFromSetTime();
            this._Interpolate(b, !1, !0, !0, a) && this.GetRuntime().UpdateRender();
            this._OnSetTime()
        }
        _SetTime(b) {
            0 > b ? this._playheadTime.Set(0) :
                b >= this.GetTotalTime() ? this._playheadTime.Set(this.GetTotalTime()) : this._playheadTime.Set(b)
        }
        _OnSetTime() {
            d.Plugins.Timeline && this.constructor === d.TimelineState && (d.Plugins.Timeline.Cnds.SetTriggerTimeline(this), this._timelineManager.Trigger(d.Plugins.Timeline.Cnds.OnTimeSet), this._timelineManager.Trigger(d.Plugins.Timeline.Cnds.OnTimeSetByName), this._timelineManager.Trigger(d.Plugins.Timeline.Cnds.OnTimeSetByTags), d.Plugins.Timeline.Cnds.SetTriggerTimeline(null))
        }
        _CanResume() {
            if (!this.GetLoop())
                if (this.GetPingPong() &&
                    1 === this._pingPongState)
                    if (this.IsForwardPlayBack()) {
                        if (this.GetTime() >= this.GetTotalTime()) return !1
                    } else {
                        if (0 >= this.GetTime()) return !1
                    }
            else if (!this.GetLoop() && !this.GetPingPong())
                if (this.IsForwardPlayBack()) {
                    if (this.GetTime() >= this.GetTotalTime()) return !1
                } else if (0 >= this.GetTime()) return !1;
            return !0
        }
        Resume() {
            this.IsReleased() || this._CanResume() && this.Play(!0)
        }
        Play(b = !1) {
            // console.log("IDDQD Play()")
            return this.IsReleased() || this.IsScheduled() ? !1 : this._IsPlaying() && this.IsCompletedTick() ? this._SchedulePlayingTimeline() : this._IsPlaying() ||
                !this.IsComplete() && !b && !this.IsImplicitPause() ? !1 : this._ScheduleStoppedTimeline()
        }
        _SchedulePlayingTimeline() {
            this.SetImplicitPause(!1);
            this._timelineManager.RemovePlayingTimeline(this);
            this._timelineManager.ScheduleTimeline(this);
            this.GetPlayPromise();
            return !0
        }
        _ScheduleStoppedTimeline() {
            this.SetImplicitPause(!1);
            this._timelineManager.ScheduleTimeline(this);
            this.GetPlayPromise();
            return !0
        }
        Stop(b = !1) {
            this.IsReleased() || (this.SetComplete(b), this._timelineManager.CompleteTimeline(this), this.IsComplete() &&
                this.ResolvePlayPromise())
        }
        Reset(b = !0, a = !1) {
            if (!this.IsReleased()) {
                if (!this._IsPlaying() && this.IsScheduled()) return this._timelineManager.DeScheduleTimeline(this);
                if (!this.IsComplete()) {
                    this.Stop(!0);
                    this.IsForwardPlayBack() ? this._SetTime(0) : this._SetTime(this.GetTotalTime());
                    var f = this.GetTime();
                    a = a ? this._InterpolateBeforeChangeLayout(f) : this._Interpolate(f, !1, !1, !0);
                    b && this._OnSetTime();
                    a && b && this.GetRuntime().UpdateRender()
                }
            }
        }
        ResetBeforeChangeLayout() {
            this.Reset(!1, !0)
        }
        _InterpolateBeforeChangeLayout(b) {
            this._Interpolate(b,
                !1, !1, !0, NaN, !1, !0)
        }
        _OnBeforeChangeLayout() {
            if (this.IsReleased()) return !0;
            if (this.HasValidGlobalTracks()) return !1;
            this._timelineManager.CompleteTimeline(this);
            this.ResetBeforeChangeLayout();
            return !0
        }
        SetInitialStateFromSetTime() {
            this.SetInitialState(!0)
        }
        SetInitialState(b) {
            if (!this.IsMarkedForRemoval())
                if (b) {
                    this._firstTick = this._initialStateSet = !0;
                    for (const a of this._tracks) a.SetInitialState()
                } else if (this.SetPlaying(!0), this.SetScheduled(!1), this.OnStarted(), this.IsComplete()) {
                this._completedTick = -1;
                this._pingPongState = 0;
                this._currentRepeatCount = 1;
                this._finishedTriggers = this._complete = !1;
                this._firstTick = this._initialStateSet = !0;
                this.IsForwardPlayBack() ? this._SetTime(0) : this._SetTime(this.GetTotalTime());
                for (const a of this._tracks) a.SetInitialState()
            } else {
                this._firstTick = !0;
                for (const a of this._tracks) a.SetResumeState()
            }
        }
        Tick(b, a) {
            if (0 !== b || 0 !== this._lastDelta) {
                this._lastDelta = b;
                var f = this.GetTime();
                this._SetTime(f + b * a * this._playbackRate);
                var c;
                this.GetLoop() || this.GetPingPong() ? this.GetLoop() &&
                    !this.GetPingPong() ? c = this._LoopCompleteCheck() : !this.GetLoop() && this.GetPingPong() ? c = this._PingPongCompleteCheck() : this.GetLoop() && this.GetPingPong() && (c = this._LoopPingPongCompleteCheck()) : c = this._SimpleCompleteCheck();
                if (c) {
                    for (const e of this._tracks) e.SetEndState();
                    this.Stop(!0);
                    this.OnCompleted();
                    return !0
                }
                return this._Interpolate(this.GetTime(), !0, !1, !1, f, !0)
            }
        }
        _Interpolate(b, a = !1, f = !1, c = !1, e = NaN, g = !1, h = !1) {
            let l = !1;
            for (var m of this._tracks) m.BeforeInterpolate();
            for (const p of this._tracks) {
                m =
                    b;
                if ("number" === typeof e) {
                    const t = this.GetTime() - p.GetStartOffset(),
                        q = e - p.GetStartOffset();
                    0 > t && 0 < q && (m = p.GetStartOffset(), this._SetTime(m))
                }
                m = p.Interpolate(m, a, f, c, this._firstTick, h);
                !l && m && (l = !0)
            }
            for (const p of this._tracks) p.AfterInterpolate();
            this._firstTick && g && (this._firstTick = !1);
            return l
        }
        _SimpleCompleteCheck() {
            if (this.IsForwardPlayBack()) {
                if (this.GetTime() >= this.GetTotalTime())
                    if (this._currentRepeatCount < this.GetRepeatCount()) this._currentRepeatCount++, this._SetTime(0);
                    else return this._SetTime(this.GetTotalTime()),
                        !0
            } else if (0 >= this.GetTime())
                if (this._currentRepeatCount < this.GetRepeatCount()) this._currentRepeatCount++, this._SetTime(this.GetTotalTime());
                else return this._SetTime(0), !0;
            return !1
        }
        _LoopCompleteCheck() {
            this.IsForwardPlayBack() ? this.GetTime() >= this.GetTotalTime() && this._SetTime(0) : 0 >= this.GetTime() && this._SetTime(this.GetTotalTime());
            return !1
        }
        _PingPongCompleteCheck() {
            if (this.IsForwardPlayBack()) {
                if (this.GetTime() >= this.GetTotalTime())
                    if (this._SetTime(this.GetTotalTime()), this.SetPlaybackRate(-1 * this.GetPlaybackRate()),
                        1 === this._pingPongState)
                        if (this._currentRepeatCount < this.GetRepeatCount()) this._currentRepeatCount++, this._pingPongState = 0;
                        else return !0;
                else 0 === this._pingPongState && (this._pingPongState = 1)
            } else if (0 >= this.GetTime())
                if (this._SetTime(0), this.SetPlaybackRate(-1 * this.GetPlaybackRate()), 1 === this._pingPongState)
                    if (this._currentRepeatCount < this.GetRepeatCount()) this._currentRepeatCount++, this._pingPongState = 0;
                    else return !0;
            else 0 === this._pingPongState && (this._pingPongState = 1);
            return !1
        }
        _LoopPingPongCompleteCheck() {
            this.IsForwardPlayBack() ?
                this.GetTime() >= this.GetTotalTime() && (this._SetTime(this.GetTotalTime()), this.SetPlaybackRate(-1 * this.GetPlaybackRate())) : 0 >= this.GetTime() && (this._SetTime(0), this.SetPlaybackRate(-1 * this.GetPlaybackRate()));
            return !1
        }
        AddTrack() {
            var b = this._timelineDataItem.GetTrackData().AddEmptyTrackDataItem();
            b = d.TrackState.Create(this, b);
            this._tracks.push(b);
            return b
        }
        CleanCaches() {
            for (const b of this._tracks) b.CleanCaches()
        }
        ClearTrackInstances() {
            for (const b of this._tracks) b.ClearInstance()
        }
        SetTrackInstance(b,
            a) {
            if (a)
                for (const f of this._tracks) {
                    if (b) {
                        if (f.GetId() !== b) continue
                    } else if (f.HasInstance()) continue;
                    f.SetInstance(a);
                    this._timelineManager.SetTimelineObjectClassToMap(a.GetObjectClass(), this);
                    break
                }
        }
        HasTrackInstance(b, a) {
            for (const f of this._tracks)
                if (a) {
                    if (a === f.GetId() && b === f.GetInstance()) return !0
                } else if (b === f.GetInstance()) return !0;
            return !1
        }
        HasValidTracks() {
            return this._tracks.some(b => b.CanInstanceBeValid())
        }
        HasValidGlobalTracks() {
            return this._tracks.some(b => b.CanInstanceBeValid() ? (b = b.GetObjectClass()) ?
                b.IsGlobal() : !1 : !1)
        }
        GetPropertyTrack(b) {
            for (const a of this.GetTracks())
                for (const f of a.GetPropertyTracks())
                    if (f.GetPropertyName() === b) return f
        }
        GetKeyframeWithTags(b) {
            b = b ? b.split(" ") : [];
            b = [...(new Set(b.map(a => a.toLowerCase().trim()))).values()];
            for (const a of this.GetTracks())
                for (const f of a.GetKeyframeDataItems())
                    if (b.every(c => f.HasTag(c))) return f
        }
        GetObjectClasses() {
            const b = [];
            for (const a of this.GetTracks()) b.push(a.GetObjectClass());
            return b.filter(a => a)
        }
        _SaveToJson() {
            return {
                tracksJson: this._SaveTracksToJson(),
                name: this._name,
                playheadTime: this.GetTime(),
                playbackRate: this._playbackRate,
                pingPongState: this._pingPongState,
                currentRepeatCount: this._currentRepeatCount,
                isPlaying: this._isPlaying,
                isScheduled: this._isScheduled,
                initialStateSet: this._initialStateSet,
                finishedTriggers: this._finishedTriggers,
                complete: this._complete,
                released: this._released,
                markedForRemoval: this._markedForRemoval,
                completedTick: this._completedTick,
                implicitPause: this._implicitPause,
                isTemplate: this._isTemplate,
                tags: this._tags.join(" "),
                stringTags: this._stringTags,
                tagsChanged: this._tagsChanged,
                firstTick: this._firstTick
            }
        }
        _LoadFromJson(b) {
            b && (this._LoadTracksFromJson(b.tracksJson), this._name = b.name, this._playheadTime.Set(b.playheadTime), this._playbackRate = b.playbackRate, this._pingPongState = b.pingPongState, this._currentRepeatCount = b.currentRepeatCount, this._isPlaying = !!b.isPlaying, this._isScheduled = !!b.isScheduled, this._initialStateSet = !!b.initialStateSet, this._finishedTriggers = b.hasOwnProperty("finishedTriggers") ? !!b.finishedTriggers : !1, this._complete = !!b.complete,
                this._released = !!b.released, this._markedForRemoval = !!b.markedForRemoval, this._completedTick = b.completedTick, this._implicitPause = !!b.implicitPause, this._isTemplate = !!b.isTemplate, this._tags = b.tags.split(" "), this._stringTags = b.stringTags, this._tagsChanged = !!b.tagsChanged, this._firstTick = !!b.firstTick)
        }
        _SaveTracksToJson() {
            return this._tracks.map(b => b._SaveToJson())
        }
        _LoadTracksFromJson(b) {
            b.forEach((a, f) => {
                this._tracks[f]._LoadFromJson(a)
            });
            this._tracks.filter(a => a.CanInstanceBeValid())
        }
        static _HasTag(b) {
            const a =
                this.GetTags();
            return "" === b ? 1 === a.length && "" === a[0] : a.includes(b)
        }
        static _GetTagArray(b) {
            if (d.IsArray(b)) return b.slice(0);
            if (d.IsString(b)) return b.split(" ")
        }
    }
}
"use strict";
{
    const d = self.C3;
    d.TrackState = class extends d.DefendedBase {
        constructor(b, a) {
            super();
            this._timeline = b;
            this._trackDataItem = a;
            this._trackData = a.GetTrackData();
            this._objectClassIndex = this._instanceUid = NaN;
            this._worldInfo = this._instance = null;
            this._isNested = 0 < a.GetStartOffset();
            this._endStateOfNestedSet = this._initialStateOfNestedSet = !1;
            this._lastKeyframeDataItem = null;
            this._keyframeDataItems = this._trackDataItem.GetKeyframeData().GetKeyframeDataItemArray();
            this._propertyTracks = [];
            for (const f of this._trackDataItem.GetPropertyTrackData().propertyTrackDataItems()) this._propertyTracks.push(d.PropertyTrackState.Create(this,
                f))
        }
        static Create(b, a) {
            return d.New(d.TrackState, b, a)
        }
        Release() {
            this._keyframeDataItems = null;
            for (const b of this._propertyTracks) b.Release();
            d.clearArray(this._propertyTracks);
            this._lastKeyframeDataItem = this._trackDataItem = this._worldInfo = this._instance = this._timeline = this._propertyTracks = null
        }
        CleanCaches() {
            for (const b of this._propertyTracks) b.CleanCaches();
            this._worldInfo = this._instance = null
        }
        GetTimeline() {
            return this._timeline
        }
        GetRuntime() {
            return this._timeline.GetRuntime()
        }
        GetKeyframeDataItems() {
            return this._keyframeDataItems ?
                this._keyframeDataItems : this._keyframeDataItems = this._trackDataItem.GetKeyframeData().GetKeyframeDataItemArray()
        }
        GetPropertyTracks() {
            return this._propertyTracks
        }
        GetPropertyTrack(b) {
            for (const a of this._propertyTracks)
                if (a.GetPropertyName() === b) return a
        }
        MaybeGetInstance() {
            this._instance || this.GetInstance()
        }
        IsInstanceValid() {
            return this._instance ? !this._instance.IsDestroyed() : !1
        }
        CanInstanceBeValid() {
            var b = this.GetInstanceUID();
            return (b = this.GetRuntime().GetInstanceByUID(b)) ? !b.IsDestroyed() : !1
        }
        GetObjectClass() {
            const b =
                this.GetObjectClassIndex();
            if (-1 !== b) return this.GetRuntime().GetObjectClassByIndex(b)
        }
        ClearInstance() {
            this._instance = null;
            this._instanceUid = -1;
            this._worldInfo = null;
            this._objectClassIndex = -1
        }
        HasInstance() {
            return !!this._instance
        }
        GetInstance() {
            if (this._instance && this.IsInstanceValid()) return this._instance;
            const b = this.GetInstanceUID();
            return this._instance = this.GetRuntime().GetInstanceByUID(b)
        }
        SetInstance(b) {
            if (this._instance !== b) {
                this.CleanCaches();
                this._instance = b;
                this._objectClassIndex = b.GetObjectClass().GetIndex();
                this._instanceUid = b.GetUID();
                this._worldInfo = b.GetWorldInfo();
                for (const g of this.propertyTrackItems()) {
                    const h = g.sourceAdapter;
                    switch (g.propertyTrack.GetSourceAdapterId()) {
                        case "instance-variable":
                            h.GetEditorIndex();
                            var a = b.GetObjectClass(),
                                f = a.GetInstanceVariableIndexByName(g.name),
                                c = a.GetInstanceVariableName(f);
                            a = a.GetInstanceVariableType(f);
                            c === g.name && a === g.type && h.UpdateInstanceVariableIndex(f);
                            break;
                        case "behavior":
                            var e = g.behaviorType;
                            f = this.GetObjectClass();
                            c = b.GetObjectClass();
                            a = h.GetBehaviorType(c);
                            e && a && (e = e.GetName(), f.GetBehaviorIndexByName(e), c.GetBehaviorIndexByName(e), h.GetEditorIndex(), h.UpdateBehaviorTypeSid(a.GetSID()))
                    }
                }
            }
        }* propertyTrackItems() {
            for (const f of this._propertyTracks) {
                var b = f.GetSourceAdapter(),
                    a = this.GetObjectClass();
                const c = {
                    propertyTrack: f,
                    sourceAdapter: b
                };
                switch (f.GetSourceAdapterId()) {
                    case "world-instance":
                        c.property = f.GetPropertyName();
                        break;
                    case "instance-variable":
                        b = b.GetEditorIndex();
                        c.name = a.GetInstanceVariableName(b);
                        c.type = a.GetInstanceVariableType(b);
                        break;
                    case "effect":
                        a = a.GetEffectList();
                        b = b.GetEffectType(a);
                        c.effectType = b;
                        break;
                    case "behavior":
                        b = b.GetBehaviorType(a);
                        c.behaviorType = b;
                        break;
                    case "plugin":
                        c.plugin = a.GetPlugin()
                }
                yield c
            }
        }
        GetWorldInfo() {
            if (this._worldInfo && this.IsInstanceValid()) return this._worldInfo;
            const b = this.GetInstance();
            b && (this._worldInfo = b.GetWorldInfo());
            return this._worldInfo
        }
        GetTrackDataItem() {
            return this._trackDataItem
        }
        GetInstanceUID() {
            return this._instanceUid ? this._instanceUid : this._trackDataItem.GetInstanceUID()
        }
        SetInstanceUID(b) {
            this._trackDataItem.SetInstanceUID(b)
        }
        GetInterpolationMode() {
            return this._trackDataItem.GetInterpolationMode()
        }
        SetInterpolationMode(b) {
            this._trackDataItem.SetInterpolationMode(b)
        }
        GetResultMode() {
            return this._trackDataItem.GetResultMode()
        }
        GetId() {
            return this._trackDataItem.GetId()
        }
        GetStartOffset() {
            return this._trackDataItem.GetStartOffset()
        }
        GetLocalTotalTime() {
            return this._trackDataItem.GetLocalTotalTime()
        }
        SetLocalTotalTime(b) {
            this._trackDataItem.SetLocalTotalTime(b)
        }
        SetResultMode(b) {
            this._trackDataItem.SetResultMode(b)
        }
        SetEase(b) {
            for (const a of this.GetKeyframeDataItems()) a.SetEase(b);
            for (const a of this.GetPropertyTracks()) a.SetEase(b)
        }
        GetEnable() {
            return this._trackDataItem.GetEnable()
        }
        SetEnable(b) {
            this._trackDataItem.SetEnable(b)
        }
        GetObjectClassIndex() {
            return isNaN(this._objectClassIndex) ? this._trackDataItem.GetObjectClassIndex() : this._objectClassIndex
        }
        SetObjectClassIndex(b) {
            this._trackDataItem.SetObjectClassIndex(b)
        }
        SetOriginalWidth(b) {
            this._trackDataItem.SetOriginalWidth(b)
        }
        GetOriginalWidth() {
            return this._trackDataItem.GetOriginalWidth()
        }
        SetOriginalHeight(b) {
            this._trackDataItem.SetOriginalHeight(b)
        }
        GetOriginalHeight() {
            return this._trackDataItem.GetOriginalHeight()
        }
        SetInitialState() {
            this.MaybeGetInstance();
            if (this.IsInstanceValid()) {
                for (var b of this._propertyTracks) b.SetInitialState();
                b = this.GetTimeline().IsForwardPlayBack() ? 0 : this.GetLocalTotalTime();
                this._lastKeyframeDataItem = this.GetLastKeyFrameBeforeTime(b);
                this._endStateOfNestedSet = this._initialStateOfNestedSet = !1;
                this.Interpolate(b)
            }
        }
        SetResumeState() {
            this.MaybeGetInstance();
            if (this.IsInstanceValid()) {
                this._timeline.IsForwardPlayBack();
                var b = this._timeline.GetTime() - this.GetStartOffset();
                this._lastKeyframeDataItem = this.GetLastKeyFrameBeforeTime(b);
                for (const a of this._propertyTracks) a.SetResumeState()
            }
        }
        SetEndState() {
            if (!this.GetTimeline().IsComplete() && (this.MaybeGetInstance(), this.IsInstanceValid() && !this._isNested)) {
                const b = this._timeline.GetTime(),
                    a = this.GetStartOffset() + this.GetLocalTotalTime();
                b >= a ? this.Interpolate(this.GetLocalTotalTime(), !0, !1, !0) : 0 >= b && this.Interpolate(0, !0, !1, !0)
            }
        }
        BeforeInterpolate() {
            for (const b of this._propertyTracks) b.BeforeInterpolate()
        }
        Interpolate(b, a = !1, f = !1, c = !1, e = !1, g = !1) {
            this.MaybeGetInstance();
            if (!this.IsInstanceValid() ||
                g && this.GetObjectClass().IsGlobal()) return !1;
            b -= this.GetStartOffset();
            if (0 > b) return !1;
            this.MaybeSetInitialStateOfNestedTrack(b, a);
            this.MaybeTriggerKeyframeReachedConditions(b, a, e);
            e = g = !1;
            for (const h of this._propertyTracks) {
                const l = h.Interpolate(b, f, !1, c);
                g || 0 === (l & d.TimelineState.WORLD_INSTANCE_BOX_CHANGE) || (g = !0);
                e || 0 === (l & d.TimelineState.LAYOUT_RENDER_CHANGE) || (e = !0)
            }
            this.MaybeSetEndStateOfNestedTrack(b, a);
            g && (b = this.GetWorldInfo()) && b.SetBboxChanged();
            return e
        }
        AfterInterpolate() {
            for (const b of this._propertyTracks) b.AfterInterpolate()
        }
        MaybeSetInitialStateOfNestedTrack(b,
            a) {
            if (a && this._isNested && !this._initialStateOfNestedSet) {
                if (this.GetTimeline().IsForwardPlayBack()) {
                    if (0 > b) return;
                    for (const f of this._propertyTracks) f.Interpolate(0, !1, !1, !0)
                } else {
                    if (b > this.GetLocalTotalTime()) return;
                    for (const f of this._propertyTracks) f.Interpolate(this.GetLocalTotalTime(), !1, !1, !0)
                }
                for (const f of this._propertyTracks) f.SetInitialState();
                this._initialStateOfNestedSet = !0
            }
        }
        MaybeSetEndStateOfNestedTrack(b, a) {
            if (a && this._isNested && !this._endStateOfNestedSet)
                if (this.GetTimeline().IsForwardPlayBack()) {
                    if (b >=
                        this.GetLocalTotalTime()) {
                        for (const f of this._propertyTracks) f.Interpolate(this.GetLocalTotalTime(), !1, !1, !0);
                        this._endStateOfNestedSet = !0
                    }
                } else if (0 >= b) {
                for (const f of this._propertyTracks) f.Interpolate(0, !1, !1, !0);
                this._endStateOfNestedSet = !0
            }
        }
        MaybeTriggerKeyframeReachedConditions(b, a, f) {
            if (!f && a) return b = this.GetLastKeyFrameBeforeTime(b), b !== this._lastKeyframeDataItem && this.OnKeyframeReached(b), this._lastKeyframeDataItem = b
        }
        GetLastKeyFrameBeforeTime(b) {
            const a = this.GetTimeline();
            let f = this._trackData.GetKeyFrameDataItemAtTime(b,
                this._trackDataItem);
            return f ? f : a.IsForwardPlayBack() ? this._trackData.GetFirstKeyFrameDataItemLowerOrEqualThan(b, this._trackDataItem) : this._trackData.GetFirstKeyFrameDataItemHigherOrEqualThan(b, this._trackDataItem)
        }
        OnKeyframeReached(b) {
            if (d.Plugins.Timeline && this.GetTimeline().constructor === d.TimelineState) {
                var a = this.GetTimeline();
                d.Plugins.Timeline.Cnds.SetTriggerTimeline(a);
                d.Plugins.Timeline.Cnds.SetTriggerKeyframe(b);
                b = a.GetTimelineManager();
                b.Trigger(d.Plugins.Timeline.Cnds.OnAnyKeyframeReached);
                b.Trigger(d.Plugins.Timeline.Cnds.OnKeyframeReached);
                d.Plugins.Timeline.Cnds.SetTriggerTimeline(null);
                d.Plugins.Timeline.Cnds.SetTriggerKeyframe(null)
            }
        }
        AddKeyframe() {
            return this._trackDataItem.GetKeyframeData().AddEmptyKeyframeDataItem()
        }
        AddPropertyTrack() {
            var b = this._trackDataItem.GetPropertyTrackData().AddEmptyPropertyTrackDataItem();
            b = d.PropertyTrackState.Create(this, b);
            this._propertyTracks.push(b);
            return b
        }
        DeleteKeyframes(b) {
            this._trackDataItem.GetKeyframeData().DeleteKeyframeDataItems(b)
        }
        DeletePropertyKeyframes(b) {
            for (const a of this._propertyTracks) a.DeletePropertyKeyframes(b)
        }
        SaveState() {
            for (const b of this._propertyTracks) b.SaveState()
        }
        CompareInitialStateWithCurrent() {
            this.MaybeGetInstance();
            if (this.IsInstanceValid())
                for (const b of this._propertyTracks) b.CompareInitialStateWithCurrent()
        }
        CompareSaveStateWithCurrent() {
            this.MaybeGetInstance();
            if (this.IsInstanceValid()) {
                var b = !1;
                for (const a of this._propertyTracks) {
                    const f = a.CompareSaveStateWithCurrent();
                    !b && f && (b = !0)
                }
                b && (b = this.AddKeyframe(), b.SetTime(this.GetTimeline().GetTime()), b.SetEase("noease"), b.SetEnable(!0), b.SetTags(""))
            }
        }
        _SaveToJson() {
            var b = this.GetInstance();
            b = b ? b.GetUID() : this.GetInstanceUID();
            return {
                propertyTracksJson: this._SavePropertyTracksToJson(),
                lastKeyframeDataItemJson: this._SaveLastKeyframeDataItemToJson(),
                initialStateOfNestedSet: this._initialStateOfNestedSet,
                endStateOfNestedSet: this._endStateOfNestedSet,
                instanceUid: b
            }
        }
        _LoadFromJson(b) {
            b && (this._LoadPropertyTracksFromJson(b.propertyTracksJson), this._LoadLastKeyframeDataItemFromJson(b.lastKeyframeDataItemJson), this._LoadInstanceFromJson(b.instanceUid), this._initialStateOfNestedSet = !1, b.hasOwnProperty.initialStateOfNestedSet && (this._initialStateOfNestedSet = b.initialStateOfNestedSet), this._endStateOfNestedSet = !1, b.hasOwnProperty.endStateOfNestedSet && (this._endStateOfNestedSet = b.endStateOfNestedSet))
        }
        _SaveLastKeyframeDataItemToJson() {
            return this._trackDataItem.GetKeyframeData().GetKeyframeDataItemIndex(this._lastKeyframeDataItem)
        }
        _SavePropertyTracksToJson() {
            return this._propertyTracks.map(b => b._SaveToJson())
        }
        _LoadPropertyTracksFromJson(b) {
            b.forEach((a, f) => {
                this._propertyTracks[f]._LoadFromJson(a)
            })
        }
        _LoadInstanceFromJson(b) {
            if (d.IsFiniteNumber(b) && (b = this.GetRuntime().GetInstanceByUID(b))) {
                var a = this.GetTimeline();
                a.ClearTrackInstances();
                a.SetTrackInstance(this._trackDataItem.GetId(), b)
            }
        }
        _LoadLastKeyframeDataItemFromJson(b) {
            this._lastKeyframeDataItem = this._trackDataItem.GetKeyframeData().GetKeyframeDataItemFromIndex(b)
        }
    }
}
"use strict";
{
    const d = self.C3;
    d.PropertyTrackState = class extends d.DefendedBase {
        constructor(b, a) {
            super();
            this._track = b;
            this._propertyTrackDataItem = a;
            this._propertyTrackData = a.GetPropertyTrackData();
            this._sourceAdapter = this.GetSourceAdapter();
            this._propertyKeyframeDataItems = this._propertyTrackDataItem.GetPropertyKeyframeData().GetPropertyKeyframeDataItemArray()
        }
        static Create(b, a) {
            return d.New(d.PropertyTrackState, b, a)
        }
        Release() {
            this._track = null;
            this._sourceAdapter && (this._sourceAdapter.Release(), this._sourceAdapter =
                null);
            this._propertyTrackData = this._propertyTrackDataItem = this._propertyKeyframeDataItems = null
        }
        GetTrack() {
            return this._track
        }
        GetPropertyTrackDataItem() {
            return this._propertyTrackDataItem
        }
        GetPropertyTrackData() {
            return this._propertyTrackData
        }
        GetTimeline() {
            return this._track.GetTimeline()
        }
        GetRuntime() {
            return this._track.GetRuntime()
        }
        GetInstance() {
            return this._track.GetInstance()
        }
        GetSourceAdapter() {
            if (this._sourceAdapter) return this._sourceAdapter;
            let b;
            switch (this._propertyTrackDataItem.GetSourceAdapterId()) {
                case "behavior":
                    b =
                        new d.PropertyTrackState.BehaviorSourceAdapter(this);
                    break;
                case "effect":
                    b = new d.PropertyTrackState.EffectSourceAdapter(this);
                    break;
                case "instance-variable":
                    b = new d.PropertyTrackState.InstanceVariableSourceAdapter(this);
                    break;
                case "plugin":
                    b = new d.PropertyTrackState.PluginSourceAdapter(this);
                    break;
                case "world-instance":
                    b = new d.PropertyTrackState.WorldInstanceSourceAdapter(this);
                    break;
                case "value":
                    b = new d.PropertyTrackState.ValueSourceAdapter(this)
            }
            return this._sourceAdapter = b
        }
        GetSourceAdapterId() {
            return this._propertyTrackDataItem.GetSourceAdapterId()
        }
        SetSourceAdapterId(b) {
            this._propertyTrackDataItem.SetSourceAdapterId(b)
        }
        GetSourceAdapterArgs() {
            return this._propertyTrackDataItem.GetSourceAdapterArguments()
        }
        SetSourceAdapterArgs(b) {
            this._propertyTrackDataItem.SetSourceAdapterArguments(b)
        }
        GetSourceAdapterValue() {
            return this.GetSourceAdapter().GetValue()
        }
        GetPropertyName() {
            return this._propertyTrackDataItem.GetProperty()
        }
        SetPropertyName(b) {
            this._propertyTrackDataItem.SetProperty(b)
        }
        GetPropertyType() {
            return this._propertyTrackDataItem.GetType()
        }
        SetPropertyType(b) {
            this._propertyTrackDataItem.SetType(b)
        }
        GetPropertyKeyframeType() {
            return this.GetPropertyTrackData().GetFirstPropertyKeyframeDataItem(this._propertyTrackDataItem).GetType()
        }
        GetMin() {
            return this._propertyTrackDataItem.GetMin()
        }
        SetMin(b) {
            this._propertyTrackDataItem.SetMin(b)
        }
        GetMax() {
            return this._propertyTrackDataItem.GetMax()
        }
        SetMax(b) {
            this._propertyTrackDataItem.SetMax(b)
        }
        GetEnable() {
            return this._propertyTrackDataItem.GetEnable()
        }
        SetEnable(b) {
            this._propertyTrackDataItem.SetEnable(b)
        }
        GetInterpolationMode() {
            return this._propertyTrackDataItem.GetInterpolationMode()
        }
        SetInterpolationMode(b) {
            this._propertyTrackDataItem.SetInterpolationMode(b)
        }
        GetResultMode() {
            return this._propertyTrackDataItem.GetResultMode()
        }
        SetResultMode(b) {
            this._propertyTrackDataItem.SetResultMode(b)
        }
        SetEase(b) {
            for (const a of this.GetPropertyKeyframeDataItems()) a.SetEase(b)
        }
        GetPropertyKeyframeDataItems() {
            return this._propertyKeyframeDataItems ?
                this._propertyKeyframeDataItems : this._propertyKeyframeDataItems = this._propertyTrackDataItem.GetPropertyKeyframeData().GetPropertyKeyframeDataItemArray()
        }* GetPropertyKeyframeValues() {
            for (const b of this.GetPropertyKeyframeDataItems()) yield b.GetValueWithResultMode()
        }
        CleanCaches() {
            this.GetSourceAdapter().CleanCaches()
        }
        GetCurrentState() {
            return this.GetSourceAdapter().GetCurrentState()
        }
        SetInitialState() {
            this.GetSourceAdapter().SetInitialState()
        }
        SetResumeState() {
            this.GetSourceAdapter().SetResumeState()
        }
        BeforeInterpolate() {
            this.GetSourceAdapter().BeforeInterpolate()
        }
        Interpolate(b,
            a = !1, f = !1, c = !1) {
            var e = this._propertyTrackDataItem;
            let g = this._propertyTrackData.GetPropertyKeyFrameDataItemAtTime(b, e);
            g ? e = this._propertyTrackData.GetFirstPropertyKeyFrameDataItemHigherThan(b, e) : (g = this._propertyTrackData.GetFirstPropertyKeyFrameDataItemLowerOrEqualThan(b, e), e = this._propertyTrackData.GetFirstPropertyKeyFrameDataItemHigherOrEqualThan(b, e));
            return this.GetSourceAdapter().Interpolate(b, g, e, a, f, c)
        }
        AfterInterpolate() {
            this.GetSourceAdapter().AfterInterpolate()
        }
        static GetStartPropertyKeyframeForTime(b,
            a) {
            const f = a.GetPropertyTrackDataItem();
            a = a._propertyTrackData;
            let c = a.GetPropertyKeyFrameDataItemAtTime(b, f);
            c || (c = a.GetFirstPropertyKeyFrameDataItemLowerOrEqualThan(b, f));
            return c
        }
        static GetEndPropertyKeyframeForTime(b, a) {
            const f = a.GetPropertyTrackDataItem();
            a = a._propertyTrackData;
            return a.GetPropertyKeyFrameDataItemAtTime(b, f) ? a.GetFirstPropertyKeyFrameDataItemHigherThan(b, f) : a.GetFirstPropertyKeyFrameDataItemHigherOrEqualThan(b, f)
        }
        AddPropertyKeyframe() {
            return this._propertyTrackDataItem.GetPropertyKeyframeData().AddEmptyPropertyKeyframeDataItem()
        }
        DeletePropertyKeyframes(b) {
            this._propertyTrackDataItem.GetPropertyKeyframeData().DeletePropertyKeyframeDataItems(b)
        }
        SaveState() {
            this.GetSourceAdapter().SaveState()
        }
        CompareInitialStateWithCurrent() {
            if (this.GetSourceAdapter().CompareInitialStateWithCurrent()) {
                const b =
                    this._propertyTrackData.GetFirstPropertyKeyframeDataItem(this._propertyTrackDataItem),
                    a = this.GetSourceAdapter().GetCurrentState();
                b.SetAbsoluteValue(a)
            }
        }
        CompareSaveStateWithCurrent() {
            const b = this.GetSourceAdapter().CompareSaveStateWithCurrent();
            b && this.AddPropertyKeyframeAtCurrentTime();
            this.GetSourceAdapter().ClearSaveState();
            return b
        }
        AddPropertyKeyframeAtCurrentTime() {
            const b = this.GetTimeline().GetTime(),
                a = this.GetSourceAdapter(),
                f = d.PropertyTrackState.GetStartPropertyKeyframeForTime(b, this),
                c =
                this.AddPropertyKeyframe();
            c.SetType(f.GetType());
            c.SetTime(b);
            c.SetEase(f.GetEase());
            c.SetEnable(!0);
            c.SetValue(a.GetValueAtTime());
            c.SetAbsoluteValue(a.GetCurrentState())
        }
        _SaveToJson() {
            return {
                sourceAdapterJson: this.GetSourceAdapter()._SaveToJson()
            }
        }
        _LoadFromJson(b) {
            b && this.GetSourceAdapter()._LoadFromJson(b.sourceAdapterJson)
        }
    }
}
"use strict";
{
    const d = self.C3.PropertyTrackState;
    d.PropertySourceAdapter = class {
        constructor(b) {
            this._propertyTrack = b;
            this._propertyAdapter = null
        }
        Release() {
            this._propertyAdapter && (this._propertyAdapter.Release(), this._propertyAdapter = null);
            this._propertyTrack = null
        }
        GetPropertyTrack() {
            return this._propertyTrack
        }
        CleanCaches() {
            this._propertyAdapter && this._propertyAdapter.CleanCaches()
        }
        GetPropertyAdapter() {
            return this._propertyAdapter ? this._propertyAdapter : this._propertyAdapter = this._CreatePropertyAdapter()
        }
        GetEditorIndex() {}
        GetIndex() {
            return this.GetEditorIndex()
        }
        GetTarget() {}
        SetInitialState() {
            this.GetPropertyAdapter().SetInitialState()
        }
        SetResumeState() {
            this.GetPropertyAdapter().SetResumeState()
        }
        BeforeInterpolate() {
            this.GetPropertyAdapter().BeforeChangeProperty()
        }
        Interpolate(b,
            a, f, c, e, g) {
            const h = d.PropertySourceAdapter.GetInterpolateFunc(this._propertyTrack)(b, a, f, this._propertyTrack);
            return e ? h : this.GetPropertyAdapter().ChangeProperty(b, h, a, f, c, g)
        }
        AfterInterpolate() {
            this.GetPropertyAdapter().AfterChangeProperty()
        }
        SaveState() {
            this.GetPropertyAdapter().SetSaveState()
        }
        ClearSaveState() {
            this.GetPropertyAdapter().ClearSaveState()
        }
        GetCurrentState() {
            return this.GetPropertyAdapter().GetCurrentState()
        }
        CompareInitialStateWithCurrent() {
            return this.GetPropertyAdapter().CompareInitialStateWithCurrent()
        }
        CompareSaveStateWithCurrent() {
            return this.GetPropertyAdapter().CompareSaveStateWithCurrent()
        }
        GetValueAtTime() {
            return d.PropertySourceAdapter.GetValueAtTime(this._propertyTrack)
        }
        _CreatePropertyAdapter() {
            const b =
                this._propertyTrack.GetPropertyType();
            switch (this._propertyTrack.GetPropertyKeyframeType()) {
                case "combo":
                case "boolean":
                case "text":
                case "string":
                    return new d.PropertyInterpolationAdapter.NoInterpolationAdapter(this);
                case "numeric":
                case "number":
                case "angle":
                    return "combo" === b ? new d.PropertyInterpolationAdapter.NoInterpolationAdapter(this) : new d.PropertyInterpolationAdapter.NumericInterpolationAdapter(this);
                case "color":
                case "offsetColor":
                    return new d.PropertyInterpolationAdapter.ColorInterpolationAdapter(this)
            }
        }
        _SaveToJson() {
            return {
                propertyAdapterJson: this.GetPropertyAdapter()._SaveToJson()
            }
        }
        _LoadFromJson(b) {
            b &&
                this.GetPropertyAdapter()._LoadFromJson(b.propertyAdapterJson)
        }
        static GetValueAtTime(b) {
            const a = b.GetTrack().GetTimeline().GetTime(),
                f = d.GetStartPropertyKeyframeForTime(a, b),
                c = d.GetEndPropertyKeyframeForTime(a, b);
            return d.PropertySourceAdapter.GetInterpolateFunc(b)(a, f, c, b)
        }
        static GetValue(b, a, f) {
            let c = b.GetResultMode();
            "combo" === b.GetPropertyType() && (c = "absolute");
            switch (c) {
                case "relative":
                    return a + f;
                case "absolute":
                    return f
            }
        }
        static GetInterpolateFunc(b) {
            switch (b.GetPropertyKeyframeType()) {
                case "numeric":
                    return d.NumericTypeAdapter.Interpolate;
                case "angle":
                    return d.AngleTypeAdapter.Interpolate;
                case "boolean":
                    return d.BooleanTypeAdapter.Interpolate;
                case "color":
                    return d.ColorTypeAdapter.Interpolate;
                case "text":
                    return d.TextTypeAdapter.Interpolate
            }
        }
        static GetWillChangeFunc(b) {
            switch (b.GetPropertyKeyframeType()) {
                case "numeric":
                    return d.NumericTypeAdapter.WillChange;
                case "angle":
                    return d.AngleTypeAdapter.WillChange;
                case "boolean":
                    return d.BooleanTypeAdapter.WillChange;
                case "color":
                    return d.ColorTypeAdapter.WillChange;
                case "text":
                    return d.TextTypeAdapter.WillChange
            }
        }
    }
}
"use strict";
{
    const d = self.C3;
    class b extends d.PropertyTrackState.PropertySourceAdapter {
        constructor(a) {
            super(a)
        }
    }
    d.PropertyTrackState.WorldInstanceSourceAdapter = b
}
"use strict";
{
    const d = self.C3;
    class b extends d.PropertyTrackState.PropertySourceAdapter {
        constructor(a) {
            super(a);
            this._updatedIndex = NaN
        }
        GetEditorIndex() {
            return this._propertyTrack.GetPropertyTrackDataItem().GetSourceAdapterArguments()[0]
        }
        GetIndex() {
            return this._updatedIndex ? this._updatedIndex : super.GetIndex()
        }
        GetTarget() {
            return this._propertyTrack.GetTrack().GetInstance()
        }
        UpdateInstanceVariableIndex(a) {
            this._propertyTrack.GetPropertyTrackDataItem().GetSourceAdapterArguments()[0] !== a && (this._updatedIndex = a)
        }
        Interpolate(a,
            f, c, e, g, h) {
            if (this.GetPropertyAdapter().CanChange(f.GetValue())) return super.Interpolate(a, f, c, e, g, h)
        }
        _SaveToJson() {
            return Object.assign(super._SaveToJson(), {
                index: this._updatedIndex
            })
        }
        _LoadFromJson(a) {
            a && (super._LoadFromJson(a), this._updatedIndex = a.index)
        }
    }
    d.PropertyTrackState.InstanceVariableSourceAdapter = b
}
"use strict";
{
    const d = self.C3;
    class b extends d.PropertyTrackState.PropertySourceAdapter {
        constructor(a) {
            super(a);
            this._sid = NaN
        }
        GetEditorIndex() {
            return this._propertyTrack.GetPropertyTrackDataItem().GetSourceAdapterArguments()[1]
        }
        GetTarget() {
            var a = this._propertyTrack.GetPropertyTrackDataItem(),
                f = this._propertyTrack.GetTrack();
            a = this._sid ? this._sid : a.GetSourceAdapterArguments()[0];
            f = f.GetInstance();
            a = f.GetBehaviorIndexBySID(a);
            return f.GetBehaviorInstances()[a].GetSdkInstance()
        }
        GetBehaviorType(a) {
            const f = this._propertyTrack.GetPropertyTrackDataItem().GetSourceAdapterArguments()[2];
            return a.GetBehaviorTypeByName(f)
        }
        UpdateBehaviorTypeSid(a) {
            this._propertyTrack.GetPropertyTrackDataItem().GetSourceAdapterArguments()[0] !== a && (this._sid = a)
        }
        Interpolate(a, f, c, e, g, h) {
            const l = this._propertyTrack.GetTrack().GetInstance();
            if (this.GetBehaviorType(l.GetObjectClass())) return super.Interpolate(a, f, c, e, g, h)
        }
        _SaveToJson() {
            return Object.assign(super._SaveToJson(), {
                sid: this._sid
            })
        }
        _LoadFromJson(a) {
            a && (super._LoadFromJson(a), this._sid = a.sid)
        }
    }
    d.PropertyTrackState.BehaviorSourceAdapter = b
}
"use strict";
{
    const d = self.C3;
    class b extends d.PropertyTrackState.PropertySourceAdapter {
        constructor(a) {
            super(a)
        }
        GetEditorIndex() {
            return this._propertyTrack.GetPropertyTrackDataItem().GetSourceAdapterArguments()[1]
        }
        GetTarget() {
            const a = this._propertyTrack.GetTrack().GetWorldInfo().GetInstanceEffectList();
            var f = a.GetEffectList();
            f = this.GetEffectType(f).GetIndex();
            return a.IsEffectIndexActive(f) ? a.GetEffectParametersForIndex(f) : null
        }
        GetEffectType(a) {
            const f = this._propertyTrack.GetPropertyTrackDataItem().GetSourceAdapterArguments()[0];
            return a.GetEffectTypeByName(f)
        }
        Interpolate(a, f, c, e, g, h) {
            if (this._IsEffectActive()) return super.Interpolate(a, f, c, e, g, h)
        }
        _IsEffectActive() {
            const a = this._propertyTrack.GetTrack().GetWorldInfo().GetInstanceEffectList();
            var f = a.GetEffectList();
            if (f = this.GetEffectType(f)) return f = f.GetIndex(), a.IsEffectIndexActive(f)
        }
    }
    d.PropertyTrackState.EffectSourceAdapter = b
}
"use strict";
{
    const d = self.C3;
    class b extends d.PropertyTrackState.PropertySourceAdapter {
        constructor(a) {
            super(a)
        }
        GetEditorIndex() {
            return this._propertyTrack.GetPropertyTrackDataItem().GetSourceAdapterArguments()[0]
        }
        GetTarget() {
            return this._propertyTrack.GetTrack().GetInstance().GetSdkInstance()
        }
        Interpolate(a, f, c, e, g, h) {
            var l = this._propertyTrack.GetTrack();
            const m = l.GetObjectClass().GetPlugin();
            l = l.GetInstance().GetObjectClass().GetPlugin();
            if (m === l) return super.Interpolate(a, f, c, e, g, h)
        }
    }
    d.PropertyTrackState.PluginSourceAdapter =
        b
}
"use strict";
{
    const d = self.C3;
    class b extends d.PropertyTrackState.PropertySourceAdapter {
        constructor(a) {
            super(a);
            this._value = 0;
            this._init = !1
        }
        SetInitialState() {
            const a = this._propertyTrack.GetPropertyTrackData();
            let f = this._propertyTrack.GetPropertyTrackDataItem();
            f = a.GetFirstPropertyKeyframeDataItem(f);
            this._value = f.GetValueWithResultMode()
        }
        SetResumeState() {}
        GetValue() {
            this._init || this._propertyTrack.Interpolate(0);
            return this._value
        }
        Interpolate(a, f, c, e, g, h) {
            e = d.PropertyTrackState.NumericTypeAdapter.Interpolate;
            this._value =
                e(a, f, c, this._propertyTrack);
            this._init = !0
        }
        SaveState() {}
        ClearSaveState() {}
        GetCurrentState() {
            return this._value
        }
        CompareInitialStateWithCurrent() {
            return !1
        }
        CompareSaveStateWithCurrent() {
            return !1
        }
        _SaveToJson() {
            return {
                value: this._value,
                init: this._init
            }
        }
        _LoadFromJson(a) {
            a && (this._value = a.value, this._init = a.hasOwnProperty("init") ? a.init : !0)
        }
    }
    d.PropertyTrackState.ValueSourceAdapter = b
}
"use strict";
self.C3.PropertyTrackState.PropertyInterpolationAdapter = class {
    constructor(d) {
        this._sourceAdapter = d;
        this._propertyTrack = d.GetPropertyTrack();
        this._worldInfo = this._propertyTrack.GetTrack().GetWorldInfo();
        this._property = this._propertyTrack.GetPropertyName();
        this._firstAbsoluteUpdate = !1;
        this._target = this._saveState = null
    }
    Release() {
        this._target = this._saveState = this._worldInfo = this._propertyTrack = this._sourceAdapter = null
    }
    CleanCaches() {
        this._target = this._saveState = this._worldInfo = null
    }
    GetPropertyTrack() {
        return this._propertyTrack
    }
    GetWorldInfo() {
        return this._worldInfo ?
            this._worldInfo : this._worldInfo = this._propertyTrack.GetTrack().GetWorldInfo()
    }
    SetFirstAbsoluteUpdate(d) {
        this._firstAbsoluteUpdate = !!d
    }
    GetFirstAbsoluteUpdate() {
        return this._firstAbsoluteUpdate
    }
    SetInitialState() {}
    SetResumeState() {}
    SetSaveState() {
        this._saveState = this.GetCurrentState()
    }
    ClearSaveState() {
        this._saveState = null
    }
    GetCurrentState() {}
    CompareInitialStateWithCurrent() {}
    CompareSaveStateWithCurrent() {}
    CanChange(d) {
        return typeof this._Getter() === typeof d
    }
    BeforeChangeProperty() {}
    ChangeProperty(d, b,
        a, f, c) {}
    AfterChangeProperty() {}
    _FirstKeyframeGetter() {
        return this._PickTimelinePlaybackMode(() => {
            const d = this._propertyTrack.GetPropertyTrackDataItem();
            return this._propertyTrack.GetPropertyTrackData().GetFirstPropertyKeyframeDataItem(d)
        }, () => {
            const d = this._propertyTrack.GetPropertyTrackDataItem();
            return this._propertyTrack.GetPropertyTrackData().GetLastPropertyKeyframeDataItem(d)
        }).GetAbsoluteValue()
    }
    _CurrentKeyframeGetter() {
        const d = this._propertyTrack.GetTimeline().GetTime() - this._propertyTrack.GetTrack().GetStartOffset();
        return this._PickTimelinePlaybackMode(() => {
            const b = this._propertyTrack.GetPropertyTrackDataItem();
            return this._propertyTrack.GetPropertyTrackData().GetFirstPropertyKeyFrameDataItemLowerOrEqualThan(d, b)
        }, () => {
            const b = this._propertyTrack.GetPropertyTrackDataItem(),
                a = this._propertyTrack.GetPropertyTrackData(),
                f = a.GetFirstPropertyKeyFrameDataItemHigherOrEqualThan(d, b);
            return f ? f : a.GetLastPropertyKeyframeDataItem(b)
        }).GetAbsoluteValue()
    }
    _PickTimelinePlaybackMode(d, b) {
        return this._propertyTrack.GetTimeline().IsForwardPlayBack() ?
            d() : b()
    }
    _PickResultMode(d, b) {
        return "relative" === this._propertyTrack.GetResultMode() ? d() : b()
    }
    _PickFirstAbsoluteUpdate(d, b) {
        return this.GetFirstAbsoluteUpdate() ? (this.SetFirstAbsoluteUpdate(!1), d()) : b()
    }
    _GetAbsoluteInitialValue(d) {}
    _GetIndex() {
        return this._sourceAdapter.GetIndex()
    }
    _GetTarget() {
        return this._target ? this._target : this._target = this._sourceAdapter.GetTarget()
    }
    _PickSource(d, b, a, f, c) {
        switch (this._propertyTrack.GetSourceAdapterId()) {
            case "behavior":
                return d();
            case "effect":
                return b();
            case "instance-variable":
                return a();
            case "plugin":
                return f();
            case "world-instance":
                return c()
        }
    }
    _SaveToJson() {
        return {
            firstAbsoluteUpdate: this._firstAbsoluteUpdate,
            saveState: this._saveState
        }
    }
    _LoadFromJson(d) {
        d && (this._firstAbsoluteUpdate = d.firstAbsoluteUpdate, this._saveState = d.saveState)
    }
    _GetPropertyKeyframeStubs(d, b = !1) {
        const a = [];
        for (const f of d) {
            d = f.GetTrack().GetStartOffset();
            for (const c of f.GetPropertyKeyframeDataItems()) b && 0 === c.GetTime() ? a.push({
                time: d + c.GetTime(),
                value: c.GetAbsoluteValue()
            }) : b || a.push({
                time: d + c.GetTime(),
                value: c.GetAbsoluteValue()
            })
        }
        return a.sort((f,
            c) => f.time - c.time)
    }
    _GetLastPropertyKeyframeStub(d, b, a) {
        return this._GetPropertyKeyframeStubLowerThanPlayhead(b, a)
    }
    _GetPropertyKeyframeStubLowerThanPlayhead(d, b) {
        for (let a = b.length - 1; 0 <= a; a--)
            if (b[a].time <= d) return b[a];
        return null
    }
};
"use strict";
{
    const d = self.C3,
        b = new Map,
        a = [0, 0, 0];
    class f extends d.PropertyTrackState.PropertyInterpolationAdapter {
        constructor(c) {
            super(c)
        }
        SetInitialState() {}
        SetResumeState() {}
        GetCurrentState() {
            const c = this._propertyTrack.GetSourceAdapterId(),
                e = this._GetTarget(),
                g = this._GetIndex();
            switch (c) {
                case "behavior":
                    return this._ToColorArray(e.GetPropertyValueByIndex(g));
                case "effect":
                    return this._ToColorArray(e[g]);
                case "plugin":
                    return this._ToColorArray(e.GetPropertyValueByIndex(g));
                case "world-instance":
                    return this._ToColorArray(this._Getter())
            }
        }
        CompareInitialStateWithCurrent() {
            const c =
                this._FirstKeyframeGetter();
            return !this._CompareColors(c, this._Getter())
        }
        CompareSaveStateWithCurrent() {
            return d.IsNullOrUndefined(this._saveState) ? !1 : !this._CompareColors(this._saveState, this._Getter())
        }
        _CompareColors(c, e) {
            return c.equalsIgnoringAlpha(e)
        }
        _FirstKeyframeGetter() {
            const c = super._FirstKeyframeGetter();
            return this._GetColorFromArray(c)
        }
        _CurrentKeyframeGetter() {
            const c = super._CurrentKeyframeGetter();
            return this._GetColorFromArray(c)
        }
        _GetAbsoluteInitialValue(c) {}
        _ToColorArray(c) {
            return d.IsInstanceOf(c,
                d.Color) ? c.toArray().slice(0, 3) : c.slice(0, 3)
        }
        _GetColorFromArray(c) {
            return d.IsInstanceOf(c, d.Color) ? c : new d.Color(c[0], c[1], c[2], 1)
        }
        CanChange(c) {
            return !0
        }
        BeforeChangeProperty() {
            var c = this._propertyTrack.GetInstance();
            b.has(c) || b.set(c, new Map);
            c = b.get(c);
            const e = this._propertyTrack.GetSourceAdapterId();
            c.has(e) || c.set(e, new Map);
            c = c.get(e);
            c.has(this._property) || c.set(this._property, {
                used: !1,
                color: new d.Color(0, 0, 0, 1)
            })
        }
        _GetTmpColor(c, e, g) {
            c = b.get(c).get(e).get(g);
            c.used = !0;
            return c.color
        }
        ChangeProperty(c,
            e, g, h, l) {
            l = this._propertyTrack.GetTimeline();
            h = this._propertyTrack.GetTrack();
            c = this._propertyTrack.GetInstance();
            var m = this._propertyTrack.GetSourceAdapter();
            g = this._propertyTrack.GetSourceAdapterId();
            m = l.GetSimilarPropertyTracks(c, m, this._property);
            if (1 < m.length) {
                if (m = this._GetPropertyKeyframeStubs(m, !0), l = this._GetLastPropertyKeyframeStub(l, l.GetTime(), m))
                    if (h = h.GetStartOffset(), m = l.time - h, 0 === m) this._GetTmpColor(c, g, this._property).addRgb(e[0], e[1], e[2]);
                    else {
                        if (0 > m) return;
                        l = e[0];
                        h = e[1];
                        e = e[2];
                        m = this._propertyTrack.Interpolate(m, !1, !0);
                        l = d.Color.DiffChannel(l, m[0]);
                        h = d.Color.DiffChannel(h, m[1]);
                        e = d.Color.DiffChannel(e, m[2]);
                        this._GetTmpColor(c, g, this._property).addRgb(l, h, e)
                    }
            } else this._Setter(e[0], e[1], e[2]);
            return d.TimelineState.LAYOUT_RENDER_CHANGE
        }
        AfterChangeProperty() {
            const c = this._propertyTrack.GetInstance();
            if (b.has(c)) {
                var e = b.get(c),
                    g = this._propertyTrack.GetSourceAdapterId();
                if (e.has(g)) {
                    var h = e.get(g);
                    if (h.has(this._property)) {
                        var l = h.get(this._property),
                            m = l.color;
                        l.used && this._Setter(m.getR(),
                            m.getG(), m.getB());
                        0 === h.size && e.delete(g);
                        0 === e.size && b.delete(c)
                    }
                }
            }
        }
        _Getter() {
            const c = this._propertyTrack.GetSourceAdapterId(),
                e = this._GetTarget(),
                g = this._GetIndex();
            switch (c) {
                case "behavior":
                    return this._GetColorFromArray(e.GetPropertyValueByIndex(g));
                case "effect":
                    return e[g].clone();
                case "plugin":
                    return this._GetColorFromArray(e.GetPropertyValueByIndex(g));
                case "world-instance":
                    return this.GetWorldInfo().GetUnpremultipliedColor().clone()
            }
        }
        _Setter(c, e, g) {
            const h = this._propertyTrack.GetSourceAdapterId(),
                l = this._GetTarget(),
                m = this._GetIndex();
            switch (h) {
                case "behavior":
                    a[0] = c;
                    a[1] = e;
                    a[2] = g;
                    l.SetPropertyValueByIndex(m, a);
                    break;
                case "effect":
                    l[m].setRgb(c, e, g);
                    break;
                case "plugin":
                    a[0] = c;
                    a[1] = e;
                    a[2] = g;
                    l.SetPropertyValueByIndex(m, a);
                    break;
                case "world-instance":
                    this.GetWorldInfo().SetUnpremultipliedColorRGB(c, e, g)
            }
        }
        _SaveToJson() {}
        _LoadFromJson(c) {}
    }
    d.PropertyTrackState.PropertyInterpolationAdapter.ColorInterpolationAdapter = f
}
"use strict";
{
    const d = self.C3;
    class b extends d.PropertyTrackState.PropertyInterpolationAdapter {
        constructor(a) {
            super(a)
        }
        SetInitialState() {}
        SetResumeState() {}
        GetCurrentState() {
            return this._Getter()
        }
        CompareInitialStateWithCurrent() {
            return this._FirstKeyframeGetter() !== this.GetCurrentState()
        }
        CompareSaveStateWithCurrent() {
            return d.IsNullOrUndefined(this._saveState) ? !1 : this._saveState !== this.GetCurrentState()
        }
        ChangeProperty(a, f, c, e, g) {
            c = d.PropertyTrackState.PropertySourceAdapter.GetWillChangeFunc(this._propertyTrack);
            var h = this._propertyTrack;
            const l = h.GetTrack();
            e = h.GetSourceAdapterId();
            g = h.GetTimeline();
            var m = l.GetInstance();
            h = h.GetSourceAdapter();
            m = g.GetSimilarPropertyTracks(m, h, this._property);
            1 < m.length && (m = this._GetPropertyKeyframeStubs(m), a += l.GetStartOffset(), a = this._GetLastPropertyKeyframeStub(g, a, m)) && (f = a.value);
            if (c(this._GetIndex(), this._GetTarget(), f, e)) switch (this._Setter(f), e) {
                case "plugin":
                    return d.TimelineState.LAYOUT_RENDER_CHANGE
            }
        }
        _Getter() {
            const a = this._propertyTrack.GetSourceAdapterId(),
                f = this._GetTarget(),
                c = this._GetIndex();
            switch (a) {
                case "behavior":
                    return f.GetPropertyValueByIndex(c);
                case "effect":
                    return f[c];
                case "instance-variable":
                    return f.GetInstanceVariableValue(c);
                case "plugin":
                    return f.GetPropertyValueByIndex(c)
            }
        }
        _Setter(a) {
            const f = this._propertyTrack.GetSourceAdapterId(),
                c = this._GetTarget(),
                e = this._GetIndex();
            switch (f) {
                case "behavior":
                    c.SetPropertyValueByIndex(e, a);
                    break;
                case "effect":
                    c[e] = a;
                    break;
                case "instance-variable":
                    c.SetInstanceVariableValue(e, a);
                    break;
                case "plugin":
                    c.SetPropertyValueByIndex(e,
                        a)
            }
        }
    }
    d.PropertyTrackState.PropertyInterpolationAdapter.NoInterpolationAdapter = b
}
"use strict";
{
    const d = self.C3,
        b = new Map,
        a = (c, e, g, h, l) => b.set(c, {
            setter: e,
            absolute_setter: g,
            getter: h,
            round: l
        });
    a("offsetX", (c, e) => c.OffsetX(e), (c, e) => c.SetX(e), c => c.GetX(), !0);
    a("offsetY", (c, e) => c.OffsetY(e), (c, e) => c.SetY(e), c => c.GetY(), !0);
    a("offsetWidth", (c, e) => c.OffsetWidth(e), (c, e) => c.SetWidth(e), c => c.GetWidth(), !0);
    a("offsetHeight", (c, e) => c.OffsetHeight(e), (c, e) => c.SetHeight(e), c => c.GetHeight(), !0);
    a("offsetAngle", (c, e) => c.OffsetAngle(e), (c, e) => c.SetAngle(e), c => c.GetAngle(), !1);
    a("offsetOpacity", (c, e) => c.OffsetOpacity(e),
        (c, e) => c.SetOpacity(e), c => c.GetOpacity(), !1);
    a("offsetOriginX", (c, e) => c.OffsetOriginX(e), (c, e) => c.SetOriginX(e), c => c.GetOriginX(), !1);
    a("offsetOriginY", (c, e) => c.OffsetOriginY(e), (c, e) => c.SetOriginY(e), c => c.GetOriginY(), !1);
    a("offsetZElevation", (c, e) => c.OffsetZElevation(e), (c, e) => c.SetZElevation(e), c => c.GetZElevation(), !0);
    a("offsetScaleX", (c, e, g) => {
        c.OffsetWidth(g.GetOriginalWidth() * e)
    }, (c, e, g) => {
        c.SetWidth(g.GetOriginalWidth() * e)
    }, (c, e) => c.GetWidth() / e.GetOriginalWidth(), !1);
    a("offsetScaleY", (c,
        e, g) => {
        c.OffsetHeight(g.GetOriginalHeight() * e)
    }, (c, e, g) => {
        c.SetHeight(g.GetOriginalHeight() * e)
    }, (c, e) => c.GetHeight() / e.GetOriginalHeight(), !1);
    class f extends d.PropertyTrackState.PropertyInterpolationAdapter {
        constructor(c) {
            super(c);
            this._lastValue = 0;
            this._instance_absolute_setter = this._instance_setter = this._instance_getter = null;
            this._round = !1;
            d.IsInstanceOf(this._propertyTrack.GetTimeline(), d.Tween) ? this._typeAdapter = new d.PropertyTrackState.PropertyInterpolationAdapter.NumericInterpolationAdapterForTween(this) :
                this._typeAdapter = new d.PropertyTrackState.PropertyInterpolationAdapter.NumericInterpolationAdapterForTimeline(this);
            c = this._propertyTrack.GetPropertyName();
            "world-instance" === this._propertyTrack.GetSourceAdapterId() && (c = b.get(c), this._instance_getter = c.getter, this._instance_setter = c.setter, this._instance_absolute_setter = c.absolute_setter, this._round = c.round)
        }
        Release() {
            this._instance_absolute_setter = this._instance_setter = this._instance_getter = this._typeAdapter = null;
            super.Release()
        }
        GetLastValue() {
            return this._lastValue
        }
        SetLastValue(c) {
            this._lastValue =
                c
        }
        SetInitialState() {
            const c = this._typeAdapter.SetInitialState();
            "number" === typeof c && (this._lastValue = c)
        }
        SetResumeState() {
            const c = this._typeAdapter.SetResumeState();
            "number" === typeof c && (this._lastValue = c)
        }
        GetCurrentState() {
            return this._Getter()
        }
        CompareInitialStateWithCurrent() {
            return this._FirstKeyframeGetter() !== this.GetCurrentState()
        }
        CompareSaveStateWithCurrent() {
            return d.IsNullOrUndefined(this._saveState) ? !1 : this._saveState !== this.GetCurrentState()
        }
        BeforeChangeProperty() {
            this._typeAdapter.BeforeChangeProperty()
        }
        ChangeProperty(c,
            e, g, h, l, m) {
            return this._typeAdapter.ChangeProperty(c, e, g, h, l, m)
        }
        AfterChangeProperty() {
            this._typeAdapter.AfterChangeProperty()
        }
        _Getter() {
            const c = this._GetTarget(),
                e = this._GetIndex(),
                g = this._propertyTrack.GetTrack(),
                h = this.GetWorldInfo();
            return this._PickSource(() => c.GetPropertyValueByIndex(e), () => c[e], () => c.GetInstanceVariableValue(e), () => c.GetPropertyValueByIndex(e), () => this._instance_getter(h, g))
        }
        _Setter(c, e, g) {
            const h = this._GetTarget(),
                l = this._GetIndex(),
                m = this._propertyTrack.GetTrack(),
                p = this.GetWorldInfo();
            this._PickSource(() => h.OffsetPropertyValueByIndex(l, c), () => h[l] += c, () => h.SetInstanceVariableOffset(l, c), () => h.OffsetPropertyValueByIndex(l, c), () => this._instance_setter(p, c, m))
        }
        _SetterAbsolute(c, e, g) {
            const h = this._GetTarget(),
                l = this._GetIndex(),
                m = this._propertyTrack.GetTrack(),
                p = this.GetWorldInfo();
            this._PickSource(() => h.SetPropertyValueByIndex(l, c), () => h[l] = c, () => h.SetInstanceVariableValue(l, c), () => h.SetPropertyValueByIndex(l, c), () => this._instance_absolute_setter(p, c, m))
        }
        _MaybeEnsureValue(c, e, g, h,
            l, m) {
            this._typeAdapter._MaybeEnsureValue(c, e, g, h, l, m)
        }
        _AddDelta(c, e, g) {
            var h = (c.toString().split(".")[1] || "").length;
            c = this._Getter();
            h = 0 === h ? this._round ? Math.round(c) : c : d.toFixed(c, h);
            this._Setter(h - c, e, g)
        }
        _SaveToJson() {
            return Object.assign(super._SaveToJson(), {
                v: this._lastValue
            })
        }
        _LoadFromJson(c) {
            c && (super._LoadFromJson(c), this._lastValue = c.v)
        }
    }
    d.PropertyTrackState.PropertyInterpolationAdapter.NumericInterpolationAdapter = f
}
"use strict";
{
    const d = self.C3,
        b = new Map;
    class a {
        constructor(f) {
            this._numericInterpolationAdapter = f
        }
        Release() {
            this._numericInterpolationAdapter = null
        }
        SetInitialState() {
            const f = this._numericInterpolationAdapter,
                c = this._numericInterpolationAdapter.GetPropertyTrack();
            return f._PickResultMode(() => f._PickTimelinePlaybackMode(() => 0, () => d.PropertyTrackState.PropertySourceAdapter.GetValueAtTime(c)), () => {})
        }
        SetResumeState() {}
        BeforeChangeProperty() {
            const f = this._numericInterpolationAdapter,
                c = this._numericInterpolationAdapter.GetPropertyTrack(),
                e = c.GetPropertyName();
            f._PickResultMode(() => {}, () => {
                var g = c.GetInstance();
                b.has(g) || b.set(g, new Map);
                g = b.get(g);
                const h = c.GetSourceAdapterId();
                g.has(h) || g.set(h, new Map);
                g = g.get(h);
                g.has(e) || g.set(e, {
                    used: !1,
                    value: 0
                })
            })
        }
        _GetTmpAbsoluteValueObject(f, c, e) {
            f = b.get(f).get(c).get(e);
            f.used = !0;
            return f
        }
        ChangeProperty(f, c, e, g, h, l) {
            const m = this._numericInterpolationAdapter,
                p = this._numericInterpolationAdapter.GetPropertyTrack(),
                t = p.GetPropertyName();
            m._PickResultMode(() => {
                const q = m.GetLastValue();
                m._Setter(c -
                    q, e, g);
                l && this._MaybeEnsureValue(f, e, g, h, q, c);
                m.SetLastValue(c)
            }, () => {
                var q = p.GetTimeline(),
                    r = p.GetTrack();
                const u = p.GetInstance();
                var x = p.GetSourceAdapter();
                const y = p.GetSourceAdapterId();
                x = q.GetSimilarPropertyTracks(u, x, t);
                if (1 < x.length) {
                    if (x = m._GetPropertyKeyframeStubs(x, !0), q = m._GetLastPropertyKeyframeStub(q, q.GetTime(), x)) r = r.GetStartOffset(), r = q.time - r, 0 === r ? this._GetTmpAbsoluteValueObject(u, y, t).value += c : 0 > r || (r = p.Interpolate(r, !1, !0), this._GetTmpAbsoluteValueObject(u, y, t).value += c - r)
                } else m._SetterAbsolute(c)
            });
            return m._PickSource(() => {}, () => d.TimelineState.LAYOUT_RENDER_CHANGE, () => {}, () => d.TimelineState.LAYOUT_RENDER_CHANGE, () => d.TimelineState.LAYOUT_RENDER_CHANGE)
        }
        AfterChangeProperty() {
            const f = this._numericInterpolationAdapter,
                c = this._numericInterpolationAdapter.GetPropertyTrack(),
                e = c.GetPropertyName();
            f._PickResultMode(() => {}, () => {
                const g = c.GetInstance();
                if (b.has(g)) {
                    var h = b.get(g),
                        l = c.GetSourceAdapterId();
                    if (h.has(l)) {
                        var m = h.get(l);
                        if (m.has(e)) {
                            var p = m.get(e),
                                t = p.value;
                            p.used && f._SetterAbsolute(t);
                            m.delete(e);
                            0 === m.size && h.delete(l);
                            0 === h.size && b.delete(g)
                        }
                    }
                }
            })
        }
        _MaybeEnsureValue(f, c, e, g, h, l) {
            const m = this._numericInterpolationAdapter;
            g || (c && f === c.GetTime() ? m._AddDelta(c.GetValueWithResultMode(), c, e) : e && f === e.GetTime() ? m._AddDelta(e.GetValueWithResultMode(), c, e) : 0 === l - h && m._AddDelta(c.GetValueWithResultMode(), c, e))
        }
    }
    d.PropertyTrackState.PropertyInterpolationAdapter.NumericInterpolationAdapterForTimeline = a
}
"use strict";
{
    const d = self.C3;
    new Map;
    class b {
        constructor(a) {
            this._numericInterpolationAdapter = a
        }
        Release() {
            this._numericInterpolationAdapter = null
        }
        SetInitialState() {
            const a = this._numericInterpolationAdapter;
            a.SetFirstAbsoluteUpdate(!0);
            return this._GetAbsoluteInitialValue(a._FirstKeyframeGetter())
        }
        SetResumeState() {
            const a = this._numericInterpolationAdapter;
            if (a._FirstKeyframeGetter() !== a._CurrentKeyframeGetter()) return a.SetFirstAbsoluteUpdate(!0), this._GetAbsoluteInitialValue(a._CurrentKeyframeGetter())
        }
        BeforeChangeProperty() {}
        ChangeProperty(a,
            f, c, e, g, h) {
            const l = this._numericInterpolationAdapter,
                m = l.GetLastValue();
            l._PickResultMode(() => {
                l._Setter(f - m, c, e);
                h && this._MaybeEnsureValue(a, c, e, g, m, f)
            }, () => {
                l._PickFirstAbsoluteUpdate(() => {
                    l._Setter(m, c, e)
                }, () => {
                    l._Setter(f - m, c, e);
                    h && this._MaybeEnsureValue(a, c, e, g, m, f)
                })
            });
            l.SetLastValue(f);
            return l._PickSource(() => {}, () => d.TimelineState.LAYOUT_RENDER_CHANGE, () => {}, () => d.TimelineState.LAYOUT_RENDER_CHANGE, () => d.TimelineState.LAYOUT_RENDER_CHANGE)
        }
        AfterChangeProperty() {}
        _GetAbsoluteInitialValue(a) {
            return a -
                this._numericInterpolationAdapter.GetCurrentState()
        }
        _MaybeEnsureValue(a, f, c, e, g, h) {
            const l = this._numericInterpolationAdapter;
            e ? f && a === f.GetTime() ? l._AddDelta(f.GetValueWithResultMode(), f, c) : c && a === c.GetTime() ? l._AddDelta(c.GetValueWithResultMode(), f, c) : c || l._AddDelta(f.GetValueWithResultMode(), f, c) : f && a === f.GetTime() ? l._AddDelta(f.GetValueWithResultMode(), f, c) : c && a === c.GetTime() ? l._AddDelta(c.GetValueWithResultMode(), f, c) : 0 === h - g && l._AddDelta(f.GetValueWithResultMode(), f, c)
        }
    }
    d.PropertyTrackState.PropertyInterpolationAdapter.NumericInterpolationAdapterForTween =
        b
}
"use strict";
{
    const d = self.C3,
        b = self.Ease;
    d.PropertyTrackState.NumericTypeAdapter = class {
        constructor() {}
        static WillChange(a, f, c, e) {
            let g;
            switch (e) {
                case "behavior":
                    g = f.GetPropertyValueByIndex(a);
                    break;
                case "effect":
                    g = f[a];
                    break;
                case "instance-variable":
                    g = f.GetInstanceVariableValue(a);
                    break;
                case "plugin":
                    g = f.GetPropertyValueByIndex(a)
            }
            return g === c ? !1 : !0
        }
        static Interpolate(a, f, c, e) {
            if (!c) return c = e.GetPropertyTrackDataItem(), c = e.GetPropertyTrackData().GetLastPropertyKeyframeDataItem(c), c.GetValueWithResultMode();
            var g =
                e.GetInterpolationMode();
            "default" === g && (g = "continuous");
            "combo" === e.GetPropertyType() && (g = "discrete");
            if ("discrete" === g) return f.GetValueWithResultMode();
            if ("continuous" === g || "step" === g) {
                "step" === g && (g = e.GetTimeline().GetStep(), 0 !== g && (g = 1 / g, a = Math.floor(a * g) / g));
                var h = f.GetTime();
                const l = c.GetTime();
                g = f.GetValueWithResultMode();
                const m = c.GetValueWithResultMode();
                if (g === m) return g;
                a = d.normalize(a, h, l);
                const p = f.GetEase();
                f = f.GetAddOn("cubic-bezier");
                c = c.GetAddOn("cubic-bezier");
                f && f.GetStartEnable() &&
                    c && c.GetEndEnable() ? (h = l - h, h = b.GetRuntimeEase(p)(h * a, 0, 1, h), h = b.GetRuntimeEase("cubicbezier")(h, g, g + f.GetStartAnchor(), m + c.GetEndAnchor(), m)) : h = b.GetRuntimeEase(p)((l - h) * a, g, m - g, l - h);
                return "integer" === e.GetPropertyType() ? Math.floor(h) : h
            }
        }
    }
}
"use strict";
{
    const d = self.C3;
    d.PropertyTrackState.AngleTypeAdapter = class {
        constructor() {}
        static WillChange(b, a, f, c) {
            let e;
            switch (c) {
                case "behavior":
                    e = a.GetPropertyValueByIndex(b);
                    break;
                case "effect":
                    e = a[b];
                    break;
                case "instance-variable":
                    e = a.GetInstanceVariableValue(b);
                    break;
                case "plugin":
                    e = a.GetPropertyValueByIndex(b)
            }
            return e === f ? !1 : !0
        }
        static Interpolate(b, a, f, c) {
            if (!f) return a = c.GetPropertyTrackDataItem(), a = c.GetPropertyTrackData().GetLastPropertyKeyframeDataItem(a), a.GetValueWithResultMode();
            var e = c.GetInterpolationMode();
            "default" === e && (e = "continuous");
            "combo" === c.GetPropertyType() && (e = "discrete");
            if ("discrete" === e) return a.GetValueWithResultMode();
            if ("continuous" === e || "step" === e) {
                "step" === e && (c = c.GetTimeline().GetStep(), 0 !== c && (c = 1 / c, b = Math.floor(b * c) / c));
                const g = a.GetTime(),
                    h = f.GetTime();
                c = a.GetValueWithResultMode();
                f = f.GetValueWithResultMode();
                if (e = a.GetAddOn("angle")) {
                    const l = e.GetRevolutions();
                    if (c === f && 0 === l) return c;
                    b = d.normalize(b, g, h);
                    a = self.Ease.GetRuntimeEase(a.GetEase())(b, 0, 1, 1);
                    switch (e.GetDirection()) {
                        case "closest":
                            return d.angleLerp(c,
                                f, a, l);
                        case "clockwise":
                            return d.angleLerpClockwise(c, f, a, l);
                        case "anti-clockwise":
                            return d.angleLerpAntiClockwise(c, f, a, l)
                    }
                } else {
                    if (c === f) return c;
                    b = d.normalize(b, g, h);
                    a = self.Ease.GetRuntimeEase(a.GetEase());
                    return d.angleLerp(c, f, a(b, 0, 1, 1))
                }
            }
        }
    }
}
"use strict";
self.C3.PropertyTrackState.BooleanTypeAdapter = class {
    constructor() {}
    static WillChange(d, b, a, f) {
        let c;
        switch (f) {
            case "behavior":
                c = b.GetPropertyValueByIndex(d);
                break;
            case "effect":
                c = b[d];
                break;
            case "instance-variable":
                c = b.GetInstanceVariableValue(d);
                break;
            case "plugin":
                c = b.GetPropertyValueByIndex(d)
        }
        return !!c === !!a ? !1 : !0
    }
    static Interpolate(d, b, a, f) {
        return a ? b.GetValueWithResultMode() ? 1 : 0 : (d = f.GetPropertyTrackDataItem(), d = f.GetPropertyTrackData().GetLastPropertyKeyframeDataItem(d), d.GetValueWithResultMode() ?
            1 : 0)
    }
};
"use strict";
{
    const d = self.C3,
        b = [0, 0, 0],
        a = [0, 0, 0],
        f = [0, 0, 0];
    d.PropertyTrackState.ColorTypeAdapter = class {
        constructor() {}
        static WillChange(c, e, g, h) {
            let l;
            switch (h) {
                case "behavior":
                    l = e.GetPropertyValueByIndex(c);
                    break;
                case "effect":
                    l = e[c];
                    break;
                case "instance-variable":
                    l = e.GetInstanceVariableValue(c);
                    break;
                case "plugin":
                    l = e.GetPropertyValueByIndex(c)
            }
            Array.isArray(g) ? (b[0] = g[0], b[1] = g[1], b[2] = g[2]) : (f.parseCommaSeparatedRgb(g), b[0] = Math.floor(255 * f.getR()), b[1] = Math.floor(255 * f.getG()), b[2] = Math.floor(255 * f.getB()));
            Array.isArray(l) ? (a[0] = l[0], a[1] = l[1], a[2] = l[2]) : (f.parseCommaSeparatedRgb(l), a[0] = Math.floor(255 * f.getR()), a[1] = Math.floor(255 * f.getG()), a[2] = Math.floor(255 * f.getB()));
            return b[0] !== a[0] || b[1] !== a[1] || b[2] !== a[2] ? !0 : !1
        }
        static Interpolate(c, e, g, h) {
            if (!g) {
                var l = h.GetPropertyTrackDataItem();
                l = h.GetPropertyTrackData().GetLastPropertyKeyframeDataItem(l);
                h = l.GetValueWithResultMode();
                b[0] = h[0];
                b[1] = h[1];
                b[2] = h[2];
                return b
            }
            l = h.GetInterpolationMode();
            "default" === l && (l = "continuous");
            if ("discrete" === l) return h =
                e.GetValueWithResultMode(), b[0] = h[0], b[1] = h[1], b[2] = h[2], b;
            if ("continuous" === l || "step" === l) {
                "step" === l && (h = h.GetTimeline().GetStep(), 0 !== h && (h = 1 / h, c = Math.floor(c * h) / h));
                h = e.GetTime();
                l = g.GetTime();
                var m = e.GetValueWithResultMode(),
                    p = g.GetValueWithResultMode();
                c = d.normalize(c, h, l);
                var t = e.GetEase();
                e = m[0];
                g = m[1];
                m = m[2];
                const q = p[0],
                    r = p[1];
                p = p[2];
                t = self.Ease.GetRuntimeEase(t);
                h = l - h;
                l = h * c;
                b[0] = e === q ? e : t(l, e, q - e, h);
                b[1] = g === r ? g : t(l, g, r - g, h);
                b[2] = m === p ? m : t(l, m, p - m, h);
                return b
            }
        }
    }
}
"use strict";
self.C3.PropertyTrackState.TextTypeAdapter = class {
    constructor() {}
    static WillChange(d, b, a, f) {
        let c;
        switch (f) {
            case "behavior":
                c = b.GetPropertyValueByIndex(d);
                break;
            case "effect":
                c = b[d];
                break;
            case "instance-variable":
                c = b.GetInstanceVariableValue(d);
                break;
            case "plugin":
                c = b.GetPropertyValueByIndex(d)
        }
        return c === a ? !1 : !0
    }
    static Interpolate(d, b, a, f) {
        return a ? b.GetValueWithResultMode() : (d = f.GetPropertyTrackDataItem(), d = f.GetPropertyTrackData().GetLastPropertyKeyframeDataItem(d), d.GetValueWithResultMode())
    }
};
"use strict";
{
    const d = self.C3;
    d.TimelineDataManager = class {
        constructor() {
            this._timelineDataItems = new Map
        }
        Release() {
            for (const b of this._timelineDataItems.values()) b.Release();
            this._timelineDataItems.clear();
            this._timelineDataItems = null
        }
        Add(b) {
            b = new d.TimelineDataItem(b);
            const a = b.GetName();
            this._timelineDataItems.set(a, b)
        }
        Get(b) {
            return this._timelineDataItems.get(b)
        }
        GetNameId() {
            return 0
        }
        static _CreateDataItems(b, a, f, c) {
            if (a)
                for (const e of a) d.TimelineDataManager._CreateDataItem("create", e, b, f, c)
        }
        static _LoadDataItemsFromJson(b, a,
            f, c) {
            b.length ? a.forEach((e, g) => {
                b[g]._LoadFromJson(e)
            }) : a.forEach(e => {
                d.TimelineDataManager._CreateDataItem("load", e, b, f, c)
            })
        }
        static _CreateDataItem(b, a, f, c, e) {
            let g;
            if ("function" === typeof c) switch (b) {
                case "load":
                    g = new c(null, e);
                    break;
                case "create":
                    g = new c(a, e)
            } else if ("object" === typeof c) switch (c = c.map.get(a[c.prop]), b) {
                case "load":
                    g = new c(null, e);
                    break;
                case "create":
                    g = new c(a, e)
            }
            switch (b) {
                case "load":
                    g._LoadFromJson(a);
                    f.push(g);
                    break;
                case "create":
                    if ("function" === typeof g.GetEnable && !g.GetEnable()) return g.Release();
                    f.push(g)
            }
        }
    }
}
"use strict";
{
    const d = self.C3;
    d.TimelineDataItem = class {
        constructor(b) {
            this._name = "";
            this._totalTime = NaN;
            this._step = 0;
            this._resultMode = this._interpolationMode = "default";
            this._pingPong = this._loop = !1;
            this._repeatCount = 1;
            this._trackData = null;
            b && (this._name = b[0], this._totalTime = b[1], this._step = b[2], this._interpolationMode = b[3], this._resultMode = b[4], this._loop = !!b[6], this._pingPong = !!b[7], this._repeatCount = b[8], this._trackData = new d.TrackData(b[5], this))
        }
        Release() {
            this._trackData.Release();
            this._trackData = null
        }
        GetTrackData() {
            this._trackData ||
                (this._trackData = new d.TrackData(null, this));
            return this._trackData
        }
        GetName() {
            return this._name
        }
        SetName(b) {
            this._name = b
        }
        GetTotalTime() {
            return this._totalTime
        }
        SetTotalTime(b) {
            this._totalTime = b
        }
        GetStep() {
            return this._step
        }
        SetStep(b) {
            this._step = b
        }
        GetInterpolationMode() {
            return this._interpolationMode
        }
        SetInterpolationMode(b) {
            this._interpolationMode = b
        }
        GetResultMode() {
            return this._resultMode
        }
        SetResultMode(b) {
            this._resultMode = b
        }
        GetLoop() {
            return this._loop
        }
        SetLoop(b) {
            this._loop = b
        }
        GetPingPong() {
            return this._pingPong
        }
        SetPingPong(b) {
            this._pingPong =
                b
        }
        GetRepeatCount() {
            return this._repeatCount
        }
        _SaveToJson() {
            return {
                trackDataJson: this._trackData._SaveToJson(),
                name: this._name,
                totalTime: this._totalTime,
                step: this._step,
                interpolationMode: this._interpolationMode,
                resultMode: this._resultMode,
                loop: this._loop,
                pingPong: this._pingPong,
                repeatCount: this._repeatCount
            }
        }
        _LoadFromJson(b) {
            b && (this.GetTrackData()._LoadFromJson(b.trackDataJson), this._name = b.name, this._totalTime = b.totalTime, this._step = b.step, this._interpolationMode = b.interpolationMode, this._resultMode =
                b.resultMode, this._loop = b.loop, this._pingPong = b.pingPong, this._repeatCount = b.repeatCount)
        }
    }
}
"use strict";
{
    const d = self.C3;
    class b {
        constructor(a, f) {
            this._trackData = f;
            this._additionalInstanceData = this._instanceData = null;
            this._objectClassIndex = this._instanceUid = NaN;
            this._resultMode = this._interpolationMode = "default";
            this._enabled = !1;
            this._propertyTrackData = this._keyframeData = null;
            this._id = "";
            this._nestedData = null;
            this._startOffset = 0;
            this._localTotalTime = this._trackData.GetTimelineDataItem().GetTotalTime();
            a && (this._instanceData = a[0], this._instanceUid = a[0][2], this._objectClassIndex = a[0][1], this._interpolationMode =
                a[1], this._resultMode = a[2], this._enabled = !!a[3], a[6] && (this._id = a[6]), a[7] && (this._nestedData = a[7], this._startOffset = a[7][0], this._localTotalTime = a[7][1]), a[8] && (this._additionalInstanceData = a[8]), this._keyframeData = new d.KeyframeData(a[4], this), this._propertyTrackData = new d.PropertyTrackData(a[5], this))
        }
        Release() {
            this._trackData = this._instanceData = null;
            this._keyframeData && (this._keyframeData.Release(), this._keyframeData = null);
            this._propertyTrackData && (this._propertyTrackData.Release(), this._propertyTrackData =
                null);
            this._nestedData = null
        }
        GetTrackData() {
            return this._trackData
        }
        GetKeyframeData() {
            this._keyframeData || (this._keyframeData = new d.KeyframeData(null, this));
            return this._keyframeData
        }
        GetPropertyTrackData() {
            this._propertyTrackData || (this._propertyTrackData = new d.PropertyTrackData(null, this));
            return this._propertyTrackData
        }
        GetInstanceData() {
            return this._instanceData
        }
        GetObjectClassIndex() {
            return this._objectClassIndex
        }
        SetObjectClassIndex(a) {
            this._objectClassIndex = a
        }
        GetInstanceUID() {
            return this._instanceUid
        }
        SetInstanceUID(a) {
            this._instanceUid =
                a
        }
        GetInterpolationMode() {
            return this._interpolationMode
        }
        SetInterpolationMode(a) {
            this._interpolationMode = a
        }
        GetResultMode() {
            return this._resultMode
        }
        SetResultMode(a) {
            this._resultMode = a
        }
        GetEnable() {
            return this._enabled
        }
        SetEnable(a) {
            this._enabled = !!a
        }
        GetId() {
            return this._id
        }
        GetStartOffset() {
            return this._startOffset
        }
        GetLocalTotalTime() {
            return this._localTotalTime
        }
        SetLocalTotalTime(a) {
            this._localTotalTime = a
        }
        GetOriginalWidth() {
            return this._additionalInstanceData[0]
        }
        SetOriginalWidth(a) {
            this._additionalInstanceData ||
                (this._additionalInstanceData = []);
            this._additionalInstanceData[0] = a
        }
        GetOriginalHeight() {
            this._additionalInstanceData || (this._additionalInstanceData = []);
            return this._additionalInstanceData[1]
        }
        SetOriginalHeight(a) {
            this._additionalInstanceData || (this._additionalInstanceData = []);
            this._additionalInstanceData[1] = a
        }
        _SaveToJson() {
            return {
                keyframeDataJson: this._keyframeData._SaveToJson(),
                propertyTrackDataJson: this._propertyTrackData._SaveToJson(),
                instanceData: this._instanceData,
                additionalInstanceData: this._additionalInstanceData,
                instanceUid: this._instanceUid,
                objectClassIndex: this._objectClassIndex,
                interpolationMode: this._interpolationMode,
                resultMode: this._resultMode,
                enabled: this._enabled,
                id: this._id,
                nestedData: this._nestedData
            }
        }
        _LoadFromJson(a) {
            a && (this._instanceData = a.instanceData, this._instanceUid = a.instanceUid, this._objectClassIndex = a.objectClassIndex, this._interpolationMode = a.interpolationMode, this._resultMode = a.resultMode, this._enabled = a.enabled, this._id = a.id, this._localTotalTime = this._trackData.GetTimelineDataItem().GetTotalTime(),
                a.nestedData && (this._nestedData = a.nestedData, this._startOffset = this._nestedData[0], this._localTotalTime = this._nestedData[1]), a.additionalInstanceData && (this._additionalInstanceData = a.additionalInstanceData), this.GetKeyframeData()._LoadFromJson(a.keyframeDataJson), this.GetPropertyTrackData()._LoadFromJson(a.propertyTrackDataJson))
        }
    }
    d.TrackData = class {
        constructor(a, f) {
            this._timelineDataItem = f;
            this._trackDataItems = [];
            this._keyframeTimeMap = new Map;
            d.TimelineDataManager._CreateDataItems(this._trackDataItems,
                a, b, this)
        }
        Release() {
            this._timelineDataItem = null;
            for (const a of this._trackDataItems) a.Release();
            d.clearArray(this._trackDataItems);
            this._trackDataItems = null;
            this._keyframeTimeMap.clear();
            this._keyframeTimeMap = null
        }
        GetTimelineDataItem() {
            return this._timelineDataItem
        }
        AddEmptyTrackDataItem() {
            const a = new b(null, this);
            this._trackDataItems.push(a);
            return a
        }
        GetFirstKeyframeDataItem(a) {
            return a.GetKeyframeData().GetKeyframeDataItemArray()[0]
        }
        GetLastKeyframeDataItem(a) {
            a = a.GetKeyframeData().GetKeyframeDataItemArray();
            return a[a.length - 1]
        }
        GetKeyFrameDataItemAtTime(a, f) {
            const c = this._keyframeTimeMap.get(f);
            if (c && c.has(a)) return c.get(a);
            for (const e of f.GetKeyframeData().keyframeDataItems())
                if (e.GetTime() === a) return c || this._keyframeTimeMap.set(f, new Map), this._keyframeTimeMap.get(f).set(a, e), e
        }
        GetFirstKeyFrameDataItemHigherThan(a, f) {
            for (const c of f.GetKeyframeData().keyframeDataItems())
                if (c.GetTime() > a) return c
        }
        GetFirstKeyFrameDataItemHigherOrEqualThan(a, f) {
            for (const c of f.GetKeyframeData().keyframeDataItems())
                if (c.GetTime() >=
                    a) return c
        }
        GetFirstKeyFrameDataItemLowerOrEqualThan(a, f) {
            for (const c of f.GetKeyframeData().keyframeDataItemsReverse())
                if (c.GetTime() <= a) return c
        }* trackDataItems() {
            for (const a of this._trackDataItems) yield a
        }
        _SaveToJson() {
            return {
                trackDataItemsJson: this._trackDataItems.map(a => a._SaveToJson())
            }
        }
        _LoadFromJson(a) {
            a && d.TimelineDataManager._LoadDataItemsFromJson(this._trackDataItems, a.trackDataItemsJson, b, this)
        }
    }
}
"use strict";
{
    const d = self.C3;
    class b {
        constructor(a, f) {
            this._propertyTrackData = f;
            this._sourceAdapterId = "";
            this._type = this._property = this._sourceAdapterArguments = null;
            this._max = this._min = NaN;
            this._resultMode = this._interpolationMode = "default";
            this._enabled = !1;
            this._propertyKeyframeData = null;
            a && (this._sourceAdapterId = a[0][0], this._sourceAdapterArguments = a[0].slice(1), this._property = a[1], this._type = a[2], this._min = a[3], this._max = a[4], this._interpolationMode = a[5], this._resultMode = a[6], this._enabled = !!a[7], this._propertyKeyframeData =
                new d.PropertyKeyframeData(a[8], this))
        }
        Release() {
            this._propertyKeyframeData.Release();
            this._sourceAdapterArguments = this._propertyTrackData = this._propertyKeyframeData = null
        }
        GetPropertyTrackData() {
            return this._propertyTrackData
        }
        GetPropertyKeyframeData() {
            this._propertyKeyframeData || (this._propertyKeyframeData = new d.PropertyKeyframeData(null, this));
            return this._propertyKeyframeData
        }
        GetSourceAdapterId() {
            return this._sourceAdapterId
        }
        SetSourceAdapterId(a) {
            this._sourceAdapterId = a
        }
        GetSourceAdapterArguments() {
            return this._sourceAdapterArguments
        }
        SetSourceAdapterArguments(a) {
            this._sourceAdapterArguments =
                a
        }
        GetProperty() {
            return this._property
        }
        SetProperty(a) {
            this._property = a
        }
        GetType() {
            return this._type
        }
        SetType(a) {
            this._type = a
        }
        GetMin() {
            return this._min
        }
        SetMin(a) {
            this._min = a
        }
        GetMax() {
            return this._max
        }
        SetMax(a) {
            this._max = a
        }
        GetInterpolationMode() {
            return this._interpolationMode
        }
        SetInterpolationMode(a) {
            this._interpolationMode = a
        }
        GetResultMode() {
            return this._resultMode
        }
        SetResultMode(a) {
            this._resultMode = a
        }
        GetEnable() {
            return this._enabled
        }
        SetEnable(a) {
            this._enabled = !!a
        }
        _SaveToJson() {
            return {
                propertyKeyframeDataJson: this._propertyKeyframeData._SaveToJson(),
                sourceAdapterId: this._sourceAdapterId,
                sourceAdapterArguments: this._sourceAdapterArguments,
                property: this._property,
                type: this._type,
                min: this._min,
                max: this._max,
                interpolationMode: this._interpolationMode,
                resultMode: this._resultMode,
                enabled: this._enabled
            }
        }
        _LoadFromJson(a) {
            a && (this._sourceAdapterId = a.sourceAdapterId, this._sourceAdapterArguments = a.sourceAdapterArguments, this._property = a.property, this._type = a.type, this._min = a.min, this._max = a.max, this._interpolationMode = a.interpolationMode, this._resultMode =
                a.resultMode, this._enabled = a.enabled, this.GetPropertyKeyframeData()._LoadFromJson(a.propertyKeyframeDataJson))
        }
    }
    d.PropertyTrackData = class {
        constructor(a, f) {
            this._trackDataItem = f;
            this._propertyTrackDataItems = [];
            this._propertyKeyframeTimeMap = new Map;
            d.TimelineDataManager._CreateDataItems(this._propertyTrackDataItems, a, b, this)
        }
        Release() {
            this._trackDataItem = null;
            for (const a of this._propertyTrackDataItems) a.Release();
            d.clearArray(this._propertyTrackDataItems);
            this._propertyTrackDataItems = null;
            this._propertyKeyframeTimeMap.clear();
            this._propertyKeyframeTimeMap = null
        }
        GetTrackDataItem() {
            return this._trackDataItem
        }
        AddEmptyPropertyTrackDataItem() {
            const a = new b(null, this);
            this._propertyTrackDataItems.push(a);
            return a
        }
        GetFirstPropertyKeyframeDataItem(a) {
            return a.GetPropertyKeyframeData().GetPropertyKeyframeDataItemArray()[0]
        }
        GetLastPropertyKeyframeDataItem(a) {
            a = a.GetPropertyKeyframeData().GetPropertyKeyframeDataItemArray();
            return a[a.length - 1]
        }
        GetPropertyKeyFrameDataItemAtTime(a, f) {
            const c = this._propertyKeyframeTimeMap.get(f);
            if (c &&
                c.has(a)) return c.get(a);
            const e = f.GetPropertyKeyframeData();
            for (const g of e.propertyKeyframeDataItems())
                if (g.GetTime() === a) return c || this._propertyKeyframeTimeMap.set(f, new Map), this._propertyKeyframeTimeMap.get(f).set(a, g), g
        }
        GetFirstPropertyKeyFrameDataItemHigherThan(a, f) {
            f = f.GetPropertyKeyframeData();
            for (const c of f.propertyKeyframeDataItems())
                if (c.GetTime() > a) return c
        }
        GetFirstPropertyKeyFrameDataItemHigherOrEqualThan(a, f) {
            f = f.GetPropertyKeyframeData();
            for (const c of f.propertyKeyframeDataItems())
                if (c.GetTime() >=
                    a) return c
        }
        GetFirstPropertyKeyFrameDataItemLowerOrEqualThan(a, f) {
            f = f.GetPropertyKeyframeData();
            for (const c of f.propertyKeyframeDataItemsReverse())
                if (c.GetTime() <= a) return c
        }* propertyTrackDataItems() {
            for (const a of this._propertyTrackDataItems) yield a
        }
        _SaveToJson() {
            return {
                propertyTrackDataItemsJson: this._propertyTrackDataItems.map(a => a._SaveToJson())
            }
        }
        _LoadFromJson(a) {
            a && d.TimelineDataManager._LoadDataItemsFromJson(this._propertyTrackDataItems, a.propertyTrackDataItemsJson, b, this)
        }
    }
}
"use strict";
{
    const d = self.C3;
    class b {
        constructor(a, f) {
            this._keyframeData = f;
            this._time = -1;
            this._ease = "noease";
            this._enable = !1;
            this._lowerTags = this._tags = null;
            a && (this._time = a[0], this._ease = a[1], this._enable = !!a[2], this._tags = (a = a[3]) ? a.split(" ") : [], this._lowerTags = new Set(this._tags.map(c => c.toLowerCase())))
        }
        Release() {
            this._keyframeData = null;
            d.clearArray(this._tags);
            this._tags = null;
            this._lowerTags.clear();
            this._lowerTags = null
        }
        GetKeyframeData() {
            return this._keyframeData
        }
        GetTime() {
            return this._time
        }
        SetTime(a) {
            this._time =
                a
        }
        GetEase() {
            return this._ease
        }
        SetEase(a) {
            this._ease = a
        }
        GetEnable() {
            return this._enable
        }
        SetEnable(a) {
            this._enable = !!a
        }
        GetTags() {
            return this._tags
        }
        SetTags(a) {
            this._tags = a ? a.split(" ") : [];
            this._lowerTags = new Set(this._tags.map(f => f.toLowerCase()))
        }
        GetLowerTags() {
            return this._lowerTags
        }
        HasTag(a) {
            return this._lowerTags.has(a.toLowerCase())
        }
        _SaveToJson() {
            return {
                time: this._time,
                ease: this._ease,
                enable: this._enable,
                tags: this._tags
            }
        }
        _LoadFromJson(a) {
            a && (this._time = a.time, this._ease = a.ease, this._enable = a.enable,
                this._tags = a.tags, this._lowerTags = new Set(this._tags.map(f => f.toLowerCase())))
        }
    }
    d.KeyframeData = class {
        constructor(a, f) {
            this._trackDataItem = f;
            this._keyframeDataItems = [];
            d.TimelineDataManager._CreateDataItems(this._keyframeDataItems, a, b, this)
        }
        Release() {
            this._trackDataItem = null;
            for (const a of this._keyframeDataItems) a.Release();
            d.clearArray(this._keyframeDataItems);
            this._keyframeDataItems = null
        }
        GetTrackDataItem() {
            return this._trackDataItem
        }
        GetKeyframeDataItemCount() {
            return this._keyframeDataItems.length
        }
        GetKeyframeDataItemArray() {
            return this._keyframeDataItems
        }
        AddEmptyKeyframeDataItem() {
            const a =
                new b(null, this);
            this._keyframeDataItems.push(a);
            return a
        }
        DeleteKeyframeDataItems(a) {
            for (const f of this._keyframeDataItems) {
                if (!a(f)) continue;
                const c = this._keyframeDataItems.indexOf(f); - 1 !== c && (f.Release(), this._keyframeDataItems.splice(c, 1))
            }
            this.SortKeyframeDataItems()
        }
        SortKeyframeDataItems() {
            this._keyframeDataItems.sort((a, f) => a.GetTime() - f.GetTime())
        }
        GetKeyframeDataItemIndex(a) {
            return this._keyframeDataItems.indexOf(a)
        }
        GetKeyframeDataItemFromIndex(a) {
            return this._keyframeDataItems[a]
        }* keyframeDataItems() {
            for (const a of this._keyframeDataItems) yield a
        }* keyframeDataItemsReverse() {
            for (let a =
                    this._keyframeDataItems.length - 1; 0 <= a; a--) yield this._keyframeDataItems[a]
        }
        _SaveToJson() {
            return {
                keyframeDataItemsJson: this._keyframeDataItems.map(a => a._SaveToJson())
            }
        }
        _LoadFromJson(a) {
            a && d.TimelineDataManager._LoadDataItemsFromJson(this._keyframeDataItems, a.keyframeDataItemsJson, b, this)
        }
    }
}
"use strict";
{
    const d = self.C3;
    class b {
        constructor(a, f) {
            this._propertyKeyframeData = f;
            this._aValue = this._value = null;
            this._type = "";
            this._time = NaN;
            this._ease = "noease";
            this._enable = !1;
            this._addonData = null;
            a && (this._value = a[0][0], this._aValue = a[0][1], this._type = a[0][2], this._time = a[1], this._ease = a[2], this._enable = !!a[3], this._addonData = null, a[4] && (this._addonData = new d.AddonData(a[4], this)))
        }
        Release() {
            this._propertyKeyframeData = null;
            this._addonData && (this._addonData.Release(), this._addonData = null)
        }
        GetAddonData() {
            return this._addonData
        }
        GetValue() {
            return this._value
        }
        SetValue(a) {
            "color" ===
            this._type && d.IsFiniteNumber(a) ? (this._value[0] = d.GetRValue(a), this._value[1] = d.GetGValue(a), this._value[2] = d.GetBValue(a)) : this._value = a
        }
        GetAbsoluteValue() {
            return this._aValue
        }
        SetAbsoluteValue(a) {
            "color" === this._type && d.IsFiniteNumber(a) ? (this._aValue[0] = d.GetRValue(a), this._aValue[1] = d.GetGValue(a), this._aValue[2] = d.GetBValue(a)) : this._aValue = a
        }
        GetValueWithResultMode() {
            const a = this._propertyKeyframeData.GetPropertyTrackDataItem().GetResultMode();
            if ("relative" === a) return this.GetValue();
            if ("absolute" ===
                a) return this.GetAbsoluteValue()
        }
        GetType() {
            return this._type
        }
        SetType(a) {
            this._type = a
        }
        GetTime() {
            return this._time
        }
        SetTime(a) {
            this._time = a
        }
        GetEase() {
            return this._ease
        }
        SetEase(a) {
            this._ease = a
        }
        GetEnable() {
            return this._enable
        }
        SetEnable(a) {
            this._enable = !!a
        }
        GetAddOn(a) {
            if (this.GetAddonData())
                for (const f of this.GetAddonData().addonDataItems())
                    if (f.GetId() === a) return f
        }
        _SaveToJson() {
            const a = this._addonData;
            return {
                addonDataJson: a ? a._SaveToJson() : a,
                value: this._value,
                aValue: this._aValue,
                type: this._type,
                time: this._time,
                ease: this._ease,
                enable: this._enable
            }
        }
        _LoadFromJson(a) {
            a && (a.addonDataJson && this._addonData._SetFromJson(a.addonDataJson), this._value = a.value, this._aValue = a.aValue, this._type = a.type, this._time = a.time, this._ease = a.ease, this._enable = a.enable)
        }
    }
    d.PropertyKeyframeData = class {
        constructor(a, f) {
            this._propertyTrackDataItem = f;
            this._propertyKeyframeDataItems = [];
            d.TimelineDataManager._CreateDataItems(this._propertyKeyframeDataItems, a, b, this)
        }
        Release() {
            this._propertyTrackDataItem = null;
            for (const a of this._propertyKeyframeDataItems) a.Release();
            d.clearArray(this._propertyKeyframeDataItems);
            this._propertyKeyframeDataItems = null
        }
        AddEmptyPropertyKeyframeDataItem() {
            const a = new b(null, this);
            this._propertyKeyframeDataItems.push(a);
            return a
        }
        DeletePropertyKeyframeDataItems(a) {
            for (const f of this._propertyKeyframeDataItems) {
                if (!a(f)) continue;
                const c = this._propertyKeyframeDataItems.indexOf(f); - 1 !== c && (f.Release(), this._propertyKeyframeDataItems.splice(c, 1))
            }
            this.SortPropertyKeyFrameDataItems()
        }
        SortPropertyKeyFrameDataItems() {
            this._propertyKeyframeDataItems.sort((a,
                f) => a.GetTime() - f.GetTime())
        }
        GetPropertyTrackDataItem() {
            return this._propertyTrackDataItem
        }
        GetPropertyKeyframeDataItemCount() {
            return this._propertyKeyframeDataItems.length
        }
        GetPropertyKeyframeDataItemArray() {
            return this._propertyKeyframeDataItems
        }* propertyKeyframeDataItems() {
            for (const a of this._propertyKeyframeDataItems) yield a
        }* propertyKeyframeDataItemsReverse() {
            for (let a = this._propertyKeyframeDataItems.length - 1; 0 <= a; a--) yield this._propertyKeyframeDataItems[a]
        }
        _SaveToJson() {
            return {
                propertyKeyframeDataItemsJson: this._propertyKeyframeDataItems.map(a =>
                    a._SaveToJson())
            }
        }
        _LoadFromJson(a) {
            a && d.TimelineDataManager._LoadDataItemsFromJson(this._propertyKeyframeDataItems, a.propertyKeyframeDataItemsJson, b, this)
        }
    }
}
"use strict";
{
    const d = self.C3;
    class b {
        constructor(c, e) {
            this._addonData = e;
            this._id = c[0];
            this._data = c[1]
        }
        Release() {
            this._data = this._addonData = null
        }
        GetAddonData() {
            return this._addonData
        }
        GetId() {
            return this._id
        }
        _SaveToJson() {
            return {
                id: this._id,
                data: this._data
            }
        }
        _LoadFromJson(c) {
            c && (this._id = c.id, this._data = c.data)
        }
    }
    class a extends b {
        constructor(c, e) {
            super(c, e);
            this._startAnchor = this._data[0];
            this._startEnable = !!this._data[1];
            this._endAnchor = this._data[2];
            this._endEnable = !!this._data[3]
        }
        Release() {
            super.Release()
        }
        GetStartAnchor() {
            return this._startAnchor
        }
        GetStartEnable() {
            return this._startEnable
        }
        GetEndAnchor() {
            return this._endAnchor
        }
        GetEndEnable() {
            return this._endEnable
        }
        _SaveToJson() {
            return Object.assign(super._SaveToJson(), {
                startAnchor: this._startAnchor,
                startEnable: !!this._startEnable,
                endAnchor: this._endAnchor,
                endEnable: !!this._endEnable
            })
        }
        _LoadFromJson(c) {
            c && (super._LoadFromJson(c), this._startAnchor = c.startAnchor, this._startEnable = !!c.startEnable, this._endAnchor = c.endAnchor, this._endEnable = !!c.endEnable)
        }
    }
    class f extends b {
        constructor(c, e) {
            super(c, e);
            this._direction = this._data[0];
            this._revolutions = this._data[1]
        }
        Release() {
            super.Release()
        }
        GetDirection() {
            return this._direction
        }
        GetRevolutions() {
            return this._revolutions
        }
        _SaveToJson() {
            return Object.assign(super._SaveToJson(), {
                direction: this._direction,
                revolutions: this._revolutions
            })
        }
        _LoadFromJson(c) {
            c && (super._LoadFromJson(c), this._direction = c.direction, this._revolutions = c.revolutions)
        }
    }
    d.AddonData = class {
        constructor(c, e) {
            this._propertyKeyframeDataItem = e;
            this._addonDataItems = [];
            d.TimelineDataManager._CreateDataItems(this._addonDataItems, c, {
                prop: 0,
                map: new Map([
                    ["cubic-bezier", a],
                    ["angle", f]
                ])
            }, this)
        }
        Release() {
            this._propertyKeyframeDataItem = null;
            for (const c of this._addonDataItems) c.Release();
            d.clearArray(this._addonDataItems);
            this._addonDataItems = null
        }
        GetPropertyKeyframeDataItem() {
            return this._propertyKeyframeDataItem
        }* addonDataItems() {
            for (const c of this._addonDataItems) yield c
        }
        _SaveToJson() {
            return {
                addonDataItemsJson: this._addonDataItems.map(c => c._SaveToJson())
            }
        }
        _LoadFromJson(c) {
            c && d.TimelineDataManager._LoadDataItemsFromJson(this._addonDataItems, c.addonDataItemsJson, {
                prop: "id",
                map: new Map([
                    ["cubic-bezier", a],
                    ["angle", f]
                ])
            }, this)
        }
    }
}
"use strict";
{
    const d = self.C3;
    let b = 0;
    d.Tween = class extends d.TimelineState {
        constructor(a, f) {
            super(`tween-${b++}`, a, f);
            this._id = "";
            this._destroyInstanceOnComplete = !1;
            this._initialValueMode = "start-value";
            this._on_started_callbacks = this._on_completed_callbacks = null
        }
        GetInstance() {
            var a = this.GetTracks();
            if (a && a.length && (a = a[0])) {
                var f = a.GetInstance();
                return a.IsInstanceValid() ? f : null
            }
        }
        AddStartedCallback(a) {
            this._on_started_callbacks || (this._on_started_callbacks = []);
            this._on_started_callbacks.push(a)
        }
        AddCompletedCallback(a) {
            this._on_completed_callbacks ||
                (this._on_completed_callbacks = []);
            this._on_completed_callbacks.push(a)
        }
        RemoveStartedCallback(a) {
            this._on_started_callbacks && (a = this._on_started_callbacks.indexOf(a), -1 !== a && this._on_started_callbacks.splice(a, 1))
        }
        RemoveCompletedCallback(a) {
            this._on_completed_callbacks && (a = this._on_completed_callbacks.indexOf(a), -1 !== a && this._on_completed_callbacks.splice(a, 1))
        }
        SetStartValue(a, f) {
            for (const e of this._tracks)
                for (const g of e._propertyTracks) {
                    if (g.GetPropertyName() !== f) continue;
                    var c = g.GetPropertyTrackData();
                    const h = g.GetPropertyTrackDataItem();
                    c = c.GetFirstPropertyKeyframeDataItem(h);
                    c.SetValue(a);
                    c.SetAbsoluteValue(a)
                }
        }
        _GetPropertyTrackState(a) {
            for (const f of this._tracks)
                for (const c of f._propertyTracks)
                    if (c.GetPropertyName() === a) return c
        }
        BeforeSetEndValues(a) {
            for (const e of a) a = this._GetPropertyTrackState(e), this.SetStartValue(a.GetCurrentState(), e);
            if (this.IsForwardPlayBack()) {
                var f = this.GetTotalTime() - this.GetTime();
                this.SetTotalTime(f);
                for (var c of this._tracks) c.SetLocalTotalTime(f);
                this._SetTime(0)
            } else {
                c =
                    this.GetTime();
                this.SetTotalTime(c);
                for (f of this._tracks) f.SetLocalTotalTime(c);
                this._SetTime(c)
            }
            this.SetInitialStateFromSetTime()
        }
        SetEndValue(a, f) {
            var c = this._GetPropertyTrackState(f);
            f = c.GetPropertyTrackData();
            c = c.GetPropertyTrackDataItem();
            f = f.GetLastPropertyKeyframeDataItem(c);
            f.SetTime(this.GetTotalTime());
            f.SetValue(a);
            f.SetAbsoluteValue(a)
        }
        SetId(a) {
            this._id = a
        }
        GetId() {
            return this._id
        }
        SetInitialValueMode(a) {
            this._initialValueMode = a
        }
        GetInitialValueMode() {
            return this._initialValueMode
        }
        SetDestroyInstanceOnComplete(a) {
            this._destroyInstanceOnComplete =
                a
        }
        GetDestroyInstanceOnComplete() {
            return this._destroyInstanceOnComplete
        }
        OnStarted() {
            if (this._on_started_callbacks)
                for (const a of this._on_started_callbacks) a(this);
            if (!this.IsComplete())
                for (const a of this._tracks) a.CompareSaveStateWithCurrent()
        }
        OnCompleted() {
            this._completedTick = this._runtime.GetTickCount()
        }
        FinishTriggers() {
            if (!this._finishedTriggers && (this._finishedTriggers = !0, this._on_completed_callbacks))
                for (const a of this._on_completed_callbacks) a(this)
        }
        SetTime(a) {
            this._DeleteIntermediateKeyframes();
            super.SetTime(a)
        }
        SetInitialState(a) {
            if (!this.InitialStateSet() && "current-state" === this.GetInitialValueMode())
                for (const f of this._tracks) f.CompareInitialStateWithCurrent();
            super.SetInitialState(a)
        }
        Stop(a = !1) {
            super.Stop(a);
            if (!this.IsComplete())
                for (const f of this._tracks) f.SaveState()
        }
        Reset(a = !0, f = !1) {
            this._DeleteIntermediateKeyframes();
            super.Reset(a, f)
        }
        _DeleteIntermediateKeyframes() {
            for (const a of this._tracks) {
                const f = c => {
                    c = c.GetTime();
                    const e = this.GetTotalTime();
                    return 0 !== c && c !== e
                };
                a.DeleteKeyframes(f);
                a.DeletePropertyKeyframes(f)
            }
        }
        _OnBeforeChangeLayout() {
            if (this.IsReleased()) return !0;
            const a = this.GetInstance();
            if (a && a.GetObjectClass().IsGlobal()) return !1;
            this._timelineManager.CompleteTimeline(this);
            this.ResetBeforeChangeLayout();
            return !0
        }
        MaybeTriggerKeyframeReachedConditions() {}
        Tick(a, f) {
            a = this.GetInstance();
            a = this.GetRuntime().GetDt(a);
            super.Tick(a, 1)
        }
        _SaveToJson() {
            const a = super._SaveToJson(),
                f = this.GetTimelineDataItem();
            return Object.assign(a, {
                tweenDataItemJson: f._SaveToJson(),
                id: this._id,
                destroyInstanceOnComplete: this._destroyInstanceOnComplete,
                initialValueMode: this._initialValueMode
            })
        }
        _LoadFromJson(a) {
            a && (this.GetTimelineDataItem()._LoadFromJson(a.tweenDataItemJson), super._LoadFromJson(a), this._id = a.id, this._destroyInstanceOnComplete = a.destroyInstanceOnComplete, this._initialValueMode = a.initialValueMode)
        }
        static IsPlaying(a) {
            return a.IsPlaying()
        }
        static IsPaused(a) {
            return a.IsPaused()
        }
        static Build(a) {
            var f = a.runtime.GetTimelineManager(),
                c = new d.TimelineDataItem;
            if (a.json) {
                c._LoadFromJson(a.json.tweenDataItemJson);
                var e = new d.Tween(c, f);
                e._LoadFromJson(a.json);
                return e
            }
            f = new d.Tween(c, f);
            d.IsArray(a.propertyTracksConfig) || (a.propertyTracksConfig = [a.propertyTracksConfig]);
            f.SetId(a.id);
            f.SetTags(a.tags);
            f.SetInitialValueMode(a.initialValueMode);
            f.SetDestroyInstanceOnComplete(a.releaseOnComplete);
            f.SetLoop(a.loop);
            f.SetPingPong(a.pingPong);
            f.SetTotalTime(a.time);
            f.SetStep(0);
            f.SetInterpolationMode("default");
            f.SetResultMode(a.propertyTracksConfig[0].resultMode);
            c = f.AddTrack();
            c.SetInstanceUID(a.instance.GetUID());
            c.SetInterpolationMode("default");
            c.SetResultMode(a.propertyTracksConfig[0].resultMode);
            c.SetEnable(!0);
            c.SetObjectClassIndex(a.instance.GetObjectClass().GetIndex());
            c.SetOriginalWidth(a.instance.GetWorldInfo().GetWidth());
            c.SetOriginalHeight(a.instance.GetWorldInfo().GetHeight());
            var g = c.AddKeyframe();
            g.SetTime(0);
            g.SetEase("noease");
            g.SetEnable(!0);
            g.SetTags("");
            g = c.AddKeyframe();
            g.SetTime(a.time);
            g.SetEase("noease");
            g.SetEnable(!0);
            g.SetTags("");
            for (e of a.propertyTracksConfig) {
                g = c.AddPropertyTrack();
                g.SetSourceAdapterId(e.sourceId);
                g.SetSourceAdapterArgs(e.sourceArgs);
                g.SetPropertyName(e.property);
                g.SetPropertyType(e.type);
                g.SetMin(NaN);
                g.SetMax(NaN);
                g.SetInterpolationMode("default");
                g.SetResultMode(e.resultMode);
                g.SetEnable(!0);
                const h = g.AddPropertyKeyframe();
                h.SetType(e.valueType);
                h.SetTime(0);
                h.SetEase(e.ease);
                h.SetEnable(!0);
                h.SetValue(e.startValue);
                h.SetAbsoluteValue(e.startValue);
                g = g.AddPropertyKeyframe();
                g.SetType(e.valueType);
                g.SetTime(a.time);
                g.SetEase(e.ease);
                g.SetEnable(!0);
                g.SetValue(e.endValue);
                g.SetAbsoluteValue(e.endValue)
            }
            return f
        }
    }
}
"use strict";
{
    const d = self.C3,
        b = self.Ease;
    d.Transition = class extends d.DefendedBase {
        constructor(a) {
            super();
            this._name = a[0];
            this._transitionKeyframes = [];
            for (const f of a[1]) a = d.TransitionKeyframe.Create(this, f), this._transitionKeyframes.push(a);
            this._precalculatedSamples = new Map;
            this._transitionKeyframeCache = new Map;
            this._PreCalcSamples();
            b.AddCustomEase(this._name, (f, c, e, g) => this.Interpolate(f, c, e, g))
        }
        static Create(a) {
            return d.New(d.Transition, a)
        }
        Release() {
            for (const a of this._transitionKeyframes) a.Release();
            d.clearArray(this._transitionKeyframes);
            this._transitionKeyframes = null;
            this._precalculatedSamples.clear();
            this._precalculatedSamples = null;
            this._transitionKeyframeCache.clear();
            this._transitionKeyframeCache = null
        }
        GetTransitionKeyFrameAt(a) {
            const f = this._transitionKeyframeCache.get(a);
            if (f) return f;
            for (const c of this._transitionKeyframes)
                if (c.GetValueX() === a) return this._transitionKeyframeCache.set(a, c), c
        }
        GetFirstTransitionKeyFrameHigherThan(a) {
            for (const f of this._transitionKeyframes)
                if (f.GetValueX() >
                    a) return f
        }
        GetFirstTransitionKeyFrameHigherOrEqualThan(a) {
            for (const f of this._transitionKeyframes)
                if (f.GetValueX() >= a) return f
        }
        GetFirstTransitionKeyFrameLowerOrEqualThan(a) {
            for (let f = this._transitionKeyframes.length - 1; 0 <= f; f--) {
                const c = this._transitionKeyframes[f];
                if (c.GetValueX() <= a) return c
            }
        }
        Interpolate(a, f, c, e) {
            var g = a / e;
            (a = this.GetTransitionKeyFrameAt(g)) ? e = this.GetFirstTransitionKeyFrameHigherThan(g): (a = this.GetFirstTransitionKeyFrameLowerOrEqualThan(g), e = this.GetFirstTransitionKeyFrameHigherOrEqualThan(g));
            var h = e.GetValueX() - a.GetValueX();
            g = d.mapToRange(g, a.GetValueX(), e.GetValueX(), 0, h);
            h = a.GetValueX();
            const l = a.GetValueY(),
                m = a.GetValueX() + a.GetStartAnchorX(),
                p = a.GetValueY() + a.GetStartAnchorY(),
                t = e.GetValueX() + e.GetEndAnchorX(),
                q = e.GetValueY() + e.GetEndAnchorY(),
                r = e.GetValueX();
            e = e.GetValueY();
            e = b.GetRuntimeEase("spline")(g, h, l, m, p, t, q, r, e, this._precalculatedSamples.get(a));
            e += a.GetValueY();
            return (1 - e) * f + e * (f + c)
        }
        _PreCalcSamples() {
            this._precalculatedSamples.clear();
            for (let c = 0; c < this._transitionKeyframes.length -
                1; c++) {
                var a = this._transitionKeyframes[c];
                if (!a.GetStartEnable()) continue;
                var f = this._transitionKeyframes[c + 1];
                const e = a.GetValueX(),
                    g = a.GetValueX() + a.GetStartAnchorX(),
                    h = f.GetValueX() + f.GetEndAnchorX();
                f = f.GetValueX();
                this._precalculatedSamples.set(a, b.GetBezierSamples(e, g, h, f))
            }
        }
    }
}
"use strict";
{
    const d = self.C3;
    d.TransitionKeyframe = class extends d.DefendedBase {
        constructor(b, a) {
            super();
            this._transition = b;
            this._valueX = a[0];
            this._valueY = a[1];
            this._startAnchorX = a[2];
            this._startAnchorY = a[3];
            this._endAnchorX = a[4];
            this._endAnchorY = a[5];
            this._startEnable = a[6];
            this._endEnable = a[7]
        }
        Release() {
            this._transition = null
        }
        static Create(b, a) {
            return d.New(d.TransitionKeyframe, b, a)
        }
        GetValueX() {
            return this._valueX
        }
        GetValueY() {
            return this._valueY
        }
        GetStartAnchorX() {
            return this._startAnchorX
        }
        GetStartAnchorY() {
            return this._startAnchorY
        }
        GetEndAnchorX() {
            return this._endAnchorX
        }
        GetEndAnchorY() {
            return this._endAnchorY
        }
        GetStartEnable() {
            return this._startEnable
        }
        GetEndEnable() {
            return this._endEnable
        }
    }
}
"use strict";
{
    const d = self.C3;
    d.TransitionManager = class extends d.DefendedBase {
        constructor(b) {
            super();
            this._runtime = b;
            this._transitions = []
        }
        Release() {
            for (const b of this._transitions) b.Release();
            d.clearArray(this._transitions);
            this._transitions = null
        }
        Create(b) {
            this._transitions.push(d.Transition.Create(b))
        }
    }
}
"use strict";
{
    const d = self.C3;
    d.SolStack = class extends d.DefendedBase {
        constructor(b) {
            super();
            this._objectClass = b;
            this._stack = [];
            this._stack.push(d.New(d.Sol, this));
            this._index = 0;
            this._current = this._stack[0]
        }
        Release() {
            for (const b of this._stack) b.Release();
            d.clearArray(this._stack);
            this._objectClass = this._current = null
        }
        GetObjectClass() {
            return this._objectClass
        }
        GetCurrentSol() {
            return this._current
        }
        Clear() {
            this.GetCurrentSol().Clear()
        }
        PushClean() {
            var b = this._stack,
                a = ++this._index;
            a === b.length ? (a = d.New(d.Sol, this),
                b.push(a), this._current = a) : (b = b[a], b.Reset(), this._current = b)
        }
        PushCopy() {
            const b = this._stack,
                a = ++this._index;
            a === b.length && b.push(d.New(d.Sol, this));
            const f = b[a];
            f.Copy(b[a - 1]);
            this._current = f
        }
        Pop() {
            this._current = this._stack[--this._index]
        }
        RemoveInstances(b) {
            const a = this._stack;
            for (let f = 0, c = a.length; f < c; ++f) a[f].RemoveInstances(b)
        }
    }
}
"use strict";
{
    const d = self.C3;
    d.Sol = class extends d.DefendedBase {
        constructor(b) {
            super();
            this._stack = b;
            this._objectClass = this._stack.GetObjectClass();
            this._eventStack = this._objectClass.GetRuntime().GetEventStack();
            this._selectAll = !0;
            this._instances = [];
            this._elseInstances = []
        }
        Release() {
            this.ClearArrays();
            this._eventStack = this._objectClass = this._stack = null
        }
        ClearArrays() {
            d.clearArray(this._instances);
            d.clearArray(this._elseInstances)
        }
        GetObjectClass() {
            return this._objectClass
        }
        IsSelectAll() {
            return this._selectAll
        }
        HasAnyInstances() {
            return this._selectAll ?
                !!this._objectClass.GetInstanceCount() : !!this._instances.length
        }
        GetInstances() {
            return this._selectAll ? this._objectClass.GetInstances() : this._instances
        }
        HasAnyElseInstances() {
            return !!this._elseInstances.length
        }
        GetElseInstances() {
            return this._elseInstances
        }
        GetExpressionInstances() {
            const b = this.GetInstances();
            return b.length ? b : this._elseInstances
        }
        Reset() {
            this._selectAll = !0;
            d.clearArray(this._elseInstances)
        }
        Clear() {
            this._selectAll = !0
        }
        Copy(b) {
            b.IsSelectAll() ? this.Reset() : (this._selectAll = !1, d.shallowAssignArray(this._instances,
                b._instances), d.clearArray(this._elseInstances))
        }
        _PushInstance(b) {
            this._instances.push(b)
        }
        _PushElseInstance(b) {
            this._elseInstances.push(b)
        }
        _SetSelectAll(b) {
            this._selectAll = !!b
        }
        _GetOwnInstances() {
            return this._instances
        }
        _GetOwnElseInstances() {
            return this._elseInstances
        }
        SetSinglePicked(b) {
            this._selectAll = !1;
            d.clearArray(this._instances);
            this._instances.push(b)
        }
        SetArrayPicked(b) {
            this._selectAll = !1;
            d.shallowAssignArray(this._instances, b)
        }
        SetSetPicked(b) {
            this._selectAll = !1;
            d.clearArray(this._instances);
            for (const a of b) this._instances.push(a)
        }
        AddElseInstances(b, a) {
            for (const f of a) b.has(f) || this._elseInstances.push(f)
        }
        TransferElseInstancesToOwn(b) {
            for (const a of b) this._instances.push(a);
            d.arrayRemoveAllInSet(this._elseInstances, b)
        }
        PickOne(b) {
            b && (this._eventStack.GetCurrentStackFrame().GetCurrentEvent().IsOrBlock() ? (this.IsSelectAll() && (d.clearArray(this._instances), d.shallowAssignArray(this._elseInstances, b.GetObjectClass().GetInstances()), this._selectAll = !1), b = this._elseInstances.indexOf(b), -1 !==
                b && (this._instances.push(this._elseInstances[b]), this._elseInstances.splice(b, 1))) : this.SetSinglePicked(b))
        }
        RemoveInstances(b) {
            d.arrayRemoveAllInSet(this._instances, b);
            d.arrayRemoveAllInSet(this._elseInstances, b)
        }
    }
}
"use strict";
{
    const d = self.C3;
    d.EventStack = class extends d.DefendedBase {
        constructor(b) {
            super();
            this._eventSheetManager = b;
            this._runtime = this._eventSheetManager.GetRuntime();
            this._stack = [];
            this._stack.push(d.New(d.EventStackFrame, this, null));
            this._index = 0;
            this._expFuncStack = []
        }
        Release() {
            for (const b of this._stack) b.Release();
            d.clearArray(this._stack);
            d.clearArray(this._expFuncStack);
            this._runtime = this._eventSheetManager = null
        }
        GetEventSheetManager() {
            return this._eventSheetManager
        }
        GetRuntime() {
            return this._runtime
        }
        GetCurrentStackFrame() {
            return this._stack[this._index]
        }
        Push(b) {
            var a =
                this._stack;
            const f = ++this._index;
            if (f === a.length) return b = d.New(d.EventStackFrame, this, b), a.push(b), b;
            a = a[f];
            a.Reset(b);
            return a
        }
        Pop() {
            --this._index
        }
        PushExpFunc(b) {
            this._expFuncStack.push(b)
        }
        PopExpFunc() {
            this._expFuncStack.pop()
        }
        GetCurrentExpFuncStackFrame() {
            const b = this._expFuncStack;
            return 0 === b.length ? null : b[b.length - 1]
        }
    }
}
"use strict";
{
    const d = self.C3;
    d.EventStackFrame = class extends d.DefendedBase {
        constructor(b, a) {
            super();
            this._stack = b;
            this._runtime = this._stack.GetRuntime();
            this._currentEvent = a;
            this._actIndex = this._cndIndex = 0;
            this._elseBranchRan = this._lastEventTrue = !1;
            this._expressionObjectClass = null;
            this._functionReturnValue = this._functionReturnType = 0
        }
        Release() {
            this.Reset(null);
            this._runtime = this._stack = null
        }
        Reset(b) {
            this._currentEvent = b;
            this._actIndex = this._cndIndex = 0;
            this._elseBranchRan = this._lastEventTrue = !1
        }
        _Restore(b, a) {
            this._currentEvent =
                b;
            this._cndIndex = 0;
            this._actIndex = a
        }
        ResetQuick() {
            this._actIndex = this._cndIndex = 0
        }
        GetCurrentEvent() {
            return this._currentEvent
        }
        SetCurrentEvent(b) {
            this._currentEvent = b
        }
        GetConditionIndex() {
            return this._cndIndex
        }
        SetConditionIndex(b) {
            this._cndIndex = b
        }
        GetActionIndex() {
            return this._actIndex
        }
        SetActionIndex(b) {
            this._actIndex = b
        }
        SetLastEventTrue(b) {
            this._lastEventTrue = !!b
        }
        GetLastEventTrue() {
            return this._lastEventTrue
        }
        SetElseBranchRan(b) {
            this._elseBranchRan = !!b
        }
        GetElseBranchRan() {
            return this._elseBranchRan
        }
        SetExpressionObjectClass(b) {
            this._expressionObjectClass =
                b
        }
        GetExpressionObjectClass() {
            return this._expressionObjectClass
        }
        InitCallFunctionExpression(b, a) {
            this._functionReturnType = b;
            this._functionReturnValue = a
        }
        GetFunctionReturnType() {
            return this._functionReturnType
        }
        SetFunctionReturnValue(b) {
            this._functionReturnValue = b
        }
        GetFunctionReturnValue() {
            return this._functionReturnValue
        }
        IsSolModifierAfterCnds() {
            const b = this._currentEvent;
            return b.IsSolWriterAfterCnds() ? !0 : this._cndIndex < b.GetConditionCount() - 1 ? !!b.GetSolModifiers().length : !1
        }
    }
}
"use strict";
{
    const d = self.C3;
    d.LocalVarStack = class extends d.DefendedBase {
        constructor(b) {
            super();
            this._eventSheetManager = b;
            this._runtime = this._eventSheetManager.GetRuntime();
            this._stack = [];
            this._index = -1;
            this._current = null;
            this._initialValues = []
        }
        Release() {
            d.clearArray(this._stack);
            this._runtime = this._eventSheetManager = null
        }
        _SetInitialValues(b) {
            this._initialValues = b;
            b = this._initialValues.slice(0);
            this._stack.push(b);
            this._index = 0;
            this._current = b
        }
        GetEventSheetManager() {
            return this._eventSheetManager
        }
        GetRuntime() {
            return this._runtime
        }
        GetCurrent() {
            return this._current
        }
        Push() {
            const b =
                ++this._index,
                a = this._stack;
            b === a.length ? a.push(this._initialValues.slice(0)) : d.shallowAssignArray(a[b], this._initialValues);
            this._current = a[b]
        }
        Pop() {
            this._current = this._stack[--this._index]
        }
    }
}
"use strict";
{
    const d = self.C3;
    d.LoopStack = class extends d.DefendedBase {
        constructor(b) {
            super();
            this._eventSheetManager = b;
            this._runtime = this._eventSheetManager.GetRuntime();
            this._stack = [];
            this._index = -1
        }
        Release() {
            d.clearArray(this._stack);
            this._runtime = this._eventSheetManager = null
        }
        GetEventSheetManager() {
            return this._eventSheetManager
        }
        GetRuntime() {
            return this._runtime
        }
        IsInLoop() {
            return 0 <= this._index
        }
        GetCurrent() {
            return this._stack[this._index]
        }
        Push() {
            ++this._index;
            if (this._index === this._stack.length) {
                var b = d.New(d.Loop,
                    this);
                this._stack.push(b);
                return b
            }
            b = this._stack[this._index];
            b.Reset();
            return b
        }
        Pop() {
            --this._index
        }
        FindByName(b) {
            const a = this._stack;
            for (let f = this._index; 0 <= f; --f) {
                const c = a[f];
                if (c.GetName() === b) return c
            }
            return null
        }
        _GetStack() {
            return this._stack.slice(0, this._index + 1)
        }
    }
}
"use strict";
{
    const d = self.C3;
    d.Loop = class extends d.DefendedBase {
        constructor(b) {
            super();
            this._loopStack = b;
            this._name = "";
            this._index = 0;
            this._isStopped = !1;
            this._end = NaN
        }
        Reset() {
            this._name = "";
            this._index = 0;
            this._isStopped = !1;
            this._end = NaN
        }
        SetName(b) {
            this._name = b
        }
        GetName() {
            return this._name
        }
        SetIndex(b) {
            this._index = b
        }
        GetIndex() {
            return this._index
        }
        Stop() {
            this._isStopped = !0
        }
        IsStopped() {
            return this._isStopped
        }
        SetEnd(b) {
            this._end = b
        }
        GetEnd() {
            return this._end
        }
    }
}
"use strict";
{
    const d = self.C3;
    d.ArrayStack = class extends d.DefendedBase {
        constructor() {
            super();
            this._stack = [];
            this._index = -1
        }
        Release() {
            d.clearArray(this._stack)
        }
        GetCurrent() {
            return this._stack[this._index]
        }
        Push() {
            ++this._index;
            if (this._index === this._stack.length) {
                const b = [];
                this._stack.push(b);
                return b
            }
            return this._stack[this._index]
        }
        Pop() {
            --this._index
        }
    }
}
"use strict";
{
    const d = self.C3;

    function b(f, c) {
        return f.GetIndex() - c.GetIndex()
    }

    function a(f, c) {
        for (let e = 0, g = f.length; e < g; ++e)
            if (f[e] !== c[e]) return !1;
        return !0
    }
    d.EventSheetManager = class extends d.DefendedBase {
        constructor(f) {
            super();
            this._runtime = f;
            this._allSheets = [];
            this._sheetsByName = new Map;
            this._allGroups = [];
            this._groupsByName = new Map;
            this._blocksBySid = new Map;
            this._cndsBySid = new Map;
            this._actsBySid = new Map;
            this._allUniqueSolModifiers = new Map;
            this._eventVarsBySid = new Map;
            this._nextLocalVarIndex = 0;
            this._allGlobalVars = [];
            this._allLocalVars = [];
            this._localVarInitialValues = [];
            this._functionBlocksByName = new Map;
            this._eventStack = d.New(d.EventStack, this);
            this._localVarStack = d.New(d.LocalVarStack, this);
            this._loopStack = d.New(d.LoopStack, this);
            this._triggersToPostInit = [];
            this._queuedTriggers = [];
            this._queuedDebugTriggers = [];
            this._blockFlushingDepth = this._executingTriggerDepth = this._runningEventsDepth = 0;
            this._scheduledWaits = [];
            this._asyncActionPromises = [];
            self.c3_callFunction = (c, e) => this._InvokeFunctionFromJS(c, e)
        }
        Release() {
            this.ClearAllScheduledWaits();
            this._eventStack.Release();
            this._eventStack = null;
            this._localVarStack.Release();
            this._localVarStack = null;
            d.clearArray(this._queuedTriggers);
            d.clearArray(this._queuedDebugTriggers);
            this._runtime = null;
            d.clearArray(this._allSheets);
            this._sheetsByName.clear()
        }
        Create(f) {
            f = d.New(d.EventSheet, this, f);
            this._allSheets.push(f);
            this._sheetsByName.set(f.GetName().toLowerCase(), f)
        }
        _AddTriggerToPostInit(f) {
            this._triggersToPostInit.push(f)
        }
        _PostInit() {
            for (const f of this._functionBlocksByName.values()) f._PostInit(!1);
            for (const f of this._allSheets) f._PostInit();
            for (const f of this._allSheets) f._UpdateDeepIncludes();
            for (const f of this._triggersToPostInit) f._PostInit(!1);
            d.clearArray(this._triggersToPostInit);
            this._localVarStack._SetInitialValues(this._localVarInitialValues)
        }
        GetRuntime() {
            return this._runtime
        }
        GetEventSheetByName(f) {
            return this._sheetsByName.get(f.toLowerCase()) || null
        }
        _RegisterGroup(f) {
            this._allGroups.push(f);
            this._groupsByName.set(f.GetGroupName(), f)
        }
        _RegisterEventBlock(f) {
            this._blocksBySid.set(f.GetSID(),
                f)
        }
        _RegisterCondition(f) {
            this._cndsBySid.set(f.GetSID(), f)
        }
        _RegisterAction(f) {
            this._actsBySid.set(f.GetSID(), f)
        }
        _RegisterFunctionBlock(f) {
            this._functionBlocksByName.set(f.GetFunctionName().toLowerCase(), f)
        }
        _RegisterEventVariable(f) {
            this._eventVarsBySid.set(f.GetSID(), f);
            f.IsGlobal() ? this._allGlobalVars.push(f) : this._allLocalVars.push(f)
        }
        _DeduplicateSolModifierList(f) {
            2 <= f.length && f.sort(b);
            let c = this._allUniqueSolModifiers.get(f.length);
            c || (c = [], this._allUniqueSolModifiers.set(f.length, c));
            for (let e =
                    0, g = c.length; e < g; ++e) {
                const h = c[e];
                if (a(f, h)) return h
            }
            c.push(f);
            return f
        }
        _GetNextLocalVarIndex(f) {
            this._localVarInitialValues.push(f.GetInitialValue());
            return this._nextLocalVarIndex++
        }
        GetEventStack() {
            return this._eventStack
        }
        GetCurrentEventStackFrame() {
            return this.GetEventStack().GetCurrentStackFrame()
        }
        GetCurrentEvent() {
            return this.GetCurrentEventStackFrame().GetCurrentEvent()
        }
        GetCurrentCondition() {
            const f = this.GetCurrentEventStackFrame();
            return f.GetCurrentEvent().GetConditionAt(f.GetConditionIndex())
        }
        GetCurrentAction() {
            const f =
                this.GetCurrentEventStackFrame();
            return f.GetCurrentEvent().GetActionAt(f.GetActionIndex())
        }
        GetLocalVarStack() {
            return this._localVarStack
        }
        GetLoopStack() {
            return this._loopStack
        }
        GetAllLocalVariablesInScope(f) {
            const c = [];
            for (f = f.GetScopeParent(); f;) d.appendArray(c, f._GetAllLocalVariablesInScope()), f = f.GetScopeParent();
            return c
        }
        _GetLocalVariablesScriptInterface(f) {
            const c = {};
            for (const e of this.GetAllLocalVariablesInScope(f)) c[e.GetJsPropName()] = e._GetScriptInterfaceDescriptor();
            return Object.create(Object.prototype,
                c)
        }
        GetEventVariableBySID(f) {
            return this._eventVarsBySid.get(f) || null
        }
        GetEventBlockBySID(f) {
            return this._blocksBySid.get(f) || null
        }
        GetConditionBySID(f) {
            return this._cndsBySid.get(f) || null
        }
        GetActionBySID(f) {
            return this._actsBySid.get(f) || null
        }
        GetFunctionBlockByName(f) {
            return this._functionBlocksByName.get(f.toLowerCase()) || null
        }
        GetAllGlobalVariables() {
            return this._allGlobalVars
        }
        GetAllLocalVariables() {
            return this._allLocalVars
        }
        ResetAllGlobalsToInitialValue() {
            for (const f of this._allGlobalVars) f.ResetToInitialValue()
        }
        GetEventGroupByName(f) {
            return this._groupsByName.get(f.toLowerCase()) ||
                null
        }
        GetEventGroupBySID(f) {
            return (f = this._blocksBySid.get(f)) && f.IsGroup() ? f : null
        }
        GetAllGroups() {
            return this._allGroups
        }
        ResetAllGroupsInitialActivation() {
            for (const f of this._allGroups) f.ResetInitialActivation()
        }
        _ResetAllHasRunFlags() {
            for (const f of this._allSheets) f._ResetHasRunFlag()
        }
        RunEvents(f) {
            this._ResetAllHasRunFlags();
            this._runningEventsDepth++;
            for (const c of f.runningLayouts())
                if (f = c.GetEventSheet()) this._runtime.PushCurrentLayout(c), f.Run(), this._runtime.PopCurrentLayout();
            this._runningEventsDepth--
        }
        async DebugRunEvents(f) {
            this._ResetAllHasRunFlags();
            this._runningEventsDepth++;
            for (const c of this._DebugRunEventsGen(f)) await this._runtime.DebugBreak(c);
            this._runningEventsDepth--
        }* _DebugRunEventsGen(f) {
            for (const c of f.runningLayouts())
                if (f = c.GetEventSheet()) this._runtime.PushCurrentLayout(c), yield* f.DebugRun(), this._runtime.PopCurrentLayout()
        }
        _Trigger(f, c, e, g) {
            let h = !1;
            if (!f.GetMainRunningLayout()) return this.QueueTrigger(c, e, g);
            this._executingTriggerDepth++;
            for (const l of f.runningLayouts())
                if (f = l.GetEventSheet()) {
                    this._runtime.PushCurrentLayout(l);
                    for (const m of f.deepIncludes()) {
                        const p = m._Trigger(c, e, g);
                        h = h || p
                    }
                    f = f._Trigger(c, e, g);
                    h = h || f;
                    this._runtime.PopCurrentLayout()
                } this._executingTriggerDepth--;
            return h
        }* _DebugTrigger(f, c, e, g) {
            let h = !1;
            if (!f.GetMainRunningLayout()) return this.QueueTrigger(c, e, g);
            this._executingTriggerDepth++;
            for (const l of f.runningLayouts())
                if (f = l.GetEventSheet()) {
                    this._runtime.PushCurrentLayout(l);
                    for (const m of f.deepIncludes()) {
                        const p = yield* m._DebugTrigger(c, e, g);
                        h = h || p
                    }
                    f = yield* f._DebugTrigger(c, e, g);
                    h = h || f;
                    this._runtime.PopCurrentLayout()
                } this._executingTriggerDepth--;
            return h
        }
        QueueTrigger(f, c, e) {
            this._queuedTriggers.push([f, c, e]);
            return !1
        }
        QueueDebugTrigger(f, c, e) {
            let g = null;
            const h = new Promise(l => g = l);
            this._queuedDebugTriggers.push([f, c, e, g]);
            return h
        }* _RunQueuedDebugTriggersGen() {
            if (this._runtime.HitBreakpoint()) throw Error("should not be in breakpoint");
            const f = this._runtime.GetLayoutManager();
            for (; this._queuedDebugTriggers.length;) {
                const [c, e, g, h] = this._queuedDebugTriggers.shift(), l = yield* this._DebugTrigger(f, c, e, g);
                h(l)
            }
        }
        async RunQueuedDebugTriggersAsync() {
            for (const f of this._RunQueuedDebugTriggersGen()) await this._runtime.DebugBreak(f)
        }
        _FastTrigger(f,
            c, e, g) {
            let h = !1;
            var l = f.GetMainRunningLayout();
            if (f = l.GetEventSheet()) {
                this._executingTriggerDepth++;
                this._runtime.PushCurrentLayout(l);
                l = f.deepIncludes();
                for (let m = 0, p = l.length; m < p; ++m) {
                    const t = l[m]._FastTrigger(c, e, g);
                    h = h || t
                }
                c = f._FastTrigger(c, e, g);
                h = h || c;
                this._runtime.PopCurrentLayout();
                this._executingTriggerDepth--;
                return h
            }
        }* _DebugFastTrigger(f, c, e, g) {
            let h = !1;
            var l = f.GetMainRunningLayout();
            if (f = l.GetEventSheet()) {
                this._executingTriggerDepth++;
                this._runtime.PushCurrentLayout(l);
                l = f.deepIncludes();
                for (let m = 0, p = l.length; m < p; ++m) {
                    const t = yield* l[m]._DebugFastTrigger(c, e, g);
                    h = h || t
                }
                c = yield* f._DebugFastTrigger(c, e, g);
                h = h || c;
                this._runtime.PopCurrentLayout();
                this._executingTriggerDepth--;
                return h
            }
        }
        GetTriggerDepth() {
            return this._executingTriggerDepth
        }
        IsInTrigger() {
            return 0 < this.GetTriggerDepth()
        }
        _IncTriggerDepth() {
            return ++this._executingTriggerDepth
        }
        _DecTriggerDepth() {
            --this._executingTriggerDepth
        }
        IsRunningEvents() {
            return 0 < this._runningEventsDepth
        }
        IsInEventEngine() {
            return this.IsRunningEvents() ||
                this.IsInTrigger()
        }
        _RunQueuedTriggers(f) {
            for (const [c, e, g] of this._queuedTriggers) this._Trigger(f, c, e, g);
            d.clearArray(this._queuedTriggers)
        }
        BlockFlushingInstances(f) {
            f ? this._blockFlushingDepth++ : this._blockFlushingDepth--
        }
        IsFlushingBlocked() {
            return 0 < this._blockFlushingDepth
        }
        ClearSol(f) {
            for (let c = 0, e = f.length; c < e; ++c) f[c].GetSolStack().Clear()
        }
        PushCleanSol(f) {
            for (let c = 0, e = f.length; c < e; ++c) f[c].GetSolStack().PushClean()
        }
        PushCopySol(f) {
            for (let c = 0, e = f.length; c < e; ++c) f[c].GetSolStack().PushCopy()
        }
        PopSol(f) {
            for (let c =
                    0, e = f.length; c < e; ++c) f[c].GetSolStack().Pop()
        }
        AddScheduledWait() {
            const f = d.New(d.ScheduledWait, this);
            this._scheduledWaits.push(f);
            return f
        }
        scheduledWaits() {
            return this._scheduledWaits
        }
        RunScheduledWaits() {
            if (this._scheduledWaits.length) {
                var f = this.GetCurrentEventStackFrame(),
                    c = !1;
                this._runningEventsDepth++;
                for (let e = 0, g = this._scheduledWaits.length; e < g; ++e) {
                    const h = this._scheduledWaits[e];
                    h._ShouldRun() && h._Run(f);
                    h.ShouldRelease() && (c = !0)
                }
                c && this._FilterScheduledWaitsToRelease();
                this._runningEventsDepth--
            }
        }
        async DebugRunScheduledWaits() {
            if (this._scheduledWaits.length) {
                var f =
                    this.GetCurrentEventStackFrame(),
                    c = !1;
                this._runningEventsDepth++;
                for (let e = 0, g = this._scheduledWaits.length; e < g; ++e) {
                    const h = this._scheduledWaits[e];
                    h._ShouldRun() && await h._DebugRun(f);
                    h.ShouldRelease() && (c = !0)
                }
                c && this._FilterScheduledWaitsToRelease();
                this._runningEventsDepth--
            }
        }
        _FilterScheduledWaitsToRelease() {
            const f = d.arrayFilterOut(this._scheduledWaits, c => c.ShouldRelease());
            for (const c of f) c.Release()
        }
        ClearAllScheduledWaits() {
            for (const f of this._scheduledWaits) f.Release();
            d.clearArray(this._scheduledWaits)
        }
        RemoveInstancesFromScheduledWaits(f) {
            for (const c of this._scheduledWaits) c.RemoveInstances(f)
        }
        AddAsyncActionPromise(f) {
            this._asyncActionPromises.push(f)
        }
        ClearAsyncActionPromises() {
            d.clearArray(this._asyncActionPromises)
        }
        GetPromiseForAllAsyncActions() {
            const f =
                Promise.all(this._asyncActionPromises);
            this._asyncActionPromises = [];
            return f
        }
        _SaveToJson() {
            return {
                groups: this._SaveGroupsToJson(),
                cnds: this._SaveCndsToJson(),
                acts: this._SaveActsToJson(),
                vars: this._SaveVarsToJson(),
                waits: this._SaveScheduledWaitsToJson()
            }
        }
        _LoadFromJson(f) {
            this._LoadGroupsFromJson(f.groups);
            this._LoadCndsFromJson(f.cnds);
            this._LoadActsFromJson(f.acts);
            this._LoadVarsFromJson(f.vars);
            this._LoadScheduledWaitsFromJson(f.waits)
        }
        _SaveGroupsToJson() {
            const f = {};
            for (const c of this.GetAllGroups()) f[c.GetSID().toString()] =
                c.IsGroupActive();
            return f
        }
        _LoadGroupsFromJson(f) {
            for (const [c, e] of Object.entries(f)) f = parseInt(c, 10), (f = this.GetEventGroupBySID(f)) && f.SetGroupActive(e)
        }
        _SaveCndsToJson() {
            const f = {};
            for (const [c, e] of this._cndsBySid) {
                const g = e._SaveToJson();
                g && (f[c.toString()] = g)
            }
            return f
        }
        _LoadCndsFromJson(f) {
            const c = new Map;
            for (const [e, g] of Object.entries(f)) c.set(parseInt(e, 10), g);
            for (const [e, g] of this._cndsBySid) g._LoadFromJson(c.get(e) || null)
        }
        _SaveActsToJson() {
            const f = {};
            for (const [c, e] of this._actsBySid) {
                const g =
                    e._SaveToJson();
                g && (f[c.toString()] = g)
            }
            return f
        }
        _LoadActsFromJson(f) {
            const c = new Map;
            for (const [e, g] of Object.entries(f)) c.set(parseInt(e, 10), g);
            for (const [e, g] of this._actsBySid) g._LoadFromJson(c.get(e) || null)
        }
        _SaveVarsToJson() {
            const f = {};
            for (const [c, e] of this._eventVarsBySid) e.IsConstant() || !e.IsGlobal() && !e.IsStatic() || (f[c.toString()] = e.GetValue());
            return f
        }
        _LoadVarsFromJson(f) {
            for (const [c, e] of Object.entries(f)) f = parseInt(c, 10), (f = this.GetEventVariableBySID(f)) && f.SetValue(e)
        }
        _SaveScheduledWaitsToJson() {
            return this._scheduledWaits.filter(f =>
                !f.IsPromise()).map(f => f._SaveToJson())
        }
        _LoadScheduledWaitsFromJson(f) {
            this.ClearAllScheduledWaits();
            for (const c of f)(f = d.ScheduledWait._CreateFromJson(this, c)) && this._scheduledWaits.push(f)
        }
        _GetPerfRecords() {
            return [...this._runtime.GetLayoutManager().runningLayouts()].map(f => f.GetEventSheet()).filter(f => f).map(f => f._GetPerfRecord())
        }
        FindFirstFunctionBlockParent(f) {
            for (; f;)
                if (f = f.GetScopeParent(), f instanceof d.FunctionBlock) return f;
            return null
        }
        _InvokeFunctionFromJS(f, c) {
            Array.isArray(c) || (c = []);
            f = this.GetFunctionBlockByName(f.toLowerCase());
            if (!f) return null;
            if (!f.IsEnabled()) return f.GetDefaultReturnValue();
            var e = f.GetFunctionParameters();
            if (c.length < e.length) {
                c = c.slice(0);
                do c.push(e[c.length].GetInitialValue()); while (c.length < e.length)
            }
            e = f.GetEventBlock();
            return e.RunAsExpressionFunctionCall(e.GetSolModifiersIncludingParents(), f.GetReturnType(), f.GetDefaultReturnValue(), ...c)
        }
    }
}
"use strict";
{
    const d = self.C3;
    d.EventSheet = class extends d.DefendedBase {
        constructor(b, a) {
            // console.log("IDDQD 1 this._hasRun = !1;")
            super();
            this._eventSheetManager = b;
            this._runtime = b.GetRuntime();
            this._name = a[0];
            this._events = [];
            this._triggers = new Map;
            this._fastTriggers = new Map;
            this._eventsByDisplayNumber = new Map;
            this._hasRun = !1;
            this._shallowIncludes = [];
            this._deepIncludes = [];
            this._alreadyIncludedSheets = new Set;
            for (const f of a[1]) this._CreateEvent(f, null, this._events);
            this._perfRecord = this._runtime.IsDebug() ? {
                type: "sheet",
                name: this._name,
                totalTimeCounter: 0,
                children: []
            } : null
        }
        Release() {
            this._runtime = this._eventSheetManager = null
        }
        _CreateEvent(b, a, f) {
            // console.log("IDDQD _CreateEvent 1 " + b[0])
            // console.log("IDDQD _CreateEvent 2 " + b)
            // console.log("IDDQD _CreateEvent 3 " + a)
            // console.log("IDDQD _CreateEvent 4 " + f)
            switch (b[0]) {
                case 0:
                case 3:
                
                    this._CreateEventBlock(b, a, f);
                    break;
                case 1:
                    this._CreateEventVariable(b, a, f);
                    break;
                case 2:
                    this._CreateInclude(b, a, f);
                    break;
                case 4:
                    this._CreateFunctionBlock(b, a);
                    break;
                case 5:
                    this._CreateScriptBlock(b, a, f);
                    break;
                default:
                    throw Error("invalid event type");
            }
        }
        _CreateEventBlock(b, a, f) {
            b = d.EventBlock.Create(this, a, b);
            if (b.IsOrBlock()) {
                f.push(b);
                f = b.GetConditions();
                for (let c = 0, e = f.length; c <
                    e; ++c) f[c].IsTrigger() && this._InitTrigger(b, c)
            } else b.IsTrigger() ? this._InitTrigger(b, 0) : f.push(b)
        }
        _CreateFunctionBlock(b, a) {
            b = d.FunctionBlock.Create(this, a, b);
            this._eventSheetManager._RegisterFunctionBlock(b)
        }
        _CreateEventVariable(b, a, f) {
            b = d.EventVariable.Create(this, a, b);
            f.push(b)
        }
        _CreateInclude(b, a, f) {
            b = d.EventInclude.Create(this, a, b);
            f.push(b)
        }
        _CreateScriptBlock(b, a, f) {
            b = d.EventScript.Create(this, a, b);
            f.push(b)
        }
        _InitTrigger(b, a) {
            b.IsOrBlock() || this._eventSheetManager._AddTriggerToPostInit(b);
            var f =
                b.GetConditionAt(a),
                c = f._GetFunc(),
                e = f.GetObjectClass();
            if (f.IsFastTrigger()) {
                var g = this._fastTriggers.get(e);
                g || (g = new Map, this._fastTriggers.set(e, g));
                f = f.GetFastTriggerValue().toLowerCase();
                e = g.get(c);
                e || (e = new Map, g.set(c, e));
                c = e.get(f);
                c || (c = [], e.set(f, c));
                c.push([b, a])
            } else g = this._triggers.get(e), g || (g = {
                    methodMap: new Map,
                    behaviors: new Map
                }, this._triggers.set(e, g)), (e = f.GetBehaviorType()) ? (f = g.behaviors.get(e), f || (f = new Map, g.behaviors.set(e, f))) : f = g.methodMap, g = f.get(c), g || (g = [], f.set(c, g)),
                g.push([b, a])
        }
        _PostInit() {
            const b = this._events;
            for (let a = 0, f = b.length; a < f; ++a) {
                const c = a < f - 1 && b[a + 1] instanceof d.EventBlock && b[a + 1].IsElseBlock();
                b[a]._PostInit(c)
            }
        }
        _AddShallowInclude(b) {
            this._shallowIncludes.push(b)
        }
        _UpdateDeepIncludes() {
            d.clearArray(this._deepIncludes);
            this._AddDeepIncludes(this);
            this._alreadyIncludedSheets.clear()
        }
        _AddDeepIncludes(b) {
            const a = b._deepIncludes,
                f = b._alreadyIncludedSheets;
            for (const c of this._shallowIncludes) {
                const e = c.GetIncludeSheet();
                c.IsActive() && b !== e && !f.has(e) &&
                    (f.add(e), e._AddDeepIncludes(b), a.push(e))
            }
        }
        deepIncludes() {
            return this._deepIncludes
        }
        GetEventSheetManager() {
            return this._eventSheetManager
        }
        GetRuntime() {
            return this._runtime
        }
        GetName() {
            return this._name
        }
        _RegisterEventByDisplayNumber(b, a) {
            this._eventsByDisplayNumber.set(a, b)
        }
        _GetEventByDisplayNumber(b) {
            return this._eventsByDisplayNumber.get(b) || null
        }
        _ResetHasRunFlag() {
            // console.log("IDDQD _ResetHasRunFlag")
            this._hasRun = !1
        }
        Run() {
            if (!this._hasRun) {
                var b = this._runtime,
                    a = b.IsCPUProfiling(),
                    f = a ? performance.now() : 0;
                // console.log("IDDQD 1 Run()")    
                this._hasRun = !0;
                var c = this.GetEventSheetManager(),
                    e = c.GetCurrentEventStackFrame();
                
                // if(fgdg === false) {
                //     console.log("IDDQD 1 " + c)
                //     console.log("IDDQD 2 " + e)
                //     fgdg = true
                // }

                for (const g of this._events) g.Run(e), c.ClearSol(g.GetSolModifiers()), c.ClearAsyncActionPromises(), b.FlushPendingInstances();
                e.Reset(null);
                a && (this._perfRecord.totalTimeCounter += performance.now() - f)
            }
        }* DebugRun() {
            if (!this._hasRun) {
                // console.log("IDDQD 1 DebugRun()")
                this._hasRun = !0;
                var b = this._runtime,
                    a = this.GetEventSheetManager(),
                    f = a.GetCurrentEventStackFrame();
                for (const c of this._events) yield* c.DebugRun(f), a.ClearSol(c.GetSolModifiers()), a.ClearAsyncActionPromises(), b.FlushPendingInstances();
                f.Reset(null)
            }
        }
        _Trigger(b,
            a, f) {
            if (a) {
                const c = a.GetObjectClass();
                // console.log("IDDQD _Trigger 1 " + b)
                // console.log("IDDQD _Trigger 2 " + a)
                // console.log("IDDQD _Trigger 3 " + c)
                // console.log("IDDQD _Trigger 4 " + f)
                this._TriggerForClass(b, a, c, f);
                for (const e of c.GetFamilies()) this._TriggerForClass(b, a, e, f)
            } else return this._TriggerForClass(b, a, null, null)
        }
        _TriggerForClass(b, a, f, c) {
            f = this._triggers.get(f);
            if (!f) return !1;
            c = c ? f.behaviors.get(c) : f.methodMap;
            if (!c) return !1;
            c = c.get(b);
            if (!c) return !1;
            b = !1;
            for (const [e, g] of c) c = this._ExecuteTrigger(a, e, g), b = b || c;
            return b
        }* _DebugTrigger(b, a, f) {
            if (a) {
                const c = a.GetObjectClass();
                yield* this._DebugTriggerForClass(b, a, c, f);
                for (const e of c.GetFamilies()) yield* this._DebugTriggerForClass(b,
                    a, e, f)
            } else return yield* this._DebugTriggerForClass(b, a, null, null)
        }* _DebugTriggerForClass(b, a, f, c) {
            f = this._triggers.get(f);
            if (!f) return !1;
            c = c ? f.behaviors.get(c) : f.methodMap;
            if (!c) return !1;
            c = c.get(b);
            if (!c) return !1;
            b = !1;
            for (const [e, g] of c) c = e.DebugCanRunFast() ? this._ExecuteTrigger(a, e, g) : yield* this._DebugExecuteTrigger(a, e, g), b = b || c;
            return b
        }
        _FastTrigger(b, a, f) {
            a = a.GetObjectClass();
            a = this._fastTriggers.get(a);
            if (!a) return !1;
            b = a.get(b);
            if (!b) return !1;
            f = b.get(f);
            if (!f) return !1;
            b = !1;
            for (let c = 0, e = f.length; c <
                e; ++c) a = f[c], a = this._ExecuteTrigger(null, a[0], a[1]), b = b || a;
            return b
        }* _DebugFastTrigger(b, a, f) {
            a = a.GetObjectClass();
            a = this._fastTriggers.get(a);
            if (!a) return !1;
            b = a.get(b);
            if (!b) return !1;
            f = b.get(f);
            if (!f) return !1;
            b = !1;
            for (let e = 0, g = f.length; e < g; ++e) {
                var c = f[e];
                a = c[0];
                c = c[1];
                a = a.DebugCanRunFast() ? this._ExecuteTrigger(null, a, c) : yield* this._DebugExecuteTrigger(null, a, c);
                b = b || a
            }
            return b
        }
        _ExecuteTrigger(b, a, f) {
            const c = this._runtime,
                e = this._eventSheetManager,
                g = e.GetCurrentEvent(),
                h = e.GetEventStack(),
                l = e.GetTriggerDepth();
            let m = !1;
            g && e.PushCleanSol(g.GetSolModifiersIncludingParents());
            e.PushCleanSol(a.GetSolModifiersIncludingParents());
            const p = 1 < l;
            p && e.GetLocalVarStack().Push();
            const t = h.Push(a);
            b && (a.GetConditions()[f].GetObjectClass().GetCurrentSol().SetSinglePicked(b), b.IsInContainer() && b.SetSiblingsSinglePicked());
            b = !0;
            if (a.GetParent()) {
                const q = a.GetTriggerParents();
                for (let r = 0, u = q.length; r < u; ++r)
                    if (!q[r].RunPreTrigger(t)) {
                        b = !1;
                        break
                    }
            }
            b && (c.IncrementExecCount(), a.IsOrBlock() ? a.RunOrBlockTrigger(t, f) : a.Run(t), m =
                t.GetLastEventTrue());
            h.Pop();
            p && e.GetLocalVarStack().Pop();
            e.PopSol(a.GetSolModifiersIncludingParents());
            g && e.PopSol(g.GetSolModifiersIncludingParents());
            g || 1 !== l || (e.ClearAsyncActionPromises(), e.IsFlushingBlocked() || c.FlushPendingInstances());
            return m
        }* _DebugExecuteTrigger(b, a, f) {
            const c = this._runtime,
                e = this._eventSheetManager,
                g = e.GetCurrentEvent(),
                h = e.GetEventStack(),
                l = e.GetTriggerDepth();
            let m = !1;
            g && e.PushCleanSol(g.GetSolModifiersIncludingParents());
            e.PushCleanSol(a.GetSolModifiersIncludingParents());
            const p = 1 < l;
            p && e.GetLocalVarStack().Push();
            const t = h.Push(a);
            b && (a.GetConditions()[f].GetObjectClass().GetCurrentSol().SetSinglePicked(b), b.IsInContainer() && b.SetSiblingsSinglePicked());
            b = !0;
            if (a.GetParent()) {
                const q = a.GetTriggerParents();
                for (let r = 0, u = q.length; r < u; ++r)
                    if (!(yield* q[r].DebugRunPreTrigger(t))) {
                        b = !1;
                        break
                    }
            }
            b && (c.IncrementExecCount(), a.IsOrBlock() ? yield* a.DebugRunOrBlockTrigger(t, f): yield* a.DebugRun(t), m = t.GetLastEventTrue());
            h.Pop();
            p && e.GetLocalVarStack().Pop();
            e.PopSol(a.GetSolModifiersIncludingParents());
            g && e.PopSol(g.GetSolModifiersIncludingParents());
            g || 1 !== l || (e.ClearAsyncActionPromises(), e.IsFlushingBlocked() || c.FlushPendingInstances());
            return m
        }
        _GetPerfRecord() {
            return this._perfRecord
        }
    }
}
"use strict";
{
    const d = self.C3,
        b = [];

    function a(c, e) {
        return !0
    }

    function* f(c, e) {
        return !0
    }
    d.EventBlock = class extends d.DefendedBase {
        constructor(c, e, g) {
            super();
            this._eventSheet = c;
            this._runtime = c.GetRuntime();
            this._parent = e;
            this._scopeParent = null;
            this._eventStack = this._runtime.GetEventSheetManager().GetEventStack();
            this._solModifiers = [];
            this._solModifiersIncludingParents = [];
            this._hasElseBlock = this._isTopLevelGroup = this._isSolWriterAfterCnds = this._hasGotSolModifiersIncludingParents = !1;
            this._isOrBlock = !!g[2];
            this._isElseBlock = !1;
            this._triggerParents = null;
            this._conditions = [];
            this._actions = [];
            this._subEvents = [];
            this._RunActions = a;
            this._DebugRunActions = f;
            this._isInitiallyActive = this._isGroup = !1;
            this._groupName = "";
            this._isGroupActive = !1;
            this._perfRecord = this._containedIncludes = null;
            this._sid = g[4];
            this._displayNumber = g[5];
            this._eventSheet._RegisterEventByDisplayNumber(this, this._displayNumber);
            this._debugData = this._runtime.IsDebug() ? {
                isBreakpoint: g[3][0],
                isBreakable: g[3][1],
                canRunAllConditionsFast: !1,
                canRunAllActionsFast: !1,
                canRunAllSubEventsFast: !1,
                canRunSelfFast: !1
            } : null;
            this.GetEventSheetManager()._RegisterEventBlock(this);
            3 === g[0] && this._InitGroup(g[1]);
            c = 0;
            for (var h of g[6]) e = d.Condition.Create(this, h, c++), this._conditions.push(e), this._AddSolModifier(e.GetObjectClass());
            c = 0;
            for (const l of g[7]) h = d.Action.Create(this, l, c++), this._actions.push(h);
            if (9 === g.length) {
                g = g[8];
                for (const l of g) this._eventSheet._CreateEvent(l, this, this._subEvents)
            }
            this._conditions.length && (this._isElseBlock = null === this._conditions[0].GetObjectClass() &&
                this._conditions[0]._GetFunc() === d.Plugins.System.Cnds.Else);
            0 === this._conditions.length && (this._conditions = b);
            0 === this._actions.length && (this._actions = b);
            0 === this._subEvents.length && (this._subEvents = b)
        }
        static Create(c, e, g) {
            return d.New(d.EventBlock, c, e, g)
        }
        _InitGroup(c) {
            this._isGroup = !0;
            this._isGroupActive = this._isInitiallyActive = !!c[0];
            this._groupName = c[1].toLowerCase();
            this._containedIncludes = [];
            this.GetEventSheetManager()._RegisterGroup(this);
            this._runtime.IsDebug() && (this._perfRecord = {
                type: "group",
                name: c[1],
                totalTimeCounter: 0,
                children: []
            })
        }
        _AddContainedInclude(c) {
            this._containedIncludes.push(c)
        }
        _AddContainerSolModifierToList(c, e) {
            for (const g of c.GetContainer().objectTypes()) e.includes(g) || e.push(g)
        }
        _AddSolModifierToList(c, e) {
            if (c)
                if (e.includes(c) || e.push(c), c.IsFamily())
                    for (const g of c.GetFamilyMembers()) g.IsInContainer() && this._AddContainerSolModifierToList(g, e);
                else c.IsInContainer() && this._AddContainerSolModifierToList(c, e)
        }
        _AddSolModifier(c) {
            this._AddSolModifierToList(c, this._solModifiers)
        }
        _AddParentSolModifier(c) {
            this._AddSolModifierToList(c,
                this._solModifiersIncludingParents)
        }
        SetAllSolModifiers() {
            this._solModifiers = this._runtime.GetAllObjectClasses()
        }
        _PostInit(c) {
            this._hasElseBlock = !!c;
            this._IdentifyTopLevelGroup();
            this._IdentifyTriggerParents();
            for (const g of this._conditions) g._PostInit();
            if (0 < this._actions.length) {
                c = !1;
                for (var e of this._actions) e._PostInit(), e.HasReturnType() && (c = !0);
                c ? (this._RunActions = this._RunActions_ReturnValue, this._DebugRunActions = this._DebugRunActions_ReturnValue) : (this._RunActions = this._RunActions_Fast, this._DebugRunActions =
                    this._DebugRunActions_Fast)
            }
            e = this._subEvents;
            for (let g = 0, h = e.length; g < h; ++g) c = g < h - 1 && e[g + 1] instanceof d.EventBlock && e[g + 1].IsElseBlock(), e[g]._PostInit(c);
            this._debugData && this._UpdateCanRunFast();
            this._perfRecord && this._GetPerfRecordParent()._GetPerfRecord().children.push(this._perfRecord)
        }
        _GetPerfRecord() {
            return this._perfRecord
        }
        _GetPerfRecordParent() {
            let c = this.GetParent();
            for (; c;) {
                if (c.IsGroup()) return c;
                c = c.GetParent()
            }
            return this._eventSheet
        }
        _UpdateCanRunFast() {
            const c = this._debugData;
            c.canRunAllConditionsFast =
                this._conditions.every(e => e.DebugCanRunFast());
            c.canRunAllActionsFast = this._actions.every(e => e.DebugCanRunFast());
            c.canRunAllSubEventsFast = this._subEvents.every(e => e.DebugCanRunFast());
            c.canRunSelfFast = c.canRunAllConditionsFast && c.canRunAllActionsFast && c.canRunAllSubEventsFast
        }
        _UpdateCanRunFastRecursive() {
            let c = this;
            do c._UpdateCanRunFast(), c = c.GetParent(); while (c)
        }
        _IdentifyTopLevelGroup() {
            if (this.IsGroup()) {
                var c = this.GetParent();
                for (this._isTopLevelGroup = !0; c;) {
                    if (!c.IsGroup()) {
                        this._isTopLevelGroup = !1;
                        break
                    }
                    c = c.GetParent()
                }
            }
        }
        _IdentifySolModifiersIncludingParents() {
            var c = this._runtime.GetAllObjectClasses();
            if (this._solModifiers === c) this._solModifiersIncludingParents = c;
            else {
                this._solModifiersIncludingParents = d.cloneArray(this._solModifiers);
                for (c = this.GetParent(); c;) {
                    for (var e of c._solModifiers) this._AddParentSolModifier(e);
                    c = c.GetParent()
                }
                e = this.GetEventSheetManager();
                this._solModifiers = e._DeduplicateSolModifierList(this._solModifiers);
                this._solModifiersIncludingParents = e._DeduplicateSolModifierList(this._solModifiersIncludingParents)
            }
        }
        _IdentifyTriggerParents() {
            if (this.HasAnyTriggeredCondition()) {
                this._triggerParents = [];
                for (var c = this.GetParent(); c;) this._triggerParents.push(c), c = c.GetParent();
                this._triggerParents.reverse()
            }
        }
        SetSolWriterAfterCnds() {
            this._isSolWriterAfterCnds = !0;
            this._parent && this._parent.SetSolWriterAfterCnds()
        }
        IsSolWriterAfterCnds() {
            return this._isSolWriterAfterCnds
        }
        GetSolModifiers() {

            return this._solModifiers
        }
        GetSolModifiersIncludingParents() {
            this._hasGotSolModifiersIncludingParents || (this._hasGotSolModifiersIncludingParents = !0, this._IdentifySolModifiersIncludingParents());
            return this._solModifiersIncludingParents
        }
        HasSolModifier(c) {
            return this._solModifiers.includes(c)
        }
        GetTriggerParents() {
            return this._triggerParents
        }
        GetEventSheet() {
            return this._eventSheet
        }
        GetEventSheetManager() {
            return this._eventSheet.GetEventSheetManager()
        }
        GetRuntime() {
            return this._runtime
        }
        GetParent() {
            return this._parent
        }
        _SetScopeParent(c) {
            this._scopeParent =
                c
        }
        GetScopeParent() {
            return this._scopeParent || this._parent
        }
        GetDisplayNumber() {
            return this._displayNumber
        }
        IsDebugBreakable() {
            return this._debugData && this._debugData.isBreakable
        }
        IsDebugBreakpoint() {
            return this.IsDebugBreakable() && this._debugData.isBreakpoint
        }
        _SetDebugBreakpoint(c) {
            this._debugData.isBreakpoint = !!c;
            this._UpdateCanRunFastRecursive()
        }
        IsGroup() {
            return this._isGroup
        }
        IsTopLevelGroup() {
            return this._isTopLevelGroup
        }
        IsElseBlock() {
            return this._isElseBlock
        }
        HasElseBlock() {
            return this._hasElseBlock
        }
        GetGroupName() {
            return this._groupName
        }
        IsGroupActive() {
            return this._isGroupActive
        }
        ResetInitialActivation() {
            this.SetGroupActive(this._isInitiallyActive)
        }
        SetGroupActive(c) {
            c = !!c;
            if (!this._isGroup) throw Error("not a group");
            if (this._isGroupActive !== c) {
                this._isGroupActive = c;
                for (const e of this._containedIncludes) e.UpdateActive();
                this._containedIncludes.length && (c = this._runtime.GetCurrentLayout().GetEventSheet()) && c._UpdateDeepIncludes()
            }
        }
        GetSID() {
            return this._sid
        }
        IsOrBlock() {
            return this._isOrBlock
        }
        IsTrigger() {
            return this._conditions.length && this._conditions[0].IsTrigger()
        }
        IsForFunctionBlock() {
            return this._scopeParent && this._scopeParent instanceof d.FunctionBlock
        }
        HasAnyTriggeredCondition() {
            return this.IsForFunctionBlock() ||
                this._conditions.some(c => c.IsTrigger())
        }
        GetConditions() {
            return this._conditions
        }
        GetConditionCount() {
            return this._conditions.length
        }
        GetConditionAt(c) {
            c = Math.floor(c);
            if (0 > c || c >= this._conditions.length) throw new RangeError("invalid condition index");
            return this._conditions[c]
        }
        GetConditionByDebugIndex(c) {
            return this.GetConditionAt(c)
        }
        IsFirstConditionOfType(c) {
            let e = c.GetIndex();
            if (0 === e) return !0;
            for (--e; 0 <= e; --e)
                if (this._conditions[e].GetObjectClass() === c.GetObjectClass()) return !1;
            return !0
        }
        GetActions() {
            return this._actions
        }
        GetActionCount() {
            return this._actions.length
        }
        GetActionAt(c) {
            c =
                Math.floor(c);
            if (0 > c || c >= this._actions.length) throw new RangeError("invalid action index");
            return this._actions[c]
        }
        GetActionByDebugIndex(c) {
            c = Math.floor(c);
            const e = this._actions.find(g => g.GetDebugIndex() === c);
            if (!e) throw new RangeError("invalid action debug index");
            return e
        }
        _HasActionIndex(c) {
            c = Math.floor(c);
            return 0 <= c && c < this._actions.length
        }
        GetSubEvents() {
            return this._subEvents
        }
        _GetAllLocalVariablesInScope() {
            return this._subEvents.filter(c => c instanceof d.EventVariable)
        }
        RunPreTrigger(c) {
            c.SetCurrentEvent(this);
            let e = !1;
            const g = this._conditions;
            for (let h = 0, l = g.length; h < l; ++h) {
                const m = g[h];
                c.SetConditionIndex(h);
                if (m.IsLooping()) throw Error("trigger cannot be used as sub-event to a loop");
                if (m.Run()) e = !0;
                else if (!this._isOrBlock) return !1
            }
            return this._isOrBlock ? e : !0
        }
        RunOrBlockTrigger(c, e) {
            c.SetCurrentEvent(this);
            this._conditions[e].Run() && (this._RunActions(c, 0) && this._RunSubEvents(c), c.SetLastEventTrue(!0))
        }* DebugRunPreTrigger(c) {
            c.SetCurrentEvent(this);
            let e = !1;
            const g = this._conditions;
            for (let h = 0, l = g.length; h <
                l; ++h) {
                const m = g[h];
                c.SetConditionIndex(h);
                if (m.IsLooping()) throw Error("trigger cannot be used as sub-event to a loop");
                if (m.DebugCanRunFast() ? m.Run() : yield* m.DebugRun()) e = !0;
                else if (!this._isOrBlock) return !1
            }
            return this._isOrBlock ? e : !0
        }* DebugRunOrBlockTrigger(c, e) {
            c.SetCurrentEvent(this);
            e = this._conditions[e];
            if (e.DebugCanRunFast() ? e.Run() : yield* e.DebugRun())(this.DebugCanRunActionsFast() ? this._RunActions(c, 0) : yield* this._DebugRunActions(c, 0)) && (this.DebugCanRunSubEventsFast() ? this._RunSubEvents() :
                yield* this._DebugRunSubEvents()), c.SetLastEventTrue(!0)
        }
        Run(c) {
            c.SetCurrentEvent(this);
            this._isElseBlock || c.SetElseBranchRan(!1);
            this._isOrBlock ? this._RunOrBlock(c) : this._RunAndBlock(c)
        }* DebugRun(c) {
            if (this.IsDebugBreakpoint() || this._runtime.DebugBreakNext()) yield this;
            c.SetCurrentEvent(this);
            this._isElseBlock || c.SetElseBranchRan(!1);
            this._isOrBlock ? yield* this._DebugRunOrBlock(c): yield* this._DebugRunAndBlock(c)
        }
        _RunOrBlock(c) {
            const e = this._conditions;
            let g = 0 === e.length;
            for (let l = 0, m = e.length; l < m; ++l) {
                var h =
                    e[l];
                h.IsTrigger() || (c.SetConditionIndex(l), h = h.Run(), g = g || h)
            }
            c.SetLastEventTrue(g);
            g && (this._RunActions(c, 0) && this._RunSubEvents(c), this._hasElseBlock && c.SetElseBranchRan(!0))
        }* _DebugRunOrBlock(c) {
            const e = this._conditions;
            let g = 0 === e.length;
            for (let l = 0, m = e.length; l < m; ++l) {
                var h = e[l];
                h.IsTrigger() || (c.SetConditionIndex(l), h = h.DebugCanRunFast() ? h.Run() : yield* h.DebugRun(), g = g || h)
            }
            c.SetLastEventTrue(g);
            g && ((this.DebugCanRunActionsFast() ? this._RunActions(c, 0) : yield* this._DebugRunActions(c, 0)) && (this.DebugCanRunSubEventsFast() ?
                this._RunSubEvents() : yield* this._DebugRunSubEvents()), this._hasElseBlock && c.SetElseBranchRan(!0))
        }
        _RunAndBlock(c) {
            const e = this._conditions;
            for (let g = 0, h = e.length; g < h; ++g) {
                const l = e[g];
                c.SetConditionIndex(g);
                if (!l.Run()) {
                    c.SetLastEventTrue(!1);
                    return
                }
            }
            c.SetLastEventTrue(!0);
            this._RunActions(c, 0) && this._RunSubEvents(c);
            c.GetLastEventTrue() && this._hasElseBlock && c.SetElseBranchRan(!0)
        }* _DebugRunAndBlock(c) {
            const e = this._conditions;
            for (let g = 0, h = e.length; g < h; ++g) {
                const l = e[g];
                c.SetConditionIndex(g);
                if (l.DebugCanRunFast() ?
                    !l.Run() : !(yield* l.DebugRun())) {
                    c.SetLastEventTrue(!1);
                    return
                }
            }
            c.SetLastEventTrue(!0);
            (this.DebugCanRunActionsFast() ? this._RunActions(c, 0) : yield* this._DebugRunActions(c, 0)) && (this.DebugCanRunSubEventsFast() ? this._RunSubEvents() : yield* this._DebugRunSubEvents());
            c.GetLastEventTrue() && this._hasElseBlock && c.SetElseBranchRan(!0)
        }
        _RunActions_Fast(c, e) {
            // console.log("IDDQD " + JSON.stringify(c))
            // console.log("IDDQD " + JSON.stringify(e))
            const g = this._actions;
            const getCircularReplacer = () => {
                const seen = new WeakSet();
                return (key, value) => {
                  if (typeof value === "object" && value !== null) {
                    if (seen.has(value)) {
                      return;
                    }
                    seen.add(value);
                  }
                  return value;
                };
              };
              
              
            for (let h = e, l = g.length; h < l; ++h) 
            {
             e = g[h], c.SetActionIndex(h), e.Run();
             // 4 = coints left, 5 = lifes
            //  console.log("IDDQD2 index h " + h);
             if(h == 5 || h == 4) {
                // console.log("IDDQD2 " + JSON.stringify(g[4]))
                // console.log("IDDQD2 " + JSON.stringify(g[5]))
                // const stringified = JSON.stringify(g[h], getCircularReplacer());
              
            //   console.log("IDDQD2 stringifff  " + stringified);
             }
            

            //  console.log("IDDQD2 index c " + JSON.stringify(this));
             
            //  console.log("IDDQD2 index e " + JSON.stringify(e));
            //  console.log("IDDQD2 index c.SetActionIndex(h) " + c.SetActionIndex(h));
            }
            return !0
        }* _DebugRunActions_Fast(c, e) {
            const g = this._actions;
            for (let h =
                    e, l = g.length; h < l; ++h) e = g[h], c.SetActionIndex(h), e.DebugCanRunFast() ? e.Run() : yield* e.DebugRun();
            return !0
        }
        _RunActions_ReturnValue(c, e) {
            const g = this.GetEventSheetManager(),
                h = this._actions;
            for (let l = e, m = h.length; l < m; ++l) {
                e = h[l];
                c.SetActionIndex(l);
                const p = e.Run();
                if (e.CanBailOut() && !0 === p) return !1;
                e.IsAsync() && p instanceof Promise && g.AddAsyncActionPromise(p)
            }
            return !0
        }* _DebugRunActions_ReturnValue(c, e) {
            const g = this.GetEventSheetManager(),
                h = this._actions;
            for (let l = e, m = h.length; l < m; ++l) {
                e = h[l];
                c.SetActionIndex(l);
                let p;
                p = e.DebugCanRunFast() ? e.Run() : yield* e.DebugRun();
                if (e.CanBailOut() && !0 === p) return !1;
                e.IsAsync() && p instanceof Promise && g.AddAsyncActionPromise(p)
            }
            return !0
        }
        _ResumeActionsAndSubEvents(c) {
            this._RunActions(c, c.GetActionIndex()) && this._RunSubEvents()
        }* _DebugResumeActionsAndSubEvents(c) {
            if (yield* this._DebugRunActions(c, c.GetActionIndex())) yield* this._DebugRunSubEvents()
        }
        _RunSubEvents() {
            if (this._subEvents.length) {
                var c = this.IsGroup() && this._runtime.IsCPUProfiling(),
                    e = c ? performance.now() : 0,
                    g = this._eventStack,
                    h = g.Push(this);
                this._isSolWriterAfterCnds ? this._RunSubEvents_SolWriterAfterCnds(h) : this._RunSubEvents_Fast(h);
                g.Pop();
                c && (this._perfRecord.totalTimeCounter += performance.now() - e)
            }
        }
        _RunSubEvents_SolWriterAfterCnds(c) {
            const e = this._isGroup,
                g = this._isTopLevelGroup,
                h = this.GetEventSheetManager(),
                l = this._subEvents;
            for (let m = 0, p = l.length, t = p - 1; m < p; ++m) {
                const q = l[m],
                    r = q.GetSolModifiers(),
                    u = !g || !e && m < t;
                u && h.PushCopySol(r);
                q.Run(c);
                u ? h.PopSol(r) : h.ClearSol(r)
            }
        }
        _RunSubEvents_Fast(c) {
            const e = this._subEvents;
            for (let g =
                    0, h = e.length; g < h; ++g) e[g].Run(c)
        }* _DebugRunSubEvents() {
            if (this._subEvents.length) {
                var c = this._eventStack,
                    e = c.Push(this);
                this._isSolWriterAfterCnds ? yield* this._DebugRunSubEvents_SolWriterAfterCnds(e): yield* this._DebugRunSubEvents_Fast(e);
                c.Pop()
            }
        }* _DebugRunSubEvents_SolWriterAfterCnds(c) {
            const e = this._isGroup,
                g = this._isTopLevelGroup,
                h = this.GetEventSheetManager(),
                l = this._subEvents;
            for (let m = 0, p = l.length, t = p - 1; m < p; ++m) {
                const q = l[m],
                    r = q.GetSolModifiers(),
                    u = !g || !e && m < t;
                u && h.PushCopySol(r);
                yield* q.DebugRun(c);
                u ? h.PopSol(r) : h.ClearSol(r)
            }
        }* _DebugRunSubEvents_Fast(c) {
            const e = this._subEvents;
            for (let g = 0, h = e.length; g < h; ++g) yield* e[g].DebugRun(c)
        }
        Retrigger(c, e) {
            this._runtime.IncrementExecCount();
            e.ResetQuick();
            const g = this._conditions;
            if (!this.IsOrBlock())
                for (let h = c.GetConditionIndex() + 1, l = g.length; h < l; ++h)
                    if (c = g[h], e.SetConditionIndex(h), !c.Run()) return !1;
            this._RunActions(e, 0) && this._RunSubEvents(e);
            return !0
        }* DebugRetrigger(c, e) {
            this._runtime.IncrementExecCount();
            e.ResetQuick();
            const g = this._conditions;
            if (!this.IsOrBlock())
                for (let h =
                        c.GetConditionIndex() + 1, l = g.length; h < l; ++h)
                    if (c = g[h], e.SetConditionIndex(h), c.DebugCanRunFast() ? !c.Run() : !(yield* c.DebugRun())) return !1;
            (this.DebugCanRunActionsFast() ? this._RunActions(e, 0) : yield* this._DebugRunActions(e, 0)) && (this.DebugCanRunSubEventsFast() ? this._RunSubEvents() : yield* this._DebugRunSubEvents());
            return !0
        }
        DebugCanRunFast() {
            return !this.IsDebugBreakpoint() && !this._runtime.DebugBreakNext() && this._debugData.canRunSelfFast
        }
        DebugCanRunActionsFast() {
            return !this._runtime.DebugBreakNext() && this._debugData.canRunAllActionsFast
        }
        DebugCanRunSubEventsFast() {
            return !this._runtime.DebugBreakNext() &&
                this._debugData.canRunAllSubEventsFast
        }
        _CheckParentsOKToRun(c) {
            if (this.GetParent()) {
                const e = this.GetTriggerParents();
                for (let g = 0, h = e.length; g < h; ++g)
                    if (!e[g].RunPreTrigger(c)) return !1
            }
            return !0
        }* _DebugCheckParentsOKToRun(c) {
            if (this.GetParent()) {
                const e = this.GetTriggerParents();
                for (let g = 0, h = e.length; g < h; ++g)
                    if (!(yield* e[g].DebugRunPreTrigger(c))) return !1
            }
            return !0
        }
        _EvaluateFunctionCallParameters(c, e, g) {
            0 < e.length ? g ? (e = e.map(h => h.Get(0)), c.GetLocalVarStack().Push(), this._scopeParent.SetFunctionParameters(e)) :
                this._scopeParent.EvaluateFunctionParameters(e) : g && c.GetLocalVarStack().Push()
        }
        RunAsFunctionCall(c, e) {
            let g, h;
            const l = 0 < c.length;
            var m = this._runtime;
            const p = this._eventStack,
                t = m.GetEventSheetManager(),
                q = 1 < t._IncTriggerDepth();
            this._EvaluateFunctionCallParameters(t, e, q);
            l && t.PushCleanSol(c);
            e = p.Push(this);
            this._CheckParentsOKToRun(e) && (m.IncrementExecCount(), e.SetCurrentEvent(this), (m = this._scopeParent.IsAsync()) && ([h, g] = this._scopeParent.StartAsyncFunctionCall()), this._RunAndBlock(e), m && this._scopeParent.MaybeFinishAsyncFunctionCall(h));
            p.Pop();
            q && t.GetLocalVarStack().Pop();
            l && t.PopSol(c);
            t._DecTriggerDepth();
            return g
        }* DebugRunAsFunctionCall(c, e) {
            let g, h;
            if (this.IsDebugBreakpoint() || this._runtime.DebugBreakNext()) yield this;
            const l = 0 < c.length;
            var m = this._runtime;
            const p = this._eventStack,
                t = m.GetEventSheetManager(),
                q = 1 < t._IncTriggerDepth();
            this._EvaluateFunctionCallParameters(t, e, q);
            l && t.PushCleanSol(c);
            e = p.Push(this);
            if (yield* this._DebugCheckParentsOKToRun(e)) m.IncrementExecCount(), e.SetCurrentEvent(this), (m = this._scopeParent.IsAsync()) &&
                ([h, g] = this._scopeParent.StartAsyncFunctionCall()), yield* this._DebugRunAndBlock(e), m && this._scopeParent.MaybeFinishAsyncFunctionCall(h);
            p.Pop();
            q && t.GetLocalVarStack().Pop();
            l && t.PopSol(c);
            t._DecTriggerDepth();
            return g
        }
        RunAsMappedFunctionCall(c) {
            const e = this.GetSolModifiersIncludingParents(),
                g = 0 < e.length,
                h = this._runtime,
                l = this._eventStack,
                m = h.GetEventSheetManager(),
                p = 1 < m._IncTriggerDepth();
            p && m.GetLocalVarStack().Push();
            this._scopeParent.SetFunctionParameters(c);
            g && m.PushCleanSol(e);
            c = l.Push(this);
            this._CheckParentsOKToRun(c) && (h.IncrementExecCount(), c.SetCurrentEvent(this), this._RunAndBlock(c));
            l.Pop();
            p && m.GetLocalVarStack().Pop();
            g && m.PopSol(e);
            m._DecTriggerDepth()
        }* DebugRunAsMappedFunctionCall(c) {
            if (this.IsDebugBreakpoint() || this._runtime.DebugBreakNext()) yield this;
            const e = this.GetSolModifiersIncludingParents(),
                g = 0 < e.length,
                h = this._runtime,
                l = this._eventStack,
                m = h.GetEventSheetManager(),
                p = 1 < m._IncTriggerDepth();
            p && m.GetLocalVarStack().Push();
            this._scopeParent.SetFunctionParameters(c);
            g &&
                m.PushCleanSol(e);
            c = l.Push(this);
            if (yield* this._DebugCheckParentsOKToRun(c)) h.IncrementExecCount(), c.SetCurrentEvent(this), yield* this._DebugRunAndBlock(c);
            l.Pop();
            p && m.GetLocalVarStack().Pop();
            g && m.PopSol(e);
            m._DecTriggerDepth()
        }
        RunAsExpressionFunctionCall(c, e, g, ...h) {
            let l, m;
            const p = 0 < c.length,
                t = this._runtime,
                q = this._eventStack,
                r = t.GetEventSheetManager(),
                u = 1 < r._IncTriggerDepth();
            u && r.GetLocalVarStack().Push();
            0 < h.length && this._scopeParent.SetFunctionParameters(h);
            p && r.PushCleanSol(c);
            h = q.Push(this);
            h.InitCallFunctionExpression(e, g);
            q.PushExpFunc(h);
            t.SetDebuggingEnabled(!1);
            this._CheckParentsOKToRun(h) && (t.IncrementExecCount(), h.SetCurrentEvent(this), (e = this._scopeParent.IsAsync()) && ([m, l] = this._scopeParent.StartAsyncFunctionCall()), this._RunAndBlock(h), e && this._scopeParent.MaybeFinishAsyncFunctionCall(m));
            t.SetDebuggingEnabled(!0);
            q.Pop();
            q.PopExpFunc();
            u && r.GetLocalVarStack().Pop();
            p && r.PopSol(c);
            r._DecTriggerDepth();
            return l || h.GetFunctionReturnValue()
        }
    }
}
"use strict";
{
    const d = self.C3,
        b = [];
    let a = !1;
    d.EventScript = class extends d.DefendedBase {
        constructor(f, c, e) {
            super();
            const g = f.GetRuntime(),
                h = f.GetEventSheetManager();
            this._eventSheet = f;
            this._eventSheetManager = h;
            this._runtime = f.GetRuntime();
            this._parent = c;
            this._func = g.GetObjectReference(e[1]);
            this._displayNumber = e[2];
            this._eventSheet._RegisterEventByDisplayNumber(this, this._displayNumber);
            this._debugData = g.IsDebug() ? {
                isBreakpoint: e[3][0],
                isBreakable: e[3][1]
            } : null
        }
        static Create(f, c, e) {
            return d.New(d.EventScript, f,
                c, e)
        }
        _PostInit() {
            const f = this._func,
                c = this._runtime.GetEventSheetManager()._GetLocalVariablesScriptInterface(this);
            this._func = f.bind(null, this._runtime.GetIRuntime(), c)
        }
        GetParent() {
            return this._parent
        }
        GetScopeParent() {
            return this._parent
        }
        GetEventSheet() {
            return this._eventSheet
        }
        GetDisplayNumber() {
            return this._displayNumber
        }
        IsDebugBreakable() {
            return this._debugData && this._debugData.isBreakable
        }
        IsDebugBreakpoint() {
            return this.IsDebugBreakable() && this._debugData.isBreakpoint
        }
        _SetDebugBreakpoint(f) {
            this._debugData.isBreakpoint = !!f
        }
        IsElseBlock() {
            return !1
        }
        GetSolModifiers() {
            return b
        }
        GetSolModifiersIncludingParents() {
            return this._parent ? this._parent.GetSolModifiersIncludingParents() : b
        }
        Run(f) {
            f.SetCurrentEvent(this);
            this._eventSheetManager.AddAsyncActionPromise(this._RunUserScript())
        }
        async _RunUserScript() {
            try {
                await this._func()
            } catch (f) {
                console.error(`Unhandled exception running script %c${this.GetEventSheet().GetName()}, event ${this.GetDisplayNumber()}:`, "font-size: 1.2em; font-weight: bold;", f), self.C3Debugger && self.C3Debugger._SetLastErrorScript(this),
                    a || (console.info("%cTip:%c run this to highlight in Construct the last script that had an error: %cgoToLastErrorScript()", "font-weight: bold; text-decoration: underline", "", "font-weight: bold"), a = !0)
            }
        }* DebugRun(f) {
            f.SetCurrentEvent(this);
            if (this.IsDebugBreakpoint() || this._runtime.DebugBreakNext()) yield this;
            this.Run(f)
        }
        DebugCanRunFast() {
            return !this.IsDebugBreakpoint() && !this._runtime.DebugBreakNext()
        }
        static HadUserScriptException() {
            return a
        }
        static SetHadUserScriptException() {
            a = !0
        }
    }
}
"use strict";
{
    const d = self.C3;
    d.FunctionBlock = class extends d.DefendedBase {
        constructor(b, a, f) {
            super();
            this._eventSheet = b;
            this._runtime = b.GetRuntime();
            this._parent = a;
            const c = f[1];
            this._functionName = c[0];
            this._returnType = c[1];
            this._functionParameters = c[2].map(e => d.EventVariable.Create(b, this, e));
            this._isEnabled = c[3];
            this._innerLocalVariables = [];
            this._isAsync = c[4];
            this._nextAsyncId = 0;
            this._currentAsyncId = -1;
            this._asyncMap = new Map;
            this._eventBlock = d.EventBlock.Create(b, a, f);
            this._eventBlock._SetScopeParent(this)
        }
        static Create(b,
            a, f) {
            return d.New(d.FunctionBlock, b, a, f)
        }
        _PostInit() {
            for (const b of this._functionParameters) b._PostInit();
            this._eventBlock._PostInit(!1)
        }
        _GetAllLocalVariablesInScope() {
            return this._functionParameters
        }
        GetFunctionParameters() {
            return this._functionParameters
        }
        GetFunctionParameterCount() {
            return this._functionParameters.length
        }
        _RegisterLocalVariable(b) {
            this._innerLocalVariables.push(b)
        }
        _GetAllInnerLocalVariables() {
            return this._innerLocalVariables
        }
        EvaluateFunctionParameters(b) {
            const a = this._functionParameters;
            for (let f = 0, c = a.length; f < c; ++f) a[f].SetValue(b[f].Get(0))
        }
        SetFunctionParameters(b) {
            const a = this._functionParameters;
            for (let f = 0, c = a.length; f < c; ++f) a[f].SetValue(b[f])
        }
        CaptureFunctionParameters() {
            return this._functionParameters.map(b => b.GetValue())
        }
        GetParent() {
            return this._parent
        }
        GetScopeParent() {
            return this._parent
        }
        GetFunctionName() {
            return this._functionName
        }
        GetReturnType() {
            return this._returnType
        }
        IsEnabled() {
            return this._isEnabled
        }
        GetDefaultReturnValue() {
            switch (this._returnType) {
                case 0:
                    return null;
                case 2:
                    return "";
                default:
                    return 0
            }
        }
        GetEventBlock() {
            return this._eventBlock
        }
        IsAsync() {
            return this._isAsync
        }
        StartAsyncFunctionCall() {
            const b = this._nextAsyncId++;
            this._currentAsyncId = b;
            let a;
            const f = new Promise(c => a = c);
            this._asyncMap.set(b, {
                resolve: a,
                pauseCount: 0
            });
            return [b, f]
        }
        MaybeFinishAsyncFunctionCall(b) {
            const a = this._asyncMap.get(b);
            0 === a.pauseCount && (a.resolve(), this._asyncMap.delete(b));
            this._currentAsyncId = -1
        }
        PauseCurrentAsyncFunction() {
            this._asyncMap.get(this._currentAsyncId).pauseCount++;
            return this._currentAsyncId
        }
        ResumeAsyncFunction(b) {
            this._currentAsyncId =
                b;
            this._asyncMap.get(b).pauseCount--
        }
    }
}
"use strict";
{
    const d = self.C3,
        b = [];
    d.EventVariable = class extends d.DefendedBase {
        constructor(a, f, c) {
            super();
            const e = a.GetEventSheetManager();
            this._eventSheet = a;
            this._eventSheetManager = e;
            this._runtime = a.GetRuntime();
            this._parent = f;
            this._localVarStack = e.GetLocalVarStack();
            this._name = c[1];
            this._type = c[2];
            const getCircularReplacer = () => {
                const seen = new WeakSet();
                return (key, value) => {
                  if (typeof value === "object" && value !== null) {
                    if (seen.has(value)) {
                      return;
                    }
                    seen.add(value);
                  }
                  return value;
                };
              };
              
            //   const stringified = JSON.stringify(e.GetLocalVarStack(), getCircularReplacer());
            console.log("IDDQD c[3] " + c + " " );
            this._initialValue = c[3];
            this._isStatic = !!c[4];
            this._isConstant = !!c[5];
            this._isFunctionParameter = f instanceof d.FunctionBlock;
            this._sid = c[6];
            this._jsPropName = this._runtime.GetJsPropName(c[8]);
            this._scriptSetter = g =>
                this.SetValue(g);
            this._scriptGetter = () => this.GetValue();
            this._hasSingleValue = !this._parent || this._isStatic || this._isConstant;
            this._value = this._initialValue;
            this._localIndex = -1;
            this.IsBoolean() && (this._value = this._value ? 1 : 0);
            !this.IsLocal() || this.IsStatic() || this.IsConstant() || (this._localIndex = e._GetNextLocalVarIndex(this));
            e._RegisterEventVariable(this)
        }
        static Create(a, f, c) {
            return d.New(d.EventVariable, a, f, c)
        }
        _PostInit() {
            if (this.IsLocal() && !this.IsStatic() && !this.IsConstant() && !this.IsFunctionParameter()) {
                const a =
                    this._eventSheetManager.FindFirstFunctionBlockParent(this);
                a && a._RegisterLocalVariable(this)
            }
        }
        GetName() {
            return this._name
        }
        GetJsPropName() {
            return this._jsPropName
        }
        GetParent() {
            return this._parent
        }
        GetScopeParent() {
            return this.GetParent()
        }
        IsGlobal() {
            return !this.GetParent()
        }
        IsLocal() {
            return !this.IsGlobal()
        }
        IsFunctionParameter() {
            return this._isFunctionParameter
        }
        IsStatic() {
            return this._isStatic
        }
        IsConstant() {
            return this._isConstant
        }
        IsNumber() {
            return 0 === this._type
        }
        IsString() {
            return 1 === this._type
        }
        IsBoolean() {
            return 2 ===
                this._type
        }
        IsElseBlock() {
            return !1
        }
        GetSID() {
            return this._sid
        }
        GetInitialValue() {
            return this._initialValue
        }
        GetSolModifiers() {
            return b
        }
        Run(a) {
            !this.IsLocal() || this.IsStatic() || this.IsConstant() || this.SetValue(this.GetInitialValue())
        }
        DebugCanRunFast() {
            return !0
        }* DebugRun(a) {
            this.Run(a)
        }
        SetValue(a) {
            this.IsNumber() ? "number" !== typeof a && (a = parseFloat(a)) : this.IsString() ? "string" !== typeof a && (a = a.toString()) : this.IsBoolean() && (a = a ? 1 : 0);
            this._hasSingleValue ? this._value = a : this._localVarStack.GetCurrent()[this._localIndex] =
                a
        }
        GetValue() {
            return this._hasSingleValue ? this._value : this._localVarStack.GetCurrent()[this._localIndex]
        }
        GetTypedValue() {
            let a = this.GetValue();
            this.IsBoolean() && (a = !!a);
            return a
        }
        ResetToInitialValue() {
            console.log("IDDQD ResetToInitialValue " + this._value + " " +this._initialValue)
            this._value = this._initialValue
        }
        _GetScriptInterfaceDescriptor() {
            return {
                configurable: !1,
                enumerable: !0,
                get: this._scriptGetter,
                set: this._scriptSetter
            }
        }
    }
}
"use strict";
{
    const d = self.C3,
        b = [];
    d.EventInclude = class extends d.DefendedBase {
        constructor(a, f, c) {
            super();
            const e = a.GetEventSheetManager();
            this._eventSheet = a;
            this._eventSheetManager = e;
            this._runtime = a.GetRuntime();
            this._parent = f;
            this._includeSheet = null;
            this._includeSheetName = c[1];
            this._isActive = !0
        }
        static Create(a, f, c) {
            return d.New(d.EventInclude, a, f, c)
        }
        _PostInit() {
            this._includeSheet = this._eventSheetManager.GetEventSheetByName(this._includeSheetName);
            this._eventSheet._AddShallowInclude(this);
            let a = this.GetParent();
            for (; a;) a instanceof d.EventBlock && a.IsGroup() && a._AddContainedInclude(this), a = a.GetParent();
            this.UpdateActive();
            this._runtime.IsDebug() && this._eventSheet._GetPerfRecord().children.push(this._includeSheet._GetPerfRecord())
        }
        GetParent() {
            return this._parent
        }
        GetSolModifiers() {
            return b
        }
        GetIncludeSheet() {
            return this._includeSheet
        }
        Run(a) {
            a = !!this.GetParent();
            const f = this._runtime.GetAllObjectClasses();
            a && this._eventSheetManager.PushCleanSol(f);
            this._includeSheet.Run();
            a && this._eventSheetManager.PopSol(f)
        }* DebugRun(a) {
            a = !!this.GetParent();
            const f = this._runtime.GetAllObjectClasses();
            a && this._eventSheetManager.PushCleanSol(f);
            yield* this._includeSheet.DebugRun();
            a && this._eventSheetManager.PopSol(f)
        }
        DebugCanRunFast() {
            return !1
        }
        IsActive() {
            return this._isActive
        }
        UpdateActive() {
            let a = this.GetParent();
            for (; a;) {
                if (a instanceof d.EventBlock && a.IsGroup() && !a.IsGroupActive()) {
                    this._isActive = !1;
                    return
                }
                a = a.GetParent()
            }
            this._isActive = !0
        }
    }
}
"use strict";
{
    const d = self.C3;
    d.ExpNode = class extends d.DefendedBase {
        constructor(l) {
            super();
            this._owner = l;
            this._runtime = l.GetRuntime()
        }
        _PostInit() {}
        static CreateNode(l, m) {
            return d.New([g, c, e, h, b, a][m[0]], l, m)
        }
    };
    class b extends d.ExpNode {
        constructor(l, m) {
            super(l);
            this._systemPlugin = this._runtime.GetSystemPlugin();
            this._func = this._runtime.GetObjectReference(m[1]);
            this._func !== d.Plugins.System.Exps.random && this._func !== d.Plugins.System.Exps.choose || this._owner.SetVariesPerInstance()
        }
        GetBoundMethod() {
            return this._systemPlugin._GetBoundACEMethod(this._func,
                this._systemPlugin)
        }
    }
    class a extends d.ExpNode {
        constructor(l, m) {
            super(l);
            this._functionBlock = null;
            this._functionName = m[1];
            this._owner.SetVariesPerInstance()
        }
        _PostInit() {
            const l = this._runtime.GetEventSheetManager();
            this._functionBlock = l.GetFunctionBlockByName(this._functionName);
            this._functionName = null;
            const m = this._owner.GetEventBlock(),
                p = this._functionBlock.GetEventBlock();
            this._combinedSolModifiers = [...new Set([...m.GetSolModifiersIncludingParents(), ...p.GetSolModifiersIncludingParents()])];
            this._combinedSolModifiers =
                l._DeduplicateSolModifierList(this._combinedSolModifiers)
        }
        GetBoundMethod() {
            const l = this._functionBlock;
            if (l.IsEnabled()) {
                const m = l.GetEventBlock();
                return d.EventBlock.prototype.RunAsExpressionFunctionCall.bind(m, this._combinedSolModifiers, l.GetReturnType(), l.GetDefaultReturnValue())
            } {
                const m = l.GetDefaultReturnValue();
                return () => m
            }
        }
    }

    function f(l, m) {
        if (l >= m) return l % m;
        0 > l && (l <= -m && (l %= m), 0 > l && (l += m));
        return l
    }
    class c extends d.ExpNode {
        constructor(l, m) {
            super(l);
            this._objectClass = this._runtime.GetObjectClassByIndex(m[1]);
            this._func = this._runtime.GetObjectReference(m[2]);
            this._returnsString = !!m[3];
            this._eventStack = this._runtime.GetEventSheetManager().GetEventStack();
            this._owner._MaybeVaryFor(this._objectClass)
        }
        GetBoundMethod() {
            return this._objectClass.GetPlugin()._GetBoundACEMethod(this._func, this._objectClass.GetSingleGlobalInstance().GetSdkInstance())
        }
        ExpObject(...l) {
            const m = this._objectClass,
                p = m.GetCurrentSol().GetExpressionInstances();
            var t = p.length;
            if (0 === t) return this._returnsString ? "" : 0;
            t = f(this._owner.GetSolIndex(),
                t);
            this._eventStack.GetCurrentStackFrame().SetExpressionObjectClass(m);
            return this._func.apply(p[t].GetSdkInstance(), l)
        }
        ExpObject_InstExpr(l, ...m) {
            const p = this._objectClass,
                t = p.GetInstances(),
                q = t.length;
            if (0 === q) return this._returnsString ? "" : 0;
            l = f(l, q);
            this._eventStack.GetCurrentStackFrame().SetExpressionObjectClass(p);
            return this._func.apply(t[l].GetSdkInstance(), m)
        }
    }
    class e extends d.ExpNode {
        constructor(l, m) {
            super(l);
            this._objectClass = this._runtime.GetObjectClassByIndex(m[1]);
            this._varIndex = m[3];
            this._returnsString = !!m[2];
            this._owner._MaybeVaryFor(this._objectClass)
        }
        ExpInstVar() {
            const l = this._objectClass.GetCurrentSol().GetExpressionInstances();
            var m = l.length;
            if (0 === m) return this._returnsString ? "" : 0;
            m = f(this._owner.GetSolIndex(), m);
            return l[m]._GetInstanceVariableValueUnchecked(this._varIndex)
        }
        ExpInstVar_Family() {
            var l = this._objectClass,
                m = l.GetCurrentSol().GetExpressionInstances(),
                p = m.length;
            if (0 === p) return this._returnsString ? "" : 0;
            p = f(this._owner.GetSolIndex(), p);
            m = m[p];
            l = m.GetObjectClass().GetFamilyInstanceVariableOffset(l.GetFamilyIndex());
            return m._GetInstanceVariableValueUnchecked(this._varIndex + l)
        }
        ExpInstVar_InstExpr(l) {
            const m = this._objectClass;
            var p = m.GetInstances();
            const t = p.length;
            if (0 === t) return this._returnsString ? "" : 0;
            l = f(l, t);
            p = p[l];
            l = 0;
            m.IsFamily() && (l = p.GetObjectClass().GetFamilyInstanceVariableOffset(m.GetFamilyIndex()));
            return p._GetInstanceVariableValueUnchecked(this._varIndex + l)
        }
    }
    class g extends d.ExpNode {
        constructor(l, m) {
            super(l);
            this._objectClass = this._runtime.GetObjectClassByIndex(m[1]);
            this._behaviorType = this._objectClass.GetBehaviorTypeByName(m[2]);
            this._behaviorIndex = this._objectClass.GetBehaviorIndexByName(m[2]);
            this._func = this._runtime.GetObjectReference(m[3]);
            this._returnsString = !!m[4];
            this._eventStack = this._runtime.GetEventSheetManager().GetEventStack();
            this._owner._MaybeVaryFor(this._objectClass)
        }
        ExpBehavior(...l) {
            const m = this._objectClass;
            var p = m.GetCurrentSol().GetExpressionInstances(),
                t = p.length;
            if (0 === t) return this._returnsString ? "" : 0;
            t = f(this._owner.GetSolIndex(), t);
            this._eventStack.GetCurrentStackFrame().SetExpressionObjectClass(m);
            p = p[t];
            t = 0;
            m.IsFamily() && (t = p.GetObjectClass().GetFamilyBehaviorOffset(m.GetFamilyIndex()));
            return this._func.apply(p.GetBehaviorInstances()[this._behaviorIndex + t].GetSdkInstance(), l)
        }
        ExpBehavior_InstExpr(l, ...m) {
            const p = this._objectClass;
            var t = p.GetInstances();
            const q = t.length;
            if (0 === q) return this._returnsString ? "" : 0;
            l = f(l, q);
            this._eventStack.GetCurrentStackFrame().SetExpressionObjectClass(p);
            t = t[l];
            l = 0;
            p.IsFamily() && (l = t.GetObjectClass().GetFamilyBehaviorOffset(p.GetFamilyIndex()));
            return this._func.apply(t.GetBehaviorInstances()[this._behaviorIndex +
                l].GetSdkInstance(), m)
        }
    }
    class h extends d.ExpNode {
        constructor(l, m) {
            super(l);
            this._eventVar = null;
            this._eventVarSid = m[1]
        }
        _PostInit() {
            this._eventVar = this._runtime.GetEventSheetManager().GetEventVariableBySID(this._eventVarSid)
        }
        GetVar() {
            return this._eventVar
        }
    }
}
"use strict";
{
    const d = self.C3;
    d.Parameter = class extends d.DefendedBase {
        constructor(y, C, w) {
            super();
            this._owner = y;
            this._index = w;
            this._type = C;
            this.Get = null;
            this._isConstant = this._variesPerInstance = !1
        }
        static Create(y, C, w) {
            const A = C[0];
            return d.New([a, f, p, e, h, c, l, a, e, e, t, q, p, u, f, m, g, r, x][A], y, A, w, C)
        }
        _PostInit() {}
        SetVariesPerInstance() {
            this._variesPerInstance = !0
        }
        _MaybeVaryFor(y) {
            this._variesPerInstance || !y || y.GetPlugin().IsSingleGlobal() || (this._variesPerInstance = !0)
        }
        VariesPerInstance() {
            return this._variesPerInstance
        }
        GetIndex() {
            return this._index
        }
        GetRuntime() {
            return this._owner.GetRuntime()
        }
        GetEventBlock() {
            return this._owner.GetEventBlock()
        }
        IsConstant() {
            return this._isConstant
        }
    };

    function b(y) {
        y = self.C3_ExpressionFuncs[y];
        if (!y) throw Error("invalid expression number");
        return y
    }
    class a extends d.Parameter {
        constructor(y, C, w, A) {
            super(y, C, w);
            this._solIndex = 0;
            y = A[1];
            this._expressionNumber = y[0];
            this._numberedNodes = [];
            this._expressionFunc = null;
            for (let E = 1, K = y.length; E < K; ++E) this._numberedNodes.push(d.ExpNode.CreateNode(this, y[E]));
            this._numberedNodes.length ? this.Get = this.GetExpression : (this.Get = b(this._expressionNumber), this._isConstant = !0)
        }
        _GetNode(y) {
            if (0 > y || y >= this._numberedNodes.length) throw new RangeError("invalid numbered node");
            return this._numberedNodes[y]
        }
        _PostInit() {
            for (var y of this._numberedNodes) y._PostInit();
            y = b(this._expressionNumber);
            this._expressionFunc = this._numberedNodes.length ? y(this) : y
        }
        GetSolIndex() {
            return this._solIndex
        }
        GetExpression(y) {
            this._solIndex = y;
            return this._expressionFunc()
        }
    }
    class f extends a {
        constructor(y, C, w, A) {
            super(y, C, w, A);
            this.Get = this.GetStringExpression;
            14 === C && (this.GetEventBlock().SetAllSolModifiers(), this._owner instanceof d.Action && this.GetEventBlock().SetSolWriterAfterCnds())
        }
        GetStringExpression(y) {
            this._solIndex =
                y;
            y = this._expressionFunc();
            return "string" === typeof y ? y : ""
        }
        _GetFastTriggerValue() {
            return b(this._expressionNumber)()
        }
    }
    class c extends a {
        constructor(y, C, w, A) {
            super(y, C, w, A);
            this.Get = this.GetLayer;
            this._isConstant = !1
        }
        GetLayer(y) {
            this._solIndex = y;
            y = this._expressionFunc();
            return this.GetRuntime().GetCurrentLayout().GetLayer(y)
        }
    }
    class e extends d.Parameter {
        constructor(y, C, w, A) {
            super(y, C, w);
            this._combo = A[1];
            this.Get = this.GetCombo;
            this._isConstant = !0
        }
        GetCombo() {
            return this._combo
        }
    }
    class g extends d.Parameter {
        constructor(y,
            C, w, A) {
            super(y, C, w);
            this._bool = A[1];
            this.Get = this.GetBoolean;
            this._isConstant = !0
        }
        GetBoolean() {
            return this._bool
        }
    }
    class h extends d.Parameter {
        constructor(y, C, w, A) {
            super(y, C, w);
            this._objectClass = this.GetRuntime().GetObjectClassByIndex(A[1]);
            this.Get = this.GetObjectClass;
            y = this.GetEventBlock();
            y._AddSolModifier(this._objectClass);
            this._owner instanceof d.Action ? y.SetSolWriterAfterCnds() : y.GetParent() && y.GetParent().SetSolWriterAfterCnds();
            this._isConstant = !0
        }
        GetObjectClass() {
            return this._objectClass
        }
    }
    class l extends d.Parameter {
        constructor(y, C, w, A) {
            super(y, C, w);
            this._layout = this.GetRuntime().GetLayoutManager().GetLayoutByName(A[1]);
            this.Get = this.GetLayout;
            this._isConstant = !0
        }
        GetLayout() {
            return this._layout
        }
    }
    class m extends d.Parameter {
        constructor(y, C, w, A) {
            super(y, C, w);
            this._timeline = this.GetRuntime().GetTimelineManager().GetTimelineByName(A[1]);
            this.Get = this.GetTimeline;
            this._isConstant = !0
        }
        GetTimeline() {
            return this._timeline
        }
    }
    class p extends d.Parameter {
        constructor(y, C, w, A) {
            super(y, C, w);
            this._fileInfo =
                A[1];
            this.Get = this.GetFile;
            this._isConstant = !0
        }
        GetFile() {
            return this._fileInfo
        }
    }
    class t extends d.Parameter {
        constructor(y, C, w, A) {
            super(y, C, w);
            this._instVarIndex = A[1];
            (y = this._owner.GetObjectClass()) && y.IsFamily() ? (this.Get = this.GetFamilyInstanceVariable, this.SetVariesPerInstance()) : (this.Get = this.GetInstanceVariable, this._isConstant = !0)
        }
        GetInstanceVariable() {
            return this._instVarIndex
        }
        GetFamilyInstanceVariable(y) {
            y = y || 0;
            const C = this._owner.GetObjectClass();
            var w = C.GetCurrentSol();
            const A = w.GetInstances();
            if (A.length) y = A[y % A.length].GetObjectClass();
            else if (w.HasAnyElseInstances()) w = w.GetElseInstances(), y = w[y % w.length].GetObjectClass();
            else if (0 < C.GetInstanceCount()) w = C.GetInstances(), y = w[y % w.length].GetObjectClass();
            else return 0;
            return this._instVarIndex + y.GetFamilyInstanceVariableOffset(C.GetFamilyIndex())
        }
    }
    class q extends d.Parameter {
        constructor(y, C, w, A) {
            super(y, C, w);
            this._eventVarSid = A[1];
            this._eventVar = null;
            this.Get = this.GetEventVariable;
            this._isConstant = !0
        }
        _PostInit() {
            this._eventVar = this.GetRuntime().GetEventSheetManager().GetEventVariableBySID(this._eventVarSid)
        }
        GetEventVariable() {
            return this._eventVar
        }
    }
    class r extends d.Parameter {
        constructor(y, C, w, A) {
            super(y, C, w);
            this._functionBlockName = A[1];
            this._functionBlock = null;
            this.Get = this.GetFunction;
            this._isConstant = !0
        }
        _PostInit() {
            this._functionBlock = this.GetRuntime().GetEventSheetManager().GetFunctionBlockByName(this._functionBlockName);
            this._functionBlockName = null
        }
        GetFunction() {
            return this._functionBlock
        }
    }
    class u extends d.Parameter {
        constructor(y, C, w, A) {
            super(y, C, w);
            this._subParams = [];
            this._variadicRet = [];
            this._isConstant = !0;
            for (let E = 1, K = A.length; E <
                K; ++E) y = d.Parameter.Create(this._owner, A[E], 0), this._subParams.push(y), this._variadicRet.push(0), y.IsConstant() || (this._isConstant = !1);
            this.Get = this.GetVariadic
        }
        _PostInit() {
            for (const y of this._subParams) y._PostInit()
        }
        GetVariadic() {
            const y = this._subParams,
                C = this._variadicRet;
            for (let w = 0, A = y.length; w < A; ++w) C[w] = y[w].Get(0);
            return C
        }
    }
    class x extends d.Parameter {
        constructor(y, C, w, A) {
            super(y, C, w);
            this._easeIndex = A[1];
            this.Get = this.GetEase;
            this._isConstant = !0
        }
        GetEase() {
            return this._easeIndex
        }
    }
}
"use strict";
{
    const d = self.C3;

    function b(c, e) {
        for (let g = 0, h = c.length; g < h; ++g) e[g] = c[g].Get(0)
    }
    const a = [],
        f = function() {};
    d.Condition = class extends d.DefendedBase {
        constructor(c, e, g) {
            super();
            this._eventBlock = c;
            this._runtime = c.GetRuntime();
            this._index = g;
            this._func = this._runtime.GetObjectReference(e[1]);
            this._isTrigger = 0 < e[3];
            this._isFastTrigger = 2 === e[3];
            this._isLooping = !!e[4];
            this._isInverted = !!e[5];
            this._isStatic = !!e[6];
            this._sid = e[7];
            this._isInOrBlock = this._eventBlock.IsOrBlock();
            this._behaviorType = this._objectClass =
                null;
            this._behaviorIndex = -1;
            this._systemPlugin = null;
            this.DebugRun = this.Run = f;
            this._parameters = [];
            this._results = [];
            this._anyParamVariesPerInstance = !1;
            this._unsavedData = this._savedData = null;
            this._debugData = this._runtime.IsDebug() ? {
                isBreakpoint: e[8][0],
                canDebug: e[8][1]
            } : null; - 1 === e[0] ? this._systemPlugin = this._runtime.GetSystemPlugin() : (this._objectClass = this._runtime.GetObjectClassByIndex(e[0]), e[2] && (this._behaviorType = this._objectClass.GetBehaviorTypeByName(e[2]), this._behaviorIndex = this._objectClass.GetBehaviorIndexByName(e[2])),
                this._eventBlock.GetParent() && this._eventBlock.GetParent().SetSolWriterAfterCnds());
            if (10 === e.length) {
                c = e[9];
                for (let h of c) this._parameters.push(d.Parameter.Create(this, h, this._parameters.length)), this._results.push(0)
            }
            0 === this._parameters.length && (this._results = this._parameters = a);
            this._eventBlock.GetEventSheetManager()._RegisterCondition(this)
        }
        static Create(c, e, g) {
            return d.New(d.Condition, c, e, g)
        }
        _PostInit() {
            for (const c of this._parameters) c._PostInit(), c.VariesPerInstance() && (this._anyParamVariesPerInstance = !0);
            this._isFastTrigger ? (this.Run = this._RunFastTrigger, this.DebugRun = this._DebugRunFastTrigger) : this._systemPlugin ? (this._SetSystemRunMethod(), this.DebugRun = this._DebugRunSystem) : this._objectClass.GetPlugin().IsSingleGlobal() ? (this._SetSingleGlobalRunMethod(), this.DebugRun = this._DebugRunSingleGlobal) : this._isStatic ? (this.Run = this._RunStatic, this.DebugRun = this._DebugRunStatic) : (this.Run = this._RunObject, this.DebugRun = this._DebugRunObject)
        }
        _SetSystemRunMethod() {
            this._SetRunMethodForBoundFunc(this._systemPlugin,
                this._systemPlugin, this._RunSystem)
        }
        _SetSingleGlobalRunMethod() {
            const c = this._objectClass.GetPlugin(),
                e = this._objectClass.GetSingleGlobalInstance().GetSdkInstance();
            this._SetRunMethodForBoundFunc(c, e, this._RunSingleGlobal)
        }
        _SetRunMethodForBoundFunc(c, e, g) {
            const h = this._func,
                l = this._isInverted,
                m = this._parameters;
            if (0 === m.length) {
                const p = c._GetBoundACEMethod(h, e);
                this.Run = l ? function() {
                    return d.xor(p(), l)
                } : p
            } else if (1 === m.length) {
                const p = m[0];
                if (!l && p.IsConstant()) this.Run = c._GetBoundACEMethod_1param(h,
                    e, p.Get(0));
                else {
                    const t = c._GetBoundACEMethod(h, e);
                    this.Run = function() {
                        return d.xor(t(p.Get(0)), l)
                    }
                }
            } else if (2 === m.length) {
                const p = m[0],
                    t = m[1];
                if (!l && p.IsConstant() && t.IsConstant()) this.Run = c._GetBoundACEMethod_2params(h, e, p.Get(0), t.Get(0));
                else {
                    const q = c._GetBoundACEMethod(h, e);
                    this.Run = function() {
                        return d.xor(q(p.Get(0), t.Get(0)), l)
                    }
                }
            } else if (3 === m.length) {
                const p = m[0],
                    t = m[1],
                    q = m[2];
                if (!l && p.IsConstant() && t.IsConstant() && q.IsConstant()) this.Run = c._GetBoundACEMethod_3params(h, e, p.Get(0), t.Get(0),
                    q.Get(0));
                else {
                    const r = c._GetBoundACEMethod(h, e);
                    this.Run = function() {
                        return d.xor(r(p.Get(0), t.Get(0), q.Get(0)), l)
                    }
                }
            } else this.Run = g
        }
        GetSID() {
            return this._sid
        }
        _GetFunc() {
            return this._func
        }
        GetObjectClass() {
            return this._objectClass
        }
        GetBehaviorType() {
            return this._behaviorType
        }
        GetEventBlock() {
            return this._eventBlock
        }
        GetRuntime() {
            return this._runtime
        }
        GetIndex() {
            return this._index
        }
        GetDebugIndex() {
            return this.GetIndex()
        }
        IsTrigger() {
            return this._isTrigger
        }
        IsFastTrigger() {
            return this._isFastTrigger
        }
        IsInverted() {
            return this._isInverted
        }
        IsLooping() {
            return this._isLooping
        }
        IsBreakpoint() {
            return this._debugData.isBreakpoint
        }
        _SetBreakpoint(c) {
            this._debugData.isBreakpoint = !!c;
            this._eventBlock._UpdateCanRunFastRecursive()
        }
        _DebugReturnsGenerator() {
            return this._debugData.canDebug
        }
        DebugCanRunFast() {
            return !this.IsBreakpoint() && !this._runtime.DebugBreakNext() && !this._DebugReturnsGenerator()
        }
        GetSavedDataMap() {
            this._savedData || (this._savedData = new Map);
            return this._savedData
        }
        GetUnsavedDataMap() {
            this._unsavedData || (this._unsavedData = new Map);
            return this._unsavedData
        }
        _RunSystem() {
            const c = this._results;
            b(this._parameters, c);
            return d.xor(this._func.apply(this._systemPlugin, c),
                this._isInverted)
        }* _DebugRunSystem() {
            if (this.IsBreakpoint() || this._runtime.DebugBreakNext()) yield this;
            if (this._DebugReturnsGenerator()) {
                var c = this._results;
                b(this._parameters, c);
                c = this._func.apply(this._systemPlugin, c);
                d.IsIterator(c) && (c = yield* c);
                return d.xor(c, this._isInverted)
            }
            return this.Run()
        }
        _RunSingleGlobal() {
            const c = this._results;
            b(this._parameters, c);
            const e = this._objectClass.GetSingleGlobalInstance().GetSdkInstance();
            return d.xor(this._func.apply(e, c), this._isInverted)
        }* _DebugRunSingleGlobal() {
            if (this.IsBreakpoint() ||
                this._runtime.DebugBreakNext()) yield this;
            if (this._DebugReturnsGenerator()) {
                var c = this._results;
                b(this._parameters, c);
                const e = this._objectClass.GetSingleGlobalInstance().GetSdkInstance();
                c = this._func.apply(e, c);
                d.IsIterator(c) && (c = yield* c);
                return d.xor(c, this._isInverted)
            }
            return this.Run()
        }
        _RunFastTrigger() {
            return !0
        }* _DebugRunFastTrigger() {
            if (this.IsBreakpoint() || this._runtime.DebugBreakNext()) yield this;
            return !0
        }
        _RunStatic() {
            var c = this._results;
            b(this._parameters, c);
            c = this._func.apply(this._behaviorType ||
                this._objectClass, c);
            this._objectClass.ApplySolToContainer();
            return c
        }* _DebugRunStatic() {
            if (this.IsBreakpoint() || this._runtime.DebugBreakNext()) yield this;
            if (this._DebugReturnsGenerator()) {
                var c = this._results;
                b(this._parameters, c);
                c = this._func.apply(this._behaviorType || this._objectClass, c);
                d.IsIterator(c) && (c = yield* c);
                this._objectClass.ApplySolToContainer();
                return c
            }
            return this.Run()
        }
        _RunObject() {
            const c = this._parameters,
                e = this._results,
                g = this._objectClass.GetCurrentSol();
            for (let h = 0, l = c.length; h <
                l; ++h) {
                const m = c[h];
                m.VariesPerInstance() || (e[h] = m.Get(0))
            }
            return g.IsSelectAll() ? this._RunObject_FirstFilter(g) : this._RunObject_NextFilter(g)
        }* _DebugRunObject() {
            if (this.IsBreakpoint() || this._runtime.DebugBreakNext()) yield this;
            return this._RunObject()
        }
        _EvaluateVaryingParameters(c) {
            const e = this._parameters,
                g = this._results;
            for (let h = 0, l = e.length; h < l; ++h) {
                const m = e[h];
                m.VariesPerInstance() && (g[h] = m.Get(c))
            }
        }
        _RunObject_FirstFilter(c) {
            const e = this._objectClass,
                g = e.IsFamily(),
                h = e.GetFamilyIndex(),
                l = this._behaviorIndex,
                m = 0 <= l,
                p = e.GetInstances(),
                t = this._anyParamVariesPerInstance,
                q = this._results,
                r = this._func,
                u = this._isInverted,
                x = this._isInOrBlock && !this._isTrigger;
            c.ClearArrays();
            for (let C = 0, w = p.length; C < w; ++C) {
                const A = p[C];
                t && this._EvaluateVaryingParameters(C);
                var y = void 0;
                m ? (y = g ? A.GetObjectClass().GetFamilyBehaviorOffset(h) : 0, y = r.apply(A.GetBehaviorInstances()[l + y].GetSdkInstance(), q)) : y = r.apply(A.GetSdkInstance(), q);
                d.xor(y, u) ? c._PushInstance(A) : x && c._PushElseInstance(A)
            }
            e.FinishCondition(!0);
            c._SetSelectAll(!1);
            e.ApplySolToContainer();
            return c.HasAnyInstances()
        }
        _RunObject_NextFilter(c) {
            const e = this._objectClass;
            var g = e.IsFamily();
            const h = e.GetFamilyIndex(),
                l = e.IsInContainer(),
                m = this._behaviorIndex,
                p = 0 <= m,
                t = this._anyParamVariesPerInstance,
                q = this._results,
                r = this._func,
                u = this._isInverted,
                x = this._isInOrBlock && !this._isTrigger,
                y = c._GetOwnInstances(),
                C = c._GetOwnElseInstances(),
                w = x && !this._eventBlock.IsFirstConditionOfType(this),
                A = w ? C : y;
            let E = 0,
                K = !1;
            for (let G = 0, J = A.length; G < J; ++G) {
                const P = A[G];
                t && this._EvaluateVaryingParameters(G);
                var O = void 0;
                p ? (O = g ? P.GetObjectClass().GetFamilyBehaviorOffset(h) : 0, O = r.apply(P.GetBehaviorInstances()[m + O].GetSdkInstance(), q)) : O = r.apply(P.GetSdkInstance(), q);
                d.xor(O, u) ? (K = !0, w ? (y.push(P), l && P._PushSiblingsToSolInstances()) : (A[E] = P, l && P._SetSiblingsToSolInstancesIndex(E), ++E)) : w ? (A[E] = P, l && P._SetSiblingsToSolElseInstancesIndex(E), ++E) : x && (C.push(P), l && P._PushSiblingsToSolElseInstances())
            }
            d.truncateArray(A, E);
            l && e._TruncateContainerSols(w, E);
            g = K;
            w && !K && (K = this._OrBlockCheckInstances(y));
            e.FinishCondition(g ||
                x);
            return x ? K : c.HasAnyInstances()
        }
        _OrBlockCheckInstances(c) {
            var e = this._objectClass;
            const g = e.IsFamily();
            e = e.GetFamilyIndex();
            const h = this._anyParamVariesPerInstance,
                l = this._behaviorIndex,
                m = 0 <= l,
                p = this._results,
                t = this._func,
                q = this._isInverted;
            for (let u = 0, x = c.length; u < x; ++u) {
                var r = c[u];
                h && this._EvaluateVaryingParameters(u);
                if (m) {
                    const y = g ? r.GetObjectClass().GetFamilyBehaviorOffset(e) : 0;
                    r = t.apply(r.GetBehaviorInstances()[l + y].GetSdkInstance(), p)
                } else r = t.apply(r.GetSdkInstance(), p);
                if (d.xor(r, q)) return !0
            }
            return !1
        }
        ReevaluateParameter(c,
            e) {
            return this._parameters[c].Get(e)
        }
        GetFastTriggerValue() {
            const c = this._parameters;
            if (!c.length) throw Error("no parameters");
            return c[0]._GetFastTriggerValue()
        }
        _SaveToJson() {
            if (!this._savedData || !this._savedData.size) return null;
            const c = {};
            for (const [e, g] of this._savedData.entries()) {
                let h = g;
                "collmemory" === e && (h = [...g.entries()].map(l => [l[0].GetUID(), l[1].GetUID(), l[2]]));
                c[e] = h
            }
            return {
                ex: c
            }
        }
        _LoadFromJson(c) {
            this._savedData && (this._savedData.clear(), this._savedData = null);
            if (c) {
                var e = this._runtime,
                    g = c.ex;
                if (g) {
                    c = this.GetSavedDataMap();
                    c.clear();
                    for (const [h, l] of Object.entries(g)) g = l, "collmemory" === h && (g = d.New(d.PairMap, l.map(m => [e.GetInstanceByUID(m[0]), e.GetInstanceByUID(m[1]), m[2]]).filter(m => m[0] && m[1]))), c.set(h, g)
                }
            }
        }
    }
}
"use strict";
{
    const d = self.C3;

    function b(e, g) {
        for (let h = 0, l = e.length; h < l; ++h) {
            // console.log("IDDQD  e[h]" +  e[h] + " " + g[h])
            g[h] = e[h].Get(0)
        }
    }
    const a = [],
        f = function() {},
        c = function*() {};
    d.Action = class extends d.DefendedBase {
        constructor(e, g, h) {
            super();
            this._eventBlock = e;
            this._runtime = e = e.GetRuntime();
            this._index = h;
            this._sid = 4 <= g.length ? g[3] : -1;
            this._actionReturnType = 5 <= g.length ? g[4] : 0;
            this._behaviorType = this._objectClass = this._func = null;
            this._behaviorIndex = -1;
            this._systemPlugin = null;
            this._callFunctionName = "";
            this._combinedSolModifiers = this._callEventBlock = null;
            this.DebugRun = this.Run = f;
            this._parameters = [];
            this._results = [];
            this._anyParamVariesPerInstance = !1;
            this._unsavedData = this._savedData = null;
            const l = (h = -3 === g[0]) ? g[2] : g[5];
            this._debugData = e.IsDebug() || h ? {
                isBreakpoint: l[0],
                canDebug: l[1],
                index: l[2]
            } : null; - 1 === g[0] ? (this._systemPlugin = e.GetSystemPlugin(), this._func = e.GetObjectReference(g[1])) : -2 === g[0] ? this._callFunctionName = g[1] : h ? (this._func = e.GetObjectReference(g[1]), this.Run = this.RunUserScript, this.DebugRun = this.DebugRunUserScript, this._actionReturnType =
                1) : (this._func = e.GetObjectReference(g[1]), this._objectClass = e.GetObjectClassByIndex(g[0]), g[2] && (this._behaviorType = this._objectClass.GetBehaviorTypeByName(g[2]), this._behaviorIndex = this._objectClass.GetBehaviorIndexByName(g[2])));
            if (7 === g.length) {
                g = g[6];
                for (const m of g) this._parameters.push(d.Parameter.Create(this, m, this._parameters.length)), this._results.push(0)
            }
            0 === this._parameters.length && (this._results = this._parameters = a);
            this._eventBlock.GetEventSheetManager()._RegisterAction(this)
        }
        static Create(e,
            g, h) {
            return d.New(d.Action, e, g, h)
        }
        _PostInit() {
            for (var e of this._parameters) e._PostInit(), e.VariesPerInstance() && (this._anyParamVariesPerInstance = !0);
            if (this._systemPlugin) this._SetSystemRunMethod(), this.DebugRun = this._DebugRunSystem;
            else if (this._callFunctionName) this._SetCallFunctionRunMethod(), this._callFunctionName = "";
            else if (this.Run === this.RunUserScript) {
                e = this._func;
                const g = this._runtime.GetEventSheetManager()._GetLocalVariablesScriptInterface(this._eventBlock);
                this._func = e.bind(null, this._runtime.GetIRuntime(),
                    g)
            } else this._behaviorType ? this.IsAsync() ? (this.Run = this._RunBehavior_Async, this.DebugRun = this._DebugRunBehavior_Async) : (this.Run = this._RunBehavior, this.DebugRun = this._DebugRunBehavior) : this._objectClass.GetPlugin().IsSingleGlobal() ? (this._SetSingleGlobalRunMethod(), this.DebugRun = this._DebugRunSingleGlobal) : this.IsAsync() ? (this.Run = this._RunObject_Async, this.DebugRun = this._DebugRunObject_Async) : this._parameters.length ? this._parameters.every(g => g.VariesPerInstance()) ? (this.Run = this._RunObject_AllParamsVary,
                this.DebugRun = this._DebugRunObject_AllParamsVary) : this._anyParamVariesPerInstance ? (this.Run = this._RunObject_SomeParamsVary, this.DebugRun = this._DebugRunObject_SomeParamsVary) : this._parameters.every(g => g.IsConstant()) ? (b(this._parameters, this._results), this.Run = this._RunObject_ParamsConst, this.DebugRun = this._DebugRunObject_ParamsConst) : (this.Run = this._RunObject_ParamsDontVary, this.DebugRun = this._DebugRunObject_ParamsDontVary) : (this.Run = this._RunObject_ParamsConst, this.DebugRun = this._DebugRunObject_ParamsConst)
        }
        _SetSystemRunMethod() {
            this._SetRunMethodForBoundFunc(this._systemPlugin,
                this._systemPlugin, this._RunSystem)
        }
        _SetSingleGlobalRunMethod() {
            const e = this._objectClass.GetPlugin(),
                g = this._objectClass.GetSingleGlobalInstance().GetSdkInstance();
            this._SetRunMethodForBoundFunc(e, g, this._RunSingleGlobal)
        }
        _SetCallFunctionRunMethod() {
            const e = this._eventBlock.GetEventSheetManager(),
                g = e.GetFunctionBlockByName(this._callFunctionName);
            g.IsEnabled() ? (this._callEventBlock = g.GetEventBlock(), this._combinedSolModifiers = [...new Set([...this._eventBlock.GetSolModifiersIncludingParents(), ...this._callEventBlock.GetSolModifiersIncludingParents()])],
                this._combinedSolModifiers = e._DeduplicateSolModifierList(this._combinedSolModifiers), this.Run = d.EventBlock.prototype.RunAsFunctionCall.bind(this._callEventBlock, this._combinedSolModifiers, this._parameters), this.DebugRun = this._DebugRunCallFunction) : (this.Run = f, this.DebugRun = c)
        }
        _SetRunMethodForBoundFunc(e, g, h) {
            const l = this._func,
                m = this._parameters;
            if (0 === m.length) this.Run = e._GetBoundACEMethod(l, g);
            else if (1 === m.length) {
                const p = m[0];
                if (p.IsConstant()) this.Run = e._GetBoundACEMethod_1param(l, g, p.Get(0));
                else {
                    const t = e._GetBoundACEMethod(l, g);
                    this.Run = function() {
                        return t(p.Get(0))
                    }
                }
            } else if (2 === m.length) {
                const p = m[0],
                    t = m[1];
                if (p.IsConstant() && t.IsConstant()) this.Run = e._GetBoundACEMethod_2params(l, g, p.Get(0), t.Get(0));
                else {
                    const q = e._GetBoundACEMethod(l, g);
                    this.Run = function() {
                        return q(p.Get(0), t.Get(0))
                    }
                }
            } else if (3 === m.length) {
                const p = m[0],
                    t = m[1],
                    q = m[2];
                if (p.IsConstant() && t.IsConstant() && q.IsConstant()) this.Run = e._GetBoundACEMethod_3params(l, g, p.Get(0), t.Get(0), q.Get(0));
                else {
                    const r = e._GetBoundACEMethod(l,
                        g);
                    this.Run = function() {
                        return r(p.Get(0), t.Get(0), q.Get(0))
                    }
                }
            } else this.Run = h
        }
        GetSID() {
            return this._sid
        }
        IsAsync() {
            return 1 === this._actionReturnType
        }
        CanBailOut() {
            return 2 === this._actionReturnType
        }
        HasReturnType() {
            return 0 !== this._actionReturnType
        }
        GetObjectClass() {
            return this._objectClass
        }
        GetEventBlock() {
            return this._eventBlock
        }
        GetRuntime() {
            return this._runtime
        }
        GetIndex() {
            return this._index
        }
        GetDebugIndex() {
            return this._debugData.index
        }
        GetCombinedSolModifiers() {
            return this._combinedSolModifiers
        }
        IsBreakpoint() {
            return this._debugData.isBreakpoint
        }
        _SetBreakpoint(e) {
            this._debugData.isBreakpoint = !!e;
            this._eventBlock._UpdateCanRunFastRecursive()
        }
        _DebugReturnsGenerator() {
            return this._debugData.canDebug
        }
        DebugCanRunFast() {
            return !this.IsBreakpoint() && !this._runtime.DebugBreakNext() && !this._DebugReturnsGenerator()
        }
        GetSavedDataMap() {
            this._savedData || (this._savedData = new Map);
            return this._savedData
        }
        GetUnsavedDataMap() {
            this._unsavedData || (this._unsavedData = new Map);
            return this._unsavedData
        }
        _RunSystem() {
            const e = this._results;
            b(this._parameters, e);
            return this._func.apply(this._systemPlugin, e)
        }* _DebugRunSystem() {
            if (this.IsBreakpoint() ||
                this._runtime.DebugBreakNext()) yield this;
            if (this._DebugReturnsGenerator()) {
                const e = this._results;
                b(this._parameters, e);
                return yield* this._func.apply(this._systemPlugin, e)
            }
            return this.Run()
        }* _DebugRunCallFunction() {
            if (this.IsBreakpoint() || this._runtime.DebugBreakNext()) yield this;
            return yield* this._callEventBlock.DebugRunAsFunctionCall(this._combinedSolModifiers, this._parameters)
        }
        _RunSingleGlobal() {
            const e = this._results;
            b(this._parameters, e);
            return this._func.apply(this._objectClass.GetSingleGlobalInstance().GetSdkInstance(),
                e)
        }* _DebugRunSingleGlobal() {
            if (this.IsBreakpoint() || this._runtime.DebugBreakNext()) yield this;
            if (this._DebugReturnsGenerator()) {
                const e = this._results;
                b(this._parameters, e);
                return yield* this._func.apply(this._objectClass.GetSingleGlobalInstance().GetSdkInstance(), e)
            }
            return this.Run()
        }
        _RunObject_ParamsConst() {
            const e = this._results,
                g = this._objectClass.GetCurrentSol().GetInstances();
            for (let h = 0, l = g.length; h < l; ++h) this._func.apply(g[h].GetSdkInstance(), e)
        }* _DebugRunObject_ParamsConst() {
            if (this.IsBreakpoint() ||
                this._runtime.DebugBreakNext()) yield this;
            if (this._DebugReturnsGenerator()) {
                const e = this._results,
                    g = this._objectClass.GetCurrentSol().GetInstances();
                for (let h = 0, l = g.length; h < l; ++h) yield* this._func.apply(g[h].GetSdkInstance(), e)
            } else this._RunObject_ParamsConst()
        }
        _RunObject_ParamsDontVary() {
            const e = this._results;
            // console.log("IDDQD _RunObject_ParamsDontVary pre 1 " + JSON.stringify(this._parameters))
            b(this._parameters, e);
            // console.log("IDDQD _RunObject_ParamsDontVary 1 " + e)
            // try {
            //     console.log("IDDQD _RunObject_ParamsDontVary 2 " + g[h].GetSdkInstance())
            // } catch (e) {
            //     // console.error(`Unhandled exception running script %c${this._eventBlock.GetEventSheet().GetName()}, event ${this._eventBlock.GetDisplayNumber()}, action ${this.GetDebugIndex() + 1}:`, "font-size: 1.2em; font-weight: bold;", e), self.C3Debugger && self.C3Debugger._SetLastErrorScript(this),
            //         // d.EventScript.HadUserScriptException() || (console.info("%cTip:%c run this to highlight in Construct the last script that had an error: %cgoToLastErrorScript()", "font-weight: bold; text-decoration: underline", "", "font-weight: bold"), d.EventScript.SetHadUserScriptException())
            // }
            
            const g = this._objectClass.GetCurrentSol().GetInstances();
            for (let h = 0, l = g.length; h < l; ++h) this._func.apply(g[h].GetSdkInstance(), e)
        }* _DebugRunObject_ParamsDontVary() {
            if (this.IsBreakpoint() ||
                this._runtime.DebugBreakNext()) yield this;
            if (this._DebugReturnsGenerator()) {
                const e = this._results;
                b(this._parameters, e);
                const g = this._objectClass.GetCurrentSol().GetInstances();
                for (let h = 0, l = g.length; h < l; ++h) yield* this._func.apply(g[h].GetSdkInstance(), e)
            } else this._RunObject_ParamsDontVary()
        }
        _RunObject_AllParamsVary() {
            const e = this._parameters,
                g = this._results,
                h = this._func,
                l = this._objectClass.GetCurrentSol().GetInstances();
            for (let m = 0, p = l.length; m < p; ++m) {
                const t = l[m];
                for (let q = 0, r = e.length; q < r; ++q) g[q] =
                    e[q].Get(m);
                h.apply(t.GetSdkInstance(), g)
            }
        }* _DebugRunObject_AllParamsVary() {
            if (this.IsBreakpoint() || this._runtime.DebugBreakNext()) yield this;
            if (this._DebugReturnsGenerator()) {
                const e = this._parameters,
                    g = this._results,
                    h = this._func,
                    l = this._objectClass.GetCurrentSol().GetInstances();
                for (let m = 0, p = l.length; m < p; ++m) {
                    const t = l[m];
                    for (let q = 0, r = e.length; q < r; ++q) g[q] = e[q].Get(m);
                    yield* h.apply(t.GetSdkInstance(), g)
                }
            } else this._RunObject_AllParamsVary()
        }
        _RunObject_SomeParamsVary() {
            const e = this._parameters,
                g = this._results,
                h = this._func,
                l = this._objectClass.GetCurrentSol().GetInstances();
            for (let p = 0, t = e.length; p < t; ++p) {
                var m = e[p];
                m.VariesPerInstance() || (g[p] = m.Get(0))
            }
            for (let p = 0, t = l.length; p < t; ++p) {
                m = l[p];
                for (let q = 0, r = e.length; q < r; ++q) {
                    const u = e[q];
                    u.VariesPerInstance() && (g[q] = u.Get(p))
                }
                h.apply(m.GetSdkInstance(), g)
            }
        }* _DebugRunObject_SomeParamsVary() {
            if (this.IsBreakpoint() || this._runtime.DebugBreakNext()) yield this;
            if (this._DebugReturnsGenerator()) {
                const g = this._parameters,
                    h = this._results,
                    l = this._func,
                    m = this._objectClass.GetCurrentSol().GetInstances();
                for (let p = 0, t = g.length; p < t; ++p) {
                    var e = g[p];
                    e.VariesPerInstance() || (h[p] = e.Get(0))
                }
                for (let p = 0, t = m.length; p < t; ++p) {
                    e = m[p];
                    for (let q = 0, r = g.length; q < r; ++q) {
                        const u = g[q];
                        u.VariesPerInstance() && (h[q] = u.Get(p))
                    }
                    yield* l.apply(e.GetSdkInstance(), h)
                }
            } else this._RunObject_SomeParamsVary()
        }
        _RunBehavior() {
            var e = this._objectClass;
            const g = e.IsFamily(),
                h = e.GetFamilyIndex(),
                l = this._parameters,
                m = this._anyParamVariesPerInstance,
                p = this._results,
                t = this._func,
                q = this._behaviorIndex;
            e = e.GetCurrentSol().GetInstances();
            for (let x = 0, y = l.length; x < y; ++x) {
                var r = l[x];
                r.VariesPerInstance() || (p[x] = r.Get(0))
            }
            for (let x = 0, y = e.length; x < y; ++x) {
                r = e[x];
                if (m)
                    for (let C = 0, w = l.length; C < w; ++C) {
                        var u = l[C];
                        u.VariesPerInstance() && (p[C] = u.Get(x))
                    }
                u = g ? r.GetObjectClass().GetFamilyBehaviorOffset(h) : 0;
                t.apply(r.GetBehaviorInstances()[q + u].GetSdkInstance(), p)
            }
        }* _DebugRunBehavior() {
            if (this.IsBreakpoint() || this._runtime.DebugBreakNext()) yield this;
            if (this._DebugReturnsGenerator()) {
                var e = this._objectClass;
                const l =
                    e.IsFamily(),
                    m = e.GetFamilyIndex(),
                    p = this._parameters,
                    t = this._anyParamVariesPerInstance,
                    q = this._results,
                    r = this._func,
                    u = this._behaviorIndex;
                e = e.GetCurrentSol().GetInstances();
                for (let x = 0, y = p.length; x < y; ++x) {
                    var g = p[x];
                    g.VariesPerInstance() || (q[x] = g.Get(0))
                }
                for (let x = 0, y = e.length; x < y; ++x) {
                    g = e[x];
                    if (t)
                        for (let C = 0, w = p.length; C < w; ++C) {
                            var h = p[C];
                            h.VariesPerInstance() && (q[C] = h.Get(x))
                        }
                    h = l ? g.GetObjectClass().GetFamilyBehaviorOffset(m) : 0;
                    yield* r.apply(g.GetBehaviorInstances()[u + h].GetSdkInstance(), q)
                }
            } else this._RunBehavior()
        }
        _RunObject_Async() {
            const e =
                this._parameters,
                g = this._results,
                h = this._func,
                l = this._objectClass.GetCurrentSol().GetInstances(),
                m = [];
            for (let p = 0, t = l.length; p < t; ++p) {
                const q = l[p];
                for (let r = 0, u = e.length; r < u; ++r) g[r] = e[r].Get(p);
                m.push(h.apply(q.GetSdkInstance(), g))
            }
            return Promise.all(m)
        }* _DebugRunObject_Async() {
            if (this.IsBreakpoint() || this._runtime.DebugBreakNext()) yield this;
            if (this._DebugReturnsGenerator()) {
                const e = this._parameters,
                    g = this._results,
                    h = this._func,
                    l = this._objectClass.GetCurrentSol().GetInstances(),
                    m = [];
                for (let p = 0,
                        t = l.length; p < t; ++p) {
                    const q = l[p];
                    for (let r = 0, u = e.length; r < u; ++r) g[r] = e[r].Get(p);
                    m.push(yield* h.apply(q.GetSdkInstance(), g))
                }
                return Promise.all(m)
            }
            return this._RunObject_Async()
        }
        _RunBehavior_Async() {
            var e = this._objectClass;
            const g = e.IsFamily(),
                h = e.GetFamilyIndex(),
                l = this._parameters,
                m = this._results,
                p = this._func,
                t = this._behaviorIndex;
            e = e.GetCurrentSol().GetInstances();
            const q = [];
            for (let r = 0, u = e.length; r < u; ++r) {
                const x = e[r];
                for (let C = 0, w = l.length; C < w; ++C) m[C] = l[C].Get(r);
                const y = g ? x.GetObjectClass().GetFamilyBehaviorOffset(h) :
                    0;
                q.push(p.apply(x.GetBehaviorInstances()[t + y].GetSdkInstance(), m))
            }
            return Promise.all(q)
        }* _DebugRunBehavior_Async() {
            if (this.IsBreakpoint() || this._runtime.DebugBreakNext()) yield this;
            if (this._DebugReturnsGenerator()) {
                var e = this._objectClass;
                const g = e.IsFamily(),
                    h = e.GetFamilyIndex(),
                    l = this._parameters,
                    m = this._results,
                    p = this._func,
                    t = this._behaviorIndex;
                e = e.GetCurrentSol().GetInstances();
                const q = [];
                for (let r = 0, u = e.length; r < u; ++r) {
                    const x = e[r];
                    for (let C = 0, w = l.length; C < w; ++C) m[C] = l[C].Get(r);
                    const y = g ?
                        x.GetObjectClass().GetFamilyBehaviorOffset(h) : 0;
                    q.push(yield* p.apply(x.GetBehaviorInstances()[t + y].GetSdkInstance(), m))
                }
                return Promise.all(q)
            }
            return this._RunBehavior_Async()
        }
        async RunUserScript() {
            try {
                await this._func()
            } catch (e) {
                console.error(`Unhandled exception running script %c${this._eventBlock.GetEventSheet().GetName()}, event ${this._eventBlock.GetDisplayNumber()}, action ${this.GetDebugIndex() + 1}:`, "font-size: 1.2em; font-weight: bold;", e), self.C3Debugger && self.C3Debugger._SetLastErrorScript(this),
                    d.EventScript.HadUserScriptException() || (console.info("%cTip:%c run this to highlight in Construct the last script that had an error: %cgoToLastErrorScript()", "font-weight: bold; text-decoration: underline", "", "font-weight: bold"), d.EventScript.SetHadUserScriptException())
            }
        }* DebugRunUserScript() {
            if (this.IsBreakpoint() || this._runtime.DebugBreakNext()) yield this;
            return this.RunUserScript()
        }
        _SaveToJson() {
            return this._savedData && this._savedData.size ? {
                ex: d.ToSuperJSON(this._savedData)
            } : null
        }
        _LoadFromJson(e) {
            this._savedData &&
                (this._savedData.clear(), this._savedData = null);
            e && (e = e.ex) && (this._savedData = d.FromSuperJSON(e))
        }
    }
}
"use strict";
{
    const d = self.C3,
        b = new d.Color;

    function a(L, N) {
        return d.compare(this.GetWorldInfo().GetX(), L, N)
    }

    function f(L, N) {
        return d.compare(this.GetWorldInfo().GetY(), L, N)
    }

    function c() {
        const L = this.GetWorldInfo();
        return L.IsInViewport(L.GetLayer().GetViewport())
    }

    function e() {
        var L = this.GetWorldInfo();
        const N = L.GetLayout();
        L = L.GetBoundingBox();
        return 0 > L.getRight() || 0 > L.getBottom() || L.getLeft() > N.GetWidth() || L.getTop() > N.GetHeight()
    }

    function g(L, N, V) {
        const Z = this.GetCurrentSol(),
            fa = Z.GetInstances();
        if (!fa.length) return !1;
        let ha = fa[0];
        var da = ha.GetWorldInfo();
        let ra = ha,
            ta = d.distanceSquared(da.GetX(), da.GetY(), N, V);
        for (let xa = 1, Ha = fa.length; xa < Ha; ++xa)
            if (ha = fa[xa], da = ha.GetWorldInfo(), da = d.distanceSquared(da.GetX(), da.GetY(), N, V), 0 === L && da < ta || 1 === L && da > ta) ta = da, ra = ha;
        Z.PickOne(ra);
        return !0
    }

    function h(L) {
        const N = this.GetWorldInfo();
        N.GetX() !== L && (N.SetX(L), N.SetBboxChanged())
    }

    function l(L) {
        const N = this.GetWorldInfo();
        N.GetY() !== L && (N.SetY(L), N.SetBboxChanged())
    }

    function m(L, N) {
        const V = this.GetWorldInfo();
        V.EqualsXY(L,
            N) || (V.SetXY(L, N), V.SetBboxChanged())
    }

    function p(L, N) {
        if (L && (L = L.GetPairedInstance(this._inst))) {
            var [V, Z] = L.GetImagePoint(N);
            N = this.GetWorldInfo();
            if (N.GetX() !== V || N.GetY() !== Z) N.SetXY(V, Z), N.SetBboxChanged()
        }
    }

    function t(L) {
        if (0 !== L) {
            var N = this.GetWorldInfo();
            N.OffsetXY(N.GetCosAngle() * L, N.GetSinAngle() * L);
            N.SetBboxChanged()
        }
    }

    function q(L, N) {
        if (0 !== N) {
            var V = this.GetWorldInfo();
            L = d.toRadians(L);
            V.OffsetXY(Math.cos(L) * N, Math.sin(L) * N);
            V.SetBboxChanged()
        }
    }

    function r() {
        return this.GetWorldInfo().GetX()
    }

    function u() {
        return this.GetWorldInfo().GetY()
    }

    function x() {
        return this._runtime.GetDt(this._inst)
    }

    function y(L, N) {
        return d.compare(this.GetWorldInfo().GetWidth(), L, N)
    }

    function C(L, N) {
        return d.compare(this.GetWorldInfo().GetHeight(), L, N)
    }

    function w(L) {
        const N = this.GetWorldInfo();
        N.GetWidth() !== L && (N.SetWidth(L), N.SetBboxChanged())
    }

    function A(L) {
        const N = this.GetWorldInfo();
        N.GetHeight() !== L && (N.SetHeight(L), N.SetBboxChanged())
    }

    function E(L, N) {
        const V = this.GetWorldInfo();
        if (V.GetWidth() !== L || V.GetHeight() !==
            N) V.SetSize(L, N), V.SetBboxChanged()
    }

    function K() {
        return this.GetWorldInfo().GetWidth()
    }

    function O() {
        return this.GetWorldInfo().GetHeight()
    }

    function G() {
        return this.GetWorldInfo().GetBoundingBox().getLeft()
    }

    function J() {
        return this.GetWorldInfo().GetBoundingBox().getTop()
    }

    function P() {
        return this.GetWorldInfo().GetBoundingBox().getRight()
    }

    function R() {
        return this.GetWorldInfo().GetBoundingBox().getBottom()
    }

    function T(L, N) {
        return d.angleDiff(this.GetWorldInfo().GetAngle(), d.toRadians(N)) <= d.toRadians(L)
    }

    function X(L) {
        return d.angleClockwise(this.GetWorldInfo().GetAngle(), d.toRadians(L))
    }

    function aa(L, N) {
        L = d.toRadians(L);
        N = d.toRadians(N);
        const V = this.GetWorldInfo().GetAngle();
        return d.angleClockwise(N, L) ? d.angleClockwise(V, L) && !d.angleClockwise(V, N) : !(!d.angleClockwise(V, L) && d.angleClockwise(V, N))
    }

    function ea(L) {
        const N = this.GetWorldInfo();
        L = d.clampAngle(d.toRadians(L));
        isNaN(L) || N.GetAngle() === L || (N.SetAngle(L), N.SetBboxChanged())
    }

    function sa(L) {
        if (!isNaN(L) && 0 !== L) {
            var N = this.GetWorldInfo();
            N.SetAngle(N.GetAngle() +
                d.toRadians(L));
            N.SetBboxChanged()
        }
    }

    function ia(L) {
        if (!isNaN(L) && 0 !== L) {
            var N = this.GetWorldInfo();
            N.SetAngle(N.GetAngle() - d.toRadians(L));
            N.SetBboxChanged()
        }
    }

    function Aa(L, N) {
        const V = this.GetWorldInfo(),
            Z = V.GetAngle();
        L = d.angleRotate(Z, d.toRadians(N), d.toRadians(L));
        isNaN(L) || Z === L || (V.SetAngle(L), V.SetBboxChanged())
    }

    function ua(L, N, V) {
        const Z = this.GetWorldInfo(),
            fa = Z.GetAngle();
        N -= Z.GetX();
        V -= Z.GetY();
        L = d.angleRotate(fa, Math.atan2(V, N), d.toRadians(L));
        isNaN(L) || fa === L || (Z.SetAngle(L), Z.SetBboxChanged())
    }

    function Da(L, N) {
        const V = this.GetWorldInfo(),
            Z = V.GetAngle();
        L -= V.GetX();
        N -= V.GetY();
        N = Math.atan2(N, L);
        isNaN(N) || Z === N || (V.SetAngle(N), V.SetBboxChanged())
    }

    function Ea() {
        return d.toDegrees(this.GetWorldInfo().GetAngle())
    }

    function Ba(L, N) {
        return d.compare(d.round6dp(100 * this.GetWorldInfo().GetOpacity()), L, N)
    }

    function za() {
        return this.GetWorldInfo().IsVisible()
    }

    function ja(L) {
        const N = this.GetWorldInfo();
        L = 2 === L ? !N.IsVisible() : 0 !== L;
        N.IsVisible() !== L && (N.SetVisible(L), this._runtime.UpdateRender())
    }

    function Fa(L) {
        L =
            d.clamp(L / 100, 0, 1);
        const N = this.GetWorldInfo();
        N.GetOpacity() !== L && (N.SetOpacity(L), this._runtime.UpdateRender())
    }

    function wa(L) {
        b.setFromRgbValue(L);
        L = this.GetWorldInfo();
        L.GetUnpremultipliedColor().equalsIgnoringAlpha(b) || (L.SetUnpremultipliedColor(b), this._runtime.UpdateRender())
    }

    function Ca() {
        const L = this.GetWorldInfo().GetUnpremultipliedColor();
        return d.PackRGBAEx(L.getR(), L.getG(), L.getB(), L.getA())
    }

    function Pa() {
        return d.round6dp(100 * this.GetWorldInfo().GetOpacity())
    }

    function Qa(L) {
        return L ?
            this.GetWorldInfo().GetLayer() === L : !1
    }

    function Ra(L) {
        const N = this.GetCurrentSol(),
            V = N.GetInstances();
        if (!V.length) return !1;
        let Z = V[0];
        for (let fa = 1, ha = V.length; fa < ha; ++fa) {
            const da = V[fa],
                ra = da.GetWorldInfo(),
                ta = Z.GetWorldInfo(),
                xa = ra.GetLayer().GetIndex(),
                Ha = ta.GetLayer().GetIndex();
            if (0 === L) {
                if (xa > Ha || xa === Ha && ra.GetZIndex() > ta.GetZIndex()) Z = da
            } else if (xa < Ha || xa === Ha && ra.GetZIndex() < ta.GetZIndex()) Z = da
        }
        N.PickOne(Z);
        return !0
    }

    function Ja(L, N, V) {
        const Z = this.GetWorldInfo();
        L = 0 === L ? Z.GetZElevation() :
            Z.GetTotalZElevation();
        return d.compare(L, N, V)
    }

    function Sa() {
        this.GetWorldInfo().ZOrderMoveToTop()
    }

    function Ta() {
        this.GetWorldInfo().ZOrderMoveToBottom()
    }

    function Ua(L) {
        L && this.GetWorldInfo().ZOrderMoveToLayer(L)
    }

    function Va(L, N) {
        L = 0 === L;
        N && (N = N.GetFirstPicked(this.GetInstance())) && this.GetWorldInfo().ZOrderMoveAdjacentToInstance(N, L)
    }

    function Wa(L) {
        const N = this.GetWorldInfo();
        N.GetZElevation() !== L && (N.SetZElevation(L), this._runtime.UpdateRender())
    }

    function Xa() {
        return this.GetWorldInfo().GetLayer().GetIndex()
    }

    function Ya() {
        return this.GetWorldInfo().GetLayer().GetName()
    }

    function Ka() {
        return this.GetWorldInfo().GetZIndex()
    }

    function Za() {
        return this.GetWorldInfo().GetZElevation()
    }

    function $a() {
        return this.GetWorldInfo().GetTotalZElevation()
    }

    function ab(L, N) {
        if (N = this.GetObjectClass().GetEffectList().GetEffectTypeByName(N)) {
            N = N.GetIndex();
            L = 1 === L;
            var V = this.GetWorldInfo().GetInstanceEffectList();
            V.IsEffectIndexActive(N) !== L && (V.SetEffectIndexActive(N, L), V.UpdateActiveEffects(), this._runtime.UpdateRender())
        }
    }

    function bb(L, N, V) {
        var Z = this.GetObjectClass().GetEffectList().GetEffectTypeByName(L);
        if (Z) {
            L = Z.GetIndex();
            var fa = this.GetWorldInfo().GetInstanceEffectList(),
                ha = fa.GetEffectParametersForIndex(L);
            N = Math.floor(N);
            if (!(0 > N || N >= ha.length)) {
                Z = Z.GetShaderProgram().GetParameterType(N);
                if ("color" === Z) {
                    b.setFromRgbValue(V);
                    N = ha[N];
                    if (b.equalsIgnoringAlpha(N)) return;
                    N.copyRgb(b)
                } else {
                    "percent" === Z && (V /= 100);
                    if (ha[N] === V) return;
                    ha[N] = V
                }
                fa.IsEffectIndexActive(L) && this._runtime.UpdateRender()
            }
        }
    }

    function cb() {
        return this.GetWorldInfo().HasParent()
    }

    function db() {
        return this.GetWorldInfo().HasChildren()
    }

    function eb(L, N) {
        const V = this.GetCurrentSol().GetInstances();
        if (0 === V.length) return !1;
        const Z = L.GetCurrentSol();
        var fa = Z.GetInstances();
        if (0 === fa.length) return !1;
        fa = new Set(fa);
        const ha = new Set;
        for (let ra = 0, ta = V.length; ra < ta; ++ra) {
            var da = V[ra];
            if (1 === N)
                for (const xa of da.parents()) xa.BelongsToObjectClass(L) && fa.has(xa) && ha.add(xa);
            else {
                if (0 === N) {
                    if (da = da.GetParent(), null === da) continue
                } else da = da.GetTopParent();
                da.BelongsToObjectClass(L) && fa.has(da) &&
                    ha.add(da)
            }
        }
        if (0 === ha.size) return !1;
        Z.SetSetPicked(ha);
        L.ApplySolToContainer();
        return !0
    }

    function fb(L, N) {
        const V = this.GetCurrentSol().GetInstances();
        if (0 === V.length) return !1;
        const Z = L.GetCurrentSol();
        var fa = Z.GetInstances();
        if (0 === fa.length) return !1;
        fa = new Set(fa);
        const ha = new Set;
        for (let da = 0, ra = V.length; da < ra; ++da) {
            const ta = V[da];
            2 === N && !ta.HasChildren() && ta.BelongsToObjectClass(L) && fa.has(ta) && ha.add(ta);
            for (const xa of 0 === N ? ta.children() : ta.allChildren()) 2 === N && xa.HasChildren() || xa.BelongsToObjectClass(L) &&
                fa.has(xa) && ha.add(xa)
        }
        if (0 === ha.size) return !1;
        Z.SetSetPicked(ha);
        L.ApplySolToContainer();
        return !0
    }

    function gb(L, N) {
        const V = this.GetCurrentSol().GetInstances();
        if (0 === V.length) return !1;
        const Z = L.GetCurrentSol();
        var fa = Z.GetInstances();
        if (0 === fa.length) return !1;
        fa = new Set(fa);
        const ha = [];
        for (let da = 0, ra = V.length; da < ra; ++da) {
            const ta = V[da].GetChildAt(N);
            null !== ta && ta.BelongsToObjectClass(L) && fa.has(ta) && ha.push(ta)
        }
        if (0 === ha.length) return !1;
        Z.SetArrayPicked(ha);
        L.ApplySolToContainer();
        return !0
    }

    function hb(L,
        N) {
        return d.compare(this._inst.GetChildCount(), L, N)
    }

    function ib(L, N, V, Z, fa, ha, da, ra) {
        const ta = this._inst,
            xa = this._runtime.GetCurrentAction().GetObjectClass();
        for (const Ha of L.allCorrespondingInstances(ta, xa)) {
            if (!Ha.GetPlugin().SupportsSceneGraph()) break;
            ta.AddChild(Ha, {
                transformX: N,
                transformY: V,
                transformWidth: Z,
                transformHeight: fa,
                transformAngle: ha,
                transformZElevation: da,
                destroyWithParent: ra
            })
        }
    }

    function jb(L) {
        const N = this._inst,
            V = this._runtime.GetCurrentAction().GetObjectClass();
        for (const Z of L.allCorrespondingInstances(N,
                V)) N.RemoveChild(Z)
    }

    function ma() {
        this._inst.HasParent() && this._inst.GetParent().RemoveChild(this._inst)
    }

    function Ga() {
        return this._inst.GetChildCount()
    }

    function kb(L, N) {
        L = Math.floor(L);
        N = Math.floor(N);
        const V = this.GetWorldInfo();
        2 > L || 2 > N || !isFinite(L) || !isFinite(N) ? (V.ReleaseMesh(), V.SetBboxChanged()) : V.CreateMesh(L, N)
    }

    function lb(L, N, V, Z, fa, ha, da) {
        const ra = this.GetWorldInfo();
        ra.SetMeshPoint(L, N, {
            mode: 0 === V ? "absolute" : "relative",
            x: Z,
            y: fa,
            u: ha,
            v: da
        }) && ra.SetBboxChanged()
    }

    function mb() {
        const L = this.GetWorldInfo();
        return L.HasMesh() ? L.GetSourceMesh().GetHSize() : 0
    }

    function nb() {
        const L = this.GetWorldInfo();
        return L.HasMesh() ? L.GetSourceMesh().GetVSize() : 0
    }

    function ob(L) {
        const N = this.GetWorldInfo();
        L = 2 === L ? !N.IsVisible() : 0 !== L;
        N.IsVisible() !== L && N.SetVisible(L)
    }

    function pb(L, N) {
        this.SetElementCSSStyle(L, N)
    }

    function La(L, N) {
        this.SetElementAttribute(L, "" + N)
    }

    function Ma(L) {
        this.RemoveElementAttribute(L)
    }

    function Na() {
        this.FocusElement()
    }

    function Oa() {
        this.BlurElement()
    }

    function Ia() {
        return this.IsElementFocused()
    }

    function k(L) {
        this._SetEnabled(0 !== L)
    }

    function n() {
        return this._IsEnabled()
    }

    function v(L, N, V) {
        return d.compare(this.GetInstance().GetInstanceVariableValue(L), N, V)
    }

    function z(L) {
        return !!this.GetInstance().GetInstanceVariableValue(L)
    }

    function B(L, N) {
        const V = this.GetCurrentSol(),
            Z = V.GetInstances();
        if (!Z.length) return !1;
        let fa = Z[0],
            ha = fa,
            da = fa.GetInstanceVariableValue(N);
        for (let ra = 1, ta = Z.length; ra < ta; ++ra) {
            fa = Z[ra];
            const xa = fa.GetInstanceVariableValue(N);
            if (0 === L && xa < da || 1 === L && xa > da) da = xa, ha = fa
        }
        V.PickOne(ha);
        return !0
    }

    function D(L) {
        return this._runtime.GetCurrentCondition().IsInverted() ? H(this, L) : F(this, L)
    }

    function F(L, N) {
        N = L.GetRuntime().GetInstanceByUID(N);
        if (!N) return !1;
        const V = L.GetCurrentSol();
        if (!V.IsSelectAll() && !V._GetOwnInstances().includes(N)) return !1;
        if (L.IsFamily()) {
            if (N.GetObjectClass().BelongsToFamily(L)) return V.PickOne(N), L.ApplySolToContainer(), !0
        } else if (N.GetObjectClass() === L) return V.PickOne(N), L.ApplySolToContainer(), !0;
        return !1
    }

    function H(L, N) {
        const V = L.GetCurrentSol();
        if (V.IsSelectAll()) {
            V._SetSelectAll(!1);
            V.ClearArrays();
            var Z = L.GetInstances();
            for (let ha = 0, da = Z.length; ha < da; ++ha) {
                var fa = Z[ha];
                fa.GetUID() === N ? V._PushElseInstance(fa) : V._PushInstance(fa)
            }
            L.ApplySolToContainer();
            return !!V._GetOwnInstances().length
        }
        Z = V._GetOwnInstances();
        fa = 0;
        for (let ha = 0, da = Z.length; ha < da; ++ha) {
            const ra = Z[ha];
            Z[fa] = ra;
            ra.GetUID() === N ? V._PushElseInstance(ra) : ++fa
        }
        d.truncateArray(Z, fa);
        L.ApplySolToContainer();
        return !!Z.length
    }

    function I() {
        this._runtime.DestroyInstance(this._inst)
    }

    function M() {
        return !0
    }

    function Q() {
        return !0
    }

    function S(L, N) {
        this.GetInstance().SetInstanceVariableValue(L, N)
    }

    function W(L, N) {
        const V = this.GetInstance(),
            Z = V.GetInstanceVariableValue(L);
        "number" === typeof Z && "number" !== typeof N ? N = parseFloat(N) : "string" === typeof Z && "string" !== typeof N && (N = N.toString());
        V.SetInstanceVariableValue(L, Z + N)
    }

    function U(L, N) {
        const V = this.GetInstance(),
            Z = V.GetInstanceVariableValue(L);
        "number" === typeof Z && ("number" !== typeof N && (N = parseFloat(N)), V.SetInstanceVariableValue(L, Z - N))
    }

    function ca(L, N) {
        this.GetInstance().SetInstanceVariableValue(L,
            N ? 1 : 0)
    }

    function ba(L) {
        const N = this.GetInstance();
        N.SetInstanceVariableValue(L, 0 === N.GetInstanceVariableValue(L) ? 1 : 0)
    }

    function Y(L) {
        let N;
        try {
            N = JSON.parse(L)
        } catch (V) {
            console.error("Failed to load from JSON string: ", V);
            return
        }
        L = this.GetInstance();
        L._OnBeforeLoad("state");
        L.LoadFromJson(N, "state")
    }

    function qa() {
        return JSON.stringify(this.GetInstance().SaveToJson("state"))
    }

    function la() {
        return this.GetInstance().GetObjectClass().GetName()
    }

    function oa() {
        const L = this._runtime.GetCurrentEventStackFrame().GetExpressionObjectClass();
        let N = L.GetInstanceCount();
        const V = this._runtime._GetInstancesPendingCreate();
        for (const Z of V) L.IsFamily() ? Z.GetObjectClass().BelongsToFamily(L) && ++N : Z.GetObjectClass() === L && ++N;
        return N
    }

    function pa() {
        return this._runtime.GetCurrentEventStackFrame().GetExpressionObjectClass().GetCurrentSol().GetInstances().length
    }

    function na() {
        return this._inst.GetIID()
    }

    function ya() {
        return this._inst.GetUID()
    }
    d.AddCommonACEs = function(L, N) {
        const V = L[1],
            Z = L[4],
            fa = L[5],
            ha = L[6],
            da = L[7],
            ra = L[8],
            ta = L[10],
            xa = L[11],
            Ha =
            L[12],
            qb = L[13],
            rb = L[14],
            va = N.Cnds,
            ka = N.Acts;
        N = N.Exps;
        L[3] && (va.CompareX = a, va.CompareY = f, va.IsOnScreen = c, va.IsOutsideLayout = e, va.PickDistance = g, ka.SetX = h, ka.SetY = l, ka.SetPos = m, ka.SetPosToObject = p, ka.MoveForward = t, ka.MoveAtAngle = q, N.X = r, N.Y = u, N.dt = x);
        Z && (va.CompareWidth = y, va.CompareHeight = C, ka.SetWidth = w, ka.SetHeight = A, ka.SetSize = E, N.Width = K, N.Height = O, N.BBoxLeft = G, N.BBoxTop = J, N.BBoxRight = P, N.BBoxBottom = R);
        fa && (va.AngleWithin = T, va.IsClockwiseFrom = X, va.IsBetweenAngles = aa, ka.SetAngle = ea, ka.RotateClockwise =
            sa, ka.RotateCounterclockwise = ia, ka.RotateTowardAngle = Aa, ka.RotateTowardPosition = ua, ka.SetTowardPosition = Da, N.Angle = Ea);
        ha && (va.IsVisible = za, va.CompareOpacity = Ba, ka.SetVisible = ja, ka.SetOpacity = Fa, ka.SetDefaultColor = wa, N.Opacity = Pa, N.ColorValue = Ca);
        da && (va.IsOnLayer = Qa, va.PickTopBottom = Ra, va.CompareZElevation = Ja, ka.MoveToTop = Sa, ka.MoveToBottom = Ta, ka.MoveToLayer = Ua, ka.ZMoveToObject = Va, ka.SetZElevation = Wa, N.LayerNumber = Xa, N.LayerName = Ya, N.ZIndex = Ka, N.ZElevation = Za, N.TotalZElevation = $a);
        ra && (ka.SetEffectEnabled =
            ab, ka.SetEffectParam = bb);
        qb && (va.HasParent = cb, va.HasChildren = db, va.PickParent = eb, va.PickChildren = fb, va.PickNthChild = gb, va.CompareChildCount = hb, ka.AddChild = ib, ka.RemoveChild = jb, ka.RemoveFromParent = ma, N.ChildCount = Ga);
        rb && (ka.SetMeshSize = kb, ka.SetMeshPoint = lb, N.MeshColumns = mb, N.MeshRows = nb);
        ta && (va.IsVisible = za, ka.SetVisible = ob, ka.SetCSSStyle = pb, ka.SetElemAttribute = La, ka.RemoveElemAttribute = Ma);
        xa && (va.IsFocused = Ia, ka.SetFocus = Na, ka.SetBlur = Oa);
        Ha && (va.IsEnabled = n, ka.SetEnabled = k);
        V || (va.CompareInstanceVar =
            v, va.IsBoolInstanceVarSet = z, va.PickInstVarHiLow = B, va.PickByUID = D, ka.SetInstanceVar = S, ka.AddInstanceVar = W, ka.SubInstanceVar = U, ka.SetBoolInstanceVar = ca, ka.ToggleBoolInstanceVar = ba, va.OnCreated = M, va.OnDestroyed = Q, ka.Destroy = I, ka.LoadFromJsonString || (ka.LoadFromJsonString = Y), N.AsJSON || (N.AsJSON = qa), N.Count = oa, N.PickedCount = pa, N.IID = na, N.UID = ya, N.ObjectTypeName = la)
    }
}
"use strict";
{
    const d = self.C3;
    d.ScheduledWait = class extends d.DefendedBase {
        constructor(b) {
            super();
            this._eventSheetManager = b;
            this._type = "";
            this._time = -1;
            this._signalTag = "";
            this._isSignalled = !1;
            this._event = null;
            this._actIndex = 0;
            this._solModifiers = [];
            this._sols = new Map;
            this._callingFunctionBlock = null;
            this._asyncId = -1;
            this._functionInnerLocalVars = this._functionParameters = null;
            this._shouldRelease = !1
        }
        Release() {
            this._type = "";
            this._time = -1;
            this._signalTag = "";
            this._functionInnerLocalVars = this._functionParameters = this._callingFunctionBlock =
                this._event = null;
            this._asyncId = -1;
            d.clearArray(this._solModifiers);
            for (const b of this._sols.values()) b.Release();
            this._sols.clear()
        }
        _Init() {
            var b = this._eventSheetManager,
                a = b.GetRuntime().GetAllObjectClasses();
            const f = b.GetCurrentEventStackFrame();
            this._event = f.GetCurrentEvent();
            this._actIndex = f.GetActionIndex() + 1;
            if (b = b.FindFirstFunctionBlockParent(this._event)) this._callingFunctionBlock = b, this._functionParameters = b.CaptureFunctionParameters(), this._functionInnerLocalVars = b._GetAllInnerLocalVariables().map(c =>
                c.GetValue()), b.IsAsync() && (this._asyncId = b.PauseCurrentAsyncFunction());
            for (const c of a)
                if (a = c.GetCurrentSol(), !a.IsSelectAll() || this._event.HasSolModifier(c)) this._solModifiers.push(c), this._sols.set(c, d.New(d.SolState, a))
        }
        InitTimer(b) {
            this._type = "timer";
            this._Init();
            this._time = this._eventSheetManager.GetRuntime().GetGameTime() + b
        }
        InitSignal(b) {
            this._type = "signal";
            this._Init();
            this._signalTag = b.toLowerCase()
        }
        InitPromise(b) {
            this._type = "promise";
            this._Init();
            b.then(() => this.SetSignalled()).catch(a => {
                console.warn("[C3 runtime] Promise rejected in 'Wait for previous actions to complete': ", a);
                this.SetSignalled()
            })
        }
        IsTimer() {
            return "timer" === this._type
        }
        IsSignal() {
            return "signal" === this._type
        }
        IsPromise() {
            return "promise" === this._type
        }
        GetSignalTag() {
            return this._signalTag
        }
        IsSignalled() {
            return this._isSignalled
        }
        SetSignalled() {
            this._isSignalled = !0
        }
        _ShouldRun() {
            return this.IsTimer() ? this._time <= this._eventSheetManager.GetRuntime().GetGameTime() : this.IsSignalled()
        }
        _RestoreState(b) {
            b._Restore(this._event,
                this._actIndex);
            for (const [a, f] of this._sols.entries()) b = a.GetCurrentSol(), f._Restore(b);
            if (b = this._callingFunctionBlock) b.SetFunctionParameters(this._functionParameters), b._GetAllInnerLocalVariables().map((a, f) => a.SetValue(this._functionInnerLocalVars[f])), b.IsAsync() && b.ResumeAsyncFunction(this._asyncId)
        }
        _Run(b) {
            this._RestoreState(b);
            this._event._ResumeActionsAndSubEvents(b);
            this._callingFunctionBlock && this._callingFunctionBlock.IsAsync() && this._callingFunctionBlock.MaybeFinishAsyncFunctionCall(this._asyncId);
            this._eventSheetManager.ClearSol(this._solModifiers);
            this._shouldRelease = !0
        }
        async _DebugRun(b) {
            this._RestoreState(b);
            for (const a of this._event._DebugResumeActionsAndSubEvents(b)) await this._eventSheetManager.GetRuntime().DebugBreak(a);
            this._callingFunctionBlock && this._callingFunctionBlock.IsAsync() && this._callingFunctionBlock.MaybeFinishAsyncFunctionCall(this._asyncId);
            this._eventSheetManager.ClearSol(this._solModifiers);
            this._shouldRelease = !0
        }
        ShouldRelease() {
            return this._shouldRelease
        }
        RemoveInstances(b) {
            for (const a of this._sols.values()) a.RemoveInstances(b)
        }
        _SaveToJson() {
            const b = {},
                a = {
                    t: this._time,
                    st: this._signalTag,
                    s: this._isSignalled,
                    ev: this._event.GetSID(),
                    sm: this._solModifiers.map(f => f.GetSID()),
                    sols: b
                };
            this._event._HasActionIndex(this._actIndex) && (a.act = this._event.GetActionAt(this._actIndex).GetSID());
            for (const [f, c] of this._sols) b[f.GetSID().toString()] = c._SaveToJson();
            return a
        }
        static _CreateFromJson(b, a) {
            const f = b.GetRuntime();
            var c = b.GetEventBlockBySID(a.ev);
            if (!c) return null;
            let e = 0;
            if (a.hasOwnProperty("act")) {
                var g = b.GetActionBySID(a.act);
                if (!g) return null;
                e = g.GetIndex()
            }
            g =
                d.New(d.ScheduledWait, b);
            g._time = a.t;
            g._type = -1 === g._time ? "signal" : "timer";
            g._signalTag = a.st;
            g._isSignalled = a.s;
            g._event = c;
            g._actIndex = e;
            for (var h of a.sm)(c = f.GetObjectClassBySID(h)) && g._solModifiers.push(c);
            for (const [l, m] of Object.entries(a.sols))
                if (a = parseInt(l, 10), a = f.GetObjectClassBySID(a)) h = d.New(d.SolState, null), h._LoadFromJson(b, m), g._sols.set(a, h);
            return g
        }
    }
}
"use strict";
{
    const d = self.C3;
    d.SolState = class extends d.DefendedBase {
        constructor(b) {
            super();
            this._objectClass = null;
            this._isSelectAll = !0;
            this._instances = [];
            b && (this._objectClass = b.GetObjectClass(), this._isSelectAll = b.IsSelectAll(), d.shallowAssignArray(this._instances, b._GetOwnInstances()))
        }
        Release() {
            this._objectClass = null;
            d.clearArray(this._instances)
        }
        _Restore(b) {
            b._SetSelectAll(this._isSelectAll);
            d.shallowAssignArray(b._GetOwnInstances(), this._instances)
        }
        RemoveInstances(b) {
            d.arrayRemoveAllInSet(this._instances,
                b)
        }
        _SaveToJson() {
            return {
                sa: this._isSelectAll,
                insts: this._instances.map(b => b.GetUID())
            }
        }
        _LoadFromJson(b, a) {
            b = b.GetRuntime();
            this._isSelectAll = !!a.sa;
            d.clearArray(this._instances);
            for (const f of a.insts)(a = b.GetInstanceByUID(f)) && this._instances.push(a)
        }
    }
}
"use strict";
{
    const d = self.C3;

    function b(a, f) {
        let c = a.get(f);
        c || (c = new Map, a.set(f, c));
        return c
    }
    d.SDKPluginBase = class extends d.DefendedBase {
        constructor(a) {
            super();
            this._runtime = a.runtime;
            this._isSingleGlobal = !!a.isSingleGlobal;
            this._isWorldType = !!a.isWorld;
            this._isRotatable = !!a.isRotatable;
            this._mustPredraw = !!a.mustPredraw;
            this._hasEffects = !!a.hasEffects;
            this._supportsSceneGraph = !!a.supportsSceneGraph;
            this._supportsMesh = !!a.supportsMesh;
            this._singleGlobalObjectClass = null;
            this._boundACEMethodCache = new Map;
            this._boundACEMethodCache_1param =
                new Map;
            this._boundACEMethodCache_2params = new Map;
            this._boundACEMethodCache_3params = new Map
        }
        Release() {
            this._runtime = null
        }
        GetRuntime() {
            return this._runtime
        }
        OnCreate() {}
        IsSingleGlobal() {
            return this._isSingleGlobal
        }
        IsWorldType() {
            return this._isWorldType
        }
        IsRotatable() {
            return this._isRotatable
        }
        MustPreDraw() {
            return this._mustPredraw
        }
        HasEffects() {
            return this._hasEffects
        }
        SupportsSceneGraph() {
            return this._supportsSceneGraph
        }
        SupportsMesh() {
            return this._supportsMesh
        }
        _GetBoundACEMethod(a, f) {
            if (!f) throw Error("missing 'this' binding");
            let c = this._boundACEMethodCache.get(a);
            if (c) return c;
            c = a.bind(f);
            this._boundACEMethodCache.set(a, c);
            return c
        }
        _GetBoundACEMethod_1param(a, f, c) {
            if (!f) throw Error("missing 'this' binding");
            const e = b(this._boundACEMethodCache_1param, a);
            let g = e.get(c);
            if (g) return g;
            g = a.bind(f, c);
            e.set(c, g);
            return g
        }
        _GetBoundACEMethod_2params(a, f, c, e) {
            if (!f) throw Error("missing 'this' binding");
            var g = b(this._boundACEMethodCache_2params, a);
            g = b(g, c);
            let h = g.get(e);
            if (h) return h;
            h = a.bind(f, c, e);
            g.set(e, h);
            return h
        }
        _GetBoundACEMethod_3params(a,
            f, c, e, g) {
            if (!f) throw Error("missing 'this' binding");
            var h = b(this._boundACEMethodCache_3params, a);
            h = b(h, c);
            h = b(h, e);
            let l = h.get(g);
            if (l) return l;
            l = a.bind(f, c, e, g);
            h.set(g, l);
            return l
        }
        _SetSingleGlobalObjectClass(a) {
            if (!this.IsSingleGlobal()) throw Error("must be single-global plugin");
            this._singleGlobalObjectClass = a
        }
        GetSingleGlobalObjectClass() {
            if (!this.IsSingleGlobal()) throw Error("must be single-global plugin");
            return this._singleGlobalObjectClass
        }
        GetSingleGlobalInstance() {
            if (!this.IsSingleGlobal()) throw Error("must be single-global plugin");
            return this._singleGlobalObjectClass.GetSingleGlobalInstance()
        }
    }
}
"use strict";
{
    const d = self.C3;
    d.SDKDOMPluginBase = class extends d.SDKPluginBase {
        constructor(b, a) {
            super(b);
            this._domComponentId = a;
            this._nextElementId = 0;
            this._instMap = new Map;
            this.AddElementMessageHandler("elem-focused", f => f._OnElemFocused());
            this.AddElementMessageHandler("elem-blurred", f => {
                f && f._OnElemBlurred()
            })
        }
        Release() {
            super.Release()
        }
        _AddElement(b) {
            const a = this._nextElementId++;
            this._instMap.set(a, b);
            return a
        }
        _RemoveElement(b) {
            this._instMap.delete(b)
        }
        AddElementMessageHandler(b, a) {
            this._runtime.AddDOMComponentMessageHandler(this._domComponentId,
                b, f => {
                    const c = this._instMap.get(f.elementId);
                    a(c, f)
                })
        }
    }
}
"use strict";
{
    const d = self.C3;
    d.SDKTypeBase = class extends d.DefendedBase {
        constructor(b) {
            super();
            this._objectClass = b;
            this._runtime = b.GetRuntime();
            this._plugin = b.GetPlugin()
        }
        Release() {
            this._plugin = this._runtime = this._objectClass = null
        }
        GetObjectClass() {
            return this._objectClass
        }
        GetRuntime() {
            return this._runtime
        }
        GetPlugin() {
            return this._plugin
        }
        GetImageInfo() {
            return this._objectClass.GetImageInfo()
        }
        FinishCondition(b) {}
        LoadTextures(b) {}
        ReleaseTextures() {}
        OnDynamicTextureLoadComplete() {}
        PreloadTexturesWithInstances(b) {}
        LoadTilemapData() {}
        GetScriptInterfaceClass() {
            return null
        }
    }
}
"use strict";
{
    const d = self.C3;
    d.SDKInstanceBase = class extends d.DefendedBase {
        constructor(b, a) {
            super();
            this._inst = b;
            this._domComponentId = a;
            this._runtime = b.GetRuntime();
            this._objectClass = this._inst.GetObjectClass();
            this._sdkType = this._objectClass.GetSdkType();
            this._tick2Func = this._tickFunc = null;
            this._isTicking2 = this._isTicking = !1;
            this._disposables = null;
            this._wasReleased = !1
        }
        Release() {
            this._wasReleased = !0;
            this._StopTicking();
            this._StopTicking2();
            this._tick2Func = this._tickFunc = null;
            this._disposables && (this._disposables.Release(),
                this._disposables = null);
            this._sdkType = this._objectClass = this._runtime = this._inst = null
        }
        WasReleased() {
            return this._wasReleased
        }
        GetInstance() {
            return this._inst
        }
        GetRuntime() {
            return this._runtime
        }
        GetObjectClass() {
            return this._objectClass
        }
        GetPlugin() {
            return this._sdkType.GetPlugin()
        }
        GetSdkType() {
            return this._sdkType
        }
        GetScriptInterface() {
            return this._inst.GetInterfaceClass()
        }
        Trigger(b) {
            return this._runtime.Trigger(b, this._inst, null)
        }
        DebugTrigger(b) {
            return this._runtime.DebugTrigger(b, this._inst, null)
        }
        TriggerAsync(b) {
            return this._runtime.TriggerAsync(b,
                this._inst, null)
        }
        FastTrigger(b, a) {
            return this._runtime.FastTrigger(b, this._inst, a)
        }
        DebugFastTrigger(b, a) {
            return this._runtime.DebugFastTrigger(b, this._inst, a)
        }
        ScheduleTriggers(b) {
            return this._runtime.ScheduleTriggers(b)
        }
        AddDOMMessageHandler(b, a) {
            this._runtime.AddDOMComponentMessageHandler(this._domComponentId, b, a)
        }
        AddDOMMessageHandlers(b) {
            for (const [a, f] of b) this.AddDOMMessageHandler(a, f)
        }
        PostToDOM(b, a) {
            this._runtime.PostComponentMessageToDOM(this._domComponentId, b, a)
        }
        PostToDOMAsync(b, a) {
            return this._runtime.PostComponentMessageToDOMAsync(this._domComponentId,
                b, a)
        }
        _PostToDOMMaybeSync(b, a) {
            if (this._runtime.IsInWorker()) this.PostToDOM(b, a);
            else return window.c3_runtimeInterface._OnMessageFromRuntime({
                type: "event",
                component: this._domComponentId,
                handler: b,
                data: a,
                responseId: null
            })
        }
        GetCurrentImageInfo() {
            return null
        }
        GetCurrentSurfaceSize() {
            var b = this.GetCurrentImageInfo();
            return b && (b = b.GetTexture()) ? [b.GetWidth(), b.GetHeight()] : [100, 100]
        }
        GetCurrentTexRect() {
            const b = this.GetCurrentImageInfo();
            return b ? b.GetTexRect() : null
        }
        GetImagePoint(b) {
            b = this._inst.GetWorldInfo();
            return [b.GetX(), b.GetY()]
        }
        Tick() {}
        Tick2() {}
        _StartTicking() {
            this._isTicking || (this._tickFunc || (this._tickFunc = () => this.Tick()), this._runtime.Dispatcher().addEventListener("tick", this._tickFunc), this._isTicking = !0)
        }
        _StopTicking() {
            this._isTicking && (this._runtime.Dispatcher().removeEventListener("tick", this._tickFunc), this._isTicking = !1)
        }
        IsTicking() {
            return this._isTicking
        }
        _StartTicking2() {
            this._isTicking2 || (this._tick2Func || (this._tick2Func = () => this.Tick2()), this._runtime.Dispatcher().addEventListener("tick2",
                this._tick2Func), this._isTicking2 = !0)
        }
        _StopTicking2() {
            this._isTicking2 && (this._runtime.Dispatcher().removeEventListener("tick2", this._tick2Func), this._isTicking2 = !1)
        }
        IsTicking2() {
            return this._isTicking2
        }
        GetDebuggerProperties() {
            return []
        }
        SaveToJson() {
            return null
        }
        LoadFromJson(b) {}
        LoadTilemapData(b, a, f) {}
        TestPointOverlapTile(b, a) {}
        GetPropertyValueByIndex(b) {}
        SetPropertyValueByIndex(b, a) {}
        OffsetPropertyValueByIndex(b, a) {
            if (0 !== a) {
                var f = this.GetPropertyValueByIndex(b);
                if ("number" !== typeof f) throw Error("expected number");
                this.SetPropertyValueByIndex(b, f + a)
            }
        }
        SetPropertyColorOffsetValueByIndex(b, a, f, c) {}
        CallAction(b, ...a) {
            b.call(this, ...a)
        }
        CallExpression(b, ...a) {
            return b.call(this, ...a)
        }
        GetScriptInterfaceClass() {
            return null
        }
    }
}
"use strict";
{
    const d = self.C3;
    d.SDKWorldInstanceBase = class extends d.SDKInstanceBase {
        constructor(b, a) {
            super(b, a);
            this._worldInfo = b.GetWorldInfo();
            this._webglcontextrestored_handler = this._webglcontextlost_handler = null
        }
        Release() {
            if (this._webglcontextlost_handler) {
                const b = this._runtime.Dispatcher();
                b.removeEventListener("webglcontextlost", this._webglcontextlost_handler);
                b.removeEventListener("webglcontextrestored", this._webglcontextrestored_handler);
                this._webglcontextrestored_handler = this._webglcontextlost_handler =
                    null
            }
            this._worldInfo = null;
            super.Release()
        }
        HandleWebGLContextLoss() {
            if (!this._webglcontextlost_handler) {
                this._webglcontextlost_handler = () => this.OnWebGLContextLost();
                this._webglcontextrestored_handler = () => this.OnWebGLContextRestored();
                var b = this._runtime.Dispatcher();
                b.addEventListener("webglcontextlost", this._webglcontextlost_handler);
                b.addEventListener("webglcontextrestored", this._webglcontextrestored_handler)
            }
        }
        OnWebGLContextLost() {}
        OnWebGLContextRestored() {}
        GetWorldInfo() {
            return this._worldInfo
        }
    }
}
"use strict";
{
    const d = self.C3,
        b = d.New(d.Rect);
    d.SDKDOMInstanceBase = class extends d.SDKWorldInstanceBase {
        constructor(a, f) {
            super(a, f);
            this._elementId = this.GetPlugin()._AddElement(this);
            this._isElementShowing = !0;
            this._autoFontSize = this._elemHasFocus = !1;
            this._lastRect = d.New(d.Rect, 0, 0, -1, -1);
            a = this._runtime.GetCanvasManager();
            this._lastWindowWidth = a.GetLastWidth();
            this._lastWindowHeight = a.GetLastHeight();
            this._isPendingUpdateState = !1;
            this._StartTicking()
        }
        Release() {
            this.GetPlugin()._RemoveElement(this._elementId);
            this.PostToDOMElement("destroy");
            this._elementId = -1;
            super.Release()
        }
        _GetElementInDOMMode() {
            if (this._runtime.IsInWorker()) throw Error("not valid in worker mode");
            return this._PostToDOMElementMaybeSync("get-element")
        }
        PostToDOMElement(a, f) {
            f || (f = {});
            f.elementId = this._elementId;
            this.PostToDOM(a, f)
        }
        _PostToDOMElementMaybeSync(a, f) {
            f || (f = {});
            f.elementId = this._elementId;
            return this._PostToDOMMaybeSync(a, f)
        }
        PostToDOMElementAsync(a, f) {
            f || (f = {});
            f.elementId = this._elementId;
            return this.PostToDOMAsync(a, f)
        }
        CreateElement(a) {
            a ||
                (a = {});
            const f = this.GetWorldInfo().IsVisible();
            a.elementId = this._elementId;
            a.isVisible = f;
            Object.assign(a, this.GetElementState());
            this._isElementShowing = !!a.isVisible;
            this._PostToDOMMaybeSync("create", a);
            this._UpdatePosition(!0)
        }
        SetElementVisible(a) {
            a = !!a;
            this._isElementShowing !== a && (this._isElementShowing = a, this.PostToDOMElement("set-visible", {
                isVisible: a
            }))
        }
        Tick() {
            this._UpdatePosition(!1)
        }
        _ShouldPreserveElement() {
            const a = this._runtime.GetCanvasManager().GetFullscreenMode();
            return "Android" === d.Platform.OS &&
                ("scale-inner" === a || "scale-outer" === a || "crop" === a)
        }
        _UpdatePosition(a) {
            var f = this.GetWorldInfo();
            const c = f.GetLayer();
            var e = f.GetX(),
                g = f.GetY();
            let [h, l] = c.LayerToCanvasCss(e, g), [m, p] = c.LayerToCanvasCss(e + f.GetWidth(), g + f.GetHeight());
            e = this._runtime.GetCanvasManager();
            g = e.GetCssWidth();
            const t = e.GetCssHeight();
            if (f.IsVisible() && c.IsVisible()) {
                if (!this._ShouldPreserveElement()) {
                    if (0 >= m || 0 >= p || h >= g || l >= t) {
                        this.SetElementVisible(!1);
                        return
                    }
                    1 > h && (h = 1);
                    1 > l && (l = 1);
                    m >= g && (m = g - 1);
                    p >= t && (p = t - 1)
                }
                b.set(h, l,
                    m, p);
                f = e.GetLastWidth();
                g = e.GetLastHeight();
                !a && b.equals(this._lastRect) && this._lastWindowWidth === f && this._lastWindowHeight === g ? this.SetElementVisible(!0) : (this._lastRect.copy(b), this._lastWindowWidth = f, this._lastWindowHeight = g, this.SetElementVisible(!0), a = null, this._autoFontSize && (a = c.GetDisplayScale() - .2), this.PostToDOMElement("update-position", {
                    left: Math.round(this._lastRect.getLeft()) + e.GetCanvasClientX(),
                    top: Math.round(this._lastRect.getTop()) + e.GetCanvasClientY(),
                    width: Math.round(this._lastRect.width()),
                    height: Math.round(this._lastRect.height()),
                    fontSize: a
                }))
            } else this.SetElementVisible(!1)
        }
        FocusElement() {
            this._PostToDOMElementMaybeSync("focus", {
                focus: !0
            })
        }
        BlurElement() {
            this._PostToDOMElementMaybeSync("focus", {
                focus: !1
            })
        }
        _OnElemFocused() {
            this._elemHasFocus = !0
        }
        _OnElemBlurred() {
            this._elemHasFocus = !1
        }
        IsElementFocused() {
            return this._elemHasFocus
        }
        SetElementCSSStyle(a, f) {
            this.PostToDOMElement("set-css-style", {
                prop: d.CSSToCamelCase(a),
                val: f
            })
        }
        SetElementAttribute(a, f) {
            this.PostToDOMElement("set-attribute", {
                name: a,
                val: f
            })
        }
        RemoveElementAttribute(a) {
            this.PostToDOMElement("remove-attribute", {
                name: a
            })
        }
        UpdateElementState() {
            this._isPendingUpdateState || (this._isPendingUpdateState = !0, Promise.resolve().then(() => {
                this._isPendingUpdateState = !1;
                this.PostToDOMElement("update-state", this.GetElementState())
            }))
        }
        GetElementState() {}
        GetElementId() {
            return this._elementId
        }
    }
}
"use strict";
{
    const d = self.C3,
        b = self.IBehavior;
    d.SDKBehaviorBase = class extends d.DefendedBase {
        constructor(a) {
            super();
            this._runtime = a.runtime;
            this._myObjectClasses = d.New(d.ArraySet);
            this._myInstances = d.New(d.ArraySet);
            this._iBehavior = null;
            if (a = a.scriptInterfaceClass) {
                if (this._iBehavior = new a(this), !(this._iBehavior instanceof b)) throw new TypeError("script interface class must derive from IBehavior");
            } else this._iBehavior = new b(this)
        }
        Release() {
            this._myInstances.Release();
            this._myObjectClasses.Release();
            this._runtime =
                null
        }
        GetRuntime() {
            return this._runtime
        }
        OnCreate() {}
        _AddObjectClass(a) {
            this._myObjectClasses.Add(a)
        }
        GetObjectClasses() {
            return this._myObjectClasses.GetArray()
        }
        _AddInstance(a) {
            this._myInstances.Add(a)
        }
        _RemoveInstance(a) {
            this._myInstances.Delete(a)
        }
        GetInstances() {
            return this._myInstances.GetArray()
        }
        GetIBehavior() {
            return this._iBehavior
        }
    }
}
"use strict";
{
    const d = self.C3;
    d.SDKBehaviorTypeBase = class extends d.DefendedBase {
        constructor(b) {
            super();
            this._runtime = b.GetRuntime();
            this._behaviorType = b;
            this._objectClass = b.GetObjectClass();
            this._behavior = b.GetBehavior();
            this._behavior._AddObjectClass(this._objectClass)
        }
        Release() {
            this._behavior = this._objectClass = this._behaviorType = this._runtime = null
        }
        GetBehaviorType() {
            return this._behaviorType
        }
        GetObjectClass() {
            return this._objectClass
        }
        GetRuntime() {
            return this._runtime
        }
        GetBehavior() {
            return this._behavior
        }
    }
}
"use strict";
{
    const d = self.C3;
    d.SDKBehaviorInstanceBase = class extends d.DefendedBase {
        constructor(b, a) {
            super();
            this._behInst = b;
            this._domComponentId = a;
            this._inst = b.GetObjectInstance();
            this._runtime = b.GetRuntime();
            this._behaviorType = b.GetBehaviorType();
            this._sdkType = this._behaviorType.GetSdkType();
            this._isPostTicking = this._isTicking2 = this._isTicking = !1;
            this._disposables = null
        }
        Release() {
            this._StopTicking();
            this._StopTicking2();
            this._StopPostTicking();
            this._disposables && (this._disposables.Release(), this._disposables =
                null);
            this._sdkType = this._behaviorType = this._runtime = this._inst = this._behInst = null
        }
        GetBehavior() {
            return this._behaviorType.GetBehavior()
        }
        GetBehaviorInstance() {
            return this._behInst
        }
        GetObjectInstance() {
            return this._inst
        }
        GetObjectClass() {
            return this._inst.GetObjectClass()
        }
        GetWorldInfo() {
            return this._inst.GetWorldInfo()
        }
        GetRuntime() {
            return this._runtime
        }
        GetBehaviorType() {
            return this._behaviorType
        }
        GetSdkType() {
            return this._sdkType
        }
        GetScriptInterface() {
            return this._behInst.GetScriptInterface()
        }
        Trigger(b) {
            return this._runtime.Trigger(b,
                this._inst, this._behaviorType)
        }
        DebugTrigger(b) {
            return this._runtime.DebugTrigger(b, this._inst, this._behaviorType)
        }
        TriggerAsync(b) {
            return this._runtime.TriggerAsync(b, this._inst, this._behaviorType)
        }
        PostCreate() {}
        Tick() {}
        Tick2() {}
        PostTick() {}
        _StartTicking() {
            this._isTicking || (this._runtime._AddBehInstToTick(this), this._isTicking = !0)
        }
        _StopTicking() {
            this._isTicking && (this._runtime._RemoveBehInstToTick(this), this._isTicking = !1)
        }
        IsTicking() {
            return this._isTicking
        }
        _StartTicking2() {
            this._isTicking2 || (this._runtime._AddBehInstToTick2(this),
                this._isTicking2 = !0)
        }
        _StopTicking2() {
            this._isTicking2 && (this._runtime._RemoveBehInstToTick2(this), this._isTicking2 = !1)
        }
        IsTicking2() {
            return this._isTicking2
        }
        _StartPostTicking() {
            this._isPostTicking || (this._runtime._AddBehInstToPostTick(this), this._isPostTicking = !0)
        }
        _StopPostTicking() {
            this._isPostTicking && (this._runtime._RemoveBehInstToPostTick(this), this._isPostTicking = !1)
        }
        IsPostTicking() {
            return this._isPostTicking
        }
        GetDebuggerProperties() {
            return []
        }
        AddDOMMessageHandler(b, a) {
            this._runtime.AddDOMComponentMessageHandler(this._domComponentId,
                b, a)
        }
        OnSpriteFrameChanged(b, a) {}
        SaveToJson() {
            return null
        }
        LoadFromJson(b) {}
        GetPropertyValueByIndex(b) {}
        SetPropertyValueByIndex(b, a) {}
        OffsetPropertyValueByIndex(b, a) {
            if (0 !== a) {
                var f = this.GetPropertyValueByIndex(b);
                if ("number" !== typeof f) throw Error("expected number");
                this.SetPropertyValueByIndex(b, f + a)
            }
        }
        SetPropertyColorOffsetValueByIndex(b, a, f, c) {}
        CallAction(b, ...a) {
            b.call(this, ...a)
        }
        CallExpression(b, ...a) {
            return b.call(this, ...a)
        }
        GetScriptInterfaceClass() {
            return null
        }
    }
}
"use strict";
{
    const d = self.C3;
    d.Plugins = {};
    d.Behaviors = {};
    d.PluginManager = class extends d.DefendedBase {
        constructor(b) {
            super();
            this._runtime = b;
            this._allPlugins = [];
            this._pluginsByCtor = new Map;
            this._systemPlugin = null;
            this._allBehaviors = [];
            this._behaviorsByCtor = new Map;
            this._jumpthruBehavior = this._solidBehavior = null
        }
        CreatePlugin(b) {
            const a = this._runtime.GetObjectReference(b[0]);
            if (!a) throw Error("missing plugin");
            d.AddCommonACEs(b, a);
            b = d.New(a, {
                runtime: this._runtime,
                isSingleGlobal: b[1],
                isWorld: b[2],
                isRotatable: b[5],
                hasEffects: b[8],
                mustPredraw: b[9],
                supportsSceneGraph: b[13],
                supportsMesh: b[14]
            });
            b.OnCreate();
            this._allPlugins.push(b);
            this._pluginsByCtor.set(a, b)
        }
        CreateSystemPlugin() {
            this._systemPlugin = d.New(d.Plugins.System, {
                runtime: this._runtime,
                isSingleGlobal: !0
            });
            this._systemPlugin.OnCreate()
        }
        CreateBehavior(b) {
            b = this._runtime.GetObjectReference(b[1]);
            if (!b) throw Error("missing behavior");
            const a = d.New(b, {
                runtime: this._runtime
            });
            a.OnCreate();
            this._allBehaviors.push(a);
            this._behaviorsByCtor.set(b, a);
            !this._solidBehavior &&
                d.Behaviors.solid && a instanceof d.Behaviors.solid ? this._solidBehavior = a : !this._jumpthruBehavior && d.Behaviors.jumpthru && a instanceof d.Behaviors.jumpthru && (this._jumpthruBehavior = a)
        }
        GetPluginByConstructorFunction(b) {
            return this._pluginsByCtor.get(b) || null
        }
        HasBehaviorByConstructorFunction(b) {
            return this._behaviorsByCtor.has(b)
        }
        GetBehaviorByConstructorFunction(b) {
            return this._behaviorsByCtor.get(b) || null
        }
        GetSystemPlugin() {
            return this._systemPlugin
        }
        GetSolidBehavior() {
            return this._solidBehavior
        }
        GetJumpthruBehavior() {
            return this._jumpthruBehavior
        }
    }
}
"use strict";
{
    const d = self.C3,
        b = new Set;
    d.ImageInfo = class extends d.DefendedBase {
        constructor() {
            super();
            this._url = "";
            this._height = this._width = this._offsetY = this._offsetX = this._pixelFormat = this._size = 0;
            this._hasMetaData = !1;
            this._imageAsset = null;
            this._textureState = "";
            this._rcTex = d.New(d.Rect);
            b.add(this)
        }
        Release() {
            this.ReleaseTexture();
            this._imageAsset = null;
            b.delete(this)
        }
        static OnWebGLContextLost() {
            for (const a of b) a._textureState = "", a._rcTex.set(0, 0, 0, 0)
        }
        LoadData(a) {
            this._url = a[0];
            this._size = a[1];
            this._pixelFormat =
                a[2];
            this._offsetX = a[3];
            this._offsetY = a[4];
            this._width = a[5];
            this._height = a[6];
            this._hasMetaData = !0
        }
        LoadAnimationFrameData(a) {
            this._url = a[0];
            this._size = a[1];
            this._offsetX = a[2];
            this._offsetY = a[3];
            this._width = a[4];
            this._height = a[5];
            this._pixelFormat = a[11];
            this._hasMetaData = !0
        }
        LoadDynamicAsset(a, f) {
            if (this._imageAsset) throw Error("already loaded asset");
            this._url = f;
            const c = {};
            d.IsAbsoluteURL(f) && (c.loadPolicy = "remote");
            this.LoadAsset(a, c);
            return this._imageAsset.Load()
        }
        ReplaceWith(a) {
            if (a === this) throw Error("cannot replace with self");
            this.ReleaseTexture();
            this._url = a._url;
            this._size = a._size;
            this._pixelFormat = a._pixelFormat;
            this._offsetX = a._offsetX;
            this._offsetY = a._offsetY;
            this._width = a._width;
            this._height = a._height;
            this._hasMetaData = a._hasMetaData;
            this._imageAsset = a._imageAsset;
            this._textureState = a._textureState;
            this._rcTex = a._rcTex
        }
        GetURL() {
            return this._url
        }
        GetSize() {
            return this._size
        }
        GetPixelFormat() {
            return this._pixelFormat
        }
        GetOffsetX() {
            return this._offsetX
        }
        GetOffsetY() {
            return this._offsetY
        }
        GetWidth() {
            return this._width
        }
        GetHeight() {
            return this._height
        }
        GetSheetWidth() {
            return this._imageAsset.GetWidth()
        }
        GetSheetHeight() {
            return this._imageAsset.GetHeight()
        }
        LoadAsset(a,
            f) {
            if (this._imageAsset) throw Error("already got asset");
            f = Object.assign({}, f, {
                url: this.GetURL(),
                size: this.GetSize()
            });
            this._imageAsset = a.LoadImage(f)
        }
        IsLoaded() {
            return this._imageAsset && this._imageAsset.IsLoaded()
        }
        async LoadStaticTexture(a, f) {
            if (!this._imageAsset) throw Error("no asset");
            if (this._textureState) throw Error("already loaded texture");
            this._textureState = "loading";
            a = await this._imageAsset.LoadStaticTexture(a, f);
            if (!a) return this._textureState = "", null;
            this._textureState = "loaded";
            this._hasMetaData ||
                (this._width = a.GetWidth(), this._height = a.GetHeight(), this._hasMetaData = !0);
            this._rcTex.set(this._offsetX, this._offsetY, this._offsetX + this._width, this._offsetY + this._height);
            this._rcTex.divide(a.GetWidth(), a.GetHeight());
            return a
        }
        ReleaseTexture() {
            this._textureState && (this._imageAsset && this._imageAsset.ReleaseTexture(), this._textureState = "", this._rcTex.set(0, 0, 0, 0))
        }
        GetTexture() {
            return this._imageAsset ? this._imageAsset.GetTexture() : null
        }
        GetTexRect() {
            return this._rcTex
        }
        async ExtractImageToCanvas() {
            const a =
                await this._imageAsset.LoadToDrawable(),
                f = d.CreateCanvas(this._width, this._height);
            f.getContext("2d").drawImage(a, this._offsetX, this._offsetY, this._width, this._height, 0, 0, this._width, this._height);
            return f
        }
    }
}
"use strict";
{
    const d = self.C3;
    d.AnimationInfo = class extends d.DefendedBase {
        constructor(b) {
            super();
            this._name = b[0];
            this._speed = b[1];
            this._isLooping = !!b[2];
            this._repeatCount = b[3];
            this._repeatTo = b[4];
            this._isPingPong = !!b[5];
            this._sid = b[6];
            this._frames = b[7].map(a => d.New(d.AnimationFrameInfo, a))
        }
        Release() {
            for (const b of this._frames) b.Release();
            d.clearArray(this._frames)
        }
        LoadAllAssets(b) {
            for (const a of this._frames) a.GetImageInfo().LoadAsset(b)
        }
        LoadAllTextures(b, a) {
            return Promise.all(this._frames.map(f => f.GetImageInfo().LoadStaticTexture(b,
                a)))
        }
        ReleaseAllTextures() {
            for (const b of this._frames) b.GetImageInfo().ReleaseTexture()
        }
        GetName() {
            return this._name
        }
        GetSID() {
            return this._sid
        }
        GetFrameCount() {
            return this._frames.length
        }
        GetFrames() {
            return this._frames
        }
        GetFrameAt(b) {
            b = Math.floor(b);
            if (0 > b || b >= this._frames.length) throw new RangeError("invalid frame");
            return this._frames[b]
        }
        GetSpeed() {
            return this._speed
        }
        IsLooping() {
            return this._isLooping
        }
        GetRepeatCount() {
            return this._repeatCount
        }
        GetRepeatTo() {
            return this._repeatTo
        }
        IsPingPong() {
            return this._isPingPong
        }
    }
}
"use strict";
{
    const d = self.C3;
    d.AnimationFrameInfo = class extends d.DefendedBase {
        constructor(b) {
            super();
            this._imageInfo = d.New(d.ImageInfo);
            this._imageInfo.LoadAnimationFrameData(b);
            this._duration = b[6];
            this._origin = d.New(d.Vector2, b[7], b[8]);
            this._imagePoints = b[9].map(a => d.New(d.ImagePoint, this, a));
            this._imagePointsByName = new Map;
            for (const a of this._imagePoints) this._imagePointsByName.set(a.GetName().toLowerCase(), a);
            this._collisionPoly = null;
            b = b[10];
            6 <= b.length && (this._collisionPoly = d.New(d.CollisionPoly, b))
        }
        Release() {
            this._collisionPoly &&
                (this._collisionPoly.Release(), this._collisionPoly = null);
            this._imageInfo.Release();
            this._imageInfo = null
        }
        GetImageInfo() {
            return this._imageInfo
        }
        GetDuration() {
            return this._duration
        }
        GetOriginX() {
            return this._origin.getX()
        }
        GetOriginY() {
            return this._origin.getY()
        }
        GetCollisionPoly() {
            return this._collisionPoly
        }
        GetImagePointByName(b) {
            return this._imagePointsByName.get(b.toLowerCase()) || null
        }
        GetImagePointByIndex(b) {
            b = Math.floor(b);
            return 0 > b || b >= this._imagePoints.length ? null : this._imagePoints[b]
        }
        GetImagePointCount() {
            return this._imagePoints.length
        }
    }
}
"use strict";
{
    const d = self.C3;
    d.ImagePoint = class extends d.DefendedBase {
        constructor(b, a) {
            super();
            this._afi = b;
            this._name = a[0];
            this._pos = d.New(d.Vector2, a[1], a[2])
        }
        Release() {}
        GetName() {
            return this._name
        }
        GetX() {
            return this._pos.getX()
        }
        GetY() {
            return this._pos.getY()
        }
        GetVec2() {
            return this._pos
        }
    }
}
"use strict";
{
    const d = self.C3,
        b = self.C3Debugger,
        a = self.IObjectClass;
    d.ObjectClass = class extends d.DefendedBase {
        constructor(f, c, e) {
            super();
            const g = f.GetObjectReference(e[1]);
            this._runtime = f;
            this._plugin = f.GetPluginManager().GetPluginByConstructorFunction(g);
            this._sdkType = null;
            this._instSdkCtor = g.Instance;
            this._index = c;
            this._sid = e[11];
            this._name = e[0];
            this._jsPropName = this._runtime.GetJsPropName(e[14]);
            this._isGlobal = !!e[9];
            this._isFamily = !!e[2];
            this._isOnLoaderLayout = !!e[10];
            this._instVars = e[3].map(h => ({
                sid: h[0],
                type: h[1],
                name: h[2],
                jsPropName: f.GetJsPropName(h[3])
            }));
            this._behaviorsCount = e[4];
            this._effectsCount = e[5];
            this._isWorldType = this._plugin.IsWorldType();
            this._effectList = null;
            this._collisionGrid = d.New(d.SparseGrid, f.GetOriginalViewportWidth(), f.GetOriginalViewportHeight());
            this._anyCollisionCellChanged = !0;
            this._anyInstanceParallaxed = !1;
            this._familyMembersSet = this._familyMembers = null;
            this._familyIndex = -1;
            this._familyEffectMap = this._familyBehaviorMap = this._familyInstVarMap = this._familiesSet = this._families =
                null;
            this._isInContainer = !1;
            this._container = null;
            this._behaviorTypes = e[8].map(h => d.BehaviorType.Create(this, h));
            this._behaviorTypesIncludingInherited = [];
            this._behaviorsByName = new Map;
            this._behaviorNameToIndex = new Map;
            this._usedBehaviorCtors = new Set;
            this._solStack = d.New(d.SolStack, this);
            this._defaultInstanceData = null;
            this._defaultLayerIndex = 0;
            this._isContained = !1;
            this._animationsBySid = this._animationsByName = this._animations = this._imageInfo = this._container = null;
            this._textureRefCount = 0;
            this._savedData =
                new Map;
            this._unsavedData = new Map;
            this._instances = [];
            this._iidsStale = !0;
            this._plugin.HasEffects() && (this._effectList = d.New(d.EffectList, this, e[12]));
            e[6] && (this._imageInfo = d.New(d.ImageInfo), this._imageInfo.LoadData(e[6]));
            if (e[7]) {
                this._animations = e[7].map(h => d.New(d.AnimationInfo, h));
                this._animationsByName = new Map;
                this._animationsBySid = new Map;
                for (const h of this._animations) this._animationsByName.set(h.GetName().toLowerCase(), h), this._animationsBySid.set(h.GetSID(), h)
            }
            this._isFamily ? (this._familyMembers = [], this._familyMembersSet = new Set, this._familyIndex = this._runtime._GetNextFamilyIndex()) : (this._families = [], this._familiesSet = new Set, this._familyInstVarMap = [], this._familyBehaviorMap = [], this._familyEffectMap = []);
            this._sdkType = d.New(g.Type, this, e[15]);
            this._instanceUserScriptClass = this._iObjectClass = null;
            this._userScriptDispatcher = d.New(d.Event.Dispatcher);
            if (c = this._sdkType.GetScriptInterfaceClass()) {
                if (this._iObjectClass = new c(this), !(this._iObjectClass instanceof a)) throw new TypeError("script interface class must derive from IObjectClass");
            } else this._iObjectClass = new a(this);
            e[13] && (c = e[13]) && this._sdkType.LoadTilemapData(c[0], c[1]);
            this._runtime.UsesLoaderLayout() && !this._isFamily && !this._isOnLoaderLayout && this._isWorldType || this.OnCreate();
            this._plugin.IsSingleGlobal() && (this._plugin._SetSingleGlobalObjectClass(this), this._CreateSingleGlobalInstance(e))
        }
        static Create(f, c, e) {
            return d.New(d.ObjectClass, f, c, e)
        }
        Release() {
            this._imageInfo && (this._imageInfo.Release(), this._imageInfo = null);
            if (this._animations) {
                for (const f of this._animations) f.Release();
                d.clearArray(this._animations);
                this._animationsByName.clear();
                this._animationsBySid.clear()
            }
            this._solStack.Release();
            this._solStack = null;
            this._savedData.clear();
            this._unsavedData.clear();
            this._runtime = this._container = null
        }
        _LoadFamily(f) {
            for (let c = 1, e = f.length; c < e; ++c) {
                const g = this._runtime.GetObjectClassByIndex(f[c]);
                this._familyMembers.push(g);
                this._familyMembersSet.add(g);
                g._families.push(this);
                g._familiesSet.add(this)
            }
        }
        _SetContainer(f) {
            this._isInContainer = !0;
            this._container = f
        }
        IsInContainer() {
            return this._isInContainer
        }
        GetContainer() {
            return this._container
        }
        _OnAfterCreate() {
            var f =
                0;
            if (!this._isFamily)
                for (var c of this._families)
                    for (var e of c.GetBehaviorTypes()) {
                        const l = e.GetName().toLowerCase();
                        this._behaviorsByName.set(l, e);
                        this._behaviorNameToIndex.set(l, f);
                        this._behaviorTypesIncludingInherited.push(e);
                        ++f
                    }
            for (var g of this.GetBehaviorTypes()) c = g.GetName().toLowerCase(), this._behaviorsByName.set(c, g), this._behaviorNameToIndex.set(c, f), this._behaviorTypesIncludingInherited.push(g), ++f;
            for (var h of this._behaviorTypesIncludingInherited) this._usedBehaviorCtors.add(h.GetBehavior().constructor);
            if (!this._isFamily && this._families.length) {
                f = this._runtime.GetFamilyCount();
                d.extendArray(this._familyInstVarMap, f, 0);
                d.extendArray(this._familyBehaviorMap, f, 0);
                d.extendArray(this._familyEffectMap, f, 0);
                f = [];
                c = h = g = 0;
                for (const l of this._families)
                    if (e = l.GetFamilyIndex(), this._familyInstVarMap[e] = g, g += l.GetInstanceVariablesCount(), this._familyBehaviorMap[e] = h, h += l.GetBehaviorTypesCount(), this._familyEffectMap[e] = c, c += l.GetEffectTypesCount(), (e = l.GetEffectList()) && this._effectList)
                        for (const m of e.GetAllEffectTypes()) f.push(m.Clone(this._effectList));
                this._effectList && this._effectList.PrependEffectTypes(f)
            }
        }
        _CreateSingleGlobalInstance(f) {
            const c = this._runtime._GetNewUID(),
                e = d.New(d.Instance, {
                    runtime: this._runtime,
                    objectType: this,
                    uid: c
                });
            e._CreateSdkInstance(f[16], []);
            this._runtime._MapInstanceByUID(c, e);
            this._instances.push(e)
        }
        GetSdkType() {
            return this._sdkType
        }
        IsOnLoaderLayout() {
            return this._isOnLoaderLayout
        }
        OnCreate() {
            this._isFamily || this._sdkType.OnCreate()
        }
        HasLoadedTextures() {
            return 0 < this._textureRefCount
        }
        LoadTextures(f) {
            if (this._isFamily) return Promise.resolve();
            this._textureRefCount++;
            return 1 === this._textureRefCount ? this._sdkType.LoadTextures(f) || Promise.resolve() : Promise.resolve()
        }
        ReleaseTextures() {
            if (!this._isFamily) {
                this._textureRefCount--;
                if (0 > this._textureRefCount) throw Error("released textures too many times");
                0 === this._textureRefCount && this._sdkType.ReleaseTextures()
            }
        }
        OnDynamicTextureLoadComplete() {
            if (this._isFamily) throw Error("not applicable to family");
            this._sdkType.OnDynamicTextureLoadComplete()
        }
        PreloadTexturesWithInstances(f) {
            return this._isFamily ?
                Promise.resolve() : this._sdkType.PreloadTexturesWithInstances(f)
        }
        GetRuntime() {
            return this._runtime
        }
        GetPlugin() {
            return this._plugin
        }
        GetInstanceSdkCtor() {
            return this._instSdkCtor
        }
        GetName() {
            return this._name
        }
        GetJsPropName() {
            return this._jsPropName
        }
        GetIndex() {
            return this._index
        }
        GetSID() {
            return this._sid
        }
        IsFamily() {
            return this._isFamily
        }
        IsGlobal() {
            return this._isGlobal
        }
        IsWorldType() {
            return this._isWorldType
        }
        GetFamilyIndex() {
            return this._familyIndex
        }
        GetBehaviorTypes() {
            return this._behaviorTypes
        }
        GetBehaviorTypesCount() {
            return this._behaviorsCount
        }
        UsesBehaviorByCtor(f) {
            return f &&
                this._usedBehaviorCtors.has(f)
        }
        GetInstanceVariablesCount() {
            return this._instVars.length
        }
        GetInstanceVariableSIDs() {
            return this._instVars.map(f => f.sid)
        }
        GetInstanceVariableIndexBySID(f) {
            return this._instVars.findIndex(c => c.sid === f)
        }
        GetInstanceVariableIndexByName(f) {
            return this._instVars.findIndex(c => c.name === f)
        }
        _GetAllInstanceVariableNames() {
            return this._instVars.map(f => f.name)
        }
        _GetAllInstanceVariableJsPropNames() {
            return this._instVars.map(f => f.jsPropName)
        }
        GetInstanceVariableType(f) {
            f = Math.floor(f);
            if (0 > f || f >= this._instVars.length) throw new RangeError("invalid instance variable index");
            return this._instVars[f].type
        }
        GetInstanceVariableName(f) {
            f = Math.floor(f);
            if (0 > f || f >= this._instVars.length) throw new RangeError("invalid instance variable index");
            return this._instVars[f].name
        }
        GetEffectTypesCount() {
            return this._effectsCount
        }
        GetBehaviorTypesIncludingInherited() {
            return this._behaviorTypesIncludingInherited
        }
        GetBehaviorTypeByName(f) {
            return this._behaviorsByName.get(f.toLowerCase()) || null
        }
        GetBehaviorIndexByName(f) {
            f =
                this._behaviorNameToIndex.get(f.toLowerCase());
            return "undefined" === typeof f ? -1 : f
        }
        GetEffectList() {
            return this._effectList
        }
        HasEffects() {
            return this._plugin.HasEffects()
        }
        UsesEffects() {
            return this._effectList && this._effectList.HasAnyEffectType()
        }
        GetSolStack() {
            return this._solStack
        }
        GetCurrentSol() {
            return this._solStack.GetCurrentSol()
        }
        GetImageInfo() {
            return this._imageInfo
        }
        SetDefaultInstanceData(f) {
            this._defaultInstanceData = f
        }
        GetDefaultInstanceData() {
            return this._defaultInstanceData
        }
        _SetDefaultLayerIndex(f) {
            this._defaultLayerIndex =
                f
        }
        GetDefaultLayerIndex() {
            return this._defaultLayerIndex
        }
        GetAnimations() {
            return this._animations
        }
        GetAnimationCount() {
            return this._animations.length
        }
        GetFamilies() {
            return this._families
        }
        BelongsToFamily(f) {
            return this._familiesSet.has(f)
        }
        GetFamilyMembers() {
            return this._familyMembers
        }
        FamilyHasMember(f) {
            return this._familyMembersSet.has(f)
        }
        GetFamilyBehaviorOffset(f) {
            return this._familyBehaviorMap[f]
        }
        GetFamilyInstanceVariableOffset(f) {
            return this._familyInstVarMap[f]
        }
        GetAnimationByName(f) {
            if (!this._animations) throw Error("no animations");
            return this._animationsByName.get(f.toLowerCase()) || null
        }
        GetAnimationBySID(f) {
            if (!this._animations) throw Error("no animations");
            return this._animationsBySid.get(f) || null
        }
        GetFirstAnimationFrame() {
            if (!this._animations) throw Error("no animations");
            return this._animations[0].GetFrameAt(0)
        }
        GetDefaultInstanceSize() {
            if (this._animations) {
                const f = this.GetFirstAnimationFrame().GetImageInfo();
                return [f.GetWidth(), f.GetHeight()]
            }
            return this._imageInfo ? [this._imageInfo.GetWidth(), this._imageInfo.GetHeight()] : [100,
                100
            ]
        }
        GetSingleGlobalInstance() {
            if (!this._plugin.IsSingleGlobal()) throw Error("not a single-global plugin");
            return this._instances[0]
        }
        GetInstances() {
            return this._instances
        }* instances() {
            yield* this._instances
        }* instancesIncludingPendingCreate() {
            yield* this._instances;
            for (const f of this._runtime._GetInstancesPendingCreate()) f.GetObjectClass() === this && (yield f)
        }
        GetInstanceCount() {
            return this._instances.length
        }
        _AddInstance(f) {
            this._instances.push(f)
        }
        _SetIIDsStale() {
            this._iidsStale = !0
        }
        _UpdateIIDs() {
            if (this._iidsStale &&
                !this._isFamily) {
                var f = this._instances,
                    c = 0;
                for (let e = f.length; c < e; ++c) f[c]._SetIID(c);
                f = this._runtime._GetInstancesPendingCreate();
                for (const e of f) e.GetObjectClass() === this && e._SetIID(c++);
                this._iidsStale = !1
            }
        }
        GetInstanceByIID(f) {
            var c = this._instances;
            if (f < c.length) return c[f];
            f -= c.length;
            c = this._runtime._GetInstancesPendingCreate();
            for (const e of c)
                if (e.GetObjectClass() === this) {
                    if (0 === f) return e;
                    --f
                } return null
        }
        GetFirstPicked(f) {
            if (f && f.IsInContainer() && f.GetObjectClass() !== this)
                for (const c of f.siblings())
                    if (c.GetObjectClass() ===
                        this) return c;
            f = this.GetCurrentSol().GetInstances();
            return f.length ? f[0] : null
        }
        GetPairedInstance(f) {
            const c = this.GetCurrentSol().GetInstances();
            return c.length ? c[f.GetIID() % c.length] : null
        }* allCorrespondingInstances(f, c) {
            const e = this.GetCurrentSol().GetInstances();
            var g = e.length;
            const h = c.GetCurrentSol(),
                l = c.GetCurrentSol().GetInstances(),
                m = l.length;
            var p = f.GetIID();
            if (c.IsFamily() || !h.IsSelectAll()) p = l.indexOf(f);
            f = Math.ceil(g / m);
            g %= m;
            0 === g || p < g ? (p *= f, g = f) : (p = g * f + (p - g) * (f - 1), g = f - 1);
            for (let t = p, q = p +
                    g; t < q; ++t) yield e[t]
        }
        FinishCondition(f) {
            this._sdkType.FinishCondition(f)
        }
        ApplySolToContainer() {
            if (this._isInContainer && !this._isFamily) {
                this._UpdateIIDs();
                var f = this.GetCurrentSol(),
                    c = f._GetOwnInstances(),
                    e = f.IsSelectAll(),
                    g = this._runtime.GetCurrentEventStackFrame();
                g = g && g.GetCurrentEvent() && g.GetCurrentEvent().IsOrBlock();
                for (const m of this._container.objectTypes())
                    if (m !== this) {
                        m._UpdateIIDs();
                        var h = m.GetCurrentSol();
                        h._SetSelectAll(e);
                        if (!e) {
                            var l = h._GetOwnInstances();
                            d.clearArray(l);
                            for (const p of c) l.push(m.GetInstanceByIID(p.GetIID()));
                            if (g) {
                                l = f._GetOwnElseInstances();
                                h = h._GetOwnElseInstances();
                                d.clearArray(h);
                                for (const p of l) h.push(m.GetInstanceByIID(p.GetIID()))
                            }
                        }
                    }
            }
        }
        _TruncateContainerSols(f, c) {
            for (const e of this.GetContainer().objectTypes()) {
                const g = e.GetCurrentSol();
                f ? d.truncateArray(g._GetOwnElseInstances(), c) : d.truncateArray(g._GetOwnInstances(), c)
            }
        }
        _GetCollisionCellGrid() {
            return this._collisionGrid
        }
        _SetAnyCollisionCellChanged(f) {
            this._anyCollisionCellChanged = !!f
        }
        _SetAnyInstanceParallaxed(f) {
            this._anyInstanceParallaxed = !!f
        }
        IsAnyInstanceParallaxed() {
            return this._anyInstanceParallaxed
        }
        _UpdateAllCollisionCells() {
            if (this._anyCollisionCellChanged &&
                this._isWorldType) {
                for (const f of this._instances) f.GetWorldInfo()._UpdateCollisionCell();
                for (const f of this._runtime._GetInstancesPendingCreate()) f.GetObjectClass() === this && f.GetWorldInfo()._UpdateCollisionCell();
                this._anyCollisionCellChanged = !1
            }
        }
        GetSavedDataMap() {
            this._savedData || (this._savedData = new Map);
            return this._savedData
        }
        GetUnsavedDataMap() {
            this._unsavedData || (this._unsavedData = new Map);
            return this._unsavedData
        }
        HasSolidBehavior() {
            return this.UsesBehaviorByCtor(d.Behaviors.solid)
        }
        HasNoSaveBehavior() {
            return this.UsesBehaviorByCtor(d.Behaviors.NoSave)
        }
        HasPersistBehavior() {
            return this.UsesBehaviorByCtor(d.Behaviors.Persist)
        }
        _SaveToJson() {
            const f = {
                instances: this._instances.map(c => c.SaveToJson())
            };
            this._savedData && this._savedData.size && (f.ex = d.ToSuperJSON(this._savedData));
            return f
        }
        _LoadFromJson(f) {
            this._savedData && (this._savedData.clear(), this._savedData = null);
            var c = f.ex;
            c && (this._savedData = d.FromSuperJSON(c));
            c = this._instances;
            f = f.instances;
            for (let e = 0, g = Math.min(c.length, f.length); e < g; ++e) c[e].LoadFromJson(f[e]);
            for (let e = f.length, g = c.length; e < g; ++e) this._runtime.DestroyInstance(c[e]);
            for (let e = c.length, g = f.length; e < g; ++e) {
                c = f[e];
                let h =
                    null;
                if (this.IsWorldType() && (h = this._runtime.GetMainRunningLayout().GetLayerBySID(c.w.l), !h)) continue;
                this._runtime.CreateInstanceFromData(this._defaultInstanceData || this, h, !1, 0, 0, !0).LoadFromJson(c)
            }
            this._SetIIDsStale()
        }
        GetIObjectClass() {
            return this._iObjectClass
        }
        UserScriptDispatcher() {
            return this._userScriptDispatcher
        }
        _GetUserScriptInstanceClass() {
            return this._instanceUserScriptClass
        }
        _SetUserScriptInstanceClass(f) {
            this._instanceUserScriptClass = f
        }
        DispatchUserScriptEvent(f) {
            var c = this._runtime;
            (c =
                c.IsDebug() && !c.GetEventSheetManager().IsInEventEngine()) && b.StartMeasuringScriptTime();
            this._userScriptDispatcher.dispatchEvent(f);
            c && b.AddScriptTime()
        }
    }
}
"use strict";
{
    const d = self.C3;
    d.Container = class extends d.DefendedBase {
        constructor(b, a) {
            super();
            this._runtime = b;
            this._objectTypes = a;
            for (const f of this._objectTypes) f._SetContainer(this)
        }
        Release() {
            this._runtime = null
        }
        GetRuntime() {
            return this._runtime
        }
        GetObjectTypes() {
            return this._objectTypes
        }
        objectTypes() {
            return this._objectTypes
        }
        HasAnyWorldType() {
            return this._objectTypes.some(b => b.IsWorldType())
        }
    }
}
"use strict";
{
    const d = self.C3,
        b = self.C3Debugger,
        a = self.IInstance,
        f = [];
    let c = 0;
    const e = new WeakMap,
        g = new WeakMap;
    d.Instance = class extends d.DefendedBase {
        constructor(h) {
            super();
            this._runtime = h.runtime;
            this._objectType = h.objectType;
            this._iScriptInterface = this._sdkInst = this._worldInfo = null;
            this._iid = 0;
            this._uid = h.uid;
            this._puid = c++;
            this._flags = 0;
            this._behaviorInstances = this._instVarValues = f;
            var l = this._objectType.GetBehaviorTypesIncludingInherited();
            0 < l.length && (this._behaviorInstances = l.map((m, p) => d.New(d.BehaviorInstance, {
                runtime: this._runtime,
                behaviorType: m,
                instance: this,
                index: p
            })));
            this._siblings = this._objectType.IsInContainer() ? [] : null;
            this._timeScale = -1;
            this._dispatcher = null;
            l = this.GetPlugin();
            l.MustPreDraw() && (this._flags |= 4);
            if (l.IsWorldType())
                if (this._worldInfo = d.New(d.WorldInfo, this, h.layer), h.worldData) this._worldInfo.Init(h.worldData);
                else {
                    this._worldInfo.InitNoData();
                    const [m, p] = this._objectType.GetDefaultInstanceSize();
                    this._worldInfo.SetSize(m, p);
                    this.GetObjectClass().UsesEffects() && this._worldInfo.GetInstanceEffectList().LoadDefaultEffectParameters()
                } h.instVarData ?
                this._LoadInstanceVariableData(h.instVarData) : this._LoadDefaultInstanceVariables()
        }
        Release() {
            this._iScriptInterface && (this._iScriptInterface._Release(), this._iScriptInterface = null);
            if (0 < this._behaviorInstances.length) {
                for (var h of this._behaviorInstances) h.Release();
                d.clearArray(this._behaviorInstances)
            }
            this._sdkInst.Release();
            this._sdkInst = null;
            if (h = e.get(this)) h.clear(), e.delete(this);
            if (h = g.get(this)) h.clear(), g.delete(this);
            this._siblings && d.clearArray(this._siblings);
            this._dispatcher && (this._dispatcher.Release(),
                this._dispatcher = null);
            this._objectType = this._runtime = null;
            0 < this._instVarValues.length && d.clearArray(this._instVarValues);
            this._worldInfo && (this._worldInfo.Release(), this._worldInfo = null)
        }
        _LoadInstanceVariableData(h) {
            0 < h.length && (this._instVarValues = [], d.shallowAssignArray(this._instVarValues, h))
        }
        _LoadDefaultInstanceVariables() {
            const h = this._objectType.GetInstanceVariablesCount();
            if (0 !== h) {
                this._instVarValues = [];
                var l = [0, 0, ""];
                for (let m = 0; m < h; ++m) this._instVarValues.push(l[this._objectType.GetInstanceVariableType(m)])
            }
        }
        _CreateSdkInstance(h,
            l) {
            if (this._sdkInst) throw Error("already got sdk instance");
            for (let m = 0, p = this._behaviorInstances.length; m < p; ++m) this._behaviorInstances[m]._CreateSdkInstance(l ? l[m] : null);
            this._sdkInst = d.New(this._objectType.GetInstanceSdkCtor(), this, h);
            if (!(this._sdkInst instanceof d.SDKInstanceBase)) throw Error("sdk type must derive from SDKInstanceBase");
            for (let m = 0, p = this._behaviorInstances.length; m < p; ++m) this._behaviorInstances[m].PostCreate();
            this._objectType._GetUserScriptInstanceClass() && this._InitUserScriptInterface()
        }
        GetSdkInstance() {
            return this._sdkInst
        }
        GetWorldInfo() {
            return this._worldInfo
        }
        GetRuntime() {
            return this._runtime
        }
        GetTimeScale() {
            return this._timeScale
        }
        GetActiveTimeScale() {
            const h =
                this._timeScale;
            return -1 === h ? this.GetRuntime().GetTimeScale() : h
        }
        SetTimeScale(h) {
            h = +h;
            if (0 > h || !isFinite(h)) h = 0;
            this._timeScale = h
        }
        RestoreTimeScale() {
            this._timeScale = -1
        }
        Dispatcher() {
            this._dispatcher || (this._dispatcher = d.New(d.Event.Dispatcher));
            return this._dispatcher
        }
        Draw(h) {
            this._sdkInst.Draw(h)
        }
        OnCreate(h) {
            this._sdkInst.OnCreate(h)
        }
        _SetHasTilemap() {
            this._flags |= 2
        }
        HasTilemap() {
            return 0 !== (this._flags & 2)
        }
        _MarkDestroyed() {
            this._flags |= 1
        }
        IsDestroyed() {
            return 0 !== (this._flags & 1)
        }
        MustPreDraw() {
            return 0 !==
                (this._flags & 4)
        }
        _IsSolidEnabled() {
            return 0 !== (this._flags & 8)
        }
        _SetSolidEnabled(h) {
            this._flags = h ? this._flags | 8 : this._flags & -9
        }
        _IsJumpthruEnabled() {
            return 0 !== (this._flags & 16)
        }
        _SetJumpthruEnabled(h) {
            this._flags = h ? this._flags | 16 : this._flags & -17
        }
        SetFlag(h, l) {
            h <<= 16;
            this._flags = l ? this._flags | h : this._flags & ~h
        }
        GetFlag(h) {
            return 0 !== (this._flags & h << 16)
        }
        GetCurrentImageInfo() {
            return this._sdkInst.GetCurrentImageInfo()
        }
        GetCurrentSurfaceSize() {
            return this._sdkInst.GetCurrentSurfaceSize()
        }
        GetCurrentTexRect() {
            return this._sdkInst.GetCurrentTexRect()
        }
        GetImagePoint(h) {
            return this._sdkInst.GetImagePoint(h)
        }
        GetObjectClass() {
            return this._objectType
        }
        BelongsToObjectClass(h) {
            return h.IsFamily() ?
                h.FamilyHasMember(this.GetObjectClass()) : this.GetObjectClass() === h
        }
        VerifySupportsSceneGraph() {
            if (!this.GetPlugin().SupportsSceneGraph()) throw Error("object does not support scene graph");
        }
        HasParent() {
            return null !== this.GetParent()
        }
        GetParent() {
            var h = this.GetWorldInfo();
            return h ? (h = h.GetParent()) ? h.GetInstance() : null : null
        }
        GetTopParent() {
            var h = this.GetWorldInfo();
            return h ? (h = h.GetTopParent()) ? h.GetInstance() : null : null
        }* parents() {
            const h = this.GetWorldInfo();
            if (h)
                for (const l of h.parents()) yield l.GetInstance()
        }
        HasChildren() {
            const h =
                this.GetWorldInfo();
            return h ? h.HasChildren() : !1
        }
        GetChildren() {
            const h = this.GetWorldInfo();
            return h ? h.GetChildren().map(l => l.GetInstance()) : []
        }* children() {
            const h = this.GetWorldInfo();
            if (h)
                for (const l of h.children()) yield l.GetInstance()
        }* allChildren() {
            const h = this.GetWorldInfo();
            if (h)
                for (const l of h.allChildren()) yield l.GetInstance()
        }
        GetChildCount() {
            const h = this.GetWorldInfo();
            return h ? h.GetChildCount() : 0
        }
        GetChildAt(h) {
            const l = this.GetWorldInfo();
            return l ? (h = l.GetChildAt(h)) ? h.GetInstance() : null :
                null
        }
        AddChild(h, l) {
            this.VerifySupportsSceneGraph();
            h.VerifySupportsSceneGraph();
            this.GetWorldInfo().AddChild(h.GetWorldInfo(), l || {})
        }
        RemoveChild(h) {
            const l = this.GetWorldInfo();
            l && l.RemoveChild(h.GetWorldInfo())
        }
        GetDestroyWithParent() {
            const h = this.GetWorldInfo();
            return h ? h.GetDestroyWithParent() : !1
        }
        SetupInitialSceneGraphConnections() {
            var h = this.GetWorldInfo();
            if (h && (h = h.GetSceneGraphChildrenExportData()))
                for (const l of h)
                    if (h = this._runtime.GetInstanceByUID(l[2])) {
                        const m = l[3];
                        this.AddChild(h, {
                            transformX: !!(m >>
                                0 & 1),
                            transformY: !!(m >> 1 & 1),
                            transformWidth: !!(m >> 2 & 1),
                            transformHeight: !!(m >> 3 & 1),
                            transformAngle: !!(m >> 4 & 1),
                            destroyWithParent: !!(m >> 5 & 1),
                            transformZElevation: !!(m >> 6 & 1)
                        })
                    }
        }
        IsInContainer() {
            return null !== this._siblings
        }
        _AddSibling(h) {
            this._siblings.push(h)
        }
        GetSiblings() {
            return this._siblings
        }
        HasSibling(h) {
            return !!this.GetSibling(h)
        }
        GetSibling(h) {
            const l = this.siblings();
            if (null === l || 0 === l.length) return !1;
            for (const m of l)
                if (m.GetObjectClass() === h) return m;
            return null
        }
        siblings() {
            return this._siblings
        }
        SetSiblingsSinglePicked() {
            for (const h of this.siblings()) h.GetObjectClass().GetCurrentSol().SetSinglePicked(h)
        }
        _PushSiblingsToSolInstances() {
            for (const h of this.siblings()) h.GetObjectClass().GetCurrentSol()._PushInstance(h)
        }
        _SetSiblingsToSolInstancesIndex(h) {
            for (const l of this.siblings()) l.GetObjectClass().GetCurrentSol()._GetOwnInstances()[h] =
                l
        }
        _PushSiblingsToSolElseInstances() {
            for (const h of this.siblings()) h.GetObjectClass().GetCurrentSol()._PushElseInstance(h)
        }
        _SetSiblingsToSolElseInstancesIndex(h) {
            for (const l of this.siblings()) l.GetObjectClass().GetCurrentSol()._GetOwnElseInstances()[h] = l
        }
        GetPlugin() {
            return this._objectType.GetPlugin()
        }
        _SetIID(h) {
            this._iid = h
        }
        GetIID() {
            this._objectType._UpdateIIDs();
            return this._iid
        }
        GetUID() {
            return this._uid
        }
        GetPUID() {
            return this._puid
        }
        GetBehaviorInstances() {
            return this._behaviorInstances
        }
        GetBehaviorInstanceFromCtor(h) {
            if (!h) return null;
            for (const l of this._behaviorInstances)
                if (l.GetBehavior() instanceof h) return l;
            return null
        }
        GetBehaviorSdkInstanceFromCtor(h) {
            return h ? (h = this.GetBehaviorInstanceFromCtor(h)) ? h.GetSdkInstance() : null : null
        }
        GetBehaviorIndexBySID(h) {
            const l = this._behaviorInstances;
            for (let m = 0, p = l.length; m < p; ++m)
                if (l[m].GetBehaviorType().GetSID() === h) return m;
            return -1
        }
        GetAllInstanceVariableValues() {
            return this._instVarValues
        }
        _GetAllInstanceVariableNames() {
            return this._objectType._GetAllInstanceVariableNames()
        }
        GetInstanceVariableCount() {
            return this._instVarValues.length
        }
        GetInstanceVariableValue(h) {
            h |=
                0;
            const l = this._instVarValues;
            if (0 > h || h >= l.length) throw new RangeError("invalid instance variable");
            return l[h]
        }
        _GetInstanceVariableValueUnchecked(h) {
            return this._instVarValues[h]
        }
        _GetInstanceVariableTypedValue(h) {
            const l = this._instVarValues[h];
            return 0 === this._objectType.GetInstanceVariableType(h) ? !!l : l
        }
        SetInstanceVariableValue(h, l) {
            h |= 0;
            const m = this._instVarValues;
            if (0 > h || h >= m.length) throw new RangeError("invalid instance variable");
            switch (this._objectType.GetInstanceVariableType(h)) {
                case 0:
                    m[h] =
                        l ? 1 : 0;
                    break;
                case 1:
                    m[h] = "number" === typeof l ? l : parseFloat(l);
                    break;
                case 2:
                    m[h] = "string" === typeof l ? l : l.toString();
                    break;
                default:
                    throw Error("unknown instance variable type");
            }
        }
        SetInstanceVariableOffset(h, l) {
            if (0 !== l) {
                h |= 0;
                var m = this._instVarValues;
                if (0 > h || h >= m.length) throw new RangeError("invalid instance variable");
                var p = m[h];
                if ("number" === typeof p) m[h] = "number" === typeof l ? m[h] + l : m[h] + parseFloat(l);
                else {
                    if ("boolean" === typeof p) throw Error("can not set offset of boolean variable");
                    if ("string" === typeof p) throw Error("can not set offset of string variable");
                    throw Error("unknown instance variable type");
                }
            }
        }
        GetSavedDataMap() {
            let h = e.get(this);
            if (h) return h;
            h = new Map;
            e.set(this, h);
            return h
        }
        GetUnsavedDataMap() {
            let h = g.get(this);
            if (h) return h;
            h = new Map;
            g.set(this, h);
            return h
        }
        _HasAnyCreateDestroyHandler(h) {
            const l = this.GetObjectClass();
            if (l.UserScriptDispatcher().HasAnyHandlerFor(h)) return !0;
            for (const m of l.GetFamilies())
                if (m.UserScriptDispatcher().HasAnyHandlerFor(h)) return !0;
            return this._runtime.UserScriptDispatcher().HasAnyHandlerFor(h) ? !0 : !1
        }
        _TriggerOnCreatedOnSelfAndRelated() {
            const h =
                new Set;
            h.add(this);
            const l = this.GetWorldInfo();
            if (l && l.HasChildren())
                for (const m of this.allChildren())
                    if (h.add(m), m.IsInContainer())
                        for (const p of m.siblings()) h.add(p);
            if (this.IsInContainer())
                for (const m of this.siblings()) h.add(m);
            for (const m of h.values()) m._TriggerOnCreated()
        }
        _TriggerOnCreated() {
            if (this._HasAnyCreateDestroyHandler("instancecreate")) {
                const h = this.GetObjectClass(),
                    l = new d.Event("instancecreate");
                l.instance = this.GetInterfaceClass();
                h.DispatchUserScriptEvent(l);
                for (const m of h.GetFamilies()) m.DispatchUserScriptEvent(l);
                this._runtime.DispatchUserScriptEvent(l)
            }
            this._runtime.Trigger(this.GetPlugin().constructor.Cnds.OnCreated, this, null)
        }
        _TriggerOnDestroyed() {
            this._runtime.Trigger(this.GetPlugin().constructor.Cnds.OnDestroyed, this, null)
        }
        _FireDestroyedScriptEvents(h) {
            if (this._iScriptInterface) {
                var l = new d.Event("destroy");
                l.isEndingLayout = h;
                this.DispatchUserScriptEvent(l)
            }
            if (this._HasAnyCreateDestroyHandler("instancedestroy")) {
                l = this.GetObjectClass();
                var m = new d.Event("instancedestroy");
                m.instance = this.GetInterfaceClass();
                m.isEndingLayout = h;
                l.DispatchUserScriptEvent(m);
                for (const p of l.GetFamilies()) p.DispatchUserScriptEvent(m);
                this._runtime.DispatchUserScriptEvent(m)
            }
        }
        _GetDebuggerProperties() {
            return this._sdkInst.GetDebuggerProperties()
        }
        SaveToJson(h = "full") {
            const l = {};
            "full" === h ? l.uid = this.GetUID() : l.c3 = !0;
            if ("visual-state" !== h) {
                var m = e.get(this);
                m && m.size && (l.ex = d.ToSuperJSON(m)); - 1 !== this.GetTimeScale() && (l.mts = this.GetTimeScale());
                if (0 < this._objectType.GetInstanceVariablesCount()) {
                    m = {};
                    var p = this._objectType.GetInstanceVariableSIDs();
                    for (let t = 0, q = this._instVarValues.length; t < q; ++t) m[p[t].toString()] = this._instVarValues[t];
                    l.ivs = m
                }
                if (this._behaviorInstances.length) {
                    m = {};
                    for (const t of this._behaviorInstances)(p = t.SaveToJson()) && (m[t.GetBehaviorType().GetSID().toString()] = p);
                    l.behs = m
                }
            }
            this._worldInfo && (l.w = this._worldInfo._SaveToJson(h));
            (h = this._sdkInst.SaveToJson()) && (l.data = h);
            return l
        }
        _OnBeforeLoad(h = "full") {
            this._worldInfo && this._worldInfo._OnBeforeLoad(h)
        }
        LoadFromJson(h, l = "full") {
            if ("full" === l) this._uid = h.uid;
            else if (!h.c3) return;
            if ("visual-state" !== l) {
                var m = e.get(this);
                m && (m.clear(), e.delete(this));
                if (m = h.ex) m = d.FromSuperJSON(m), e.set(this, m);
                this._timeScale = h.hasOwnProperty("mts") ? h.mts : -1;
                if (m = h.ivs)
                    for (const [q, r] of Object.entries(m))
                        if (m = parseInt(q, 10), m = this._objectType.GetInstanceVariableIndexBySID(m), !(0 > m || m >= this._instVarValues.length)) {
                            var p = r;
                            null === p && (p = NaN);
                            this._instVarValues[m] = p
                        }
            }
            if (this.GetPlugin().IsWorldType()) {
                m = h.w;
                var t = m.l;
                this._worldInfo.GetLayer().GetSID() !== t && (p = this._worldInfo.GetLayer(), (t = p.GetLayout().GetLayerBySID(t)) ?
                    (this._worldInfo._SetLayer(t), p._RemoveInstance(this, !0), t._AddInstance(this, !0), t.SetZIndicesChanged(), this._worldInfo.SetBboxChanged()) : "full" === l && this._runtime.DestroyInstance(this));
                this._worldInfo._LoadFromJson(m, l)
            }
            if ("visual-state" !== l && (l = h.behs))
                for (const [q, r] of Object.entries(l)) l = parseInt(q, 10), l = this.GetBehaviorIndexBySID(l), 0 > l || l >= this._behaviorInstances.length || this._behaviorInstances[l].LoadFromJson(r);
            (h = h.data) && this._sdkInst.LoadFromJson(h)
        }
        GetInterfaceClass() {
            return this._iScriptInterface ||
                this._InitUserScriptInterface()
        }
        _InitUserScriptInterface() {
            var h = this._worldInfo ? self.IWorldInstance : a;
            const l = this._sdkInst.GetScriptInterfaceClass(),
                m = this._objectType._GetUserScriptInstanceClass(),
                p = m || l || h;
            a._Init(this);
            this._iScriptInterface = new p;
            a._Init(null);
            if (l && !(this._iScriptInterface instanceof h)) throw new TypeError(`script interface class '${l.name}' does not extend the right base class '${h.name}'`);
            if (m && (h = l || h, !(this._iScriptInterface instanceof h))) throw new TypeError(`setInstanceClass(): class '${m.name}' does not extend the right base class '${h.name}'`);
            return this._iScriptInterface
        }
        _GetInstVarsScriptDescriptor(h) {
            if (0 !== this._instVarValues.length) {
                var l = {},
                    m = this._objectType._GetAllInstanceVariableJsPropNames();
                for (let p = 0, t = m.length; p < t; ++p) l[m[p]] = {
                    configurable: !1,
                    enumerable: !0,
                    get: d.Instance.prototype._GetInstanceVariableTypedValue.bind(this, p),
                    set: d.Instance.prototype.SetInstanceVariableValue.bind(this, p)
                };
                l = Object.create(Object.prototype, l);
                h.instVars = {
                    value: l,
                    writable: !1
                }
            }
        }
        _GetBehaviorsScriptDescriptor(h) {
            var l = this._behaviorInstances;
            if (0 !==
                l.length) {
                var m = {};
                for (const p of l) m[p.GetBehaviorType().GetJsPropName()] = {
                    value: p.GetScriptInterface(),
                    writable: !1
                };
                l = Object.create(Object.prototype, m);
                h.behaviors = {
                    value: l,
                    writable: !1
                }
            }
        }
        DispatchUserScriptEvent(h) {
            h.instance = this.GetInterfaceClass();
            var l = this._runtime;
            (l = l.IsDebug() && !l.GetEventSheetManager().IsInEventEngine()) && b.StartMeasuringScriptTime();
            this.GetInterfaceClass().dispatchEvent(h);
            l && b.AddScriptTime()
        }
    }
}
"use strict";
{
    const d = self.C3;
    d.SceneGraphInfo = class extends d.DefendedBase {
        constructor(b) {
            super();
            this._owner = b;
            this._parent = null;
            this._children = [];
            this._myStartWidth = b.GetWidth();
            this._myStartHeight = b.GetHeight();
            this._parentStartAngle = 0
        }
        Release() {
            this._parent = null;
            d.clearArray(this._children)
        }
        SetParent(b) {
            this._parentStartAngle = (this._parent = b) ? b.GetAngle() : 0
        }
        GetParent() {
            return this._parent
        }
        HasChildren() {
            return 0 < this._children.length
        }
        GetChildren() {
            return this._children
        }
        _GetStartWidth() {
            return this._myStartWidth
        }
        _GetStartHeight() {
            return this._myStartHeight
        }
        GetParentScaleX() {
            return this._owner.GetTransformWithParentWidth() ?
                this._parent.GetWidth() / this._parent._GetSceneGraphInfo()._GetStartWidth() : 1
        }
        GetParentScaleY() {
            return this._owner.GetTransformWithParentHeight() ? this._parent.GetHeight() / this._parent._GetSceneGraphInfo()._GetStartHeight() : 1
        }
        GetParentStartAngle() {
            return this._parentStartAngle
        }
        _SaveToJson() {
            return {
                sw: this._myStartWidth,
                sh: this._myStartHeight,
                psa: this._parentStartAngle,
                c: this._children.map(b => {
                    let a = "";
                    b.GetTransformWithParentX() && (a += "x");
                    b.GetTransformWithParentY() && (a += "y");
                    b.GetTransformWithParentWidth() &&
                        (a += "w");
                    b.GetTransformWithParentHeight() && (a += "h");
                    b.GetTransformWithParentAngle() && (a += "a");
                    b.GetTransformWithParentZElevation() && (a += "z");
                    b.GetDestroyWithParent() && (a += "d");
                    return {
                        uid: b.GetInstance().GetUID(),
                        f: a
                    }
                })
            }
        }
        _LoadFromJson(b) {
            this._myStartWidth = b.sw;
            this._myStartHeight = b.sh;
            this._parentStartAngle = b.psa
        }
        _OnAfterLoad(b) {
            const a = this._owner,
                f = a.GetRuntime();
            for (const c of b.c) {
                b = f.GetInstanceByUID(c.uid).GetWorldInfo();
                const e = c.f,
                    g = {};
                g.transformX = e.includes("x");
                g.transformY = e.includes("y");
                g.transformWidth = e.includes("w");
                g.transformHeight = e.includes("h");
                g.transformAngle = e.includes("a");
                g.transformZElevation = e.includes("z");
                g.destroyWithParent = e.includes("d");
                a.AddChild(b, g)
            }
        }
    }
}
"use strict";
{
    const d = self.C3,
        b = d.New(d.Rect),
        a = d.New(d.Quad),
        f = d.New(d.Event, "bboxchange", !1),
        c = d.New(d.Color, 0, 0, 0, 0),
        e = d.New(d.CollisionPoly),
        g = d.New(d.Color, 1, 1, 1, 1),
        h = d.New(d.Rect, 0, 0, -1, -1),
        l = d.New(d.Rect, 0, 0, -1, -1),
        m = new Set(["absolute", "relative"]),
        p = [];
    let t = !0;
    d.WorldInfo = class extends d.DefendedBase {
        constructor(q, r) {
            super();
            this._inst = q;
            this._objectClass = q.GetObjectClass();
            this._runtime = q.GetRuntime();
            this._layer = r;
            this._zIndex = -1;
            this._flags = 196635;
            this._objectClass.GetPlugin().IsRotatable() && (this._flags |=
                128);
            this._oy = this._ox = this._cosA = this._sinA = this._a = this._h = this._w = this._zElevation = this._y = this._x = NaN;
            this._boundingBox = d.New(d.Rect);
            this._boundingQuad = d.New(d.Quad);
            this._collisionCells = l;
            this._renderCells = h;
            this._solidFilterTags = this._transformedPolyInfo = this._sourceCollisionPoly = null;
            this._colorPremultiplied = this._color = g;
            this._instanceEffectList = this._stateGroup = null;
            this._inst.GetObjectClass().UsesEffects() && (this._instanceEffectList = d.New(d.InstanceEffectList, this._inst, this));
            this._sceneGraphInfo =
                null;
            this._sceneGraphFlagsExportData = NaN;
            this._sceneGraphChildrenExportData = null;
            this._sceneGraphZIndex = this._sceneGraphZIndexExportData = NaN;
            this._meshInfo = null
        }
        _MarkDestroyed() {
            this._flags |= 256
        }
        Release() {
            this._stateGroup && (this._runtime.GetRenderer().ReleaseStateGroup(this._stateGroup), this._stateGroup = null);
            this._sourceCollisionPoly = null;
            this._transformedPolyInfo && (this._transformedPolyInfo.poly.Release(), this._transformedPolyInfo = null);
            this._solidFilterTags && (this._solidFilterTags.clear(), this._solidFilterTags =
                null);
            this.ReleaseMesh();
            this.HasParent() && this.GetParent().RemoveChild(this);
            if (this.HasChildren()) {
                const q = [...this.GetChildren()];
                for (const r of q) this.RemoveChild(r)
            }
            this._ReleaseSceneGraphInfo();
            this._layer = this._runtime = this._objectClass = this._inst = null
        }
        Init(q) {
            t = !1;
            this.SetXY(q[0], q[1]);
            this.SetZElevation(q[2]);
            this.SetSize(q[3], q[4]);
            this.IsRotatable() ? this.SetAngle(q[6]) : this._a = 0;
            c.setFromJSON(q[7]);
            this._SetColor(c);
            this.SetOriginX(q[8]);
            this.SetOriginY(q[9]);
            this.SetBlendMode(q[10]);
            this._instanceEffectList &&
                this._instanceEffectList._LoadEffectParameters(q[12]);
            q[14] && (this._sceneGraphFlagsExportData = q[14][0], this._sceneGraphChildrenExportData = q[14][1], this._sceneGraphZIndexExportData = q[14][2]);
            if (q[15]) {
                var r = q[15];
                this.CreateMesh(r[0], r[1]);
                q = this.GetSourceMesh();
                r = r[2];
                for (let u = 0, x = r.length; u < x; ++u) {
                    const y = r[u];
                    for (let C = 0, w = y.length; C < w; ++C) {
                        const A = y[C],
                            E = q.GetMeshPointAt(C, u);
                        E.SetX(A[0]);
                        E.SetY(A[1]);
                        E.SetU(A[2]);
                        E.SetV(A[3])
                    }
                }
            }
            t = !0;
            this._UpdateRendererStateGroup()
        }
        InitNoData() {
            this._sinA = this._a =
                this._h = this._w = this._zElevation = this._y = this._x = 0;
            this._cosA = 1;
            this._oy = this._ox = 0;
            this._UpdateRendererStateGroup()
        }
        GetRuntime() {
            return this._runtime
        }
        GetObjectClass() {
            return this._objectClass
        }
        GetInstance() {
            return this._inst
        }
        _GetParentOffsetAngle() {
            return this.GetTransformWithParentAngle() ? this.GetParent().GetAngle() - this._sceneGraphInfo.GetParentStartAngle() : 0
        }
        SetX(q) {
            q = +q;
            if (this.GetTransformWithParentX()) {
                const r = this._sceneGraphInfo;
                q -= this.GetX();
                const u = -this._GetParentOffsetAngle();
                0 === u ? this._x +=
                    q / r.GetParentScaleX() : (this._x += Math.cos(u) * q / r.GetParentScaleX(), this.GetTransformWithParentY() && (this._y += Math.sin(u) * q / r.GetParentScaleY()))
            } else this._x = q
        }
        OffsetX(q) {
            q = +q;
            this.GetTransformWithParentX() ? this.SetX(this.GetX() + q) : this._x += q
        }
        GetX() {
            if (this.GetTransformWithParentX()) {
                let q = this._x;
                const r = this._sceneGraphInfo,
                    u = this.GetParent(),
                    x = this._GetParentOffsetAngle();
                0 === x ? q *= r.GetParentScaleX() : (q = q * r.GetParentScaleX() * Math.cos(x), this.GetTransformWithParentY() && (q -= this._y * r.GetParentScaleY() *
                    Math.sin(x)));
                return u.GetX() + q
            }
            return this._x
        }
        SetY(q) {
            q = +q;
            if (this.GetTransformWithParentY()) {
                const r = this._sceneGraphInfo;
                q -= this.GetY();
                const u = -this._GetParentOffsetAngle();
                0 === u ? this._y += q / r.GetParentScaleY() : (this.GetTransformWithParentX() && (this._x -= Math.sin(u) * q / r.GetParentScaleX()), this._y += Math.cos(u) * q / r.GetParentScaleY())
            } else this._y = q
        }
        OffsetY(q) {
            q = +q;
            this.GetTransformWithParentY() ? this.SetY(this.GetY() + q) : this._y += q
        }
        GetY() {
            if (this.GetTransformWithParentY()) {
                let q = this._y;
                const r = this._sceneGraphInfo,
                    u = this.GetParent(),
                    x = this._GetParentOffsetAngle();
                0 === x ? q *= r.GetParentScaleY() : (q = q * r.GetParentScaleY() * Math.cos(x), this.GetTransformWithParentX() && (q += this._x * r.GetParentScaleX() * Math.sin(x)));
                return u.GetY() + q
            }
            return this._y
        }
        SetXY(q, r) {
            q = +q;
            r = +r;
            if (this.GetTransformWithParentXOrY()) {
                const x = this.GetTransformWithParentX(),
                    y = this.GetTransformWithParentY(),
                    C = this._sceneGraphInfo,
                    w = q - this.GetX(),
                    A = r - this.GetY();
                var u = -this._GetParentOffsetAngle();
                if (0 === u) this._x = x ? this._x + w / C.GetParentScaleX() : q, this._y =
                    y ? this._y + A / C.GetParentScaleY() : r;
                else {
                    const E = Math.sin(u);
                    u = Math.cos(u);
                    this._x = x ? y ? this._x + (u * w - E * A) / C.GetParentScaleX() : this._x + u * w / C.GetParentScaleX() : q;
                    this._y = y ? x ? this._y + (E * w + u * A) / C.GetParentScaleY() : this._y + u * A / C.GetParentScaleY() : r
                }
            } else this._x = q, this._y = r
        }
        OffsetXY(q, r) {
            q = +q;
            r = +r;
            this.GetTransformWithParentXOrY() ? this.SetXY(this.GetX() + q, this.GetY() + r) : (this._x += q, this._y += r)
        }
        EqualsXY(q, r) {
            return this.GetX() === q && this.GetY() === r
        }
        SetZElevation(q) {
            q = +q;
            this.GetTransformWithParentZElevation() &&
                (q -= this.GetParent().GetZElevation());
            this._zElevation !== q && (this._zElevation = q, this._UpdateZElevation(), q = this.GetLayer(), 0 !== this._zElevation && q._SetAnyInstanceZElevated(), q.SetZIndicesChanged())
        }
        _UpdateZElevation() {
            this._UpdateRendererStateGroup();
            if (this.HasChildren()) {
                const q = this.GetChildren();
                for (let r = 0, u = q.length; r < u; r++) {
                    const x = q[r];
                    x.GetTransformWithParentZElevation() && x._UpdateZElevation()
                }
            }
        }
        OffsetZElevation(q) {
            this.SetZElevation(this.GetZElevation() + q)
        }
        GetZElevation() {
            return this.GetTransformWithParentZElevation() ?
                this.GetParent().GetZElevation() + this._zElevation : this._zElevation
        }
        GetTotalZElevation() {
            return this.GetLayer().GetZElevation() + this.GetZElevation()
        }
        SetWidth(q) {
            q = +q;
            this.GetTransformWithParentWidth() ? this._w *= q / this.GetWidth() : this._w = q
        }
        OffsetWidth(q) {
            q = +q;
            this.GetTransformWithParentWidth() ? this.SetWidth(this.GetWidth() + q) : this._w += q
        }
        GetWidth() {
            return this.GetTransformWithParentWidth() ? this.GetParent().GetWidth() * this._w : this._w
        }
        SetHeight(q) {
            q = +q;
            this.GetTransformWithParentHeight() ? this._h *= q / this.GetHeight() :
                this._h = q
        }
        OffsetHeight(q) {
            q = +q;
            this.GetTransformWithParentHeight() ? this.SetHeight(this.GetHeight() + q) : this._h += q
        }
        GetHeight() {
            return this.GetTransformWithParentHeight() ? this.GetParent().GetHeight() * this._h : this._h
        }
        SetSize(q, r) {
            q = +q;
            r = +r;
            this.GetTransformWithParentWidth() ? this._w *= q / this.GetWidth() : this._w = q;
            this.GetTransformWithParentHeight() ? this._h *= r / this.GetHeight() : this._h = r
        }
        GetSceneGraphScale() {
            if (this.HasParent()) {
                const q = this._sceneGraphInfo;
                return Math.min(q.GetParentScaleX(), q.GetParentScaleY())
            }
            return 1
        }
        IsRotatable() {
            return 0 !==
                (this._flags & 128)
        }
        SetAngle(q) {
            q = +q;
            this.IsRotatable() && (this.GetTransformWithParentAngle() && (q -= this.GetParent().GetAngle()), q = d.clampAngle(q), this._a !== q && (this._a = q, this._MarkSinCosAngleChanged()))
        }
        OffsetAngle(q) {
            q = +q;
            0 !== q && this.IsRotatable() && (this._a = d.clampAngle(this._a + q), this._MarkSinCosAngleChanged())
        }
        _MarkSinCosAngleChanged() {
            this._flags |= 262144;
            if (this.HasChildren()) {
                const q = this.GetChildren();
                for (let r = 0, u = q.length; r < u; r++) q[r]._MarkSinCosAngleChanged()
            }
        }
        GetAngle() {
            return this.GetTransformWithParentAngle() ?
                d.clampAngle(this.GetParent().GetAngle() + this._a) : this._a
        }
        _MaybeUpdateSinCosAngle() {
            const q = this._flags;
            if (0 !== (q & 262144)) {
                var r = this.GetAngle();
                this._sinA = Math.sin(r);
                this._cosA = Math.cos(r);
                this._flags = q & -262145
            }
        }
        GetSinAngle() {
            this._MaybeUpdateSinCosAngle();
            return this._sinA
        }
        GetCosAngle() {
            this._MaybeUpdateSinCosAngle();
            return this._cosA
        }
        SetOriginX(q) {
            this._ox = +q
        }
        OffsetOriginX(q) {
            this._ox += +q
        }
        GetOriginX() {
            return this._ox
        }
        SetOriginY(q) {
            this._oy = +q
        }
        OffsetOriginY(q) {
            this._oy += +q
        }
        GetOriginY() {
            return this._oy
        }
        _SetColor(q) {
            this._color.equals(q) ||
                (this._color === g ? (this._color = d.New(d.Color, q), this._colorPremultiplied = d.New(d.Color, q), this._colorPremultiplied.premultiply()) : q.equalsRgba(1, 1, 1, 1) ? this._colorPremultiplied = this._color = g : (this._color.set(q), this._colorPremultiplied.set(q), this._colorPremultiplied.premultiply()), this._UpdateRendererStateGroup())
        }
        SetOpacity(q) {
            q = d.clamp(+q, 0, 1);
            this._color.a !== q && (c.copyRgb(this._color), c.a = q, this._SetColor(c))
        }
        OffsetOpacity(q) {
            this.SetOpacity(this.GetOpacity() + q)
        }
        GetOpacity() {
            return this._color.a
        }
        SetUnpremultipliedColor(q) {
            this._color.equalsIgnoringAlpha(q) ||
                (c.copyRgb(q), c.a = this._color.a, this._SetColor(c))
        }
        SetUnpremultipliedColorRGB(q, r, u) {
            c.setRgb(q, r, u);
            this.SetUnpremultipliedColor(c)
        }
        OffsetUnpremultipliedColorRGB(q, r, u) {
            if (0 !== q || 0 !== r || 0 !== u) c.copyRgb(this._color), c.r += q, c.g += r, c.b += u, this.SetUnpremultipliedColor(c)
        }
        GetUnpremultipliedColor() {
            return this._color
        }
        GetPremultipliedColor() {
            return this._colorPremultiplied
        }
        GetDestroyWithParent() {
            return 0 !== (this._flags & 512)
        }
        SetDestroyWithParent(q) {
            this._SetFlag(512, q)
        }
        GetTransformWithParentX() {
            return 0 !==
                (this._flags & 1024)
        }
        SetTransformWithParentX(q) {
            this._SetFlag(1024, q)
        }
        GetTransformWithParentY() {
            return 0 !== (this._flags & 2048)
        }
        GetTransformWithParentXOrY() {
            return 0 !== (this._flags & 3072)
        }
        SetTransformWithParentY(q) {
            this._SetFlag(2048, q)
        }
        GetTransformWithParentWidth() {
            return 0 !== (this._flags & 4096)
        }
        SetTransformWithParentWidth(q) {
            this._SetFlag(4096, q)
        }
        GetTransformWithParentHeight() {
            return 0 !== (this._flags & 8192)
        }
        SetTransformWithParentHeight(q) {
            this._SetFlag(8192, q)
        }
        GetTransformWithParentAngle() {
            return 0 !==
                (this._flags & 16384)
        }
        SetTransformWithParentAngle(q) {
            this._SetFlag(16384, q)
        }
        GetTransformWithParentZElevation() {
            return 0 !== (this._flags & 32768)
        }
        SetTransformWithParentZElevation(q) {
            this._SetFlag(32768, q)
        }
        _ClearAllSceneGraphFlags() {
            this._flags &= -65025
        }
        AddChild(q, r) {
            if (q !== this && !q.HasParent() && !this._HasChildRecursive(q) && !this._HasAnyParent(q)) {
                var u = q.GetX(),
                    x = q.GetY(),
                    y = q.GetWidth(),
                    C = q.GetHeight(),
                    w = q.GetAngle(),
                    A = q.GetZElevation();
                q._SetParent(this);
                q.SetTransformWithParentX(r.transformX);
                q.SetTransformWithParentY(r.transformY);
                q.SetTransformWithParentWidth(r.transformWidth);
                q.SetTransformWithParentHeight(r.transformHeight);
                q.SetTransformWithParentAngle(r.transformAngle);
                q.SetTransformWithParentZElevation(r.transformZElevation);
                q.SetDestroyWithParent(r.destroyWithParent);
                r.transformX && (q._x = u - this.GetX(), r.transformWidth && (q._x /= this.GetWidth() / this._sceneGraphInfo._GetStartWidth()));
                r.transformY && (q._y = x - this.GetY(), r.transformHeight && (q._y /= this.GetHeight() / this._sceneGraphInfo._GetStartHeight()));
                r.transformWidth && (q._w =
                    y / this.GetWidth());
                r.transformHeight && (q._h = C / this.GetHeight());
                r.transformAngle && (q._a = w - this.GetAngle());
                r.transformZElevation && (q._zElevation = A - this.GetZElevation());
                this._AddChildToSceneGraphInfo(q);
                this.SetBboxChanged()
            }
        }
        RemoveChild(q) {
            if (q.GetParent() === this) {
                var r = q.GetX(),
                    u = q.GetY(),
                    x = q.GetWidth(),
                    y = q.GetHeight(),
                    C = q.GetAngle(),
                    w = q.GetZElevation();
                q._SetParent(null);
                q._ClearAllSceneGraphFlags();
                q.SetXY(r, u);
                q.SetSize(x, y);
                q.SetAngle(C);
                q.SetZElevation(w);
                this._RemoveChildFromSceneGraphInfo(q);
                this.SetBboxChanged()
            }
        }
        _ResetAllSceneGraphState() {
            for (var q of this.children()) this.RemoveChild(q);
            (q = this.GetParent()) && q.RemoveChild(this);
            this._ClearAllSceneGraphFlags()
        }
        HasParent() {
            return null !== this.GetParent()
        }
        GetParent() {
            const q = this._sceneGraphInfo;
            return null !== q ? q.GetParent() : null
        }
        GetTopParent() {
            let q = this;
            for (; q.HasParent();) q = q.GetParent();
            return q
        }* parents() {
            let q = this.GetParent();
            for (; q;) yield q, q = q.GetParent()
        }
        HasChild(q) {
            return this.GetChildren().includes(q)
        }
        HasChildren() {
            const q =
                this._sceneGraphInfo;
            return null !== q ? q.HasChildren() : !1
        }
        GetChildren() {
            const q = this._sceneGraphInfo;
            return null !== q ? q.GetChildren() : p
        }
        children() {
            return this.GetChildren()
        }* allChildren() {
            for (const q of this.children()) yield q, yield* q.allChildren()
        }
        GetChildCount() {
            return this.GetChildren().length
        }
        GetChildAt(q) {
            const r = this.GetChildren();
            q = Math.floor(+q);
            return 0 > q || q >= r.length ? null : r[q]
        }
        _CreateSceneGraphInfo(q) {
            this._sceneGraphInfo || (this._sceneGraphInfo = d.New(d.SceneGraphInfo, this));
            q && this._sceneGraphInfo.SetParent(q)
        }
        _GetSceneGraphInfo() {
            return this._sceneGraphInfo
        }
        _ReleaseSceneGraphInfo() {
            this._sceneGraphInfo &&
                (this._sceneGraphInfo.Release(), this._sceneGraphInfo = null)
        }
        _SetParent(q) {
            q ? (q._CreateSceneGraphInfo(null), this._CreateSceneGraphInfo(q)) : (this._sceneGraphInfo && this._sceneGraphInfo.SetParent(null), this.HasChildren() || this._ReleaseSceneGraphInfo())
        }
        _HasAnyParent(q) {
            if (!this.HasParent()) return !1;
            const r = this.GetParent();
            return r === q ? !0 : r._HasAnyParent(q)
        }
        _HasChildRecursive(q) {
            if (this.HasChild(q)) return !0;
            for (const r of this.GetChildren())
                if (r._HasChildRecursive(q)) return !0;
            return !1
        }
        _AddChildToSceneGraphInfo(q) {
            this._sceneGraphInfo.GetChildren().push(q)
        }
        _RemoveChildFromSceneGraphInfo(q) {
            const r =
                this._sceneGraphInfo.GetChildren(),
                u = r.indexOf(q); - 1 !== u && r.splice(u, 1);
            0 !== r.length || this.HasParent() || this._ReleaseSceneGraphInfo();
            q.HasChildren() || q._ReleaseSceneGraphInfo()
        }
        GetSceneGraphChildrenExportData() {
            return this._sceneGraphChildrenExportData
        }
        GetSceneGraphZIndexExportData() {
            return this._sceneGraphZIndexExportData
        }
        GetSceneGraphZIndex() {
            return this._sceneGraphZIndex
        }
        SetSceneGraphZIndex(q) {
            this._sceneGraphZIndex = q
        }
        _UpdateRendererStateGroup() {
            if (t) {
                var q = this._runtime.GetRenderer();
                this._stateGroup &&
                    q.ReleaseStateGroup(this._stateGroup);
                this._stateGroup = q.AcquireStateGroup(q.GetTextureFillShaderProgram() || "<default>", this.GetBlendMode(), this._colorPremultiplied, this.GetZElevation())
            }
        }
        GetRendererStateGroup() {
            return this._stateGroup
        }
        HasDefaultColor() {
            return this._color === g
        }
        SetBlendMode(q) {
            q |= 0;
            if (0 > q || 31 < q) throw new RangeError("invalid blend mode");
            this.GetBlendMode() !== q && (this._flags = this._flags & -2080374785 | q << 26, this._UpdateRendererStateGroup())
        }
        GetBlendMode() {
            return (this._flags & 2080374784) >>
                26
        }
        _SetLayer(q) {
            this._layer = q;
            0 !== this.GetZElevation() && this._layer._SetAnyInstanceZElevated()
        }
        GetLayer() {
            return this._layer
        }
        GetLayout() {
            return this.GetLayer().GetLayout()
        }
        _SetZIndex(q) {
            this._zIndex = q | 0
        }
        GetZIndex() {
            this._layer._UpdateZIndices();
            return this._zIndex
        }
        _GetLastCachedZIndex() {
            return this._zIndex
        }
        _SetFlag(q, r) {
            this._flags = r ? this._flags | q : this._flags & ~q
        }
        IsVisible() {
            return 0 !== (this._flags & 1)
        }
        SetVisible(q) {
            this._SetFlag(1, q)
        }
        IsCollisionEnabled() {
            return 0 !== (this._flags & 8)
        }
        SetCollisionEnabled(q) {
            q = !!q;
            this.IsCollisionEnabled() !== q && (this._SetFlag(8, q), q ? this.SetBboxChanged() : this._RemoveFromCollisionCells())
        }
        SetSolidCollisionFilter(q, r) {
            this._SetFlag(32, q);
            this._solidFilterTags && this._solidFilterTags.clear();
            if (r.trim()) {
                this._solidFilterTags || (this._solidFilterTags = new Set);
                for (const u of r.split(" ")) u && this._solidFilterTags.add(u.toLowerCase())
            } else this._solidFilterTags = null
        }
        IsSolidCollisionAllowed(q) {
            const r = 0 !== (this._flags & 32),
                u = this._solidFilterTags;
            if (!q || !u) return !r;
            for (const x of u)
                if (q.has(x)) return r;
            return !r
        }
        SetBboxChanged() {
            this._flags |= 65554;
            this._objectClass._SetAnyCollisionCellChanged(!0);
            this._runtime.UpdateRender();
            this._layer.UsesRenderCells() && (this.CalculateBbox(this._boundingBox, this._boundingQuad, !0), this._flags &= -3, this._UpdateRenderCell());
            0 !== (this._flags & 4) && this._inst.Dispatcher().dispatchEvent(f);
            if (null !== this._sceneGraphInfo) {
                const q = this._sceneGraphInfo.GetChildren();
                for (let r = 0, u = q.length; r < u; ++r) q[r].SetBboxChanged()
            }
        }
        CalculateBbox(q, r, u) {
            const x = this.GetX(),
                y = this.GetY(),
                C = this.GetWidth(),
                w = this.GetHeight(),
                A = this.GetAngle();
            q.setWH(x - this._ox * C, y - this._oy * w, C, w);
            u && this.HasMesh() && this._ExpandBboxForMesh(q);
            0 === A ? r.setFromRect(q) : (q.offset(-x, -y), r.setFromRotatedRectPrecalc(q, this.GetSinAngle(), this.GetCosAngle()), r.offset(x, y), r.getBoundingBox(q));
            q.normalize()
        }
        _UpdateBbox() {
            const q = this._flags;
            0 !== (q & 2) && (this.CalculateBbox(this._boundingBox, this._boundingQuad, !0), this._flags = q & -3)
        }
        GetBoundingBox() {
            this._UpdateBbox();
            return this._boundingBox
        }
        GetBoundingQuad() {
            this._UpdateBbox();
            return this._boundingQuad
        }
        PixelRoundQuad(q) {
            var r = this.GetX(),
                u = this.GetY();
            r = Math.round(r) - r;
            u = Math.round(u) - u;
            if (0 === r && 0 === u) return q;
            a.copy(q);
            a.offset(r, u);
            return a
        }
        OverwriteBoundingBox(q) {
            this._boundingBox.copy(q);
            this._boundingQuad.setFromRect(this._boundingBox);
            this._flags &= -3;
            this._UpdateCollisionCell();
            this._UpdateRenderCell()
        }
        SetBboxChangeEventEnabled(q) {
            this._SetFlag(4, q)
        }
        IsBboxChangeEventEnabled() {
            return 0 !== (this._flags & 4)
        }
        IsInViewport(q) {
            return 0 === this.GetZElevation() ? q.intersectsRect(this.GetBoundingBox()) :
                this._IsInViewport_ZElevated()
        }
        _IsInViewport_ZElevated() {
            const q = this.GetLayer(),
                r = this.GetTotalZElevation();
            if (r >= q.GetCameraZ()) return !1;
            q.GetViewportForZ(r, b);
            return b.intersectsRect(this.GetBoundingBox())
        }
        SetSourceCollisionPoly(q) {
            this._sourceCollisionPoly = q;
            this._DiscardTransformedCollisionPoly();
            this.HasMesh() && (this._meshInfo.meshPoly = null)
        }
        GetSourceCollisionPoly() {
            return this._sourceCollisionPoly
        }
        HasOwnCollisionPoly() {
            return null !== this._sourceCollisionPoly || this.HasMesh()
        }
        GetTransformedCollisionPoly() {
            return this._GetCustomTransformedCollisionPolyPrecalc(this.GetWidth(),
                this.GetHeight(), this.GetAngle(), this.GetSinAngle(), this.GetCosAngle())
        }
        GetCustomTransformedCollisionPoly(q, r, u) {
            let x = 0,
                y = 1;
            0 !== u && (x = Math.sin(u), y = Math.cos(u));
            return this._GetCustomTransformedCollisionPolyPrecalc(q, r, u, x, y)
        }
        _GetCustomTransformedCollisionPolyPrecalc(q, r, u, x, y) {
            let C = this._transformedPolyInfo;
            null === C && (this._transformedPolyInfo = C = {
                poly: d.New(d.CollisionPoly),
                width: NaN,
                height: NaN,
                angle: NaN
            });
            const w = C.poly;
            if (C.width === q && C.height === r && C.angle === u) return w;
            const A = this._sourceCollisionPoly;
            if (this.HasMesh()) {
                const E = this.GetOriginX(),
                    K = this.GetOriginY(),
                    O = this.GetSourceMesh();
                let G = this._meshInfo.meshPoly;
                G || (A ? (e.copy(A), e.offset(E, K)) : e.setDefaultPoints(), G = O.InsertPolyMeshVertices(e), this._meshInfo.meshPoly = G);
                O.TransformCollisionPoly(G, w);
                w.offset(-E, -K);
                w.transformPrecalc(q, r, x, y)
            } else A ? (w.copy(A), w.transformPrecalc(q, r, x, y)) : w.setFromQuad(this.GetBoundingQuad(), -this.GetX(), -this.GetY());
            C.width = q;
            C.height = r;
            C.angle = u;
            return w
        }
        _DiscardTransformedCollisionPoly() {
            this.SetPhysicsBodyChanged(!0);
            const q = this._transformedPolyInfo;
            null !== q && (q.width = NaN)
        }
        CreateMesh(q, r) {
            q = Math.floor(q);
            r = Math.floor(r);
            if (!this.GetInstance().GetPlugin().SupportsMesh()) throw Error("object does not support mesh");
            this.ReleaseMesh();
            this._meshInfo = {
                sourceMesh: d.New(d.Gfx.Mesh, q, r),
                transformedMesh: d.New(d.Gfx.Mesh, q, r),
                meshPoly: null
            }
        }
        HasMesh() {
            return null !== this._meshInfo
        }
        GetSourceMesh() {
            if (!this.HasMesh()) throw Error("no mesh");
            return this._meshInfo.sourceMesh
        }
        GetTransformedMesh() {
            if (!this.HasMesh()) throw Error("no mesh");
            return this._meshInfo.transformedMesh
        }
        SetMeshChanged(q) {
            this._SetFlag(65536, q)
        }
        IsMeshChanged() {
            return 0 !== (this._flags & 65536)
        }
        SetPhysicsBodyChanged(q) {
            this._SetFlag(131072, q)
        }
        IsPhysicsBodyChanged() {
            return 0 !== (this._flags & 131072)
        }
        _ExpandBboxForMesh(q) {
            var r = this._meshInfo.sourceMesh;
            const u = Math.min(r.GetMinX(), 0),
                x = Math.min(r.GetMinY(), 0),
                y = Math.max(r.GetMaxX(), 1);
            r = Math.max(r.GetMaxY(), 1);
            const C = q.width(),
                w = q.height();
            q.offsetLeft(u * C);
            q.offsetTop(x * w);
            q.offsetRight((y - 1) * C);
            q.offsetBottom((r -
                1) * w)
        }
        ReleaseMesh() {
            this._meshInfo && (this._meshInfo.sourceMesh.Release(), this._meshInfo.transformedMesh.Release(), this._meshInfo = null, this._DiscardTransformedCollisionPoly())
        }
        SetMeshPoint(q, r, u) {
            q = Math.floor(q);
            r = Math.floor(r);
            var x = u.mode || "absolute";
            if (!m.has(x)) throw Error("invalid mode");
            x = "relative" === x;
            let y = u.x,
                C = u.y,
                w = "number" === typeof u.u ? u.u : x ? 0 : -1;
            u = "number" === typeof u.v ? u.v : x ? 0 : -1;
            if (!this.HasMesh()) return !1;
            const A = this.GetSourceMesh(),
                E = A.GetMeshPointAt(q, r);
            if (null === E) return !1;
            x &&
                (y += q / (A.GetHSize() - 1), C += r / (A.GetVSize() - 1)); - 1 !== w || x ? (x && (w += q / (A.GetHSize() - 1)), w = d.clamp(w, 0, 1)) : w = E.GetU(); - 1 !== u || x ? (x && (u += r / (A.GetVSize() - 1)), u = d.clamp(u, 0, 1)) : u = E.GetV();
            if (E.GetX() === y && E.GetY() === C && E.GetU() === w && E.GetV() === u) return !1;
            E.SetX(y);
            E.SetY(C);
            E.SetU(w);
            E.SetV(u);
            this._DiscardTransformedCollisionPoly();
            return !0
        }
        HasTilemap() {
            return this._inst.HasTilemap()
        }
        ContainsPoint(q, r) {
            return this.GetBoundingBox().containsPoint(q, r) && this.GetBoundingQuad().containsPoint(q, r) ? this.HasTilemap() ?
                this._inst.GetSdkInstance().TestPointOverlapTile(q, r) : this.HasOwnCollisionPoly() ? this.GetTransformedCollisionPoly().containsPoint(q - this.GetX(), r - this.GetY()) : !0 : !1
        }
        _IsCollisionCellChanged() {
            return 0 !== (this._flags & 16)
        }
        _UpdateCollisionCell() {
            if (this._IsCollisionCellChanged() && this.IsCollisionEnabled() && 0 === (this._flags & 256)) {
                var q = this.GetBoundingBox(),
                    r = this._objectClass._GetCollisionCellGrid(),
                    u = this._collisionCells;
                b.set(r.XToCell(q.getLeft()), r.YToCell(q.getTop()), r.XToCell(q.getRight()), r.YToCell(q.getBottom()));
                u.equals(b) || (q = this._inst, u === l ? (r.Update(q, null, b), this._collisionCells = d.New(d.Rect, b)) : (r.Update(q, u, b), u.copy(b)), this._flags &= -17)
            }
        }
        _RemoveFromCollisionCells() {
            const q = this._collisionCells;
            q !== l && (this._objectClass._GetCollisionCellGrid().Update(this._inst, q, null), this._collisionCells = l)
        }
        _UpdateRenderCell() {
            const q = this.GetLayer();
            if (q.UsesRenderCells() && 0 === (this._flags & 256)) {
                var r = q.GetRenderGrid(),
                    u = this.GetBoundingBox(),
                    x = this._renderCells;
                b.set(r.XToCell(u.getLeft()), r.YToCell(u.getTop()),
                    r.XToCell(u.getRight()), r.YToCell(u.getBottom()));
                x.equals(b) || (u = this._inst, x === h ? (r.Update(u, null, b), this._renderCells = d.New(d.Rect, b)) : (r.Update(u, x, b), x.copy(b)), q.SetRenderListStale())
            }
        }
        _RemoveFromRenderCells() {
            const q = this._renderCells;
            q !== h && (this.GetLayer().GetRenderGrid().Update(this._inst, q, null), this._renderCells = h)
        }
        GetRenderCellRange() {
            return this._renderCells
        }
        ZOrderMoveToTop() {
            const q = this._inst,
                r = this._layer,
                u = r._GetInstances();
            u.length && u[u.length - 1] === q || (r._RemoveInstance(q, !1), r._AddInstance(q,
                !1), this._runtime.UpdateRender())
        }
        ZOrderMoveToBottom() {
            const q = this._inst,
                r = this._layer,
                u = r._GetInstances();
            u.length && u[0] === q || (r._RemoveInstance(q, !1), r._PrependInstance(q, !1), this._runtime.UpdateRender())
        }
        ZOrderMoveToLayer(q) {
            const r = this._inst,
                u = this._layer;
            if (u.GetLayout() !== q.GetLayout()) throw Error("layer from different layout");
            q !== u && (u._RemoveInstance(r, !0), this._SetLayer(q), q._AddInstance(r, !0), this._runtime.UpdateRender())
        }
        ZOrderMoveAdjacentToInstance(q, r) {
            const u = this._inst,
                x = this._layer;
            if (q.GetUID() !== u.GetUID()) {
                var y = q.GetWorldInfo();
                if (!y) throw Error("expected world instance");
                var C = y.GetLayer();
                y = !1;
                x.GetIndex() !== C.GetIndex() && (x._RemoveInstance(u, !0), this._SetLayer(C), C._AddInstance(u, !0), y = !0);
                q = C.MoveInstanceAdjacent(u, q, !!r);
                (y || q) && this._runtime.UpdateRender()
            }
        }
        GetInstanceEffectList() {
            return this._instanceEffectList
        }
        _SetHasAnyActiveEffect(q) {
            this._SetFlag(64, q)
        }
        HasAnyActiveEffect() {
            return 0 !== (this._flags & 64)
        }
        _SaveToJson(q) {
            const r = {
                x: this.GetX(),
                y: this.GetY(),
                w: this.GetWidth(),
                h: this.GetHeight(),
                l: this.GetLayer().GetSID(),
                zi: this.GetZIndex()
            };
            0 !== this.GetZElevation() && (r.ze = this.GetZElevation());
            0 !== this.GetAngle() && (r.a = this.GetAngle());
            this.HasDefaultColor() || (r.c = this._color.toJSON());
            .5 !== this.GetOriginX() && (r.oX = this.GetOriginX());
            .5 !== this.GetOriginY() && (r.oY = this.GetOriginY());
            0 !== this.GetBlendMode() && (r.bm = this.GetBlendMode());
            this.IsVisible() || (r.v = this.IsVisible());
            this.IsCollisionEnabled() || (r.ce = this.IsCollisionEnabled());
            this.IsBboxChangeEventEnabled() && (r.be =
                this.IsBboxChangeEventEnabled());
            this._instanceEffectList && (r.fx = this._instanceEffectList._SaveToJson());
            const u = 0 !== (this._flags & 32);
            u && (r.sfi = u);
            this._solidFilterTags && (r.sft = [...this._solidFilterTags].join(" "));
            this._sceneGraphInfo && "visual-state" !== q && (r.sgi = this._sceneGraphInfo._SaveToJson());
            this.HasMesh() && (r.mesh = this.GetSourceMesh().SaveToJson());
            return r
        }
        _OnBeforeLoad(q) {
            "visual-state" !== q && this._ResetAllSceneGraphState()
        }
        _LoadFromJson(q, r) {
            t = !1;
            this.SetX(q.x);
            this.SetY(q.y);
            this.SetWidth(q.w);
            this.SetHeight(q.h);
            this._SetZIndex(q.zi);
            this.SetZElevation(q.hasOwnProperty("ze") ? q.ze : 0);
            this.SetAngle(q.hasOwnProperty("a") ? q.a : 0);
            q.hasOwnProperty("c") ? c.setFromJSON(q.c) : q.hasOwnProperty("o") ? (c.copyRgb(this._color), c.a = q.o) : c.setRgba(1, 1, 1, 1);
            this._SetColor(c);
            this.SetOriginX(q.hasOwnProperty("oX") ? q.oX : .5);
            this.SetOriginY(q.hasOwnProperty("oY") ? q.oY : .5);
            this.SetBlendMode(q.hasOwnProperty("bm") ? q.bm : 0);
            this.SetVisible(q.hasOwnProperty("v") ? q.v : !0);
            this.SetCollisionEnabled(q.hasOwnProperty("ce") ?
                q.ce : !0);
            this.SetBboxChangeEventEnabled(q.hasOwnProperty("be") ? q.be : !1);
            this.SetSolidCollisionFilter(q.hasOwnProperty("sfi") ? q.sfi : !1, q.hasOwnProperty("sft") ? q.sft : "");
            this._instanceEffectList && q.hasOwnProperty("fx") && this._instanceEffectList._LoadFromJson(q.fx);
            if (q.hasOwnProperty("sgi") && "visual-state" !== r) {
                this._CreateSceneGraphInfo(null);
                const u = this._sceneGraphInfo,
                    x = q.sgi;
                u._LoadFromJson(x);
                const y = this.GetRuntime().Dispatcher(),
                    C = () => {
                        y.removeEventListener("afterload", C);
                        u._OnAfterLoad(x)
                    };
                y.addEventListener("afterload", C)
            }
            q.hasOwnProperty("mesh") ? (q = q.mesh, this.CreateMesh(q.cols, q.rows), this.GetSourceMesh().LoadFromJson(q)) : this.ReleaseMesh();
            this.SetBboxChanged();
            t = !0;
            this._UpdateRendererStateGroup()
        }
    }
}
"use strict";
{
    const d = self.C3;
    d.BehaviorType = class extends d.DefendedBase {
        constructor(b, a) {
            super();
            const f = b.GetRuntime(),
                c = f.GetPluginManager(),
                e = f.GetObjectReference(a[1]);
            c.HasBehaviorByConstructorFunction(e) || c.CreateBehavior(a);
            this._runtime = f;
            this._objectClass = b;
            this._behavior = c.GetBehaviorByConstructorFunction(e);
            this._sdkType = null;
            this._instSdkCtor = e.Instance;
            this._sid = a[2];
            this._name = a[0];
            this._jsPropName = this._runtime.GetJsPropName(a[3]);
            this._sdkType = d.New(e.Type, this);
            this.OnCreate()
        }
        static Create(b,
            a) {
            return d.New(d.BehaviorType, b, a)
        }
        Release() {
            this._behavior = this._runtime = null;
            this._sdkType.Release();
            this._instSdkCtor = this._sdkType = null
        }
        GetSdkType() {
            return this._sdkType
        }
        OnCreate() {
            this._sdkType.OnCreate()
        }
        GetRuntime() {
            return this._runtime
        }
        GetObjectClass() {
            return this._objectClass
        }
        GetBehavior() {
            return this._behavior
        }
        GetInstanceSdkCtor() {
            return this._instSdkCtor
        }
        GetName() {
            return this._name
        }
        GetSID() {
            return this._sid
        }
        GetJsPropName() {
            return this._jsPropName
        }
    }
}
"use strict";
{
    const d = self.C3,
        b = self.IBehaviorInstance;
    d.BehaviorInstance = class extends d.DefendedBase {
        constructor(a) {
            super();
            this._runtime = a.runtime;
            this._behaviorType = a.behaviorType;
            this._behavior = this._behaviorType.GetBehavior();
            this._inst = a.instance;
            this._index = a.index;
            this._iScriptInterface = this._sdkInst = null;
            this._behavior._AddInstance(this._inst)
        }
        Release() {
            this._iScriptInterface && (this._iScriptInterface._Release(), this._iScriptInterface = null);
            this._behavior._RemoveInstance(this._inst);
            this._sdkInst.Release();
            this._inst = this._behavior = this._behaviorType = this._runtime = this._iScriptInterface = this._sdkInst = null
        }
        _CreateSdkInstance(a) {
            if (this._sdkInst) throw Error("already got sdk instance");
            this._sdkInst = d.New(this._behaviorType.GetInstanceSdkCtor(), this, a);
            this._InitScriptInterface()
        }
        GetSdkInstance() {
            return this._sdkInst
        }
        GetObjectInstance() {
            return this._inst
        }
        GetRuntime() {
            return this._runtime
        }
        GetBehaviorType() {
            return this._behaviorType
        }
        GetBehavior() {
            return this._behavior
        }
        _GetIndex() {
            return this._index
        }
        PostCreate() {
            this._sdkInst.PostCreate()
        }
        OnSpriteFrameChanged(a,
            f) {
            this._sdkInst.OnSpriteFrameChanged(a, f)
        }
        _GetDebuggerProperties() {
            return this._sdkInst.GetDebuggerProperties()
        }
        SaveToJson() {
            return this._sdkInst.SaveToJson()
        }
        LoadFromJson(a) {
            return this._sdkInst.LoadFromJson(a)
        }
        static SortByTickSequence(a, f) {
            var c = a.GetObjectInstance(),
                e = f.GetObjectInstance();
            const g = c.GetObjectClass().GetIndex(),
                h = e.GetObjectClass().GetIndex();
            if (g !== h) return g - h;
            c = c.GetPUID();
            e = e.GetPUID();
            return c !== e ? c - e : a.GetBehaviorInstance()._GetIndex() - f.GetBehaviorInstance()._GetIndex()
        }
        _InitScriptInterface() {
            const a =
                this._sdkInst.GetScriptInterfaceClass(),
                f = a || b;
            b._Init(this);
            this._iScriptInterface = new f;
            b._Init(null);
            if (a && !(this._iScriptInterface instanceof b)) throw new TypeError(`script interface class '${a.name}' does not extend the right base class '${b.name}'`);
        }
        GetScriptInterface() {
            return this._iScriptInterface
        }
    }
}
"use strict";
{
    const d = self.C3;
    d.EffectList = class extends d.DefendedBase {
        constructor(b, a) {
            super();
            this._owner = b;
            this._allEffectTypes = [];
            this._activeEffectTypes = [];
            this._effectTypesByName = new Map;
            this._effectParams = [];
            this._preservesOpaqueness = !0;
            for (const f of a) b = d.New(d.EffectType, this, f, this._allEffectTypes.length), this._allEffectTypes.push(b), this._effectTypesByName.set(b.GetName().toLowerCase(), b), 3 <= f.length && this._effectParams.push(this._LoadSingleEffectParameters(f[2]));
            this.GetRuntime()._AddEffectList(this)
        }
        Release() {
            d.clearArray(this._allEffectTypes);
            d.clearArray(this._activeEffectTypes);
            this._effectTypesByName.clear();
            d.clearArray(this._effectParams);
            this._owner = null
        }
        PrependEffectTypes(b) {
            if (b.length) {
                this._allEffectTypes = b.concat(this._allEffectTypes);
                for (const a of b) this._effectTypesByName.set(a.GetName().toLowerCase(), a);
                for (let a = 0, f = this._allEffectTypes.length; a < f; ++a) this._allEffectTypes[a]._SetIndex(a)
            }
        }
        _LoadSingleEffectParameters(b) {
            b = b.slice(0);
            for (let a = 0, f = b.length; a < f; ++a) {
                const c = b[a];
                if (Array.isArray(c)) {
                    const e = d.New(d.Color);
                    e.setFromJSON(c);
                    b[a] = e
                }
            }
            return b
        }
        GetOwner() {
            return this._owner
        }
        GetRuntime() {
            return this._owner.GetRuntime()
        }
        UpdateActiveEffects() {
            d.clearArray(this._activeEffectTypes);
            let b = !0;
            for (const a of this._allEffectTypes) a.IsActive() && (this._activeEffectTypes.push(a), a.GetShaderProgram().PreservesOpaqueness() || (b = !1));
            this._preservesOpaqueness = b
        }
        GetAllEffectTypes() {
            return this._allEffectTypes
        }
        HasAnyEffectType() {
            return 0 < this._allEffectTypes.length
        }
        GetEffectTypeByName(b) {
            return this._effectTypesByName.get(b.toLowerCase()) ||
                null
        }
        GetEffectTypeByIndex(b) {
            b = Math.floor(+b);
            if (0 > b || b >= this._allEffectTypes.length) throw new RangeError("invalid effect type index");
            return this._allEffectTypes[b]
        }
        IsEffectIndexActive(b) {
            return this.GetEffectTypeByIndex(b).IsActive()
        }
        SetEffectIndexActive(b, a) {
            this.GetEffectTypeByIndex(b).SetActive(a)
        }
        GetActiveEffectTypes() {
            return this._activeEffectTypes
        }
        HasAnyActiveEffect() {
            return 0 < this._activeEffectTypes.length
        }
        PreservesOpaqueness() {
            return this._preservesOpaqueness
        }
        GetEffectParametersForIndex(b) {
            return this._effectParams[b]
        }
        static SaveFxParamToJson(b) {
            return b &&
                b instanceof d.Color ? {
                    t: "color",
                    v: b.toJSON()
                } : b
        }
        static LoadFxParamFromJson(b) {
            if ("object" === typeof b) {
                if ("color" === b.t) {
                    const a = d.New(d.Color);
                    a.setFromJSON(b.v);
                    return a
                }
                throw Error("invalid effect parameter type");
            }
            return b
        }
        static SaveFxParamsToJson(b) {
            return b.map(d.EffectList.SaveFxParamToJson)
        }
        static LoadFxParamsFromJson(b) {
            return b.map(d.EffectList.LoadFxParamFromJson)
        }
        SaveToJson() {
            return this._allEffectTypes.map(b => ({
                name: b.GetName(),
                active: b.IsActive(),
                params: d.EffectList.SaveFxParamsToJson(this._effectParams[b.GetIndex()])
            }))
        }
        LoadFromJson(b) {
            for (const a of b)
                if (b =
                    this.GetEffectTypeByName(a.name)) b.SetActive(a.active), this._effectParams[b.GetIndex()] = d.EffectList.LoadFxParamsFromJson(a.params);
            this.UpdateActiveEffects()
        }
    }
}
"use strict";
{
    const d = self.C3;
    d.EffectType = class extends d.DefendedBase {
        constructor(b, a, f) {
            super();
            this._effectList = b;
            this._id = a[0];
            this._name = a[1];
            this._index = f;
            this._shaderProgram = null;
            this._isActive = !0
        }
        Release() {
            this._shaderProgram = this._effectList = null
        }
        Clone(b) {
            b = d.New(d.EffectType, b, [this._id, this._name], -1);
            b._shaderProgram = this._shaderProgram;
            b._isActive = this._isActive;
            return b
        }
        _InitRenderer(b) {
            b = b.GetShaderProgramByName(this._id);
            if (!b) throw Error("failed to find shader program '" + this._id + "'");
            this._shaderProgram =
                b
        }
        GetEffectList() {
            return this._effectList
        }
        GetName() {
            return this._name
        }
        _SetIndex(b) {
            this._index = b
        }
        GetIndex() {
            return this._index
        }
        GetOwner() {
            return this._effectList.GetOwner()
        }
        GetRuntime() {
            return this._effectList.GetRuntime()
        }
        SetActive(b) {
            this._isActive = !!b
        }
        IsActive() {
            return this._isActive
        }
        GetShaderProgram() {
            return this._shaderProgram
        }
        GetDefaultParameterValues() {
            const b = [];
            for (let a = 0, f = this._shaderProgram.GetParameterCount(); a < f; ++a) {
                const c = this._shaderProgram.GetParameterType(a);
                if ("float" === c || "percent" ===
                    c) b.push(0);
                else if ("color" === c) b.push(d.New(d.Color, 1, 1, 1, 1));
                else throw new TypeError("unknown effect parameter type");
            }
            return b
        }
    }
}
"use strict";
{
    const d = self.C3;
    d.InstanceEffectList = class extends d.DefendedBase {
        constructor(b, a, f) {
            super();
            this._inst = b;
            this._wi = a;
            this._effectList = b.GetObjectClass().GetEffectList();
            this._activeEffectFlags = [];
            this._activeEffectTypes = [];
            this._preservesOpaqueness = !0;
            this._effectParams = [];
            for (const c of this._effectList.GetAllEffectTypes()) this._activeEffectFlags.push(!0);
            this.UpdateActiveEffects()
        }
        Release() {
            d.clearArray(this._activeEffectFlags);
            d.clearArray(this._activeEffectTypes);
            d.clearArray(this._effectParams);
            this._effectList = this._inst = null
        }
        _LoadEffectParameters(b) {
            for (const a of b) this._effectParams.push(this._LoadSingleEffectParameters(a))
        }
        _LoadSingleEffectParameters(b) {
            b = b.slice(0);
            for (let a = 0, f = b.length; a < f; ++a) {
                const c = b[a];
                if (Array.isArray(c)) {
                    const e = d.New(d.Color);
                    e.setFromJSON(c);
                    b[a] = e
                }
            }
            return b
        }
        LoadDefaultEffectParameters() {
            for (const b of this._effectList.GetAllEffectTypes()) this._effectParams.push(b.GetDefaultParameterValues())
        }
        GetOwner() {
            return this._owner
        }
        GetEffectList() {
            return this._effectList
        }
        GetRuntime() {
            return this._inst.GetRuntime()
        }
        UpdateActiveEffects() {
            d.clearArray(this._activeEffectTypes);
            const b = this._effectList.GetAllEffectTypes(),
                a = this._activeEffectTypes,
                f = this._activeEffectFlags;
            let c = !0;
            for (let e = 0, g = b.length; e < g; ++e)
                if (f[e]) {
                    const h = b[e];
                    a.push(h);
                    h.GetShaderProgram().PreservesOpaqueness() || (c = !1)
                } this._preservesOpaqueness = c;
            this._wi._SetHasAnyActiveEffect(!!a.length)
        }
        GetActiveEffectTypes() {
            return this._activeEffectTypes
        }
        GetEffectParametersForIndex(b) {
            return this._effectParams[b]
        }
        PreservesOpaqueness() {
            return this._preservesOpaqueness
        }
        HasAnyActiveBackgroundBlendingEffect() {
            return this._activeEffectTypes.some(b =>
                b.GetShaderProgram().UsesDest())
        }
        IsEffectIndexActive(b) {
            return this._activeEffectFlags[b]
        }
        SetEffectIndexActive(b, a) {
            this._activeEffectFlags[b] = !!a
        }
        GetAllEffectTypes() {
            return this._effectList.GetAllEffectTypes()
        }
        _SaveToJson() {
            return this._effectList.GetAllEffectTypes().map(b => ({
                name: b.GetName(),
                active: this._activeEffectFlags[b.GetIndex()],
                params: d.EffectList.SaveFxParamsToJson(this._effectParams[b.GetIndex()])
            }))
        }
        _LoadFromJson(b) {
            for (const a of b)
                if (b = this._effectList.GetEffectTypeByName(a.name)) this._activeEffectFlags[b.GetIndex()] =
                    a.active, this._effectParams[b.GetIndex()] = d.EffectList.LoadFxParamsFromJson(a.params);
            this.UpdateActiveEffects()
        }
    }
}
"use strict";
{
    const d = self.C3,
        b = [],
        a = [],
        f = [],
        c = d.New(d.CollisionPoly),
        e = d.New(d.CollisionPoly),
        g = d.New(d.Quad),
        h = d.New(d.Rect),
        l = d.New(d.Rect);
    d.CollisionEngine = class extends d.DefendedBase {
        constructor(m) {
            super();
            this._runtime = m;
            this._registeredCollisions = [];
            this._polyCheckSec = this._polyCheckCount = this._collisionCheckSec = this._collisionCheckCount = 0
        }
        Release() {
            this._runtime = null
        }
        _Update1sStats() {
            this._collisionCheckSec = this._collisionCheckCount;
            this._collisionCheckCount = 0;
            this._polyCheckSec = this._polyCheckCount;
            this._polyCheckCount = 0
        }
        Get1secCollisionChecks() {
            return this._collisionCheckSec
        }
        Get1secPolyChecks() {
            return this._polyCheckSec
        }
        RegisterCollision(m, p) {
            const t = m.GetWorldInfo(),
                q = p.GetWorldInfo();
            t && q && t.IsCollisionEnabled() && q.IsCollisionEnabled() && this._registeredCollisions.push([m, p])
        }
        AddRegisteredCollisionCandidates(m, p, t) {
            for (const [q, r] of this._registeredCollisions) {
                let u;
                if (m === q) u = r;
                else if (m === r) u = q;
                else continue;
                u.BelongsToObjectClass(p) && (t.includes(u) || t.push(u))
            }
        }
        CheckRegisteredCollision(m,
            p) {
            if (!this._registeredCollisions.length) return !1;
            for (const [t, q] of this._registeredCollisions)
                if (m === t && p === q || m === q && p === t) return !0;
            return !1
        }
        ClearRegisteredCollisions() {
            d.clearArray(this._registeredCollisions)
        }
        TestOverlap(m, p) {
            if (!m || !p || m === p) return !1;
            m = m.GetWorldInfo();
            p = p.GetWorldInfo();
            if (!m.IsCollisionEnabled() || !p.IsCollisionEnabled()) return !1;
            this._collisionCheckCount++;
            const t = m.GetLayer(),
                q = p.GetLayer();
            return t.IsTransformCompatibleWith(q) ? this._TestOverlap_SameLayers(m, p) : this._TestOverlap_DifferentLayers(m,
                p)
        }
        _TestOverlap_SameLayers(m, p) {
            if (!m.GetBoundingBox().intersectsRect(p.GetBoundingBox())) return !1;
            this._polyCheckCount++;
            if (!m.GetBoundingQuad().intersectsQuad(p.GetBoundingQuad()) || m.HasTilemap() && p.HasTilemap()) return !1;
            if (m.HasTilemap()) return this.TestTilemapOverlap(m, p);
            if (p.HasTilemap()) return this.TestTilemapOverlap(p, m);
            if (!m.HasOwnCollisionPoly() && !p.HasOwnCollisionPoly()) return !0;
            const t = m.GetTransformedCollisionPoly(),
                q = p.GetTransformedCollisionPoly();
            return t.intersectsPoly(q, p.GetX() -
                m.GetX(), p.GetY() - m.GetY())
        }
        _TestOverlap_DifferentLayers(m, p) {
            var t = m.GetLayer();
            const q = p.GetLayer();
            c.copy(m.GetTransformedCollisionPoly());
            e.copy(p.GetTransformedCollisionPoly());
            var r = c.pointsArr();
            for (let u = 0, x = r.length; u < x; u += 2) {
                const y = u + 1,
                    C = r[y],
                    [w, A] = t.LayerToCanvasCss(r[u] + m.GetX(), C + m.GetY());
                r[u] = w;
                r[y] = A
            }
            m = e.pointsArr();
            for (let u = 0, x = m.length; u < x; u += 2) {
                t = u + 1;
                r = m[t];
                const [y, C] = q.LayerToCanvasCss(m[u] + p.GetX(), r + p.GetY());
                m[u] = y;
                m[t] = C
            }
            c.setBboxChanged();
            e.setBboxChanged();
            this._polyCheckCount++;
            return c.intersectsPoly(e, 0, 0)
        }
        TestTilemapOverlap(m, p) {
            const t = p.GetBoundingBox(),
                q = m.GetX(),
                r = m.GetY();
            var u = m.GetInstance().GetSdkInstance();
            m = p.GetX();
            const x = p.GetY(),
                y = p.HasOwnCollisionPoly(),
                C = p.GetBoundingQuad();
            u.GetCollisionRectCandidates(t, a);
            for (let E = 0, K = a.length; E < K; ++E) {
                var w = a[E];
                u = w.GetRect();
                this._collisionCheckCount++;
                if (t.intersectsRectOffset(u, q, r) && (g.setFromRect(u), g.offset(q, r), g.intersectsQuad(C)))
                    if (y) {
                        var A = p.GetTransformedCollisionPoly();
                        if (w = w.GetPoly()) {
                            if (this._polyCheckCount++,
                                w.intersectsPoly(A, m - (q + u.getLeft()), x - (r + u.getTop()))) return d.clearArray(a), !0
                        } else if (c.setFromQuad(g, 0, 0), c.intersectsPoly(A, m, x)) return d.clearArray(a), !0
                    } else if (A = w.GetPoly()) {
                    if (c.setFromQuad(C, 0, 0), A.intersectsPoly(c, -(q + u.getLeft()), -(r + u.getTop()))) return d.clearArray(a), !0
                } else return d.clearArray(a), !0
            }
            d.clearArray(a);
            return !1
        }
        TestAndSelectCanvasPointOverlap(m, p, t, q) {
            const r = m.GetCurrentSol();
            var u = this._runtime.GetCurrentEvent();
            if (!u) throw Error("cannot call outside event");
            u = u.IsOrBlock();
            if (r.IsSelectAll()) {
                q || (r._SetSelectAll(!1), d.clearArray(r._GetOwnInstances()));
                for (var x of m.GetInstances()) {
                    var y = x.GetWorldInfo(),
                        C = y.GetLayer();
                    const [w, A] = C.CanvasCssToLayer(p, t, y.GetTotalZElevation());
                    if (y.ContainsPoint(w, A)) {
                        if (q) return !1;
                        r._PushInstance(x)
                    } else u && r._PushElseInstance(x)
                }
            } else {
                x = u ? r._GetOwnElseInstances() : r._GetOwnInstances();
                y = 0;
                for (let w = 0, A = x.length; w < A; ++w) {
                    C = x[w];
                    const E = C.GetWorldInfo(),
                        K = E.GetLayer(),
                        [O, G] = K.CanvasCssToLayer(p, t, E.GetTotalZElevation());
                    if (E.ContainsPoint(O,
                            G)) {
                        if (q) return !1;
                        u ? r._PushInstance(C) : x[y++] = C
                    } else u && (x[y++] = C)
                }
                q || (x.length = y)
            }
            m.ApplySolToContainer();
            return q ? !0 : r.HasAnyInstances()
        }
        GetCollisionCandidates(m, p, t, q) {
            m = m ? 1 !== m.GetParallaxX() || 1 !== m.GetParallaxY() : !1;
            if (p.IsFamily())
                for (const r of p.GetFamilyMembers()) m || r.IsAnyInstanceParallaxed() ? d.appendArray(q, r.GetInstances()) : (r._UpdateAllCollisionCells(), r._GetCollisionCellGrid().QueryRange(t, q));
            else m || p.IsAnyInstanceParallaxed() ? d.appendArray(q, p.GetInstances()) : (p._UpdateAllCollisionCells(),
                p._GetCollisionCellGrid().QueryRange(t, q))
        }
        GetObjectClassesCollisionCandidates(m, p, t, q) {
            for (const r of p) this.GetCollisionCandidates(m, r, t, q)
        }
        GetSolidCollisionCandidates(m, p, t) {
            const q = this._runtime.GetSolidBehavior();
            q && this.GetObjectClassesCollisionCandidates(m, q.GetObjectClasses(), p, t)
        }
        GetJumpthruCollisionCandidates(m, p, t) {
            const q = this._runtime.GetJumpthruBehavior();
            q && this.GetObjectClassesCollisionCandidates(m, q.GetObjectClasses(), p, t)
        }
        IsSolidCollisionAllowed(m, p) {
            return m._IsSolidEnabled() &&
                (!p || p.GetWorldInfo().IsSolidCollisionAllowed(m.GetSavedDataMap().get("solidTags")))
        }
        TestOverlapSolid(m) {
            const p = m.GetWorldInfo();
            this.GetSolidCollisionCandidates(p.GetLayer(), p.GetBoundingBox(), b);
            for (const t of b)
                if (this.IsSolidCollisionAllowed(t, m) && this.TestOverlap(m, t)) return d.clearArray(b), t;
            d.clearArray(b);
            return null
        }
        TestRectOverlapSolid(m, p) {
            this.GetSolidCollisionCandidates(null, m, b);
            for (const t of b)
                if (this.IsSolidCollisionAllowed(t, p) && this.TestRectOverlap(m, t)) return d.clearArray(b),
                    t;
            d.clearArray(b);
            return null
        }
        TestOverlapJumpthru(m, p) {
            let t = null;
            p && (t = f, d.clearArray(t));
            const q = m.GetWorldInfo();
            this.GetJumpthruCollisionCandidates(q.GetLayer(), q.GetBoundingBox(), b);
            for (const r of b)
                if (r._IsJumpthruEnabled() && this.TestOverlap(m, r))
                    if (p) t.push(r);
                    else return d.clearArray(b), r;
            d.clearArray(b);
            return t
        }
        PushOut(m, p, t, q, r) {
            q = q || 50;
            const u = m.GetWorldInfo(),
                x = u.GetX(),
                y = u.GetY();
            for (let C = 0; C < q; ++C)
                if (u.SetXY(x + p * C, y + t * C), u.SetBboxChanged(), !this.TestOverlap(m, r)) return !0;
            u.SetXY(x,
                y);
            u.SetBboxChanged();
            return !1
        }
        PushOutSolid(m, p, t, q, r, u) {
            q = q || 50;
            const x = m.GetWorldInfo(),
                y = x.GetX(),
                C = x.GetY();
            let w = null,
                A = null;
            for (let E = 0; E < q; ++E)
                if (x.SetXY(y + p * E, C + t * E), x.SetBboxChanged(), !this.TestOverlap(m, w))
                    if (w = this.TestOverlapSolid(m)) A = w;
                    else if (r && (w = u ? this.TestOverlap(m, u) ? u : null : this.TestOverlapJumpthru(m)) && (A = w), !w) return A && this.PushInFractional(m, p, t, A, 16, !0), !0;
            x.SetXY(y, C);
            x.SetBboxChanged();
            return !1
        }
        PushOutSolidAxis(m, p, t, q) {
            q = q || 50;
            const r = m.GetWorldInfo(),
                u = r.GetX(),
                x = r.GetY();
            let y = null,
                C = null;
            for (let w = 0; w < q; ++w)
                for (let A = 0; 2 > A; ++A) {
                    const E = 2 * A - 1;
                    r.SetXY(u + p * w * E, x + t * w * E);
                    r.SetBboxChanged();
                    if (!this.TestOverlap(m, y))
                        if (y = this.TestOverlapSolid(m)) C = y;
                        else return C && this.PushInFractional(m, p * E, t * E, C, 16, !0), !0
                }
            r.SetXY(u, x);
            r.SetBboxChanged();
            return !1
        }
        PushInFractional(m, p, t, q, r, u) {
            let x = 2,
                y = !1;
            var C = !1;
            const w = m.GetWorldInfo();
            let A = w.GetX(),
                E = w.GetY();
            for (; x <= r;) C = 1 / x, x *= 2, w.OffsetXY(p * C * (y ? 1 : -1), t * C * (y ? 1 : -1)), w.SetBboxChanged(), this.TestOverlap(m, q) || u && this.TestOverlapSolid(m) ?
                C = y = !0 : (C = y = !1, A = w.GetX(), E = w.GetY());
            C && (w.SetXY(A, E), w.SetBboxChanged())
        }
        PushOutSolidNearest(m, p = 100) {
            let t = 0;
            const q = m.GetWorldInfo(),
                r = q.GetX(),
                u = q.GetY();
            let x = 0,
                y = this.TestOverlapSolid(m);
            if (!y) return !0;
            for (; t <= p;) {
                let C = 0,
                    w = 0;
                switch (x) {
                    case 0:
                        C = 0;
                        w = -1;
                        t++;
                        break;
                    case 1:
                        C = 1;
                        w = -1;
                        break;
                    case 2:
                        C = 1;
                        w = 0;
                        break;
                    case 3:
                        w = C = 1;
                        break;
                    case 4:
                        C = 0;
                        w = 1;
                        break;
                    case 5:
                        C = -1;
                        w = 1;
                        break;
                    case 6:
                        C = -1;
                        w = 0;
                        break;
                    case 7:
                        w = C = -1
                }
                x = (x + 1) % 8;
                q.SetXY(Math.floor(r + C * t), Math.floor(u + w * t));
                q.SetBboxChanged();
                if (!this.TestOverlap(m,
                        y) && (y = this.TestOverlapSolid(m), !y)) return !0
            }
            q.SetXY(r, u);
            q.SetBboxChanged();
            return !1
        }
        CalculateBounceAngle(m, p, t, q) {
            const r = m.GetWorldInfo(),
                u = r.GetX(),
                x = r.GetY(),
                y = Math.max(10, d.distanceTo(p, t, u, x));
            var C = d.angleTo(p, t, u, x),
                w = q || this.TestOverlapSolid(m);
            if (!w) return d.clampAngle(C + Math.PI);
            let A = w;
            var E = 0,
                K = 0;
            const O = d.toRadians(5);
            let G;
            for (G = 1; 36 > G; ++G) {
                const J = C - G * O;
                r.SetXY(p + Math.cos(J) * y, t + Math.sin(J) * y);
                r.SetBboxChanged();
                if (!this.TestOverlap(m, A) && (A = q ? null : this.TestOverlapSolid(m), !A)) {
                    E =
                        J;
                    break
                }
            }
            36 === G && (E = d.clampAngle(C + Math.PI));
            A = w;
            for (G = 1; 36 > G; ++G)
                if (w = C + G * O, r.SetXY(p + Math.cos(w) * y, t + Math.sin(w) * y), r.SetBboxChanged(), !this.TestOverlap(m, A) && (A = q ? null : this.TestOverlapSolid(m), !A)) {
                    K = w;
                    break
                } 36 === G && (K = d.clampAngle(C + Math.PI));
            r.SetXY(u, x);
            r.SetBboxChanged();
            if (K === E) return K;
            m = d.angleDiff(K, E) / 2;
            m = d.angleClockwise(K, E) ? d.clampAngle(E + m + Math.PI) : d.clampAngle(K + m);
            E = Math.cos(C);
            C = Math.sin(C);
            K = Math.cos(m);
            m = Math.sin(m);
            p = E * K + C * m;
            return d.angleTo(0, 0, E - 2 * p * K, C - 2 * p * m)
        }
        TestSegmentOverlap(m,
            p, t, q, r) {
            if (!r) return !1;
            const u = r.GetWorldInfo();
            if (!u.IsCollisionEnabled()) return !1;
            this._collisionCheckCount++;
            h.set(Math.min(m, t), Math.min(p, q), Math.max(m, t), Math.max(p, q));
            if (!u.GetBoundingBox().intersectsRect(h)) return !1;
            if (r.HasTilemap()) return this._TestSegmentOverlapTilemap(m, p, t, q, r, u);
            this._polyCheckCount++;
            return u.GetBoundingQuad().intersectsSegment(m, p, t, q) ? u.HasOwnCollisionPoly() ? u.GetTransformedCollisionPoly().intersectsSegment(u.GetX(), u.GetY(), m, p, t, q) : !0 : !1
        }
        _TestSegmentOverlapTilemap(m,
            p, t, q, r, u) {
            const x = u.GetX();
            u = u.GetY();
            r = r.GetSdkInstance();
            l.set(m, p, t, q);
            l.normalize();
            r.GetCollisionRectCandidates(l, a);
            for (let C = 0, w = a.length; C < w; ++C) {
                var y = a[C];
                r = y.GetRect();
                this._collisionCheckCount++;
                if (h.intersectsRectOffset(r, x, u) && (g.setFromRect(r), g.offset(x, u), g.intersectsSegment(m, p, t, q)))
                    if (y = y.GetPoly()) {
                        if (this._polyCheckCount++, y.intersectsSegment(x + r.getLeft(), u + r.getTop(), m, p, t, q)) return d.clearArray(a), !0
                    } else return d.clearArray(a), !0
            }
            d.clearArray(a);
            return !1
        }
        TestRectOverlap(m,
            p) {
            if (!p) return !1;
            const t = p.GetWorldInfo();
            if (!t.IsCollisionEnabled()) return !1;
            this._collisionCheckCount++;
            if (!t.GetBoundingBox().intersectsRect(m)) return !1;
            if (p.HasTilemap()) return this._TestRectOverlapTilemap(m, p, t);
            this._polyCheckCount++;
            g.setFromRect(m);
            if (!t.GetBoundingQuad().intersectsQuad(g)) return !1;
            if (!t.HasOwnCollisionPoly()) return !0;
            c.setFromRect(m, t.GetX(), t.GetY());
            m = t.GetTransformedCollisionPoly();
            return c.intersectsPoly(m, 0, 0)
        }
        _TestRectOverlapTilemap(m, p, t) {
            const q = t.GetX();
            t = t.GetY();
            p.GetSdkInstance().GetCollisionRectCandidates(m, a);
            for (let u = 0, x = a.length; u < x; ++u) {
                var r = a[u];
                p = r.GetRect();
                this._collisionCheckCount++;
                if (m.intersectsRectOffset(p, q, t))
                    if (r = r.GetPoly()) {
                        if (this._polyCheckCount++, c.setFromRect(m, 0, 0), r.intersectsPoly(c, -(q + p.getLeft()), -(t + p.getTop()))) return d.clearArray(a), !0
                    } else return d.clearArray(a), !0
            }
            d.clearArray(a);
            return !1
        }
        TestRayIntersectsInstance(m, p) {
            if (m) {
                var t = m.GetWorldInfo();
                t.IsCollisionEnabled() && (this._collisionCheckCount++, t.GetBoundingBox().intersectsRect(p.rect) &&
                    (m.HasTilemap() ? this._TestRayIntersectsTilemap(m, t, p) : (this._polyCheckCount++, t.HasOwnCollisionPoly() ? p.TestInstancePoly(m, t.GetX(), t.GetY(), t.GetTransformedCollisionPoly()) : p.TestInstanceQuad(m, t.GetBoundingQuad()))))
            }
        }
        _TestRayIntersectsTilemap(m, p, t) {
            const q = p.GetX(),
                r = p.GetY();
            m.GetSdkInstance().GetCollisionRectCandidates(t.rect, a);
            for (let x = 0, y = a.length; x < y; x++) {
                var u = a[x];
                const C = u.GetRect();
                this._collisionCheckCount++;
                t.rect.intersectsRectOffset(C, q, r) && (u = u.GetPoly(), this._polyCheckCount++,
                    u ? t.TestInstancePoly(m, q + C.getLeft(), r + C.getTop(), u) : t.TestInstanceRect(m, p.GetX(), p.GetY(), C))
            }
            d.clearArray(a)
        }
    }
}
"use strict";
{
    const d = self.C3;
    d.SparseGrid = class extends d.DefendedBase {
        constructor(b, a) {
            super();
            this._cellWidth = b;
            this._cellHeight = a;
            this._cells = d.New(d.PairMap)
        }
        Release() {
            this._cells.Release();
            this._cells = null
        }
        GetCell(b, a, f) {
            let c = this._cells.Get(b, a);
            return c ? c : f ? (c = d.New(d.GridCell, this, b, a), this._cells.Set(b, a, c), c) : null
        }
        XToCell(b) {
            b = Math.floor(b / this._cellWidth);
            return isFinite(b) ? b : 0
        }
        YToCell(b) {
            b = Math.floor(b / this._cellHeight);
            return isFinite(b) ? b : 0
        }
        Update(b, a, f) {
            if (a)
                for (let c = a.getLeft(), e = a.getRight(); c <=
                    e; ++c)
                    for (let g = a.getTop(), h = a.getBottom(); g <= h; ++g) {
                        if (f && f.containsPoint(c, g)) continue;
                        const l = this.GetCell(c, g, !1);
                        l && (l.Remove(b), l.IsEmpty() && this._cells.Delete(c, g))
                    }
            if (f)
                for (let c = f.getLeft(), e = f.getRight(); c <= e; ++c)
                    for (let g = f.getTop(), h = f.getBottom(); g <= h; ++g) a && a.containsPoint(c, g) || this.GetCell(c, g, !0).Insert(b)
        }
        QueryRange(b, a) {
            let f = this.XToCell(b.getLeft());
            const c = this.YToCell(b.getTop()),
                e = this.XToCell(b.getRight());
            b = this.YToCell(b.getBottom());
            if (isFinite(e) && isFinite(b))
                for (; f <=
                    e; ++f)
                    for (let g = c; g <= b; ++g) {
                        const h = this.GetCell(f, g, !1);
                        h && h.Dump(a)
                    }
        }
    }
}
"use strict";
{
    const d = self.C3;
    d.GridCell = class extends d.DefendedBase {
        constructor(b, a, f) {
            super();
            this._grid = b;
            this._x = a;
            this._y = f;
            this._instances = d.New(d.ArraySet)
        }
        Release() {
            this._instances.Release();
            this._grid = this._instances = null
        }
        IsEmpty() {
            return this._instances.IsEmpty()
        }
        Insert(b) {
            this._instances.Add(b)
        }
        Remove(b) {
            this._instances.Delete(b)
        }
        Dump(b) {
            d.appendArray(b, this._instances.GetArray())
        }
    }
}
"use strict";
{
    const d = self.C3;
    d.Ray = class {
        constructor() {
            this.dy = this.dx = this.y2 = this.x2 = this.y1 = this.x1 = 0;
            this.rect = new d.Rect;
            this.hitFraction = 2;
            this.hitUid = null;
            this.distance = this.hitY = this.hitX = this.hitNormalDy = this.hitNormalDx = this.hitNormal = 0;
            this.normalX = 1;
            this.normalY = 0;
            this.reflectionX = 1;
            this.reflectionY = 0
        }
        DidCollide() {
            return 1.000001 > this.hitFraction
        }
        Set(b, a, f, c) {
            this.x1 = b;
            this.y1 = a;
            this.x2 = f;
            this.y2 = c;
            this.dx = f - b;
            this.dy = c - a;
            this.rect.set(b, a, f, c);
            this.rect.normalize();
            this.hitFraction = 2;
            this.hitUid =
                null;
            this.distance = this.hitY = this.hitX = this.hitNormalDy = this.hitNormalDx = this.hitNormal = 0;
            this.normalX = 1;
            this.normalY = 0;
            this.reflectionX = 1;
            this.reflectionY = 0;
            return this
        }
        Complete() {
            if (!1 !== this.DidCollide()) {
                var b = this.dx * this.hitFraction,
                    a = this.dy * this.hitFraction,
                    f = Math.sqrt(b * b + a * a);
                b /= f;
                a /= f;
                this.distance = f - 1E-6;
                this.hitX = this.x1 + b * this.distance;
                this.hitY = this.y1 + a * this.distance;
                this.hitNormal = Math.atan2(this.hitNormalDy, this.hitNormalDx) + Math.PI / 2;
                this.normalX = Math.cos(this.hitNormal);
                this.normalY =
                    Math.sin(this.hitNormal);
                f = b * this.normalX + a * this.normalY;
                this.reflectionX = b - 2 * this.normalX * f;
                this.reflectionY = a - 2 * this.normalY * f;
                0 < f && (this.hitNormal = d.clampAngle(this.hitNormal + Math.PI), this.normalX = -this.normalX, this.normalY = -this.normalY)
            }
        }
        TestInstanceSegment(b, a, f, c, e) {
            const g = d.rayIntersect(this.x1, this.y1, this.x2, this.y2, a, f, c, e);
            0 <= g && g < this.hitFraction && (this.hitFraction = g, this.hitUid = b.GetUID(), this.hitNormalDx = a - c, this.hitNormalDy = f - e)
        }
        TestInstanceRect(b, a, f, c) {
            const e = a + c.getLeft();
            a +=
                c.getRight();
            const g = f + c.getTop();
            f += c.getBottom();
            this.TestInstanceSegment(b, e, g, a, g);
            this.TestInstanceSegment(b, a, g, a, f);
            this.TestInstanceSegment(b, a, f, e, f);
            this.TestInstanceSegment(b, e, f, e, g)
        }
        TestInstanceQuad(b, a) {
            const f = a.getTlx(),
                c = a.getTly(),
                e = a.getTrx(),
                g = a.getTry(),
                h = a.getBrx(),
                l = a.getBry(),
                m = a.getBlx();
            a = a.getBly();
            this.TestInstanceSegment(b, f, c, e, g);
            this.TestInstanceSegment(b, e, g, h, l);
            this.TestInstanceSegment(b, h, l, m, a);
            this.TestInstanceSegment(b, m, a, f, c)
        }
        TestInstancePoly(b, a, f, c) {
            c = c.pointsArr();
            for (let e = 0, g = c.length; e < g; e += 2) {
                const h = (e + 2) % g;
                this.TestInstanceSegment(b, c[e] + a, c[e + 1] + f, c[h] + a, c[h + 1] + f)
            }
        }
    }
}
"use strict";
{
    const d = self.C3,
        b = new Set("off crop scale-inner scale-outer letterbox-scale letterbox-integer-scale".split(" ")),
        a = new Set(["high", "low"]),
        f = d.New(d.Quad),
        c = d.New(d.Rect);
    d.CanvasManager = class extends d.DefendedBase {
        constructor(e) {
            super();
            this._runtime = e;
            this._webglRenderer = this._canvas = null;
            this._gpuPreference = "high-performance";
            this._canvasCssOffsetY = this._canvasCssOffsetX = this._canvasDeviceHeight = this._canvasDeviceWidth = this._canvasCssHeight = this._canvasCssWidth = this._windowInnerHeight = this._windowInnerWidth =
                0;
            this._enableMipmaps = !0;
            this._drawHeight = this._drawWidth = 0;
            this._documentFullscreenMode = this._fullscreenMode = "letterbox-scale";
            this._deviceTransformOffY = this._deviceTransformOffX = 0;
            this._fullscreenScalingQuality = this._wantFullscreenScalingQuality = "high";
            this._isDocumentFullscreen = !1;
            this._availableAdditionalRenderTargets = [];
            this._usedAdditionalRenderTargets = new Set;
            this._gpuFrameTimingsBuffer = this._shaderData = null;
            this._gpuTimeEndFrame = this._gpuTimeStartFrame = 0;
            this._gpuCurUtilisation = NaN;
            this._gpuLastUtilisation =
                0;
            this._layersGpuProfile = new Map;
            this._snapshotFormat = "";
            this._snapshotQuality = 1;
            this._snapshotArea = d.New(d.Rect);
            this._snapshotUrl = "";
            this._snapshotResolve = this._snapshotPromise = null;
            this._loaderStartTime = 0;
            this._rafId = -1;
            this._loadingProgress = 0;
            this._loadingprogress_handler = g => this._loadingProgress = g.progress;
            this._percentText = null;
            this._splashTextures = {
                logo: null,
                powered: null,
                website: null
            };
            this._splashFadeOutStartTime = this._splashFadeInFinishTime = this._splashFrameNumber = 0;
            this._splashState = "fade-in";
            this._splashDoneResolve = null;
            this._splashDonePromise = new Promise(g => this._splashDoneResolve = g)
        }
        _SetGPUPowerPreference(e) {
            this._gpuPreference = e
        }
        async CreateCanvas(e) {
            this._canvas = e.canvas;
            this._canvas.addEventListener("webglcontextlost", h => this._OnWebGLContextLost(h));
            this._canvas.addEventListener("webglcontextrestored", h => this._OnWebGLContextRestored(h));
            const g = {
                powerPreference: this._gpuPreference,
                enableGpuProfiling: !0
            };
            "Android" === d.Platform.OS && "Chromium" === d.Platform.BrowserEngine && 75 > d.Platform.BrowserVersionNumber &&
                (console.warn("[Construct 3] Disabling WebGL 2 because this device appears to be affected by crbug.com/934823. Install software updates to avoid this."), g.maxWebGLVersion = 1);
            "standard" === this._runtime.GetCompositingMode() ? g.alpha = !0 : (g.alpha = !1, g.lowLatency = !0);
            this._webglRenderer = d.New(d.Gfx.WebGLRenderer, this._canvas, g);
            await this._webglRenderer.InitState();
            this._webglRenderer.SupportsGPUProfiling() || (this._gpuLastUtilisation = NaN);
            this._runtime.AddDOMComponentMessageHandler("runtime", "window-resize",
                h => this._OnWindowResize(h));
            this._runtime.AddDOMComponentMessageHandler("runtime", "fullscreenchange", h => this._OnFullscreenChange(h));
            this._runtime.AddDOMComponentMessageHandler("runtime", "fullscreenerror", h => this._OnFullscreenError(h));
            this._isDocumentFullscreen = !!e.isFullscreen;
            this.SetSize(e.windowInnerWidth, e.windowInnerHeight, !0);
            this._shaderData = self.C3_Shaders;
            await this._LoadShaderPrograms();
            e = !1;
            for (const h of this._runtime._GetAllEffectLists()) {
                for (const l of h.GetAllEffectTypes()) l._InitRenderer(this._webglRenderer),
                    l.GetShaderProgram().UsesDest() && (e = !0);
                h.UpdateActiveEffects()
            }
            this._runtime._SetUsesAnyBackgroundBlending(e);
            this._webglRenderer.SupportsGPUProfiling() && (this._gpuFrameTimingsBuffer = d.New(d.Gfx.WebGLQueryResultBuffer, this._webglRenderer));
            this._webglRenderer.SetMipmapsEnabled(this._enableMipmaps)
        }
        async _LoadShaderPrograms() {
            if (this._shaderData) {
                var e = [];
                for (const [g, h] of Object.entries(this._shaderData)) {
                    const l = d.Gfx.WebGLShaderProgram.GetDefaultVertexShaderSource();
                    e.push(this._webglRenderer.CreateShaderProgram(h,
                        l, g))
                }
                await Promise.all(e);
                this._webglRenderer.ResetLastProgram();
                this._webglRenderer.SetTextureFillMode()
            }
        }
        Release() {
            this._canvas = this._webglRenderer = this._runtime = null
        }
        _OnWindowResize(e) {
            const g = e.devicePixelRatio;
            this._runtime.IsInWorker() && (self.devicePixelRatio = g);
            this._runtime._SetDevicePixelRatio(g);
            this.SetSize(e.innerWidth, e.innerHeight);
            this._runtime.UpdateRender()
        }
        _OnFullscreenChange(e) {
            this._isDocumentFullscreen = !!e.isFullscreen;
            this.SetSize(e.innerWidth, e.innerHeight, !0);
            this._runtime.UpdateRender()
        }
        _OnFullscreenError(e) {
            this._isDocumentFullscreen = !!e.isFullscreen;
            this.SetSize(e.innerWidth, e.innerHeight, !0);
            this._runtime.UpdateRender()
        }
        SetSize(e, g, h = !1) {
            e = Math.floor(e);
            g = Math.floor(g);
            if (0 >= e || 0 >= g) throw Error("invalid size");
            if (this._windowInnerWidth !== e || this._windowInnerHeight !== g || h) this._windowInnerWidth = e, this._windowInnerHeight = g, h = this.GetCurrentFullscreenMode(), "letterbox-scale" === h ? this._CalculateLetterboxScale(e, g) : "letterbox-integer-scale" === h ? this._CalculateLetterboxIntegerScale(e, g) : "off" === h ? this._CalculateFixedSizeCanvas(e,
                g) : this._CalculateFullsizeCanvas(e, g), this._UpdateFullscreenScalingQuality(h), this._canvas.width = this._canvasDeviceWidth, this._canvas.height = this._canvasDeviceHeight, this._runtime.PostComponentMessageToDOM("canvas", "update-size", {
                marginLeft: this._canvasCssOffsetX,
                marginTop: this._canvasCssOffsetY,
                styleWidth: this._canvasCssWidth,
                styleHeight: this._canvasCssHeight
            }), this._webglRenderer.SetSize(this._canvasDeviceWidth, this._canvasDeviceHeight, !0)
        }
        _CalculateLetterboxScale(e, g) {
            const h = this._runtime.GetDevicePixelRatio(),
                l = this._runtime.GetOriginalViewportWidth(),
                m = this._runtime.GetOriginalViewportHeight(),
                p = l / m;
            e / g > p ? (this._canvasCssWidth = Math.round(g * p), this._canvasCssHeight = g, this._canvasCssOffsetX = Math.floor((e - this._canvasCssWidth) / 2), this._canvasCssOffsetY = 0) : (this._canvasCssWidth = e, this._canvasCssHeight = Math.round(e / p), this._canvasCssOffsetX = 0, this._canvasCssOffsetY = Math.floor((g - this._canvasCssHeight) / 2));
            this._canvasDeviceWidth = Math.round(this._canvasCssWidth * h);
            this._canvasDeviceHeight = Math.round(this._canvasCssHeight *
                h);
            this._runtime.SetViewportSize(l, m)
        }
        _CalculateLetterboxIntegerScale(e, g) {
            const h = this._runtime.GetDevicePixelRatio();
            1 !== h && (e += 1, g += 1);
            const l = this._runtime.GetOriginalViewportWidth(),
                m = this._runtime.GetOriginalViewportHeight();
            var p = l / m;
            p = e / g > p ? g * p * h / l : e / p * h / m;
            1 < p ? p = Math.floor(p) : 1 > p && (p = 1 / Math.ceil(1 / p));
            this._canvasDeviceWidth = Math.round(l * p);
            this._canvasDeviceHeight = Math.round(m * p);
            this._canvasCssWidth = this._canvasDeviceWidth / h;
            this._canvasCssHeight = this._canvasDeviceHeight / h;
            this._canvasCssOffsetX =
                Math.max(Math.floor((e - this._canvasCssWidth) / 2), 0);
            this._canvasCssOffsetY = Math.max(Math.floor((g - this._canvasCssHeight) / 2), 0);
            this._runtime.SetViewportSize(l, m)
        }
        _CalculateFullsizeCanvas(e, g) {
            const h = this._runtime.GetDevicePixelRatio();
            this._canvasCssWidth = e;
            this._canvasCssHeight = g;
            this._canvasDeviceWidth = Math.round(this._canvasCssWidth * h);
            this._canvasDeviceHeight = Math.round(this._canvasCssHeight * h);
            this._canvasCssOffsetY = this._canvasCssOffsetX = 0;
            e = this.GetDisplayScale();
            this._runtime.SetViewportSize(this._canvasCssWidth /
                e, this._canvasCssHeight / e)
        }
        _CalculateFixedSizeCanvas(e, g) {
            const h = this._runtime.GetDevicePixelRatio();
            this._canvasCssWidth = this._runtime.GetViewportWidth();
            this._canvasCssHeight = this._runtime.GetViewportHeight();
            this._canvasDeviceWidth = Math.round(this._canvasCssWidth * h);
            this._canvasDeviceHeight = Math.round(this._canvasCssHeight * h);
            this.IsDocumentFullscreen() ? (this._canvasCssOffsetX = Math.floor((e - this._canvasCssWidth) / 2), this._canvasCssOffsetY = Math.floor((g - this._canvasCssHeight) / 2)) : this._canvasCssOffsetY =
                this._canvasCssOffsetX = 0;
            this._runtime.SetViewportSize(this._runtime.GetViewportWidth(), this._runtime.GetViewportHeight())
        }
        _UpdateFullscreenScalingQuality(e) {
            if ("high" === this._wantFullscreenScalingQuality) this._drawWidth = this._canvasDeviceWidth, this._drawHeight = this._canvasDeviceHeight, this._fullscreenScalingQuality = "high";
            else {
                let h;
                if ("off" === this.GetCurrentFullscreenMode()) {
                    var g = this._runtime.GetViewportWidth();
                    h = this._runtime.GetViewportHeight()
                } else g = this._runtime.GetOriginalViewportWidth(),
                    h = this._runtime.GetOriginalViewportHeight();
                this._canvasDeviceWidth < g && this._canvasDeviceHeight < h ? (this._drawWidth = this._canvasDeviceWidth, this._drawHeight = this._canvasDeviceHeight, this._fullscreenScalingQuality = "high") : (this._drawWidth = g, this._drawHeight = h, this._fullscreenScalingQuality = "low", "scale-inner" === e ? (e = g / h, g = this._windowInnerWidth / this._windowInnerHeight, g < e ? this._drawWidth = this._drawHeight * g : g > e && (this._drawHeight = this._drawWidth / g)) : "scale-outer" === e && (e = g / h, g = this._windowInnerWidth /
                    this._windowInnerHeight, g > e ? this._drawWidth = this._drawHeight * g : g < e && (this._drawHeight = this._drawWidth / g)))
            }
        }
        IsDocumentFullscreen() {
            return this._isDocumentFullscreen
        }
        SetFullscreenMode(e) {
            if (!b.has(e)) throw Error("invalid fullscreen mode");
            this._fullscreenMode = e
        }
        GetFullscreenMode() {
            return this._fullscreenMode
        }
        SetDocumentFullscreenMode(e) {
            if (!b.has(e)) throw Error("invalid fullscreen mode");
            this._documentFullscreenMode = e
        }
        GetDocumentFullscreenMode() {
            return this._documentFullscreenMode
        }
        GetCurrentFullscreenMode() {
            return this.IsDocumentFullscreen() ?
                this.GetDocumentFullscreenMode() : this.GetFullscreenMode()
        }
        SetFullscreenScalingQuality(e) {
            if (!a.has(e)) throw Error("invalid fullscreen scaling quality");
            this._wantFullscreenScalingQuality = e
        }
        GetSetFullscreenScalingQuality() {
            return this._wantFullscreenScalingQuality
        }
        GetCurrentFullscreenScalingQuality() {
            return this._fullscreenScalingQuality
        }
        static _FullscreenModeNumberToString(e) {
            switch (e) {
                case 0:
                    return "off";
                case 1:
                    return "crop";
                case 2:
                    return "scale-inner";
                case 3:
                    return "scale-outer";
                case 4:
                    return "letterbox-scale";
                case 5:
                    return "letterbox-integer-scale";
                default:
                    throw Error("invalid fullscreen mode");
            }
        }
        GetLastWidth() {
            return this._windowInnerWidth
        }
        GetLastHeight() {
            return this._windowInnerHeight
        }
        GetDrawWidth() {
            return this._drawWidth
        }
        GetDrawHeight() {
            return this._drawHeight
        }
        SetMipmapsEnabled(e) {
            this._enableMipmaps = !!e
        }
        IsWebGLContextLost() {
            return this._webglRenderer.IsContextLost()
        }
        _OnWebGLContextLost(e) {
            console.log("[Construct 3] WebGL context lost");
            e.preventDefault();
            this._availableAdditionalRenderTargets = [];
            this._usedAdditionalRenderTargets.clear();
            this._webglRenderer.OnContextLost();
            this._runtime._OnWebGLContextLost()
        }
        async _OnWebGLContextRestored(e) {
            await this._webglRenderer.OnContextRestored();
            await this._LoadShaderPrograms();
            for (const g of this._runtime._GetAllEffectLists())
                for (const h of g.GetAllEffectTypes()) h._InitRenderer(this._webglRenderer);
            await this._runtime._OnWebGLContextRestored();
            console.log("[Construct 3] WebGL context restored")
        }
        GetWebGLRenderer() {
            return this._webglRenderer
        }
        GetRenderScale() {
            return "low" === this._fullscreenScalingQuality ?
                1 / this._runtime.GetDevicePixelRatio() : this.GetDisplayScale()
        }
        GetDisplayScale() {
            const e = this.GetCurrentFullscreenMode();
            if ("off" === e || "crop" === e) return 1;
            const g = this._runtime.GetOriginalViewportWidth(),
                h = this._runtime.GetOriginalViewportHeight(),
                l = g / h,
                m = this._canvasDeviceWidth / this._canvasDeviceHeight;
            return "scale-inner" !== e && m > l || "scale-inner" === e && m < l ? this._canvasCssHeight / h : this._canvasCssWidth / g
        }
        SetDeviceTransformOffset(e, g) {
            this._deviceTransformOffX = e;
            this._deviceTransformOffY = g
        }
        SetDeviceTransform(e,
            g, h) {
            g = (g || this._drawWidth) / 2 + this._deviceTransformOffX;
            h = (h || this._drawHeight) / 2 + this._deviceTransformOffY;
            e.SetCameraXYZ(g, h, 100 * this._runtime.GetDevicePixelRatio());
            e.SetLookXYZ(g, h, 0);
            e.ResetModelView();
            e.UpdateModelView()
        }
        SetCssTransform(e) {
            const g = this._canvasCssWidth / 2,
                h = this._canvasCssHeight / 2;
            e.SetCameraXYZ(g, h, 100);
            e.SetLookXYZ(g, h, 0);
            e.ResetModelView();
            e.UpdateModelView()
        }
        GetDeviceWidth() {
            return this._canvasDeviceWidth
        }
        GetDeviceHeight() {
            return this._canvasDeviceHeight
        }
        GetCssWidth() {
            return this._canvasCssWidth
        }
        GetCssHeight() {
            return this._canvasCssHeight
        }
        GetCanvasClientX() {
            return this._canvasCssOffsetX
        }
        GetCanvasClientY() {
            return this._canvasCssOffsetY
        }
        GetAdditionalRenderTarget(e) {
            const g =
                this._availableAdditionalRenderTargets,
                h = g.findIndex(m => m.IsCompatibleWithOptions(e));
            let l; - 1 !== h ? (l = g[h], g.splice(h, 1)) : l = this._webglRenderer.CreateRenderTarget(e);
            this._usedAdditionalRenderTargets.add(l);
            return l
        }
        ReleaseAdditionalRenderTarget(e) {
            if (!this._usedAdditionalRenderTargets.has(e)) throw Error("render target not in use");
            this._usedAdditionalRenderTargets.delete(e);
            this._availableAdditionalRenderTargets.push(e)
        }* activeLayersGpuProfiles() {
            for (const e of this._runtime.GetLayoutManager().runningLayouts())
                for (const g of e.GetLayers()) {
                    const h =
                        this._layersGpuProfile.get(g);
                    h && (yield h)
                }
        }
        GetLayerTimingsBuffer(e) {
            if (!this._webglRenderer.SupportsGPUProfiling()) return null;
            let g = this._layersGpuProfile.get(e);
            g || (g = {
                name: e.GetName(),
                timingsBuffer: d.New(d.Gfx.WebGLQueryResultBuffer, this._webglRenderer),
                curUtilisation: 0,
                lastUtilisation: 0
            }, this._layersGpuProfile.set(e, g));
            return g.timingsBuffer
        }
        _Update1sFrameRange() {
            if (this._webglRenderer.SupportsGPUProfiling() && 0 === this._gpuTimeEndFrame) {
                this._gpuTimeEndFrame = this._webglRenderer.GetFrameNumber();
                this._gpuCurUtilisation = NaN;
                for (const e of this.activeLayersGpuProfiles()) e.curUtilisation = NaN
            }
        }
        _UpdateTick() {
            if (this._webglRenderer.SupportsGPUProfiling() && isNaN(this._gpuCurUtilisation) && (this._gpuCurUtilisation = this._gpuFrameTimingsBuffer.GetFrameRangeResultSum(this._gpuTimeStartFrame, this._gpuTimeEndFrame), !isNaN(this._gpuCurUtilisation))) {
                if (this._runtime.IsDebug())
                    for (const e of this.activeLayersGpuProfiles())
                        if (e.curUtilisation = e.timingsBuffer.GetFrameRangeResultSum(this._gpuTimeStartFrame,
                                this._gpuTimeEndFrame), isNaN(e.curUtilisation)) return;
                this._gpuFrameTimingsBuffer.DeleteAllBeforeFrameNumber(this._gpuTimeEndFrame);
                this._gpuLastUtilisation = Math.min(this._gpuCurUtilisation, 1);
                if (this._runtime.IsDebug()) {
                    for (const e of this.activeLayersGpuProfiles()) e.timingsBuffer.DeleteAllBeforeFrameNumber(this._gpuTimeEndFrame), e.lastUtilisation = Math.min(e.curUtilisation, 1);
                    self.C3Debugger.UpdateGPUProfile(this._gpuLastUtilisation, [...this.activeLayersGpuProfiles()])
                }
                this._gpuTimeStartFrame = this._gpuTimeEndFrame;
                this._gpuTimeEndFrame = 0
            }
        }
        GetGPUFrameTimingsBuffer() {
            return this._gpuFrameTimingsBuffer
        }
        GetGPUUtilisation() {
            return this._gpuLastUtilisation
        }
        SnapshotCanvas(e, g, h, l, m, p) {
            this._snapshotFormat = e;
            this._snapshotQuality = g;
            this._snapshotArea.setWH(h, l, m, p);
            return this._snapshotPromise ? this._snapshotPromise : this._snapshotPromise = new Promise(t => {
                this._snapshotResolve = t
            })
        }
        _MaybeTakeSnapshot() {
            if (this._snapshotFormat) {
                var e = this._canvas,
                    g = this._snapshotArea,
                    h = d.clamp(Math.floor(g.getLeft()), 0, e.width),
                    l = d.clamp(Math.floor(g.getTop()),
                        0, e.height),
                    m = g.width();
                m = 0 === m ? e.width - h : d.clamp(Math.floor(m), 0, e.width - h);
                g = g.height();
                g = 0 === g ? e.height - l : d.clamp(Math.floor(g), 0, e.height - l);
                (0 !== h || 0 !== l || m !== e.width || g !== e.height) && 0 < m && 0 < g && (e = d.CreateCanvas(m, g), e.getContext("2d").drawImage(this._canvas, h, l, m, g, 0, 0, m, g));
                d.CanvasToBlob(e, this._snapshotFormat, this._snapshotQuality).then(p => {
                    this._snapshotUrl = URL.createObjectURL(p);
                    this._snapshotPromise = null;
                    this._snapshotResolve(this._snapshotUrl)
                });
                this._snapshotFormat = "";
                this._snapshotQuality =
                    1
            }
        }
        GetCanvasSnapshotUrl() {
            return this._snapshotUrl
        }
        InitLoadingScreen(e) {
            2 === e ? (this._percentText = d.New(d.Gfx.RendererText, this._webglRenderer), this._percentText.SetIsAsync(!1), this._percentText.SetFontName("Arial"), this._percentText.SetFontSize(16), this._percentText.SetHorizontalAlignment("center"), this._percentText.SetVerticalAlignment("center"), this._percentText.SetSize(300, 200)) : 0 === e ? (e = this._runtime.GetLoadingLogoAsset()) && e.LoadStaticTexture(this._webglRenderer).catch(g => console.warn("[C3 runtime] Failed to create texture for loading logo: ",
                g)) : 4 === e && (this._LoadSvgSplashImage("splash-images/splash-logo.svg").then(g => {
                "done" === this._splashState ? this._webglRenderer.DeleteTexture(g) : this._splashTextures.logo = g
            }).catch(g => console.warn("Failed to load splash image: ", g)), this._LoadBitmapSplashImage("splash-images/splash-poweredby-512.png").then(g => {
                "done" === this._splashState ? this._webglRenderer.DeleteTexture(g) : this._splashTextures.powered = g
            }).catch(g => console.warn("Failed to load splash image: ", g)), this._LoadBitmapSplashImage("splash-images/splash-website-512.png").then(g => {
                "done" === this._splashState ? this._webglRenderer.DeleteTexture(g) : this._splashTextures.website = g
            }).catch(g => console.warn("Failed to load splash image: ", g)))
        }
        async _LoadSvgSplashImage(e) {
            e = (new URL(e, this._runtime.GetBaseURL())).toString();
            e = await d.FetchBlob(e);
            e = await this._runtime.RasterSvgImage(e, 2048, 2048);
            return await this._webglRenderer.CreateStaticTextureAsync(e, {
                mipMapQuality: "high"
            })
        }
        async _LoadBitmapSplashImage(e) {
            e = (new URL(e, this._runtime.GetBaseURL())).toString();
            e = await d.FetchBlob(e);
            return await this._webglRenderer.CreateStaticTextureAsync(e, {
                mipMapQuality: "high"
            })
        }
        HideCordovaSplashScreen() {
            this._runtime.PostComponentMessageToDOM("runtime", "hide-cordova-splash")
        }
        StartLoadingScreen() {
            this._loaderStartTime = Date.now();
            this._runtime.Dispatcher().addEventListener("loadingprogress", this._loadingprogress_handler);
            this._rafId = requestAnimationFrame(() => this._DrawLoadingScreen());
            3 !== this._runtime.GetLoaderStyle() && this.HideCordovaSplashScreen()
        }
        async EndLoadingScreen() {
            this._loadingProgress =
                1;
            const e = this._runtime.GetLoaderStyle();
            4 === e && await this._splashDonePromise;
            this._splashDonePromise = this._splashDoneResolve = null; - 1 !== this._rafId && (cancelAnimationFrame(this._rafId), this._rafId = -1);
            this._runtime.Dispatcher().removeEventListener("loadingprogress", this._loadingprogress_handler);
            this._loadingprogress_handler = null;
            this._percentText && (this._percentText.Release(), this._percentText = null);
            this._runtime.ReleaseLoadingLogoAsset();
            this._webglRenderer.Start();
            this._splashTextures.logo && (this._webglRenderer.DeleteTexture(this._splashTextures.logo),
                this._splashTextures.logo = null);
            this._splashTextures.powered && (this._webglRenderer.DeleteTexture(this._splashTextures.powered), this._splashTextures.powered = null);
            this._splashTextures.website && (this._webglRenderer.DeleteTexture(this._splashTextures.website), this._splashTextures.website = null);
            this._webglRenderer.ClearRgba(0, 0, 0, 0);
            this._webglRenderer.Finish();
            this._splashState = "done";
            this._gpuTimeStartFrame = this._webglRenderer.GetFrameNumber();
            3 === e && this.HideCordovaSplashScreen()
        }
        _DrawLoadingScreen() {
            if (-1 !==
                this._rafId) {
                var e = this._webglRenderer;
                e.Start();
                this._rafId = -1;
                var g = this._runtime.GetAssetManager().HasHadErrorLoading(),
                    h = this._runtime.GetLoaderStyle();
                3 !== h && (this.SetCssTransform(e), e.ClearRgba(0, 0, 0, 0), e.ResetColor(), e.SetTextureFillMode(), e.SetTexture(null));
                if (0 === h) this._DrawProgressBarAndLogoLoadingScreen(g);
                else if (1 === h) this._DrawProgressBarLoadingScreen(g, 120, 0);
                else if (2 === h) this._DrawPercentTextLoadingScreen(g);
                else if (3 === h) d.noop();
                else if (4 === h) this._DrawSplashLoadingScreen(g);
                else throw Error("invalid loader style");
                e.Finish();
                this._rafId = requestAnimationFrame(() => this._DrawLoadingScreen())
            }
        }
        _DrawPercentTextLoadingScreen(e) {
            e ? this._percentText.SetColorRgb(1, 0, 0) : this._percentText.SetColorRgb(.6, .6, .6);
            this._percentText.SetText(Math.round(100 * this._loadingProgress) + "%");
            e = this._canvasCssWidth / 2;
            const g = this._canvasCssHeight / 2;
            f.setRect(e - 150, g - 100, e + 150, g + 100);
            this._webglRenderer.SetTexture(this._percentText.GetTexture());
            this._webglRenderer.Quad3(f, this._percentText.GetTexRect())
        }
        _DrawProgressBarLoadingScreen(e,
            g, h) {
            const l = this._webglRenderer;
            l.SetColorFillMode();
            e ? l.SetColorRgba(1, 0, 0, 1) : l.SetColorRgba(.118, .565, 1, 1);
            e = this._canvasCssWidth / 2;
            const m = this._canvasCssHeight / 2,
                p = g / 2;
            c.setWH(e - p, m - 4 + h, Math.floor(g * this._loadingProgress), 8);
            l.Rect(c);
            c.setWH(e - p, m - 4 + h, g, 8);
            c.offset(-.5, -.5);
            c.inflate(.5, .5);
            l.SetColorRgba(0, 0, 0, 1);
            l.LineRect2(c);
            c.inflate(1, 1);
            l.SetColorRgba(1, 1, 1, 1);
            l.LineRect2(c)
        }
        _DrawProgressBarAndLogoLoadingScreen(e) {
            var g = this._runtime.GetLoadingLogoAsset();
            if (g)
                if (g = g.GetTexture()) {
                    var h =
                        g.GetWidth(),
                        l = g.GetHeight(),
                        m = this._canvasCssWidth / 2,
                        p = this._canvasCssHeight / 2,
                        t = h / 2;
                    l /= 2;
                    f.setRect(m - t, p - l, m + t, p + l);
                    this._webglRenderer.SetTexture(g);
                    this._webglRenderer.Quad(f);
                    this._DrawProgressBarLoadingScreen(e, h, l + 16)
                } else this._DrawProgressBarLoadingScreen(e, 120, 0);
            else this._DrawProgressBarLoadingScreen(e, 120, 0)
        }
        _DrawSplashLoadingScreen(e) {
            const g = this._webglRenderer,
                h = this._splashTextures.logo,
                l = this._splashTextures.powered,
                m = this._splashTextures.website,
                p = Date.now();
            0 === this._splashFrameNumber &&
                (this._loaderStartTime = p);
            const t = this._runtime.IsPreview() || this._runtime.IsFBInstantAvailable() && !this._runtime.IsCordova(),
                q = t ? 0 : 200,
                r = t ? 0 : 3E3;
            let u = 1;
            "fade-in" === this._splashState ? u = Math.min((p - this._loaderStartTime) / 300, 1) : "fade-out" === this._splashState && (u = Math.max(1 - (p - this._splashFadeOutStartTime) / 300, 0));
            g.SetColorFillMode();
            g.SetColorRgba(.231 * u, .251 * u, .271 * u, u);
            c.set(0, 0, this._canvasCssWidth, this._canvasCssHeight);
            g.Rect(c);
            const x = Math.ceil(this._canvasCssWidth),
                y = Math.ceil(this._canvasCssHeight);
            let C;
            256 < this._canvasCssHeight ? (g.SetColorRgba(.302 * u, .334 * u, .365 * u, u), C = Math.max(.005 * y, 2), c.setWH(0, .8 * y - C / 2, x, C), g.Rect(c), e ? g.SetColorRgba(u, 0, 0, u) : g.SetColorRgba(.161 * u, .953 * u, .816 * u, u), e = x * this._loadingProgress, c.setWH(.5 * x - e / 2, .8 * y - C / 2, e, C), g.Rect(c), g.SetColorRgba(u, u, u, u), g.SetTextureFillMode(), l && (e = 1.5 * d.clamp(.22 * y, 105, .6 * x), C = e / 8, c.setWH(.5 * x - e / 2, .2 * y - C / 2, e, C), g.SetTexture(l), g.Rect(c)), h && (C = e = Math.min(.395 * y, .95 * x), c.setWH(.5 * x - e / 2, .485 * y - C / 2, e, C), g.SetTexture(h), g.Rect(c)), m && (e =
                1.5 * d.clamp(.22 * y, 105, .6 * x), C = e / 8, c.setWH(.5 * x - e / 2, .868 * y - C / 2, e, C), g.SetTexture(m), g.Rect(c))) : (g.SetColorRgba(.302 * u, .334 * u, .365 * u, u), C = Math.max(.005 * y, 2), c.setWH(0, .85 * y - C / 2, x, C), g.Rect(c), e ? g.SetColorRgba(u, 0, 0, u) : g.SetColorRgba(.161 * u, .953 * u, .816 * u, u), e = x * this._loadingProgress, c.setWH(.5 * x - e / 2, .85 * y - C / 2, e, C), g.Rect(c), g.SetColorRgba(u, u, u, u), g.SetTextureFillMode(), h && (C = e = .55 * y, c.setWH(.5 * x - e / 2, .45 * y - C / 2, e, C), g.SetTexture(h), g.Rect(c)));
            this._splashFrameNumber++;
            "fade-in" === this._splashState &&
                300 <= p - this._loaderStartTime && 2 <= this._splashFrameNumber && (this._splashState = "wait", this._splashFadeInFinishTime = p);
            "wait" === this._splashState && p - this._splashFadeInFinishTime >= r && 1 <= this._loadingProgress && (this._splashState = "fade-out", this._splashFadeOutStartTime = p);
            ("fade-out" === this._splashState && p - this._splashFadeOutStartTime >= 300 + q || t && 1 <= this._loadingProgress && 500 > p - this._loaderStartTime) && this._splashDoneResolve()
        }
    }
}
var urlParams;
(window.onpopstate = function () {
    var match,
        pl     = /\+/g,  // Regex for replacing addition symbol with a space
        search = /([^&=]+)=?([^&]*)/g,
        decode = function (s) { return decodeURIComponent(s.replace(pl, " ")); },
        query  = window.location.search.substring(1);
  
    urlParams = {};
    while (match = search.exec(query))
       urlParams[decode(match[1])] = decode(match[2]);
})();
"use strict";
{
    const d = self.C3,
        b = self.C3Debugger,
        a = {
            messagePort: null,
            baseUrl: "",
            headless: !1,
            hasDom: !0,
            isInWorker: !1,
            useAudio: !0,
            projectData: "",
            exportType: ""
        };
    let f = !0;
    d.Runtime = class extends d.DefendedBase {
        constructor(c) {
            c = Object.assign({}, a, c);
            super();
            this._messagePort = c.messagePort;
            this._baseUrl = c.baseUrl;
            this._isHeadless = !!c.headless;
            this._hasDom = !!c.hasDom;
            this._isInWorker = !!c.isInWorker;
            f = c.ife;
            this._useAudio = !!c.useAudio;
            this._exportType = c.exportType;
            this._isiOSCordova = !!c.isiOSCordova;
            this._isiOSWebView = !!c.isiOSWebView;
            this._isFBInstantAvailable = !!c.isFBInstantAvailable;
            this._opusWasmScriptUrl = c.opusWasmScriptUrl;
            this._opusWasmBinaryUrl = c.opusWasmBinaryUrl;
            this._isDebugging = this._breakpointsEnabled = this._isDebug = !("preview" !== this._exportType || !c.isDebug);
            this._debuggingDisabled = 0;
            this._additionalLoadPromises = [];
            this._additionalCreatePromises = [];
            this._isUsingCreatePromises = !1;
            this._appId = this._projectUniqueId = this._projectVersion = this._projectName = "";
            this._originalViewportHeight = this._originalViewportWidth =
                0;
            this._devicePixelRatio = self.devicePixelRatio;
            this._loaderStyle = this._viewportHeight = this._viewportWidth = this._parallaxYorigin = this._parallaxXorigin = 0;
            this._usesLoaderLayout = !1;
            this._isLoading = !0;
            this._usesAnyBackgroundBlending = !1;
            this._loadingLogoAsset = null;
            this._assetManager = d.New(d.AssetManager, this, c);
            this._layoutManager = d.New(d.LayoutManager, this);
            this._eventSheetManager = d.New(d.EventSheetManager, this);
            this._pluginManager = d.New(d.PluginManager, this);
            this._collisionEngine = d.New(d.CollisionEngine,
                this);
            this._timelineManager = d.New(d.TimelineManager, this);
            this._transitionManager = d.New(d.TransitionManager, this);
            this._allObjectClasses = [];
            this._objectClassesByName = new Map;
            this._objectClassesBySid = new Map;
            this._familyCount = 0;
            this._allContainers = [];
            this._allEffectLists = [];
            this._currentLayoutStack = [];
            this._instancesPendingCreate = [];
            this._instancesPendingDestroy = new Map;
            this._isFlushingPendingInstances = this._hasPendingInstances = !1;
            this._nextUid = this._objectCount = 0;
            this._instancesByUid = new Map;
            this._instancesToReleaseAtEndOfTick =
                new Set;
            this._instancesToReleaseAffectedObjectClasses = new Set;
            this._objectReferenceTable = [];
            this._jsPropNameTable = [];
            this._canvasManager = null;
            this._framerateMode = "vsync";
            this._compositingMode = "standard";
            this._sampling = "trilinear";
            this._isPixelRoundingEnabled = !1;
            this._needRender = !0;
            this._isPausedOnBlur = this._pauseOnBlur = !1;
            this._tickCallbacks = {
                normal: e => {
                    this._ruafId = this._rafId = -1;
                    this.Tick(e)
                },
                tickOnly: e => {
                    this._ruafId = -1;
                    this.Tick(e, !1, "skip-render")
                },
                renderOnly: () => {
                    this._rafId = -1;
                    this.Render()
                }
            };
            this._ruafId = this._rafId = -1;
            this._execCount = this._tickCountNoSave = this._tickCount = 0;
            this._hasStartedTicking = this._isInTick = this._hasStarted = !1;
            this._isLayoutFirstTick = !0;
            this._suspendCount = 0;
            this._scheduleTriggersThrottle = new d.PromiseThrottle(1);
            this._randomNumberCallback = () => Math.random();
            this._dt = this._dt1 = this._lastTickTime = this._startTime = 0;
            this._timeScale = 1;
            this._minimumFramerate = 30;
            this._gameTime = d.New(d.KahanSum);
            this._wallTime = d.New(d.KahanSum);
            this._fpsFrameCount = -1;
            this._mainThreadTime =
                this._mainThreadTimeCounter = this._fps = this._fpsLastTime = 0;
            this._isLoadingState = !1;
            this._loadFromSlotName = this._saveToSlotName = "";
            this._loadFromJson = null;
            this._lastSaveJson = "";
            this._savegamesStorage = this._projectStorage = null;
            this._dispatcher = d.New(d.Event.Dispatcher);
            this._domEventHandlers = new Map;
            this._pendingResponsePromises = new Map;
            this._nextDomResponseId = 0;
            this._isReadyToHandleEvents = this._didRequestDeviceMotionEvent = this._didRequestDeviceOrientationEvent = !1;
            this._waitingToHandleEvents = [];
            this._eventObjects = {
                pretick: d.New(d.Event, "pretick", !1),
                tick: d.New(d.Event, "tick", !1),
                tick2: d.New(d.Event, "tick2", !1),
                instancedestroy: d.New(d.Event, "instancedestroy", !1),
                beforelayoutchange: d.New(d.Event, "beforelayoutchange", !1),
                layoutchange: d.New(d.Event, "layoutchange", !1)
            };
            this._eventObjects.instancedestroy.instance = null;
            this._userScriptDispatcher = d.New(d.Event.Dispatcher);
            this._userScriptEventObjects = null;
            this._behInstsToTick = d.New(d.RedBlackSet, d.BehaviorInstance.SortByTickSequence);
            this._behInstsToPostTick = d.New(d.RedBlackSet,
                d.BehaviorInstance.SortByTickSequence);
            this._behInstsToTick2 = d.New(d.RedBlackSet, d.BehaviorInstance.SortByTickSequence);
            this._jobScheduler = d.New(d.JobSchedulerRuntime, this, c.jobScheduler);
            c.canvas && (this._canvasManager = d.New(d.CanvasManager, this));
            this._messagePort.onmessage = e => this._OnMessageFromDOM(e.data);
            this.AddDOMComponentMessageHandler("runtime", "visibilitychange", e => this._OnVisibilityChange(e));
            this.AddDOMComponentMessageHandler("runtime", "opus-decode", e => this._WasmDecodeWebMOpus(e.arrayBuffer));
            this.AddDOMComponentMessageHandler("runtime", "get-remote-preview-status-info", () => this._GetRemotePreviewStatusInfo());
            this.AddDOMComponentMessageHandler("runtime", "js-invoke-function", e => this._InvokeFunctionFromJS(e));
            this.AddDOMComponentMessageHandler("runtime", "go-to-last-error-script", self.goToLastErrorScript);
            this._dispatcher.addEventListener("window-blur", e => this._OnWindowBlur(e));
            this._dispatcher.addEventListener("window-focus", () => this._OnWindowFocus());
            this._timelineManager.AddRuntimeListeners();
            this._iRuntime = null;
            this._interfaceMap = new WeakMap;
            this._commonScriptInterfaces = {
                keyboard: null,
                mouse: null,
                touch: null
            }
        }
        static Create(c) {
            return d.New(d.Runtime, c)
        }
        Release() {
            d.clearArray(this._allObjectClasses);
            this._objectClassesByName.clear();
            this._objectClassesBySid.clear();
            this._layoutManager.Release();
            this._layoutManager = null;
            this._eventSheetManager.Release();
            this._eventSheetManager = null;
            this._pluginManager.Release();
            this._pluginManager = null;
            this._assetManager.Release();
            this._assetManager = null;
            this._collisionEngine.Release();
            this._collisionEngine = null;
            this._timelineManager.Release();
            this._timelineManager = null;
            this._transitionManager.Release();
            this._transitionManager = null;
            this._canvasManager && (this._canvasManager.Release(), this._canvasManager = null);
            this._dispatcher.Release();
            this._tickEvent = this._dispatcher = null
        } ["_OnMessageFromDOM"](c) {
            const e = c.type;
            if ("event" === e) this._OnEventFromDOM(c);
            else if ("result" === e) this._OnResultFromDOM(c);
            else throw Error(`unknown message '${e}'`);
        }
        _OnEventFromDOM(c) {
            if (this._isReadyToHandleEvents) {
                var e =
                    c.component,
                    g = c.handler,
                    h = c.data,
                    l = c.dispatchOpts,
                    m = !(!l || !l.dispatchRuntimeEvent);
                l = !(!l || !l.dispatchUserScriptEvent);
                var p = c.responseId;
                if ("runtime" === e && (m && (c = new d.Event(g), c.data = h, this._dispatcher.dispatchEventAndWaitAsyncSequential(c)), l)) {
                    c = new d.Event(g, !0);
                    for (const [t, q] of Object.entries(h)) c[t] = q;
                    this.DispatchUserScriptEvent(c)
                }
                if (c = this._domEventHandlers.get(e))
                    if (c = c.get(g)) {
                        m = null;
                        try {
                            m = c(h)
                        } catch (t) {
                            console.error(`Exception in '${e}' handler '${g}':`, t);
                            null !== p && this._PostResultToDOM(p,
                                !1, "" + t);
                            return
                        }
                        null !== p && (m && m.then ? m.then(t => this._PostResultToDOM(p, !0, t)).catch(t => {
                            console.error(`Rejection from '${e}' handler '${g}':`, t);
                            this._PostResultToDOM(p, !1, "" + t)
                        }) : this._PostResultToDOM(p, !0, m))
                    } else m || l || console.warn(`[Runtime] No DOM handler '${g}' for component '${e}'`);
                else m || l || console.warn(`[Runtime] No DOM event handlers for component '${e}'`)
            } else this._waitingToHandleEvents.push(c)
        }
        _PostResultToDOM(c, e, g) {
            this._messagePort.postMessage({
                type: "result",
                responseId: c,
                isOk: e,
                result: g
            })
        }
        _OnResultFromDOM(c) {
            const e = c.responseId,
                g = c.isOk;
            c = c.result;
            const h = this._pendingResponsePromises.get(e);
            g ? h.resolve(c) : h.reject(c);
            this._pendingResponsePromises.delete(e)
        }
        AddDOMComponentMessageHandler(c, e, g) {
            let h = this._domEventHandlers.get(c);
            h || (h = new Map, this._domEventHandlers.set(c, h));
            if (h.has(e)) throw Error(`[Runtime] Component '${c}' already has handler '${e}'`);
            h.set(e, g)
        }
        PostComponentMessageToDOM(c, e, g) {
            this._messagePort.postMessage({
                type: "event",
                component: c,
                handler: e,
                data: g,
                responseId: null
            })
        }
        PostComponentMessageToDOMAsync(c, e, g) {
            const h = this._nextDomResponseId++,
                l = new Promise((m, p) => {
                    this._pendingResponsePromises.set(h, {
                        resolve: m,
                        reject: p
                    })
                });
            this._messagePort.postMessage({
                type: "event",
                component: c,
                handler: e,
                data: g,
                responseId: h
            });
            return l
        }
        PostToDebugger(c) {
            if (!this.IsDebug()) throw Error("not in debug mode");
            this.PostComponentMessageToDOM("runtime", "post-to-debugger", c)
        }
        async Init(c) {
            this.IsDebug() ? await b.Init(this) : self.C3Debugger && self.C3Debugger.InitPreview(this);
            var [e] = await Promise.all([this._assetManager.FetchJson("data.json"), this._MaybeLoadOpusDecoder(), this._jobScheduler.Init()]);
            this._LoadDataJson(e);
            await this._InitialiseCanvas(c);
            this.IsPreview() || console.info("Made with Construct 3, the game and app creator :: https://www.construct.net");
            e = this.GetWebGLRenderer();
            console.info(`[C3 runtime] Hosted in ${this.IsInWorker() ? "worker" : "DOM"}, using ${this._assetManager.GetScriptsType()} scripts, rendering with WebGL ${e.GetWebGLVersionNumber()} [${e.GetUnmaskedRenderer()}] (${e.IsDesynchronized() ?
                "desynchronized" : "standard"} compositing)`);
            e.HasMajorPerformanceCaveat() && console.warn("[C3 runtime] WebGL indicates a major performance caveat. Software rendering may be in use. This can result in significantly degraded performance.");
            this._isReadyToHandleEvents = !0;
            for (const g of this._waitingToHandleEvents) this._OnEventFromDOM(g);
            d.clearArray(this._waitingToHandleEvents);
            this._canvasManager && this._canvasManager.StartLoadingScreen();
            for (const g of c.runOnStartupFunctions) this._additionalLoadPromises.push(this._RunOnStartupFunction(g));
            await Promise.all([this._assetManager.WaitForAllToLoad(), ...this._additionalLoadPromises]);
            d.clearArray(this._additionalLoadPromises);
            if (this._assetManager.HasHadErrorLoading()) this._canvasManager && this._canvasManager.HideCordovaSplashScreen();
            else return this._canvasManager && await this._canvasManager.EndLoadingScreen(), await this._dispatcher.dispatchEventAndWaitAsync(new d.Event("beforeruntimestart")), await this.Start(), this._messagePort.postMessage({
                type: "runtime-ready"
            }), this
        }
        async _RunOnStartupFunction(c) {
            try {
                await c(this._iRuntime)
            } catch (e) {
                console.error("[C3 runtime] Error in runOnStartup function: ",
                    e)
            }
        }
        _LoadDataJson(c) {
            c = c.project;
            this._projectName = c[0];
            this._projectVersion = c[16];
            this._projectUniqueId = c[31];
            this._appId = c[38];
            const e = c[39] || "loading-logo.png";
            this._isPixelRoundingEnabled = !!c[9];
            this._originalViewportWidth = this._viewportWidth = c[10];
            this._originalViewportHeight = this._viewportHeight = c[11];
            this._parallaxXorigin = this._originalViewportWidth / 2;
            this._parallaxYorigin = this._originalViewportHeight / 2;
            this._compositingMode = c[36];
            this._framerateMode = c[37];
            "low-latency" === this._compositingMode &&
                this.IsAndroidWebView() && 77 >= d.Platform.BrowserVersionNumber && (console.warn("[C3 runtime] Desynchronized (low-latency) compositing is enabled, but is disabled in the Android WebView <=77 due to crbug.com/1008842. Reverting to synchronized (standard) compositing."), this._compositingMode = "standard");
            this._sampling = c[14];
            this._usesLoaderLayout = !!c[18];
            this._loaderStyle = c[19];
            this._nextUid = c[21];
            this._pauseOnBlur = c[22];
            const g = this._assetManager;
            g._SetAudioFiles(c[7], c[25]);
            g._SetMediaSubfolder(c[8]);
            g._SetFontsSubfolder(c[32]);
            g._SetIconsSubfolder(c[28]);
            g._SetWebFonts(c[29]);
            if (0 === this._loaderStyle) {
                let t = "";
                this.IsPreview() ? g._HasLocalUrlBlob(e) && (t = g.GetLocalUrlAsBlobUrl(e)) : t = g.GetIconsSubfolder() + e;
                t && (this._loadingLogoAsset = g.LoadImage({
                    url: t
                }))
            }
            this._canvasManager && (this._canvasManager.SetFullscreenMode(d.CanvasManager._FullscreenModeNumberToString(c[12])), this._canvasManager.SetFullscreenScalingQuality(c[23] ? "high" : "low"), this._canvasManager.SetMipmapsEnabled(0 !== c[24]), this._canvasManager._SetGPUPowerPreference(c[34]));
            this._pluginManager.CreateSystemPlugin();
            this._objectReferenceTable = self.C3_GetObjectRefTable();
            for (var h of c[2]) this._pluginManager.CreatePlugin(h);
            this._objectReferenceTable = self.C3_GetObjectRefTable();
            this._LoadJsPropNameTable();
            for (var l of c[3]) h = d.ObjectClass.Create(this, this._allObjectClasses.length, l), this._allObjectClasses.push(h), this._objectClassesByName.set(h.GetName().toLowerCase(), h), this._objectClassesBySid.set(h.GetSID(), h);
            for (const t of c[4]) this._allObjectClasses[t[0]]._LoadFamily(t);
            for (var m of c[27]) l = m.map(t => this._allObjectClasses[t]), this._allContainers.push(d.New(d.Container, this, l));
            for (const t of this._allObjectClasses) t._OnAfterCreate();
            for (const t of c[5]) this._layoutManager.Create(t);
            (m = c[1]) && (m = this._layoutManager.GetLayoutByName(m)) && this._layoutManager.SetFirstLayout(m);
            for (var p of c[33]) this._timelineManager.Create(p);
            for (const t of c[35]) this._transitionManager.Create(t);
            this._InitScriptInterfaces();
            for (const t of c[6]) this._eventSheetManager.Create(t);
            this._eventSheetManager._PostInit();
            this._InitGlobalVariableScriptInterface();
            d.clearArray(this._objectReferenceTable);
            this.FlushPendingInstances();
            p = "any";
            c = c[20];
            1 === c ? p = "portrait" : 2 === c && (p = "landscape");
            this.PostComponentMessageToDOM("runtime", "set-target-orientation", {
                targetOrientation: p
            })
        }
        GetLoaderStyle() {
            return this._loaderStyle
        }
        IsFBInstantAvailable() {
            return this._isFBInstantAvailable
        }
        IsLoading() {
            return this._isLoading
        }
        AddLoadPromise(c) {
            this._additionalLoadPromises.push(c)
        }
        SetUsingCreatePromises(c) {
            this._isUsingCreatePromises = !!c
        }
        AddCreatePromise(c) {
            this._isUsingCreatePromises && this._additionalCreatePromises.push(c)
        }
        GetCreatePromises() {
            return this._additionalCreatePromises
        }
        _GetNextFamilyIndex() {
            return this._familyCount++
        }
        GetFamilyCount() {
            return this._familyCount
        }
        _AddEffectList(c) {
            this._allEffectLists.push(c)
        }
        _GetAllEffectLists() {
            return this._allEffectLists
        }
        async _InitialiseCanvas(c) {
            this._canvasManager && (await this._canvasManager.CreateCanvas(c), this._canvasManager.InitLoadingScreen(this._loaderStyle))
        }
        async _MaybeLoadOpusDecoder() {
            if (!this._assetManager.IsAudioFormatSupported("audio/webm; codecs=opus")) {
                var c =
                    null,
                    e = null;
                try {
                    this.IsiOSCordova() && "file:" === location.protocol ? e = await this._assetManager.CordovaFetchLocalFileAsArrayBuffer(this._opusWasmBinaryUrl) : c = await this._assetManager.FetchBlob(this._opusWasmBinaryUrl)
                } catch (g) {
                    console.info("Failed to fetch Opus decoder WASM; assuming project has no Opus audio.", g);
                    return
                }
                e ? this.AddJobWorkerBuffer(e, "opus-decoder-wasm") : this.AddJobWorkerBlob(c, "opus-decoder-wasm");
                await this.AddJobWorkerScripts([this._opusWasmScriptUrl])
            }
        }
        async _WasmDecodeWebMOpus(c) {
            return await this.AddJob("OpusDecode", {
                arrayBuffer: c
            }, [c])
        }
        async Start() {
            this._hasStarted = !0;
            this._startTime = Date.now();
            if (this._usesLoaderLayout) {
                for (var c of this._allObjectClasses) c.IsFamily() || c.IsOnLoaderLayout() || !c.IsWorldType() || c.OnCreate();
                this._assetManager.WaitForAllToLoad().then(() => {
                    this._isLoading = !1;
                    this._OnLoadFinished()
                })
            } else this._isLoading = !1;
            this._assetManager.SetInitialLoadFinished();
            this.IsDebug() && b.RuntimeInit(f);
            for (const e of this._layoutManager.GetAllLayouts()) e._CreateGlobalNonWorlds();
            c = this._layoutManager.GetFirstLayout();
            await c._Load(null, this.GetWebGLRenderer());
            await c._StartRunning(!0);
            this._fpsLastTime = performance.now();
            this._usesLoaderLayout || this._OnLoadFinished();
            (await this.PostComponentMessageToDOMAsync("runtime", "before-start-ticking")).isSuspended ? this._suspendCount++ : this.Tick()
        }
        _OnLoadFinished() {
            this.Trigger(d.Plugins.System.Cnds.OnLoadFinished, null, null);
            this.PostComponentMessageToDOM("runtime", "register-sw")
        }
        GetObjectReference(c) {
            c = Math.floor(c);
            const e = this._objectReferenceTable;
            if (0 > c || c >= e.length) throw Error("invalid object reference");
            return e[c]
        }
        _LoadJsPropNameTable() {
            for (const c of self.C3_JsPropNameTable) {
                const e = d.first(Object.keys(c));
                this._jsPropNameTable.push(e)
            }
        }
        GetJsPropName(c) {
            c = Math.floor(c);
            const e = this._jsPropNameTable;
            // console.log("IDDQD " + c)
            // console.log("IDDQD " + e[c])
            if (0 > c || c >= e.length) throw Error("invalid prop reference");
            return e[c]
        }
        HasDOM() {
            return this._hasDom
        }
        IsHeadless() {
            return this._isHeadless
        }
        IsInWorker() {
            return this._isInWorker
        }
        GetBaseURL() {
            return this._baseUrl
        }
        GetEventSheetManager() {
            return this._eventSheetManager
        }
        GetEventStack() {
            return this._eventSheetManager.GetEventStack()
        }
        GetCurrentEventStackFrame() {
            return this._eventSheetManager.GetCurrentEventStackFrame()
        }
        GetCurrentEvent() {
            return this._eventSheetManager.GetCurrentEvent()
        }
        GetCurrentCondition() {
            return this._eventSheetManager.GetCurrentCondition()
        }
        IsCurrentConditionFirst() {
            return 0 ===
                this.GetCurrentEventStackFrame().GetConditionIndex()
        }
        GetCurrentAction() {
            // console.log("IDDQD GetCurrentAction " + this._eventSheetManager.GetCurrentAction())
            return this._eventSheetManager.GetCurrentAction()
        }
        GetPluginManager() {
            return this._pluginManager
        }
        GetSystemPlugin() {
            return this._pluginManager.GetSystemPlugin()
        }
        GetObjectClassByIndex(c) {
            c = Math.floor(c);
            if (0 > c || c >= this._allObjectClasses.length) throw new RangeError("invalid index");
            return this._allObjectClasses[c]
        }
        GetObjectClassByName(c) {
            return this._objectClassesByName.get(c.toLowerCase()) || null
        }
        GetObjectClassBySID(c) {
            return this._objectClassesBySid.get(c) ||
                null
        }
        GetSingleGlobalObjectClassByCtor(c) {
            return (c = this._pluginManager.GetPluginByConstructorFunction(c)) ? c.GetSingleGlobalObjectClass() : null
        }
        GetAllObjectClasses() {
            return this._allObjectClasses
        }* allInstances() {
            for (const c of this._allObjectClasses) c.IsFamily() || (yield* c.instances())
        }
        Dispatcher() {
            return this._dispatcher
        }
        UserScriptDispatcher() {
            return this._userScriptDispatcher
        }
        DispatchUserScriptEvent(c) {
            c.runtime = this.GetIRuntime();
            const e = this.IsDebug() && !this._eventSheetManager.IsInEventEngine();
            e &&
                b.StartMeasuringScriptTime();
            this._userScriptDispatcher.dispatchEvent(c);
            e && b.AddScriptTime()
        }
        DispatchUserScriptEventAsyncWait(c) {
            c.runtime = this.GetIRuntime();
            return this._userScriptDispatcher.dispatchEventAndWaitAsync(c)
        }
        GetOriginalViewportWidth() {
            return this._originalViewportWidth
        }
        GetOriginalViewportHeight() {
            return this._originalViewportHeight
        }
        SetOriginalViewportSize(c, e) {
            this._originalViewportWidth = c;
            this._originalViewportHeight = e
        }
        GetViewportWidth() {
            return this._viewportWidth
        }
        GetViewportHeight() {
            return this._viewportHeight
        }
        SetViewportSize(c,
            e) {
            this._viewportWidth = c;
            this._viewportHeight = e
        }
        _SetDevicePixelRatio(c) {
            this._devicePixelRatio = c
        }
        GetDevicePixelRatio() {
            return this._devicePixelRatio
        }
        GetParallaxXOrigin() {
            return this._parallaxXorigin
        }
        GetParallaxYOrigin() {
            return this._parallaxYorigin
        }
        GetCanvasManager() {
            return this._canvasManager
        }
        GetDrawWidth() {
            return this._canvasManager ? this._canvasManager.GetDrawWidth() : this._viewportWidth
        }
        GetDrawHeight() {
            return this._canvasManager ? this._canvasManager.GetDrawHeight() : this._viewportHeight
        }
        GetRenderScale() {
            return this._canvasManager ?
                this._canvasManager.GetRenderScale() : 1
        }
        GetDisplayScale() {
            return this._canvasManager ? this._canvasManager.GetDisplayScale() : 1
        }
        GetCanvasClientX() {
            return this._canvasManager ? this._canvasManager.GetCanvasClientX() : 0
        }
        GetCanvasClientY() {
            return this._canvasManager ? this._canvasManager.GetCanvasClientY() : 0
        }
        GetCanvasCssWidth() {
            return this._canvasManager ? this._canvasManager.GetCssWidth() : 0
        }
        GetCanvasCssHeight() {
            return this._canvasManager ? this._canvasManager.GetCssHeight() : 0
        }
        GetFullscreenMode() {
            return this._canvasManager ?
                this._canvasManager.GetFullscreenMode() : "off"
        }
        GetAdditionalRenderTarget(c) {
            return this._canvasManager ? this._canvasManager.GetAdditionalRenderTarget(c) : null
        }
        ReleaseAdditionalRenderTarget(c) {
            this._canvasManager && this._canvasManager.ReleaseAdditionalRenderTarget(c)
        }
        _SetUsesAnyBackgroundBlending(c) {
            this._usesAnyBackgroundBlending = !!c
        }
        UsesAnyBackgroundBlending() {
            return this._usesAnyBackgroundBlending
        }
        GetGPUUtilisation() {
            return this._canvasManager ? this._canvasManager.GetGPUUtilisation() : NaN
        }
        IsLinearSampling() {
            return "nearest" !==
                this.GetSampling()
        }
        GetFramerateMode() {
            return this._framerateMode
        }
        GetCompositingMode() {
            return this._compositingMode
        }
        GetSampling() {
            return this._sampling
        }
        UsesLoaderLayout() {
            return this._usesLoaderLayout
        }
        GetLoadingLogoAsset() {
            return this._loadingLogoAsset
        }
        ReleaseLoadingLogoAsset() {
            this._loadingLogoAsset && (this._loadingLogoAsset.Release(), this._loadingLogoAsset = null)
        }
        GetLayoutManager() {
            return this._layoutManager
        }
        GetMainRunningLayout() {
            return this._layoutManager.GetMainRunningLayout()
        }
        GetTimelineManager() {
            return this._timelineManager
        }
        GetTransitionManager() {
            return this._transitionManager
        }
        GetAssetManager() {
            return this._assetManager
        }
        LoadImage(c) {
            return this._assetManager.LoadImage(c)
        }
        CreateInstance(c,
            e, g, h, l) {
            return this.CreateInstanceFromData(c, e, !1, g, h, !1, l)
        }
        CreateInstanceFromData(c, e, g, h, l, m, p) {
            var t = null;
            let q = null;
            if (c instanceof d.ObjectClass) {
                q = c;
                if (q.IsFamily()) {
                    c = q.GetFamilyMembers();
                    var r = Math.floor(this.Random() * c.length);
                    q = c[r]
                }
                t = q.GetDefaultInstanceData()
            } else t = c, q = this.GetObjectClassByIndex(t[1]);
            var u = q.GetPlugin().IsWorldType();
            if (this._isLoading && u && !q.IsOnLoaderLayout()) return null;
            const x = e;
            u || (e = null);
            var y = g && !m && t && !this._instancesByUid.has(t[2]) ? t[2] : this._nextUid++;
            r =
                t ? t[0] : null;
            c = d.New(d.Instance, {
                runtime: this,
                objectType: q,
                layer: e,
                worldData: r,
                instVarData: t ? t[3] : null,
                uid: y
            });
            this._instancesByUid.set(y, c);
            y = null;
            u && (y = c.GetWorldInfo(), "undefined" !== typeof h && "undefined" !== typeof l && (y.SetX(h), y.SetY(l)), q._SetAnyCollisionCellChanged(!0));
            e && (p || e._AddInstance(c, !0), 1 === e.GetParallaxX() && 1 === e.GetParallaxY() || q._SetAnyInstanceParallaxed(!0), e.GetLayout().MaybeLoadTexturesFor(q));
            this._objectCount++;
            if (q.IsInContainer() && !g && !m) {
                for (var C of q.GetContainer().objectTypes()) {
                    if (C ===
                        q) continue;
                    const w = this.CreateInstanceFromData(C, x, !1, y ? y.GetX() : h, y ? y.GetY() : l, !0, !1);
                    c._AddSibling(w)
                }
                for (const w of c.siblings()) {
                    w._AddSibling(c);
                    for (const A of c.siblings()) w !== A && w._AddSibling(A)
                }
            }
            u && !g && p && this._CreateChildInstancesFromData(c, r, y, e, h, l);
            if (q.IsInContainer() && !g && !m && p)
                for (const w of c.siblings()) g = w.GetWorldInfo(), C = w.GetObjectClass().GetDefaultInstanceData()[0], this._CreateChildInstancesFromData(w, C, g, e, g.GetX(), g.GetY());
            !m && p && ("undefined" === typeof h && (h = r[0]), "undefined" ===
                typeof l && (l = r[1]), e = y.GetTopParent(), h = h - y.GetX() + e.GetX(), l = l - y.GetY() + e.GetY(), e.SetXY(h, l));
            q._SetIIDsStale();
            l = t ? d.cloneArray(t[5]) : null;
            t = t ? t[4].map(w => d.cloneArray(w)) : null;
            (u = u && r && r[13]) && c._SetHasTilemap();
            c._CreateSdkInstance(l, t);
            u && (r = r[13], c.GetSdkInstance().LoadTilemapData(r[2], r[0], r[1]));
            this._instancesPendingCreate.push(c);
            this._hasPendingInstances = !0;
            this.IsDebug() && b.InstanceCreated(c);
            return c
        }
        _CreateChildInstancesFromData(c, e, g, h, l, m) {
            var p = g.GetSceneGraphZIndexExportData(),
                t = g.GetSceneGraphChildrenExportData();
            c.GetWorldInfo().SetSceneGraphZIndex(p);
            if (t) {
                "undefined" === typeof l && (l = e[0]);
                "undefined" === typeof m && (m = e[1]);
                p = new Set;
                g = e[0];
                e = e[1];
                for (const y of t) {
                    var q = y[1],
                        r = y[2];
                    t = y[3];
                    var u = !!y[4];
                    const C = y[5];
                    r = this._layoutManager.GetLayoutBySID(y[0]).GetLayer(q).GetInitialInstanceData(r);
                    q = this.GetObjectClassByIndex(r[1]);
                    var x = c.HasSibling(q);
                    const w = p.has(q);
                    x && !w && u ? (u = c.GetSibling(q), x = l + r[0][0] - g, r = m + r[0][1] - e, u.GetWorldInfo().SetXY(x, r), u.GetWorldInfo().SetSceneGraphZIndex(C),
                        c.AddChild(u, {
                            transformX: !!(t >> 0 & 1),
                            transformY: !!(t >> 1 & 1),
                            transformWidth: !!(t >> 2 & 1),
                            transformHeight: !!(t >> 3 & 1),
                            transformAngle: !!(t >> 4 & 1),
                            destroyWithParent: !!(t >> 5 & 1),
                            transformZElevation: !!(t >> 6 & 1)
                        }), p.add(q)) : (q = this.CreateInstanceFromData(r, h, !1, l + r[0][0] - g, m + r[0][1] - e, !1, !0), q.GetWorldInfo().SetSceneGraphZIndex(C), c.AddChild(q, {
                        transformX: !!(t >> 0 & 1),
                        transformY: !!(t >> 1 & 1),
                        transformWidth: !!(t >> 2 & 1),
                        transformHeight: !!(t >> 3 & 1),
                        transformAngle: !!(t >> 4 & 1),
                        destroyWithParent: !!(t >> 5 & 1),
                        transformZElevation: !!(t >>
                            6 & 1)
                    }))
                }
            }
        }
        DestroyInstance(c) {
            if (!this._instancesToReleaseAtEndOfTick.has(c)) {
                var e = c.GetObjectClass(),
                    g = this._instancesPendingDestroy.get(e);
                if (g) {
                    if (g.has(c)) return;
                    g.add(c)
                } else g = new Set, g.add(c), this._instancesPendingDestroy.set(e, g);
                this.IsDebug() && b.InstanceDestroyed(c);
                c._MarkDestroyed();
                this._hasPendingInstances = !0;
                if (c.IsInContainer())
                    for (const h of c.siblings()) this.DestroyInstance(h);
                for (const h of c.children()) h.GetDestroyWithParent() && this.DestroyInstance(h);
                this._layoutManager.IsEndingLayout() ||
                    this._isLoadingState || (e = this.GetEventSheetManager(), e.BlockFlushingInstances(!0), c._TriggerOnDestroyed(), e.BlockFlushingInstances(!1));
                c._FireDestroyedScriptEvents(this._layoutManager.IsEndingLayout())
            }
        }
        FlushPendingInstances() {
            this._hasPendingInstances && (this._isFlushingPendingInstances = !0, this._FlushInstancesPendingCreate(), this._FlushInstancesPendingDestroy(), this._hasPendingInstances = this._isFlushingPendingInstances = !1, this.UpdateRender())
        }
        _FlushInstancesPendingCreate() {
            for (const c of this._instancesPendingCreate) {
                const e =
                    c.GetObjectClass();
                e._AddInstance(c);
                for (const g of e.GetFamilies()) g._AddInstance(c), g._SetIIDsStale()
            }
            d.clearArray(this._instancesPendingCreate)
        }
        _FlushInstancesPendingDestroy() {
            this._dispatcher.SetDelayRemoveEventsEnabled(!0);
            for (const [c, e] of this._instancesPendingDestroy.entries()) this._FlushInstancesPendingDestroyForObjectClass(c, e), e.clear();
            this._instancesPendingDestroy.clear();
            this._dispatcher.SetDelayRemoveEventsEnabled(!1)
        }
        _FlushInstancesPendingDestroyForObjectClass(c, e) {
            for (const h of e) {
                var g =
                    this._eventObjects.instancedestroy;
                g.instance = h;
                this._dispatcher.dispatchEvent(g);
                this._instancesByUid.delete(h.GetUID());
                if (g = h.GetWorldInfo()) g._RemoveFromCollisionCells(), g._RemoveFromRenderCells(), g._MarkDestroyed();
                this._instancesToReleaseAtEndOfTick.add(h);
                this._objectCount--
            }
            d.arrayRemoveAllInSet(c.GetInstances(), e);
            c._SetIIDsStale();
            this._instancesToReleaseAffectedObjectClasses.add(c);
            0 === c.GetInstances().length && c._SetAnyInstanceParallaxed(!1);
            for (const h of c.GetFamilies()) d.arrayRemoveAllInSet(h.GetInstances(),
                e), h._SetIIDsStale(), this._instancesToReleaseAffectedObjectClasses.add(h);
            if (c.GetPlugin().IsWorldType()) {
                c = new Set([...e].map(h => h.GetWorldInfo().GetLayer()));
                for (const h of c) h._RemoveAllInstancesInSet(e)
            }
        }
        _GetInstancesPendingCreate() {
            return this._instancesPendingCreate
        }
        _GetNewUID() {
            return this._nextUid++
        }
        _MapInstanceByUID(c, e) {
            this._instancesByUid.set(c, e)
        }
        _OnWebGLContextLost() {
            this._dispatcher.dispatchEvent(d.New(d.Event, "webglcontextlost"));
            this.SetSuspended(!0);
            for (var c of this._allObjectClasses) !c.IsFamily() &&
                c.HasLoadedTextures() && c.ReleaseTextures();
            (c = this.GetMainRunningLayout()) && c._OnWebGLContextLost();
            d.ImageInfo.OnWebGLContextLost();
            d.ImageAsset.OnWebGLContextLost()
        }
        async _OnWebGLContextRestored() {
            await this.GetMainRunningLayout()._Load(null, this.GetWebGLRenderer());
            this._dispatcher.dispatchEvent(d.New(d.Event, "webglcontextrestored"));
            this.SetSuspended(!1);
            this.UpdateRender()
        }
        _OnVisibilityChange(c) {
            this.SetSuspended(c.hidden)
        }
        _OnWindowBlur(c) {
            this.IsPreview() && this._pauseOnBlur && !d.Platform.IsMobile &&
                !c.data.parentHasFocus && (this.SetSuspended(!0), this._isPausedOnBlur = !0)
        }
        _OnWindowFocus() {
            this._isPausedOnBlur && (this.SetSuspended(!1), this._isPausedOnBlur = !1)
        }
        _RequestAnimationFrame() {
            const c = this._tickCallbacks;
            "vsync" === this._framerateMode ? -1 === this._rafId && (this._rafId = d.RequestPostAnimationFrame(c.normal)) : "unlimited-tick" === this._framerateMode ? (-1 === this._ruafId && (this._ruafId = d.RequestUnlimitedAnimationFrame(c.tickOnly)), -1 === this._rafId && (this._rafId = d.RequestPostAnimationFrame(c.renderOnly))) :
                -1 === this._ruafId && (this._ruafId = d.RequestUnlimitedAnimationFrame(c.normal))
        }
        _CancelAnimationFrame() {
            -1 !== this._rafId && (d.CancelPostAnimationFrame(this._rafId), this._rafId = -1); - 1 !== this._ruafId && (d.CancelUnlimitedAnimationFrame(this._ruafId), this._ruafId = -1)
        }
        IsSuspended() {
            return 0 < this._suspendCount
        }
        SetSuspended(c) {
            var e = this.IsSuspended();
            this._suspendCount += c ? 1 : -1;
            0 > this._suspendCount && (this._suspendCount = 0);
            c = this.IsSuspended();
            !e && c ? (console.log("[Construct 3] Suspending"), this._CancelAnimationFrame(),
                this._dispatcher.dispatchEvent(d.New(d.Event, "suspend")), this.Trigger(d.Plugins.System.Cnds.OnSuspend, null, null)) : e && !c && (console.log("[Construct 3] Resuming"), this._fpsLastTime = this._lastTickTime = e = performance.now(), this._mainThreadTimeCounter = this._mainThreadTime = this._fps = this._fpsFrameCount = 0, this._dispatcher.dispatchEvent(d.New(d.Event, "resume")), this.Trigger(d.Plugins.System.Cnds.OnResume, null, null), this.HitBreakpoint() || this.Tick(e))
        }
        _AddBehInstToTick(c) {
            this._behInstsToTick.Add(c)
        }
        _AddBehInstToPostTick(c) {
            this._behInstsToPostTick.Add(c)
        }
        _AddBehInstToTick2(c) {
            this._behInstsToTick2.Add(c)
        }
        _RemoveBehInstToTick(c) {
            this._behInstsToTick.Remove(c)
        }
        _RemoveBehInstToPostTick(c) {
            this._behInstsToPostTick.Remove(c)
        }
        _RemoveBehInstToTick2(c) {
            this._behInstsToTick2.Remove(c)
        }
        _BehaviorTick() {
            this._behInstsToTick.SetQueueingEnabled(!0);
            for (const c of this._behInstsToTick) c.Tick();
            this._behInstsToTick.SetQueueingEnabled(!1)
        }
        _BehaviorPostTick() {
            this._behInstsToPostTick.SetQueueingEnabled(!0);
            for (const c of this._behInstsToPostTick) c.PostTick();
            this._behInstsToPostTick.SetQueueingEnabled(!1)
        }
        _BehaviorTick2() {
            this._behInstsToTick2.SetQueueingEnabled(!0);
            for (const c of this._behInstsToTick2) c.Tick2();
            this._behInstsToTick2.SetQueueingEnabled(!1)
        }* _DebugBehaviorTick() {
            this._behInstsToTick.SetQueueingEnabled(!0);
            for (const c of this._behInstsToTick) {
                const e =
                    c.Tick();
                d.IsIterator(e) && (yield* e)
            }
            this._behInstsToTick.SetQueueingEnabled(!1)
        }* _DebugBehaviorPostTick() {
            this._behInstsToPostTick.SetQueueingEnabled(!0);
            for (const c of this._behInstsToPostTick) {
                const e = c.PostTick();
                d.IsIterator(e) && (yield* e)
            }
            this._behInstsToPostTick.SetQueueingEnabled(!1)
        }* _DebugBehaviorTick2() {
            this._behInstsToTick2.SetQueueingEnabled(!0);
            for (const c of this._behInstsToTick2) {
                const e = c.Tick2();
                d.IsIterator(e) && (yield* e)
            }
            this._behInstsToTick2.SetQueueingEnabled(!1)
        }
        async Tick(c, e,
            g) {
            this._hasStartedTicking = !0;
            const h = "background-wake" === g;
            g = "background-wake" !== g && "skip-render" !== g;
            this._hasStarted && (!this.IsSuspended() || e || h) && (e = performance.now(), this._isInTick = !0, c || (c = e), this._MeasureDt(c), c = this.Step_BeforePreTick(), this.IsDebugging() && await c, c = this._dispatcher.dispatchEventAndWait_AsyncOptional(this._eventObjects.pretick), c instanceof Promise && await c, c = this.Step_AfterPreTick(), this.IsDebugging() && await c, this._NeedsHandleSaveOrLoad() && await this._HandleSaveOrLoad(),
                this.GetLayoutManager().IsPendingChangeMainLayout() && await this._MaybeChangeLayout(), c = this.Step_RunEventsEtc(), this.IsDebugging() && await c, g && this.Render(), this.IsSuspended() || h || this._RequestAnimationFrame(), this._tickCount++, this._tickCountNoSave++, this._execCount++, this._isInTick = !1, this._mainThreadTimeCounter += performance.now() - e)
        }
        async Step_BeforePreTick() {
            const c = this._eventSheetManager,
                e = this.IsDebug();
            this.FlushPendingInstances();
            c.BlockFlushingInstances(!0);
            this.PushCurrentLayout(this.GetMainRunningLayout());
            e && b.StartMeasuringTime();
            this.IsDebugging() ? await c.DebugRunScheduledWaits() : c.RunScheduledWaits();
            e && b.AddEventsTime();
            this.PopCurrentLayout();
            c.BlockFlushingInstances(!1);
            this.FlushPendingInstances();
            c.BlockFlushingInstances(!0)
        }
        async Step_AfterPreTick() {
            const c = this.IsDebug(),
                e = this.IsDebugging(),
                g = this._dispatcher,
                h = this._eventObjects,
                l = this._userScriptEventObjects;
            c && b.StartMeasuringTime();
            e ? await this.DebugIterateAndBreak(this._DebugBehaviorTick()) : this._BehaviorTick();
            e ? await this.DebugIterateAndBreak(this._DebugBehaviorPostTick()) :
                this._BehaviorPostTick();
            c && b.AddBehaviorTickTime();
            c && b.StartMeasuringTime();
            e ? await this.DebugFireGeneratorEventAndBreak(h.tick) : g.dispatchEvent(h.tick);
            c && b.AddPluginTickTime();
            this._eventSheetManager.BlockFlushingInstances(!1);
            this.DispatchUserScriptEvent(l.tick)
        }
        async Step_RunEventsEtc() {
            const c = this._eventSheetManager,
                e = this._dispatcher,
                g = this._eventObjects,
                h = this.IsDebug(),
                l = this.IsDebugging();
            h && b.StartMeasuringTime();
            l ? await c.DebugRunEvents(this._layoutManager) : c.RunEvents(this._layoutManager);
            h && b.AddEventsTime();
            this._collisionEngine.ClearRegisteredCollisions();
            this._ReleaseInstancesAtEndOfTick();
            this._isLayoutFirstTick = !1;
            c.BlockFlushingInstances(!0);
            h && b.StartMeasuringTime();
            l ? await this.DebugIterateAndBreak(this._DebugBehaviorTick2()) : this._BehaviorTick2();
            h && b.AddBehaviorTickTime();
            h && b.StartMeasuringTime();
            l ? await this.DebugFireGeneratorEventAndBreak(g.tick2) : e.dispatchEvent(g.tick2);
            h && b.AddPluginTickTime();
            c.BlockFlushingInstances(!1);
            l && await c.RunQueuedDebugTriggersAsync()
        }
        _ReleaseInstancesAtEndOfTick() {
            if (0 !==
                this._instancesToReleaseAtEndOfTick.size) {
                var c = this._dispatcher;
                c.SetDelayRemoveEventsEnabled(!0);
                for (const e of this._instancesToReleaseAffectedObjectClasses) e.GetSolStack().RemoveInstances(this._instancesToReleaseAtEndOfTick);
                this._instancesToReleaseAffectedObjectClasses.clear();
                this._eventSheetManager.RemoveInstancesFromScheduledWaits(this._instancesToReleaseAtEndOfTick);
                for (const e of this._instancesToReleaseAtEndOfTick) e.Release();
                this._instancesToReleaseAtEndOfTick.clear();
                c.SetDelayRemoveEventsEnabled(!1)
            }
        }
        async _MaybeChangeLayout() {
            const c =
                this.GetLayoutManager();
            let e = 0;
            for (; c.IsPendingChangeMainLayout() && 10 > e++;) await this._DoChangeLayout(c.GetPendingChangeMainLayout())
        }
        _MeasureDt(c) {
            if (0 !== this._lastTickTime) {
                this._dt1 = Math.max(c - this._lastTickTime, 0) / 1E3;
                const e = 1 / this._minimumFramerate;
                .5 < this._dt1 ? this._dt1 = 0 : this._dt1 > e && (this._dt1 = e)
            }
            this._lastTickTime = c;
            this._dt = this._dt1 * this._timeScale;
            this._gameTime.Add(this._dt);
            this._wallTime.Add(this._dt1);
            this._canvasManager && this._canvasManager._UpdateTick();
            1E3 <= c - this._fpsLastTime &&
                (this._fpsLastTime += 1E3, 1E3 <= c - this._fpsLastTime && (this._fpsLastTime = c), this._fps = this._fpsFrameCount, this._fpsFrameCount = 0, this._mainThreadTime = Math.min(this._mainThreadTimeCounter / 1E3, 1), this._mainThreadTimeCounter = 0, this._canvasManager && this._canvasManager._Update1sFrameRange(), this._collisionEngine._Update1sStats(), this.IsDebug() && b.Update1sPerfStats());
            this._fpsFrameCount++
        }
        async _DoChangeLayout(c) {
            // var gss = await this._SaveToJsonString();
            // console.log("IDDQD _DoChangeLayout " + gss)
            // console.log("IDDQD " + gss["events"]["vars"]["7916911569938776"])
            const e = this._dispatcher,
                g = this.GetLayoutManager().GetMainRunningLayout();
            await g._StopRunning();
            g._Unload(c, this.GetWebGLRenderer());
            g === c && this._eventSheetManager.ClearAllScheduledWaits();
            this._collisionEngine.ClearRegisteredCollisions();
            this._ReleaseInstancesAtEndOfTick();
            e.dispatchEvent(this._eventObjects.beforelayoutchange);
            d.Asyncify.SetHighThroughputMode(!0);
            await c._Load(g, this.GetWebGLRenderer());
            d.Asyncify.SetHighThroughputMode(!1);
            await c._StartRunning(!1);
            e.dispatchEvent(this._eventObjects.layoutchange);
            this.UpdateRender();
            this._isLayoutFirstTick = !0;
            this.FlushPendingInstances()
        }
        UpdateRender() {
            this._needRender = !0
        }
        GetWebGLRenderer() {
            return this._canvasManager ? this._canvasManager.GetWebGLRenderer() : null
        }
        GetRenderer() {
            return this.GetWebGLRenderer()
        }
        Render() {
            if (this._canvasManager && !this._canvasManager.IsWebGLContextLost()) {
                var c = this.GetWebGLRenderer();
                c.Start();
                c.CheckForQueryResults();
                if (this._needRender) {
                    var e = this.IsDebug();
                    e && b.StartMeasuringTime();
                    this._needRender = !1;
                    var g = null;
                    c.SupportsGPUProfiling() && (g = this._canvasManager.GetGPUFrameTimingsBuffer().AddTimeElapsedQuery(), c.StartQuery(g));
                    c.SetTextureFillMode();
                    c.SetAlphaBlend();
                    c.SetColorRgba(1, 1, 1, 1);
                    c.SetRenderTarget(null);
                    c.SetTexture(null);
                    this._layoutManager.GetMainRunningLayout().Draw(c);
                    g && c.EndQuery(g);
                    c.Finish();
                    e && (b.AddDrawCallsTime(), b.UpdateInspectHighlight());
                    this._canvasManager && this._canvasManager._MaybeTakeSnapshot()
                } else c.IncrementFrameNumber()
            }
        }
        Trigger(c, e, g) {
            if (!this._hasStarted) return !1;
            var h = !this._isInTick && !this._eventSheetManager.IsInTrigger();
            let l = 0;
            h && (l = performance.now());
            const m = this.IsDebug();
            m && this.SetDebuggingEnabled(!1);
            c = this._eventSheetManager._Trigger(this._layoutManager, c, e, g);
            h && (h = performance.now() - l, this._mainThreadTimeCounter += h, m && b.AddTriggersTime(h));
            m && this.SetDebuggingEnabled(!0);
            return c
        }
        DebugTrigger(c, e, g) {
            if (!this.IsDebug()) return this.Trigger(c, e, g);
            if (this.HitBreakpoint()) throw Error("called DebugTrigger() while stopped on breakpoint");
            if (!this._isInTick && !this._eventSheetManager.IsInTrigger()) throw Error("called DebugTrigger() outside of event code - use TriggerAsync() instead");
            return this._eventSheetManager._DebugTrigger(this._layoutManager,
                c, e, g)
        }
        async TriggerAsync(c, e, g) {
            if (!this.IsDebugging()) return this.Trigger(c, e, g);
            if (!this._hasStarted) return !1;
            if (this.HitBreakpoint()) return this._eventSheetManager.QueueDebugTrigger(c, e, g);
            if (!this.GetMainRunningLayout()) return this._eventSheetManager.QueueTrigger(c, e, g);
            const h = performance.now();
            c = this._eventSheetManager._DebugTrigger(this._layoutManager, c, e, g);
            for (e = c.next(); !e.done;) await this.DebugBreak(e.value), e = c.next();
            this.IsSuspended() || this._eventSheetManager.IsInTrigger() || (await this._eventSheetManager.RunQueuedDebugTriggersAsync(),
                this._hasStartedTicking && !this._isInTick && this._RequestAnimationFrame());
            this._mainThreadTimeCounter += performance.now() - h;
            return e.value
        }
        FastTrigger(c, e, g) {
            const h = this.IsDebug();
            h && this.SetDebuggingEnabled(!1);
            c = this._eventSheetManager._FastTrigger(this._layoutManager, c, e, g);
            h && this.SetDebuggingEnabled(!0);
            return c
        }
        DebugFastTrigger(c, e, g) {
            return this._eventSheetManager._DebugFastTrigger(this._layoutManager, c, e, g)
        }
        ScheduleTriggers(c) {
            return this._scheduleTriggersThrottle.Add(c)
        }
        PushCurrentLayout(c) {
            this._currentLayoutStack.push(c)
        }
        PopCurrentLayout() {
            if (!this._currentLayoutStack.length) throw Error("layout stack empty");
            this._currentLayoutStack.pop()
        }
        GetCurrentLayout() {
            return this._currentLayoutStack.length ? this._currentLayoutStack[this._currentLayoutStack.length - 1] : this.GetMainRunningLayout()
        }
        GetDt(c) {
            return c && -1 !== c.GetTimeScale() ? this._dt1 * c.GetTimeScale() : this._dt
        }
        _GetDtFast() {
            return this._dt
        }
        GetDt1() {
            return this._dt1
        }
        GetTimeScale() {
            return this._timeScale
        }
        SetTimeScale(c) {
            if (isNaN(c) || 0 > c) c = 0;
            this._timeScale = c
        }
        SetMinimumFramerate(c) {
            this._minimumFramerate = d.clamp(c, 1, 120)
        }
        GetMinimumFramerate() {
            return this._minimumFramerate
        }
        GetFPS() {
            return this._fps
        }
        GetMainThreadTime() {
            return this._mainThreadTime
        }
        GetStartTime() {
            return this._startTime
        }
        GetGameTime() {
            return this._gameTime.Get()
        }
        GetWallTime() {
            return this._wallTime.Get()
        }
        GetTickCount() {
            return this._tickCount
        }
        GetTickCountNoSave() {
            return this._tickCountNoSave
        }
        IncrementExecCount() {
            ++this._execCount
        }
        GetExecCount() {
            return this._execCount
        }
        GetObjectCount() {
            return this._objectCount
        }
        GetProjectName() {
            return this._projectName
        }
        GetProjectVersion() {
            return this._projectVersion
        }
        GetProjectUniqueId() {
            return this._projectUniqueId
        }
        GetAppId() {
            return this._appId
        }
        GetInstanceByUID(c) {
            if (this._isLoadingState) throw Error("cannot call while loading state - wait until afterload event");
            return this._instancesByUid.get(c) || null
        }
        _RefreshUidMap() {
            this._instancesByUid.clear();
            for (const c of this._allObjectClasses)
                if (!c.IsFamily())
                    for (const e of c.GetInstances()) this._instancesByUid.set(e.GetUID(), e)
        }
        IsPreview() {
            return "preview" === this._exportType
        }
        IsDebug() {
            return this._isDebug
        }
        GetExportType() {
            return this._exportType
        }
        IsCordova() {
            return "cordova" === this._exportType
        }
        IsAndroidWebView() {
            return "Android" === d.Platform.OS && ("cordova" === this._exportType || "playable-ad" === this._exportType || "instant-games" ===
                this._exportType)
        }
        IsiOSCordova() {
            return this._isiOSCordova
        }
        IsiOSWebView() {
            return this._isiOSWebView
        }
        GetCollisionEngine() {
            return this._collisionEngine
        }
        GetSolidBehavior() {
            return this._pluginManager.GetSolidBehavior()
        }
        GetJumpthruBehavior() {
            return this._pluginManager.GetJumpthruBehavior()
        }
        IsLayoutFirstTick() {
            return this._isLayoutFirstTick
        }
        SetPixelRoundingEnabled(c) {
            c = !!c;
            this._isPixelRoundingEnabled !== c && (this._isPixelRoundingEnabled = c, this.UpdateRender())
        }
        IsPixelRoundingEnabled() {
            return this._isPixelRoundingEnabled
        }
        SaveToSlot(c) {
            this._saveToSlotName =
                c
        }
        LoadFromSlot(c) {
            this._loadFromSlotName = c
        }
        LoadFromJsonString(c) {
            this._loadFromJson = c
        }
        GetLastSaveJsonString() {
            return this._lastSaveJson
        }
        _NeedsHandleSaveOrLoad() {
            return true
        }
        async _HandleSaveOrLoad() {
            this._saveToSlotName && (this.FlushPendingInstances(), await this._DoSaveToSlot(this._saveToSlotName), this._ClearSaveOrLoad());
            this._loadFromSlotName && (await this._DoLoadFromSlot(this._loadFromSlotName), this._ClearSaveOrLoad(), this.IsDebug() &&
                b.StepIfPausedInDebugger());
            if (null !== this._loadFromJson) {
                this.FlushPendingInstances();
                try {
                    await this._DoLoadFromJsonString(this._loadFromJson), this._lastSaveJson = this._loadFromJson, await this.TriggerAsync(d.Plugins.System.Cnds.OnLoadComplete, null), this._lastSaveJson = ""
                } catch (c) {
                    console.error("[Construct 3] Failed to load state from JSON string: ", c), await this.TriggerAsync(d.Plugins.System.Cnds.OnLoadFailed, null)
                }
                this._ClearSaveOrLoad()
            }
        }
        _ClearSaveOrLoad() {
            this._loadFromSlotName = this._saveToSlotName =
                "";
            this._loadFromJson = null
        }
        _GetProjectStorage() {
            this._projectStorage || (this._projectStorage = localforage.createInstance({
                name: "c3-localstorage-" + this.GetProjectUniqueId(),
                description: this.GetProjectName()
            }));
            return this._projectStorage
        }
        _GetSavegamesStorage() {
            this._savegamesStorage || (this._savegamesStorage = localforage.createInstance({
                name: "c3-savegames-" + this.GetProjectUniqueId(),
                description: this.GetProjectName()
            }));
            return this._savegamesStorage
        }
        async _DoSaveToSlot(c) {
            const e = await this._SaveToJsonString();
            try {
                await this._GetSavegamesStorage().setItem(c, e), console.log("[Construct 3] Saved state to storage (" + e.length + " chars)"), this._lastSaveJson = e, await this.TriggerAsync(d.Plugins.System.Cnds.OnSaveComplete, null), this._lastSaveJson = ""
            } catch (g) {
                console.error("[Construct 3] Failed to save state to storage: ", g), await this.TriggerAsync(d.Plugins.System.Cnds.OnSaveFailed, null)
            }
        }
        async _DoLoadFromSlot(c) {
            try {
                const e = await this._GetSavegamesStorage().getItem(c);
                if (!e) throw Error("empty slot");
                console.log("[Construct 3] Loaded state from storage (" +
                    e.length + " chars)");
                await this._DoLoadFromJsonString(e);
                this._lastSaveJson = e;
                await this.TriggerAsync(d.Plugins.System.Cnds.OnLoadComplete, null);
                this._lastSaveJson = ""
            } catch (e) {
                console.error("[Construct 3] Failed to load state from storage: ", e), await this.TriggerAsync(d.Plugins.System.Cnds.OnLoadFailed, null)
            }
        }
        async _SaveToJsonString() {
            const c = {
                c3save: !0,
                version: 1,
                rt: {
                    time: this.GetGameTime(),
                    walltime: this.GetWallTime(),
                    timescale: this.GetTimeScale(),
                    tickcount: this.GetTickCount(),
                    execcount: this.GetExecCount(),
                    next_uid: this._nextUid,
                    running_layout: this.GetMainRunningLayout().GetSID(),
                    start_time_offset: Date.now() - this._startTime
                },
                types: {},
                layouts: {},
                events: this._eventSheetManager._SaveToJson(),
                timelines: this._timelineManager._SaveToJson(),
                user_script_data: null
            };
            for (var e of this._allObjectClasses) e.IsFamily() || e.HasNoSaveBehavior() || (c.types[e.GetSID().toString()] = e._SaveToJson());
            for (const g of this._layoutManager.GetAllLayouts()) c.layouts[g.GetSID().toString()] = g._SaveToJson();
            e = this._CreateUserScriptEvent("save");
            e.saveData = null;
            await this.DispatchUserScriptEventAsyncWait(e);
            c.user_script_data = e.saveData;
            var hgg = JSON.stringify(c)
            console.log("IDDQD vars: " + JSON.stringify(c["events"]["vars"]))
            console.log("IDDQD lifes: " + c["events"]["vars"]["6991572027589697"])
            console.log("IDDQD level:  " + c["rt"]["running_layout"])
            console.log("IDDQD urlParams: i_id: " + urlParams["i_id"])
            console.log("IDDQD urlParams: user_id: " + urlParams["user_id"])
            var levelId = c["rt"]["running_layout"]
            console.log("IDDQD levelId: " + levelId)
            var lifes = c["events"]["vars"]["6991572027589697"]
            if(lifes !== 0) {
                var points = 0
                switch (levelId) {
                    case 6495216941307649:
                        points = 1 * lifes
                        console.log("IDDQD level: level 1")
                        break;
                    case 603391552649806:
                        points = 2 * lifes
                        console.log("IDDQD level: level 2")
                        break;
                    case 3483513303330653:
                        points = 3 * lifes
                        console.log("IDDQD level: level 3")
                        break;
                    case 9294741076399654:
                        points = 4 * lifes
                        console.log("IDDQD level: level 4")
                        break;
                    case 1835720964065002:
                        points = 5 * lifes
                        console.log("IDDQD level: level 5")
                        break;
                    case 3394140191041329:
                        points = 6 * lifes
                        console.log("IDDQD level: level 6")
                        break;
                    default:
                        throw Error(`unknown message from worker '${a}'`);
                 }
                 if(points !== 0) {
                    console.log("IDDQD need add points: " + points)
                    fetch("https://voljchill.cf:4435/score/?user_id="+urlParams["user_id"]+"&score="+points+"&i_id="+urlParams["i_id"])
                        .then((response) => response.json())
                        .then((json) => console.log(json));
                 }
            }
            return hgg
        }
        IsLoadingState() {
            return this._isLoadingState
        }
        async _DoLoadFromJsonString(c) {
            // console.log("IDDQD _DoLoadFromJsonSt " + JSON.stringify(c))
            c = JSON.parse(c);
            if (c.c2save) throw Error("C2 saves are incompatible with C3 runtime");
            if (!c.c3save) throw Error("not valid C3 save data");
            if (1 < c.version) throw Error("C3 save data from future version");
            this._dispatcher.dispatchEvent(d.New(d.Event, "beforeload"));
            for (var e of this.allInstances()) e._OnBeforeLoad();
            this._isLoadingState = !0;
            e = c.rt;
            this._gameTime.Set(e.time);
            this._wallTime.Set(e.walltime);
            this._timeScale = e.timescale;
            this._tickCount = e.tickcount;
            this._execCount = e.execcount;
            this._startTime = Date.now() - e.start_time_offset;
            var g = e.running_layout;
            if (g !== this.GetMainRunningLayout().GetSID())
                if (g = this._layoutManager.GetLayoutBySID(g)) await this._DoChangeLayout(g);
                else return;
            for (const [l, m] of Object.entries(c.types)) g = parseInt(l, 10), g = this.GetObjectClassBySID(g), !g || g.IsFamily() || g.HasNoSaveBehavior() ||
                g._LoadFromJson(m);
            this.FlushPendingInstances();
            this._RefreshUidMap();
            this._isLoadingState = !1;
            this._nextUid = e.next_uid;
            for (const [l, m] of Object.entries(c.layouts)) e = parseInt(l, 10), (e = this._layoutManager.GetLayoutBySID(e)) && e._LoadFromJson(m);
            this._eventSheetManager._LoadFromJson(c.events);
            for (var h of this._allObjectClasses)
                if (!h.IsFamily() && h.IsInContainer())
                    for (const l of h.GetInstances()) {
                        e = l.GetIID();
                        for (const m of h.GetContainer().objectTypes())
                            if (m !== h) {
                                g = m.GetInstances();
                                if (0 > e || e >= g.length) throw Error("missing sibling instance");
                                l._AddSibling(g[e])
                            }
                    }
            this._timelineManager._LoadFromJson(c.timelines);
            this._dispatcher.dispatchEvent(d.New(d.Event, "afterload"));
            h = this._CreateUserScriptEvent("load");
            h.saveData = c.user_script_data;
            await this.DispatchUserScriptEventAsyncWait(h);
            this.UpdateRender()
        }
        async AddJobWorkerScripts(c) {
            c = (await Promise.all(c.map(e => this._assetManager.FetchBlob(e)))).map(e => URL.createObjectURL(e));
            this._jobScheduler.ImportScriptsToJobWorkers(c)
        }
        AddJobWorkerBlob(c, e) {
            this._jobScheduler.SendBlobToJobWorkers(c,
                e)
        }
        AddJobWorkerBuffer(c, e) {
            this._jobScheduler.SendBufferToJobWorkers(c, e)
        }
        AddJob(c, e, g) {
            return this._jobScheduler.AddJob(c, e, g)
        }
        BroadcastJob(c, e, g) {
            return this._jobScheduler.BroadcastJob(c, e, g)
        }
        InvokeDownload(c, e) {
            this.PostComponentMessageToDOM("runtime", "invoke-download", {
                url: c,
                filename: e
            })
        }
        async RasterSvgImage(c, e, g, h, l, m) {
            h = h || e;
            l = l || g;
            if (this.IsInWorker()) return (await this.PostComponentMessageToDOMAsync("runtime", "raster-svg-image", {
                blob: c,
                imageWidth: e,
                imageHeight: g,
                surfaceWidth: h,
                surfaceHeight: l,
                imageBitmapOpts: m
            })).imageBitmap;
            c = await self.C3_RasterSvgImageBlob(c, e, g, h, l);
            return m ? await self.createImageBitmap(c, m) : c
        }
        async GetSvgImageSize(c) {
            return this.IsInWorker() ? await this.PostComponentMessageToDOMAsync("runtime", "get-svg-image-size", {
                blob: c
            }) : await self.C3_GetSvgImageSize(c)
        }
        RequestDeviceOrientationEvent() {
            this._didRequestDeviceOrientationEvent || (this._didRequestDeviceOrientationEvent = !0, this.PostComponentMessageToDOM("runtime", "enable-device-orientation"))
        }
        RequestDeviceMotionEvent() {
            this._didRequestDeviceMotionEvent ||
                (this._didRequestDeviceMotionEvent = !0, this.PostComponentMessageToDOM("runtime", "enable-device-motion"))
        }
        Random() {
            return this._randomNumberCallback()
        }
        SetRandomNumberGeneratorCallback(c) {
            this._randomNumberCallback = c
        }
        _GetRemotePreviewStatusInfo() {
            return {
                fps: this.GetFPS(),
                cpu: this.GetMainThreadTime(),
                gpu: this.GetGPUUtilisation(),
                layout: this.GetMainRunningLayout() ? this.GetMainRunningLayout().GetName() : "",
                renderer: this.GetWebGLRenderer().GetUnmaskedRenderer()
            }
        }
        HitBreakpoint() {
            return this.IsDebug() ? b.HitBreakpoint() :
                !1
        }
        DebugBreak(c) {
            return this.IsDebugging() ? b.DebugBreak(c) : Promise.resolve()
        }
        DebugBreakNext() {
            return this.IsDebugging() ? b.BreakNext() : !1
        }
        SetDebugBreakpointsEnabled(c) {
            this._breakpointsEnabled = !!c;
            this._UpdateDebuggingFlag()
        }
        AreDebugBreakpointsEnabled() {
            return this._breakpointsEnabled
        }
        IsDebugging() {
            return this._isDebugging
        }
        SetDebuggingEnabled(c) {
            c ? this._debuggingDisabled-- : this._debuggingDisabled++;
            this._UpdateDebuggingFlag()
        }
        _UpdateDebuggingFlag() {
            this._isDebugging = this.IsDebug() && this._breakpointsEnabled &&
                0 === this._debuggingDisabled
        }
        IsCPUProfiling() {
            return this.IsDebug() && b.IsCPUProfiling()
        }
        IsGPUProfiling() {
            return this.IsDebug() && this.GetWebGLRenderer().SupportsGPUProfiling() && b.IsGPUProfiling()
        }
        async DebugIterateAndBreak(c) {
            if (c)
                for (const e of c) await this.DebugBreak(e)
        }
        DebugFireGeneratorEventAndBreak(c) {
            return this.DebugIterateAndBreak(this._dispatcher.dispatchGeneratorEvent(c))
        }
        _InvokeFunctionFromJS(c) {
            return this._eventSheetManager._InvokeFunctionFromJS(c.name, c.params)
        }
        GetIRuntime() {
            return this._iRuntime
        }
        _CreateUserScriptEvent(c) {
            c =
                d.New(d.Event, c, !1);
            c.runtime = this._iRuntime;
            return c
        }
        _InitScriptInterfaces() {
            var c = {};
            for (const e of this._allObjectClasses) c[e.GetJsPropName()] = {
                value: e.GetIObjectClass(),
                enumerable: !0,
                writable: !1
            };
            c = Object.create(Object.prototype, c);
            this._iRuntime = new self.IRuntime(this, c);
            this._userScriptEventObjects = {
                tick: this._CreateUserScriptEvent("tick")
            }
        }
        _InitGlobalVariableScriptInterface() {
            const c = {};
            for (const e of this.GetEventSheetManager().GetAllGlobalVariables()) c[e.GetJsPropName()] = e._GetScriptInterfaceDescriptor();
            this._iRuntime._InitGlobalVars(c)
        }
        _GetCommonScriptInterfaces() {
            return this._commonScriptInterfaces
        }
        _MapScriptInterface(c, e) {
            this._interfaceMap.set(c, e)
        }
        _UnwrapScriptInterface(c) {
            return this._interfaceMap.get(c)
        }
    };
    self.C3_CreateRuntime = d.Runtime.Create;
    self.C3_InitRuntime = (c, e) => c.Init(e)
}
"use strict";
{
    const d = self.C3;
    d.JobSchedulerRuntime = class extends d.DefendedBase {
        constructor(b, a) {
            super();
            this._runtime = b;
            this._jobPromises = new Map;
            this._nextJobId = 0;
            this._inputPort = a.inputPort;
            a.outputPort.onmessage = f => this._OnJobWorkerMessage(f);
            this._maxNumWorkers = a.maxNumWorkers;
            this._jobWorkerCount = 1;
            this._hadErrorCreatingWorker = this._isCreatingWorker = !1
        }
        async Init() {}
        ImportScriptsToJobWorkers(b) {
            this._inputPort.postMessage({
                type: "_import_scripts",
                scripts: b
            })
        }
        SendBlobToJobWorkers(b, a) {
            this._inputPort.postMessage({
                type: "_send_blob",
                blob: b,
                id: a
            })
        }
        SendBufferToJobWorkers(b, a) {
            this._inputPort.postMessage({
                type: "_send_buffer",
                buffer: b,
                id: a
            }, [b])
        }
        AddJob(b, a, f, c, e) {
            f || (f = []);
            const g = this._nextJobId++;
            b = {
                type: b,
                isBroadcast: !1,
                jobId: g,
                params: a,
                transferables: f
            };
            a = new Promise((h, l) => {
                this._jobPromises.set(g, {
                    resolve: h,
                    progress: c,
                    reject: l,
                    cancelled: !1
                })
            });
            e && e.SetAction(() => this._CancelJob(g));
            this._inputPort.postMessage(b, f);
            this._MaybeCreateExtraWorker();
            return a
        }
        BroadcastJob(b, a, f) {
            f || (f = []);
            const c = this._nextJobId++;
            this._inputPort.postMessage({
                type: b,
                isBroadcast: !0,
                jobId: c,
                params: a,
                transferables: f
            }, f)
        }
        _CancelJob(b) {
            const a = this._jobPromises.get(b);
            a && (a.cancelled = !0, a.resolve = null, a.progress = null, a.reject = null, this._inputPort.postMessage({
                type: "_cancel",
                jobId: b
            }))
        }
        _OnJobWorkerMessage(b) {
            b = b.data;
            const a = b.type,
                f = b.jobId;
            switch (a) {
                case "result":
                    this._OnJobResult(f, b.result);
                    break;
                case "progress":
                    this._OnJobProgress(f, b.progress);
                    break;
                case "error":
                    this._OnJobError(f, b.error);
                    break;
                case "ready":
                    this._OnJobWorkerReady();
                    break;
                default:
                    throw Error(`unknown message from worker '${a}'`);
            }
        }
        _OnJobResult(b, a) {
            const f = this._jobPromises.get(b);
            if (!f) throw Error("invalid job ID");
            f.cancelled || f.resolve(a);
            this._jobPromises.delete(b)
        }
        _OnJobProgress(b, a) {
            b = this._jobPromises.get(b);
            if (!b) throw Error("invalid job ID");
            !b.cancelled && b.progress && b.progress(a)
        }
        _OnJobError(b, a) {
            const f = this._jobPromises.get(b);
            if (!f) throw Error("invalid job ID");
            f.cancelled || f.reject(a);
            this._jobPromises.delete(b)
        }
        _OnJobWorkerReady() {
            this._isCreatingWorker && (this._isCreatingWorker = !1, this._jobWorkerCount++, this._jobWorkerCount <
                this._maxNumWorkers ? this._MaybeCreateExtraWorker() : this._inputPort.postMessage({
                    type: "_no_more_workers"
                }))
        }
        async _MaybeCreateExtraWorker() {
            if (!(this._jobWorkerCount >= this._maxNumWorkers || this._isCreatingWorker || this._hadErrorCreatingWorker || this._jobPromises.size <= this._jobWorkerCount)) try {
                this._isCreatingWorker = !0, (await this._runtime.PostComponentMessageToDOMAsync("runtime", "create-job-worker")).outputPort.onmessage = b => this._OnJobWorkerMessage(b)
            } catch (b) {
                this._hadErrorCreatingWorker = !0, this._isCreatingWorker = !1, console.error(`[Construct 3] Failed to create job worker; stopping creating any more (created ${this._jobWorkerCount} so far)`, b)
            }
        }
    }
}
self.C3_Shaders = {};
"use strict";
{
    const d = self.C3;
    let b = null,
        a = "",
        f = "",
        c = [],
        e = "",
        g = "",
        h = "";
    const l = d.New(d.ArrayStack);

    function m(p, t) {
        p = p[1];
        t = t[1];
        if ("number" === typeof p && "number" === typeof t) return p - t;
        p = "" + p;
        t = "" + t;
        return p < t ? -1 : p > t ? 1 : 0
    }
    d.Plugins.System = class extends d.SDKPluginBase {
        constructor(p) {
            super(p);
            this._loopStack = this._runtime.GetEventSheetManager().GetLoopStack();
            this._eventStack = this._runtime.GetEventSheetManager().GetEventStack();
            this._imagesLoadingComplete = this._imagesLoadingTotal = 0;
            this._functionMaps = new Map
        }
        Release() {
            super.Release()
        }
        UpdateRender() {
            this._runtime.UpdateRender()
        }
        Trigger(p) {
            this._runtime.Trigger(p,
                null, null)
        }
        GetRegex(p, t) {
            b && p === a && t === f || (b = new RegExp(p, t), a = p, f = t);
            b.lastIndex = 0;
            return b
        }
        GetRegexMatches(p, t, q) {
            if (p === e && t === g && q === h) return c;
            const r = this.GetRegex(t, q);
            c = p.match(r);
            e = p;
            g = t;
            h = q;
            return c
        }
        async _LoadTexturesForObjectClasses(p, t) {
            if (t.length) {
                this._imagesLoadingTotal += t.length;
                var q = [];
                for (const r of t) q.push(p.MaybeLoadTexturesFor(r));
                await d.PromiseAllWithProgress(q, () => {
                    this._imagesLoadingComplete++
                });
                this._imagesLoadingComplete++;
                this._imagesLoadingComplete === this._imagesLoadingTotal &&
                    (this._runtime.Trigger(d.Plugins.System.Cnds.OnImageLoadingComplete, null, null), this._imagesLoadingTotal = this._imagesLoadingComplete = 0)
            }
        }
        _UnloadTexturesForObjectClasses(p, t) {
            for (const q of t) 0 === q.GetInstanceCount() && p.MaybeUnloadTexturesFor(q)
        }
        _GetForEachStack() {
            return l
        }
        _Repeat(p) {
            var t = this._runtime.GetEventSheetManager();
            const q = t.GetEventStack(),
                r = q.GetCurrentStackFrame(),
                u = r.GetCurrentEvent(),
                x = u.GetSolModifiers();
            var y = r.IsSolModifierAfterCnds();
            const C = q.Push(u),
                w = t.GetLoopStack(),
                A = w.Push();
            A.SetEnd(p);
            if (y)
                for (y = 0; y < p && !A.IsStopped(); ++y) t.PushCopySol(x), A.SetIndex(y), u.Retrigger(r, C), t.PopSol(x);
            else
                for (t = 0; t < p && !A.IsStopped(); ++t) A.SetIndex(t), u.Retrigger(r, C);
            q.Pop();
            w.Pop();
            return !1
        }* _DebugRepeat(p) {
            var t = this._runtime.GetEventSheetManager();
            const q = t.GetEventStack(),
                r = q.GetCurrentStackFrame(),
                u = r.GetCurrentEvent(),
                x = u.GetSolModifiers();
            var y = r.IsSolModifierAfterCnds();
            const C = q.Push(u),
                w = t.GetLoopStack(),
                A = w.Push();
            A.SetEnd(p);
            if (y)
                for (y = 0; y < p && !A.IsStopped(); ++y) t.PushCopySol(x),
                    A.SetIndex(y), yield* u.DebugRetrigger(r, C), t.PopSol(x);
            else
                for (t = 0; t < p && !A.IsStopped(); ++t) A.SetIndex(t), yield* u.DebugRetrigger(r, C);
            q.Pop();
            w.Pop();
            return !1
        }
        _While() {
            var p = this._runtime.GetEventSheetManager();
            const t = p.GetEventStack(),
                q = t.GetCurrentStackFrame(),
                r = q.GetCurrentEvent(),
                u = r.GetSolModifiers();
            var x = q.IsSolModifierAfterCnds();
            const y = t.Push(r),
                C = p.GetLoopStack(),
                w = C.Push();
            if (x)
                for (x = 0; !w.IsStopped(); ++x) p.PushCopySol(u), w.SetIndex(x), r.Retrigger(q, y) || w.Stop(), p.PopSol(u);
            else
                for (p =
                    0; !w.IsStopped(); ++p) w.SetIndex(p), r.Retrigger(q, y) || w.Stop();
            t.Pop();
            C.Pop();
            return !1
        }* _DebugWhile() {
            var p = this._runtime.GetEventSheetManager();
            const t = p.GetEventStack(),
                q = t.GetCurrentStackFrame(),
                r = q.GetCurrentEvent(),
                u = r.GetSolModifiers();
            var x = q.IsSolModifierAfterCnds();
            const y = t.Push(r),
                C = p.GetLoopStack(),
                w = C.Push();
            if (x)
                for (x = 0; !w.IsStopped(); ++x) p.PushCopySol(u), w.SetIndex(x), (yield* r.DebugRetrigger(q, y)) || w.Stop(), p.PopSol(u);
            else
                for (p = 0; !w.IsStopped(); ++p) w.SetIndex(p), (yield* r.DebugRetrigger(q,
                    y)) || w.Stop();
            t.Pop();
            C.Pop();
            return !1
        }
        _For(p, t, q) {
            var r = this._runtime.GetEventSheetManager();
            const u = r.GetEventStack(),
                x = u.GetCurrentStackFrame(),
                y = x.GetCurrentEvent(),
                C = y.GetSolModifiers(),
                w = x.IsSolModifierAfterCnds(),
                A = u.Push(y),
                E = r.GetLoopStack(),
                K = E.Push();
            K.SetName(p);
            K.SetEnd(q);
            if (q < t)
                if (w)
                    for (p = t; p >= q && !K.IsStopped(); --p) r.PushCopySol(C), K.SetIndex(p), y.Retrigger(x, A), r.PopSol(C);
                else
                    for (r = t; r >= q && !K.IsStopped(); --r) K.SetIndex(r), y.Retrigger(x, A);
            else if (w)
                for (p = t; p <= q && !K.IsStopped(); ++p) r.PushCopySol(C),
                    K.SetIndex(p), y.Retrigger(x, A), r.PopSol(C);
            else
                for (r = t; r <= q && !K.IsStopped(); ++r) K.SetIndex(r), y.Retrigger(x, A);
            u.Pop();
            E.Pop();
            return !1
        }* _DebugFor(p, t, q) {
            var r = this._runtime.GetEventSheetManager();
            const u = r.GetEventStack(),
                x = u.GetCurrentStackFrame(),
                y = x.GetCurrentEvent(),
                C = y.GetSolModifiers(),
                w = x.IsSolModifierAfterCnds(),
                A = u.Push(y),
                E = r.GetLoopStack(),
                K = E.Push();
            K.SetName(p);
            K.SetEnd(q);
            if (q < t)
                if (w)
                    for (p = t; p >= q && !K.IsStopped(); --p) r.PushCopySol(C), K.SetIndex(p), yield* y.DebugRetrigger(x, A), r.PopSol(C);
                else
                    for (r = t; r >= q && !K.IsStopped(); --r) K.SetIndex(r), yield* y.DebugRetrigger(x, A);
            else if (w)
                for (p = t; p <= q && !K.IsStopped(); ++p) r.PushCopySol(C), K.SetIndex(p), yield* y.DebugRetrigger(x, A), r.PopSol(C);
            else
                for (r = t; r <= q && !K.IsStopped(); ++r) K.SetIndex(r), yield* y.DebugRetrigger(x, A);
            u.Pop();
            E.Pop();
            return !1
        }
        _ForEach(p) {
            var t = this._runtime.GetEventSheetManager();
            const q = t.GetEventStack(),
                r = q.GetCurrentStackFrame(),
                u = r.GetCurrentEvent(),
                x = u.GetSolModifiers();
            var y = r.IsSolModifierAfterCnds();
            const C = q.Push(u),
                w = t.GetLoopStack(),
                A = w.Push(),
                E = p.IsInContainer(),
                K = p.GetCurrentSol(),
                O = l.Push();
            d.shallowAssignArray(O, K.GetInstances());
            A.SetEnd(O.length);
            if (y)
                for (let G = 0, J = O.length; G < J && !A.IsStopped(); ++G) t.PushCopySol(x), y = O[G], p.GetCurrentSol().SetSinglePicked(y), E && y.SetSiblingsSinglePicked(), A.SetIndex(G), u.Retrigger(r, C), t.PopSol(x);
            else {
                K._SetSelectAll(!1);
                p = K._GetOwnInstances();
                d.clearArray(p);
                p.push(null);
                for (let G = 0, J = O.length; G < J && !A.IsStopped(); ++G) t = O[G], p[0] = t, E && t.SetSiblingsSinglePicked(), A.SetIndex(G),
                    u.Retrigger(r, C)
            }
            q.Pop();
            w.Pop();
            d.clearArray(O);
            l.Pop();
            return !1
        }* _DebugForEach(p) {
            var t = this._runtime.GetEventSheetManager();
            const q = t.GetEventStack(),
                r = q.GetCurrentStackFrame(),
                u = r.GetCurrentEvent(),
                x = u.GetSolModifiers();
            var y = r.IsSolModifierAfterCnds();
            const C = q.Push(u),
                w = t.GetLoopStack(),
                A = w.Push(),
                E = p.IsInContainer(),
                K = p.GetCurrentSol(),
                O = l.Push();
            d.shallowAssignArray(O, K.GetInstances());
            A.SetEnd(O.length);
            if (y)
                for (let G = 0, J = O.length; G < J && !A.IsStopped(); ++G) t.PushCopySol(x), y = O[G], p.GetCurrentSol().SetSinglePicked(y),
                    E && y.SetSiblingsSinglePicked(), A.SetIndex(G), yield* u.DebugRetrigger(r, C), t.PopSol(x);
            else {
                K._SetSelectAll(!1);
                p = K._GetOwnInstances();
                d.clearArray(p);
                p.push(null);
                for (let G = 0, J = O.length; G < J && !A.IsStopped(); ++G) t = O[G], p[0] = t, E && t.SetSiblingsSinglePicked(), A.SetIndex(G), yield* u.DebugRetrigger(r, C)
            }
            q.Pop();
            w.Pop();
            d.clearArray(O);
            l.Pop();
            return !1
        }
        _ForEachOrdered(p, t) {
            var q = this._runtime.GetEventSheetManager();
            const r = q.GetEventStack(),
                u = q.GetCurrentCondition(),
                x = r.GetCurrentStackFrame(),
                y = x.GetCurrentEvent(),
                C = y.GetSolModifiers(),
                w = x.IsSolModifierAfterCnds(),
                A = r.Push(y),
                E = q.GetLoopStack(),
                K = E.Push(),
                O = p.IsInContainer(),
                G = p.GetCurrentSol(),
                J = l.Push();
            d.clearArray(J);
            const P = G.GetInstances();
            K.SetEnd(P.length);
            for (let R = 0, T = P.length; R < T; ++R) J.push([P[R], u.ReevaluateParameter(1, R)]);
            J.sort(m);
            1 === t && J.reverse();
            if (w)
                for (let R = 0, T = J.length; R < T && !K.IsStopped(); ++R) q.PushCopySol(C), t = J[R][0], p.GetCurrentSol().SetSinglePicked(t), O && t.SetSiblingsSinglePicked(), K.SetIndex(R), y.Retrigger(x, A), q.PopSol(C);
            else {
                G._SetSelectAll(!1);
                p = G._GetOwnInstances();
                d.clearArray(p);
                p.push(null);
                for (let R = 0, T = J.length; R < T && !K.IsStopped(); ++R) q = J[R][0], p[0] = q, O && q.SetSiblingsSinglePicked(), K.SetIndex(R), y.Retrigger(x, A)
            }
            r.Pop();
            E.Pop();
            d.clearArray(J);
            l.Pop();
            return !1
        }* _DebugForEachOrdered(p, t) {
            var q = this._runtime.GetEventSheetManager();
            const r = q.GetEventStack(),
                u = q.GetCurrentCondition(),
                x = r.GetCurrentStackFrame(),
                y = x.GetCurrentEvent(),
                C = y.GetSolModifiers(),
                w = x.IsSolModifierAfterCnds(),
                A = r.Push(y),
                E = q.GetLoopStack(),
                K = E.Push(),
                O = p.IsInContainer(),
                G = p.GetCurrentSol(),
                J = l.Push();
            d.clearArray(J);
            const P = G.GetInstances();
            K.SetEnd(P.length);
            for (let R = 0, T = P.length; R < T; ++R) J.push([P[R], u.ReevaluateParameter(1, R)]);
            J.sort(m);
            1 === t && J.reverse();
            if (w)
                for (let R = 0, T = J.length; R < T && !K.IsStopped(); ++R) q.PushCopySol(C), t = J[R][0], p.GetCurrentSol().SetSinglePicked(t), O && t.SetSiblingsSinglePicked(), K.SetIndex(R), yield* y.DebugRetrigger(x, A), q.PopSol(C);
            else {
                G._SetSelectAll(!1);
                p = G._GetOwnInstances();
                d.clearArray(p);
                p.push(null);
                for (let R = 0, T = J.length; R < T && !K.IsStopped(); ++R) q =
                    J[R][0], p[0] = q, O && q.SetSiblingsSinglePicked(), K.SetIndex(R), yield* y.DebugRetrigger(x, A)
            }
            r.Pop();
            E.Pop();
            d.clearArray(J);
            l.Pop();
            return !1
        }
        _GetFunctionMap(p, t) {
            let q = this._functionMaps.get(p);
            if (q) return q;
            if (!t) return null;
            q = {
                defaultFunc: null,
                strMap: new Map
            };
            this._functionMaps.set(p, q);
            return q
        }
        _DoCallMappedFunction(p, t, q, r, u) {
            t.GetEventBlock().RunAsMappedFunctionCall(q);
            r && p.PopSol(u)
        }* _DebugDoCallMappedFunction(p, t, q, r, u) {
            yield* t.GetEventBlock().DebugRunAsMappedFunctionCall(q);
            r && p.PopSol(u)
        }
    }
}
"use strict";
{
    const d = self.C3;
    d.Plugins.System.Type = class extends d.DefendedBase {
        constructor(b) {
            super();
            this._objectClass = b;
            this._runtime = b.GetRuntime();
            this._plugin = b.GetPlugin()
        }
        OnCreate() {}
        Release() {
            this._plugin = this._runtime = this._objectClass = null
        }
    }
}
"use strict";
{
    const d = self.C3;
    d.Plugins.System.Instance = class extends d.DefendedBase {
        constructor(b, a) {
            super();
            this._inst = b;
            this._objectClass = this._inst.GetObjectClass();
            this._sdkType = this._objectClass.GetSdkType();
            this._runtime = this._inst.GetRuntime()
        }
        Release() {
            this._runtime = this._sdkType = this._objectClass = this._inst = null
        }
    }
}
"use strict";
{
    const d = self.C3,
        b = [];
    d.Plugins.System.Cnds = {
        EveryTick() {
            return !0
        },
        OnLayoutStart() {
            return !0
        },
        OnLayoutEnd() {
            return !0
        },
        OnSuspend() {
            return !0
        },
        OnResume() {
            return !0
        },
        IsSuspended() {
            return this._runtime.IsSuspended()
        },
        Else() {
            const a = this._runtime.GetCurrentEventStackFrame();
            return a.GetElseBranchRan() ? !1 : !a.GetLastEventTrue()
        },
        TriggerOnce() {
            const a = this._runtime.GetCurrentCondition().GetSavedDataMap();
            let f = a.get("TriggerOnce_lastTick");
            "undefined" === typeof f && (f = -1, a.set("TriggerOnce_lastTick", -1));
            const c =
                this._runtime.GetTickCount();
            a.set("TriggerOnce_lastTick", c);
            return this._runtime.IsLayoutFirstTick() || f !== c - 1
        },
        Every(a) {
            const f = this._runtime.GetCurrentCondition().GetSavedDataMap(),
                c = f.get("Every_lastTime") || 0,
                e = this._runtime.GetGameTime();
            f.has("Every_seconds") || f.set("Every_seconds", a);
            const g = f.get("Every_seconds");
            if (e >= c + g) return f.set("Every_lastTime", c + g), e >= f.get("Every_lastTime") + .04 && f.set("Every_lastTime", e), f.set("Every_seconds", a), !0;
            e < c - .1 && f.set("Every_lastTime", e);
            return !1
        },
        IsGroupActive(a) {
            return (a =
                this._runtime.GetEventSheetManager().GetEventGroupByName(a)) && a.IsGroupActive()
        },
        IsPreview() {
            return this._runtime.IsPreview()
        },
        IsMobile() {
            return d.Platform.IsMobile
        },
        OnLoadFinished() {
            return !0
        },
        OnCanvasSnapshot() {
            return !0
        },
        EffectsSupported() {
            return !0
        },
        OnSaveComplete() {
            return !0
        },
        OnSaveFailed() {
            return !0
        },
        OnLoadComplete() {
            return !0
        },
        OnLoadFailed() {
            return !0
        },
        ObjectUIDExists(a) {
            return !!this._runtime.GetInstanceByUID(a)
        },
        IsOnPlatform(a) {
            switch (a) {
                case 0:
                    return "browser" === d.Platform.Context;
                case 1:
                    return "iOS" ===
                        d.Platform.OS;
                case 2:
                    return "Android" === d.Platform.OS;
                case 8:
                    return "cordova" === d.Platform.Context;
                case 9:
                    return "scirra-arcade" === this._runtime.GetExportType();
                case 10:
                    return "nwjs" === d.Platform.Context;
                case 13:
                    return "windows-uwp" === this._runtime.GetExportType();
                default:
                    return !1
            }
        },
        RegexTest(a, f, c) {
            return this.GetRegex(f, c).test(a)
        },
        Compare(a, f, c) {
            return d.compare(a, f, c)
        },
        CompareBetween(a, f, c) {
            return a >= f && a <= c
        },
        CompareVar(a, f, c) {
            return d.compare(a.GetValue(), f, c)
        },
        CompareBoolVar(a) {
            return !!a.GetValue()
        },
        CompareTime(a, f) {
            const c = this._runtime.GetGameTime();
            return 0 === a ? (a = this._runtime.GetCurrentCondition().GetSavedDataMap(), !a.get("CompareTime_executed") && c >= f ? (a.set("CompareTime_executed", !0), !0) : !1) : d.compare(c, a, f)
        },
        IsNaN(a) {
            return isNaN(a)
        },
        AngleWithin(a, f, c) {
            return d.angleDiff(d.toRadians(a), d.toRadians(c)) <= d.toRadians(f)
        },
        IsClockwiseFrom(a, f) {
            return d.angleClockwise(d.toRadians(a), d.toRadians(f))
        },
        IsBetweenAngles(a, f, c) {
            a = d.toRadians(a);
            f = d.toRadians(f);
            c = d.toRadians(c);
            return d.angleClockwise(c,
                f) ? d.angleClockwise(a, f) && !d.angleClockwise(a, c) : !(!d.angleClockwise(a, f) && d.angleClockwise(a, c))
        },
        IsValueType(a, f) {
            return "number" === typeof a ? 0 === f : 1 === f
        },
        EvaluateExpression(a) {
            return !!a
        },
        PickByComparison(a, f, c, e) {
            if (!a) return !1;
            const g = this._GetForEachStack(),
                h = g.Push(),
                l = a.GetCurrentSol();
            d.shallowAssignArray(h, l.GetInstances());
            l.IsSelectAll() && d.clearArray(l._GetOwnElseInstances());
            const m = this._runtime.GetCurrentCondition();
            let p = 0;
            for (let t = 0, q = h.length; t < q; ++t) {
                const r = h[t];
                h[p] = r;
                f = m.ReevaluateParameter(1,
                    t);
                e = m.ReevaluateParameter(3, t);
                d.compare(f, c, e) ? ++p : l._PushElseInstance(r)
            }
            d.truncateArray(h, p);
            l.SetArrayPicked(h);
            f = !!h.length;
            d.clearArray(h);
            g.Pop();
            a.ApplySolToContainer();
            return f
        },
        PickByEvaluate(a, f) {
            if (!a) return !1;
            const c = this._GetForEachStack(),
                e = c.Push(),
                g = a.GetCurrentSol();
            d.shallowAssignArray(e, g.GetInstances());
            g.IsSelectAll() && d.clearArray(g._GetOwnElseInstances());
            const h = this._runtime.GetCurrentCondition();
            let l = 0;
            for (let m = 0, p = e.length; m < p; ++m) {
                const t = e[m];
                e[l] = t;
                (f = h.ReevaluateParameter(1,
                    m)) ? ++l: g._PushElseInstance(t)
            }
            d.truncateArray(e, l);
            g.SetArrayPicked(e);
            f = !!e.length;
            d.clearArray(e);
            c.Pop();
            a.ApplySolToContainer();
            return f
        },
        PickNth(a, f) {
            if (!a) return !1;
            const c = a.GetCurrentSol(),
                e = c.GetInstances();
            f = Math.floor(f);
            if (f >= e.length) return !1;
            c.PickOne(e[f]);
            a.ApplySolToContainer();
            return !0
        },
        PickRandom(a) {
            if (!a) return !1;
            const f = a.GetCurrentSol(),
                c = f.GetInstances(),
                e = Math.floor(this._runtime.Random() * c.length);
            if (e >= c.length) return !1;
            f.PickOne(c[e]);
            a.ApplySolToContainer();
            return !0
        },
        PickAll(a) {
            if (!a ||
                !a.GetInstanceCount()) return !1;
            a.GetCurrentSol()._SetSelectAll(!0);
            a.ApplySolToContainer();
            return !0
        },
        PickOverlappingPoint(a, f, c) {
            if (!a) return !1;
            const e = a.GetCurrentSol();
            var g = e.GetInstances();
            const h = this._runtime.GetCurrentEvent().IsOrBlock(),
                l = this._runtime.GetCurrentCondition().IsInverted();
            e.IsSelectAll() ? (d.shallowAssignArray(b, g), e.ClearArrays(), e._SetSelectAll(!1)) : h ? (d.shallowAssignArray(b, e._GetOwnElseInstances()), d.clearArray(e._GetOwnElseInstances())) : (d.shallowAssignArray(b, e._GetOwnInstances()),
                d.clearArray(e._GetOwnInstances()));
            for (let m = 0, p = b.length; m < p; ++m) g = b[m], d.xor(g.GetWorldInfo().ContainsPoint(f, c), l) ? e._PushInstance(g) : e._PushElseInstance(g);
            a.ApplySolToContainer();
            return d.xor(!!e._GetOwnInstances().length, l)
        },
        PickLastCreated(a) {
            if (!a) return !1;
            var f = a.IsFamily();
            let c = null;
            const e = this._runtime._GetInstancesPendingCreate();
            for (let g = e.length - 1; 0 <= g; --g) {
                const h = e[g];
                if (f) {
                    if (h.GetObjectClass().BelongsToFamily(a)) {
                        c = h;
                        break
                    }
                } else if (h.GetObjectClass() === a) {
                    c = h;
                    break
                }
            }
            c || (f = a.GetInstances(),
                f.length && (c = f[f.length - 1]));
            if (!c) return !1;
            a.GetCurrentSol().PickOne(c);
            a.ApplySolToContainer();
            return !0
        },
        Repeat(a) {
            return this._runtime.IsDebugging() ? this._DebugRepeat(a) : this._Repeat(a)
        },
        While() {
            return this._runtime.IsDebugging() ? this._DebugWhile() : this._While()
        },
        For(a, f, c) {
            return this._runtime.IsDebugging() ? this._DebugFor(a, f, c) : this._For(a, f, c)
        },
        ForEach(a) {
            return this._runtime.IsDebugging() ? this._DebugForEach(a) : this._ForEach(a)
        },
        ForEachOrdered(a, f, c) {
            return this._runtime.IsDebugging() ? this._DebugForEachOrdered(a,
                c) : this._ForEachOrdered(a, c)
        },
        LayerVisible(a) {
            return a ? a.IsVisible() : !1
        },
        LayerEmpty(a) {
            return a ? !a.GetInstanceCount() : !1
        },
        LayerCmpOpacity(a, f, c) {
            return a ? d.compare(100 * a.GetOpacity(), f, c) : !1
        },
        OnImageLoadingComplete() {
            return !0
        },
        IsLoadingImages() {
            return 0 < this._imagesLoadingTotal
        }
    }
}
"use strict";
{
    const d = self.C3;

    function b(h, l) {
        const m = h[0] - l[0];
        return 0 !== m ? m : h[1] - l[1]
    }

    function a(h, l) {
        return h[1] - l[1]
    }
    const f = [],
        c = [],
        e = d.New(d.Rect),
        g = d.New(d.Color);
    d.Plugins.System.Acts = {
        SetVar(h, l) {
            h.SetValue(l)
        },
        AddVar(h, l) {
            h.IsNumber() && "number" !== typeof l && (l = parseFloat(l));
            h.SetValue(h.GetValue() + l)
        },
        SubVar(h, l) {
            h.IsNumber() && h.SetValue(h.GetValue() - l)
        },
        SetBoolVar(h, l) {
            h.SetValue(!!l)
        },
        ToggleBoolVar(h) {
            h.SetValue(!h.GetValue())
        },
        ResetGlobals() {
            this._runtime.GetEventSheetManager().ResetAllGlobalsToInitialValue()
        },
        CreateObject(h, l, m, p, t) {
            h && l && (m = this._runtime.CreateInstance(h, l, m, p, t)) && (t && l.SortAndAddSceneGraphInstancesByZIndex(m), l = this._runtime.GetEventSheetManager(), l.BlockFlushingInstances(!0), m._TriggerOnCreatedOnSelfAndRelated(), l.BlockFlushingInstances(!1), h.GetCurrentSol().SetSinglePicked(m), m.IsInContainer() && m.SetSiblingsSinglePicked())
        },
        CreateObjectByName(h, l, m, p, t) {
            h && l && (h = this._runtime.GetObjectClassByName(h)) && d.Plugins.System.Acts.CreateObject.call(this, h, l, m, p, t)
        },
        RecreateInitialObjects(h,
            l, m, p, t, q, r, u, x, y) {
            if (h) {
                var C = this._runtime.GetCurrentLayout();
                if (q && (C = this._runtime.GetLayoutManager().GetLayoutByName(q), !C)) return;
                q = null;
                if ("number" !== typeof r || 0 <= r)
                    if (q = C.GetLayer(r), !q) return;
                e.set(l, m, p, t);
                l = C.RecreateInitialObjects(h, e, q, u, x, y);
                h.GetCurrentSol().SetArrayPicked(l);
                h.ApplySolToContainer()
            }
        },
        StopLoop() {
            const h = this._loopStack;
            h.IsInLoop() && h.GetCurrent().Stop()
        },
        SetGroupActive(h, l) {
            (h = this._runtime.GetEventSheetManager().GetEventGroupByName(h)) && (0 === l ? h.SetGroupActive(!1) :
                1 === l ? h.SetGroupActive(!0) : h.SetGroupActive(!h.IsGroupActive()))
        },
        SetTimescale(h) {
            this._runtime.SetTimeScale(h)
        },
        SetObjectTimescale(h, l) {
            0 > l && (l = 0);
            if (h) {
                h = h.GetCurrentSol().GetInstances();
                for (const m of h) m.SetTimeScale(l)
            }
        },
        RestoreObjectTimescale(h) {
            if (h) {
                h = h.GetCurrentSol().GetInstances();
                for (const l of h) l.RestoreTimeScale()
            }
        },
        Wait(h) {
            if (!(0 > h)) return this._runtime.GetEventSheetManager().AddScheduledWait().InitTimer(h), !0
        },
        WaitForSignal(h) {
            this._runtime.GetEventSheetManager().AddScheduledWait().InitSignal(h);
            return !0
        },
        WaitForPreviousActions() {
            const h = this._runtime.GetEventSheetManager();
            h.AddScheduledWait().InitPromise(h.GetPromiseForAllAsyncActions());
            return !0
        },
        Signal(h) {
            h = h.toLowerCase();
            for (const l of this._runtime.GetEventSheetManager().scheduledWaits()) l.IsSignal() && l.GetSignalTag() === h && l.SetSignalled()
        },
        async SnapshotCanvas(h, l, m, p, t, q) {
            const r = this._runtime.GetCanvasManager();
            r && (this.UpdateRender(), await r.SnapshotCanvas(0 === h ? "image/png" : "image/jpeg", l / 100, m, p, t, q), await this._runtime.TriggerAsync(d.Plugins.System.Cnds.OnCanvasSnapshot,
                null))
        },
        SetCanvasSize(h, l) {
            if (!(0 >= h || 0 >= l)) {
                this._runtime.SetViewportSize(h, l);
                var m = this._runtime.GetCurrentLayout();
                m.BoundScrolling();
                for (const p of m.GetLayers()) p.UpdateViewport();
                if (m = this._runtime.GetCanvasManager()) "off" !== m.GetCurrentFullscreenMode() && this._runtime.SetOriginalViewportSize(h, l), m.SetSize(m.GetLastWidth(), m.GetLastHeight(), !0), this._runtime.UpdateRender()
            }
        },
        SetFullscreenQuality(h) {
            const l = this._runtime.GetCanvasManager();
            l && "off" !== l.GetCurrentFullscreenMode() && (l.SetFullscreenScalingQuality(0 !==
                h ? "high" : "low"), l.SetSize(l.GetLastWidth(), l.GetLastHeight(), !0))
        },
        SaveState(h) {
            this._runtime.SaveToSlot(h)
        },
        LoadState(h) {
            this._runtime.LoadFromSlot(h)
        },
        LoadStateJSON(h) {
            this._runtime.LoadFromJsonString(h)
        },
        SetHalfFramerateMode(h) {},
        ResetPersisted() {
            for (const h of this._runtime.GetLayoutManager().GetAllLayouts()) h.ResetPersistData()
        },
        SetPixelRounding(h) {
            this._runtime.SetPixelRoundingEnabled(0 !== h)
        },
        SetMinimumFramerate(h) {
            this._runtime.SetMinimumFramerate(h)
        },
        SortZOrderByInstVar(h, l) {
            if (h) {
                var m = h.GetCurrentSol().GetInstances(),
                    p = this._runtime.GetCurrentLayout(),
                    t = h.IsFamily();
                h = h.GetFamilyIndex();
                for (let r = 0, u = m.length; r < u; ++r) {
                    var q = m[r];
                    const x = q.GetWorldInfo();
                    if (!x) continue;
                    let y;
                    y = t ? q.GetInstanceVariableValue(l + q.GetObjectClass().GetFamilyInstanceVariableOffset(h)) : q.GetInstanceVariableValue(l);
                    f.push([x.GetLayer().GetIndex(), x.GetZIndex()]);
                    c.push([q, y])
                }
                if (f.length) {
                    f.sort(b);
                    c.sort(a);
                    l = !1;
                    for (let r = 0, u = f.length; r < u; ++r) m = c[r][0], t = p.GetLayerByIndex(f[r][0]), h = f[r][1], q = t._GetInstances(), q[h] !== m && (q[h] = m, m.GetWorldInfo()._SetLayer(t),
                        t.SetZIndicesChanged(), l = !0);
                    l && this._runtime.UpdateRender();
                    d.clearArray(f);
                    d.clearArray(c)
                }
            }
        },
        GoToLayout(h) {
            if (!this._runtime.IsLoading()) {
                var l = this._runtime.GetLayoutManager();
                l.IsPendingChangeMainLayout() || l.ChangeMainLayout(h)
            }
        },
        GoToLayoutByName(h) {
            if (!this._runtime.IsLoading()) {
                var l = this._runtime.GetLayoutManager();
                l.IsPendingChangeMainLayout() || (h = l.GetLayoutByName(h)) && l.ChangeMainLayout(h)
            }
        },
        NextPrevLayout(h) {
            if (!this._runtime.IsLoading()) {
                var l = this._runtime.GetLayoutManager();
                if (!l.IsPendingChangeMainLayout()) {
                    var m =
                        l.GetAllLayouts(),
                        p = m.indexOf(l.GetMainRunningLayout());
                    h && 0 === p || (h || p !== m.length - 1) && l.ChangeMainLayout(m[p + (h ? -1 : 1)])
                }
            }
        },
        RestartLayout() {
            if (!this._runtime.IsLoading()) {
                var h = this._runtime.GetLayoutManager();
                h.IsPendingChangeMainLayout() || (h.ChangeMainLayout(h.GetMainRunningLayout()), this._runtime.GetEventSheetManager().ResetAllGroupsInitialActivation())
            }
        },
        SetLayerVisible(h, l) {
            h && h.SetVisible(l)
        },
        SetLayerOpacity(h, l) {
            h && h.SetOpacity(l / 100)
        },
        SetLayerScale(h, l) {
            h && h.SetOwnScale(l)
        },
        SetLayerScaleRate(h,
            l) {
            h && h.SetScaleRate(l)
        },
        SetLayerAngle(h, l) {
            h && (l = d.clampAngle(d.toRadians(+l)), h.GetOwnAngle() !== l && (h.SetAngle(l), this.UpdateRender()))
        },
        SetLayerParallax(h, l, m) {
            h && h.SetParallax(l / 100, m / 100)
        },
        SetLayerZElevation(h, l) {
            h && h.SetZElevation(l)
        },
        SetLayerBackground(h, l) {
            h && (g.setFromRgbValue(l), g.clamp(), h = h.GetBackgroundColor(), h.equalsIgnoringAlpha(g) || (h.copyRgb(g), this.UpdateRender()))
        },
        SetLayerTransparent(h, l) {
            h && (l = !!l, h.IsTransparent() !== l && (h.SetTransparent(l), this.UpdateRender()))
        },
        SetLayerBlendMode(h,
            l) {
            h && h.GetBlendMode() !== l && (h.SetBlendMode(l), this.UpdateRender())
        },
        SetLayerEffectEnabled(h, l, m) {
            h && (h = h.GetEffectList(), m = h.GetEffectTypeByName(m)) && (l = 1 === l, m.IsActive() !== l && (m.SetActive(l), h.UpdateActiveEffects(), this._runtime.UpdateRender()))
        },
        SetLayerEffectParam(h, l, m, p) {
            if (h && (h = h.GetEffectList(), l = h.GetEffectTypeByName(l))) {
                var t = l.GetIndex();
                h = h.GetEffectParametersForIndex(t);
                m = Math.floor(m);
                if (!(0 > m || m >= h.length)) {
                    t = l.GetShaderProgram().GetParameterType(m);
                    if ("color" === t) {
                        g.setFromRgbValue(p);
                        m = h[m];
                        if (g.equalsIgnoringAlpha(m)) return;
                        m.copyRgb(g)
                    } else {
                        "percent" === t && (p /= 100);
                        if (h[m] === p) return;
                        h[m] = p
                    }
                    l.IsActive() && this._runtime.UpdateRender()
                }
            }
        },
        SetLayerForceOwnTexture(h, l) {
            h && (l = !!l, h.IsForceOwnTexture() !== l && (h.SetForceOwnTexture(l), this.UpdateRender()))
        },
        SetLayoutScale(h) {
            const l = this._runtime.GetCurrentLayout();
            l.GetScale() !== h && (l.SetScale(h), this.UpdateRender())
        },
        SetLayoutAngle(h) {
            h = d.clampAngle(d.toRadians(+h));
            const l = this._runtime.GetCurrentLayout();
            l.GetAngle() !== h && (l.SetAngle(h),
                this.UpdateRender())
        },
        SetLayoutEffectEnabled(h, l) {
            const m = this._runtime.GetCurrentLayout().GetEffectList();
            if (l = m.GetEffectTypeByName(l)) h = 1 === h, l.IsActive() !== h && (l.SetActive(h), m.UpdateActiveEffects(), this._runtime.UpdateRender())
        },
        SetLayoutEffectParam(h, l, m) {
            var p = this._runtime.GetCurrentLayout().GetEffectList();
            if (h = p.GetEffectTypeByName(h)) {
                var t = h.GetIndex();
                p = p.GetEffectParametersForIndex(t);
                l = Math.floor(l);
                if (!(0 > l || l >= p.length)) {
                    t = h.GetShaderProgram().GetParameterType(l);
                    if ("color" === t) {
                        g.setFromRgbValue(m);
                        l = p[l];
                        if (g.equalsIgnoringAlpha(l)) return;
                        l.copyRgb(g)
                    } else {
                        "percent" === t && (m /= 100);
                        if (p[l] === m) return;
                        p[l] = m
                    }
                    h.IsActive() && this._runtime.UpdateRender()
                }
            }
        },
        ScrollX(h) {
            this._runtime.GetCurrentLayout().SetScrollX(h)
        },
        ScrollY(h) {
            this._runtime.GetCurrentLayout().SetScrollY(h)
        },
        Scroll(h, l) {
            const m = this._runtime.GetCurrentLayout();
            m.SetScrollX(h);
            m.SetScrollY(l)
        },
        ScrollToObject(h) {
            if (h && (h = h.GetFirstPicked()) && (h = h.GetWorldInfo())) {
                var l = this._runtime.GetCurrentLayout();
                l.SetScrollX(h.GetX());
                l.SetScrollY(h.GetY())
            }
        },
        async LoadObjectTextures(h) {
            const l = this._runtime.GetMainRunningLayout();
            l && h && !this._runtime.IsLoading() && (h = h.IsFamily() ? h.GetFamilyMembers() : [h], await this._LoadTexturesForObjectClasses(l, h))
        },
        async LoadObjectTexturesByName(h) {
            await d.Plugins.System.Acts.LoadObjectTextures.call(this, this._runtime.GetObjectClassByName(h))
        },
        UnloadObjectTextures(h) {
            const l = this._runtime.GetMainRunningLayout();
            l && h && (h = h.IsFamily() ? h.GetFamilyMembers() : [h], this._UnloadTexturesForObjectClasses(l, h))
        },
        UnloadObjectTexturesByName(h) {
            d.Plugins.System.Acts.UnloadObjectTexturesByName.call(this,
                this._runtime.GetObjectClassByName(h))
        },
        UnloadUnusedTextures() {
            const h = this._runtime.GetMainRunningLayout();
            if (h) {
                var l = h._GetTextureLoadedObjectTypes();
                this._UnloadTexturesForObjectClasses(h, l)
            }
        },
        async LoadLayoutTextures(h) {
            const l = this._runtime.GetMainRunningLayout();
            h && l && !this._runtime.IsLoading() && await this._LoadTexturesForObjectClasses(l, h._GetInitialObjectClasses())
        },
        async LoadLayoutTexturesByName(h) {
            const l = this._runtime.GetMainRunningLayout();
            (h = this._runtime.GetLayoutManager().GetLayoutByName(h)) &&
            l && !this._runtime.IsLoading() && await this._LoadTexturesForObjectClasses(l, h._GetInitialObjectClasses())
        },
        SetFunctionReturnValue(h) {
            const l = this._eventStack.GetCurrentExpFuncStackFrame();
            if (l) switch (l.GetFunctionReturnType()) {
                case 1:
                    "number" === typeof h && l.SetFunctionReturnValue(h);
                    break;
                case 2:
                    "string" === typeof h && l.SetFunctionReturnValue(h);
                    break;
                case 3:
                    l.SetFunctionReturnValue(h)
            }
        },
        MapFunction(h, l, m) {
            var p = this._GetFunctionMap(h.toLowerCase(), !0);
            const t = p.strMap,
                q = l.toLowerCase();
            t.has(q) && console.warn(`[Construct 3] Function map '${h}' string '${l}' already in map; overwriting entry`);
            if (p = d.first(t.values()) || p.defaultFunc) {
                p = 0 !== p.GetReturnType();
                const r = 0 !== m.GetReturnType();
                if (p !== r) {
                    console.error(`[Construct 3] Function map '${h}' string '${l}' function return type not compatible with other functions in the map; entry ignored`);
                    return
                }
            }
            t.set(q, m)
        },
        MapFunctionDefault(h, l) {
            const m = this._GetFunctionMap(h.toLowerCase(), !0);
            m.defaultFunc && console.warn(`[Construct 3] Function map '${h}' already has a default; overwriting entry`);
            var p = d.first(m.strMap.values()) || m.defaultFunc;
            if (p) {
                p =
                    0 !== p.GetReturnType();
                const t = 0 !== l.GetReturnType();
                if (p !== t) {
                    console.error(`[Construct 3] Function map '${h}' default: function return type not compatible with other functions in the map; entry ignored`);
                    return
                }
            }
            m.defaultFunc = l
        },
        CallMappedFunction(h, l, m) {
            m = Math.floor(m);
            var p = this._GetFunctionMap(h.toLowerCase(), !1);
            if (p) {
                var t = p.strMap.get(l.toLowerCase());
                if (!t)
                    if (p.defaultFunc) t = p.defaultFunc, m = 0;
                    else {
                        console.warn(`[Construct 3] Call mapped function: no function associated with map '${h}' string '${l}'; call ignored (consider setting a default)`);
                        return
                    } if (t.IsEnabled())
                    if (0 !== t.GetReturnType()) console.warn(`[Construct 3] Call mapped function: map '${h}' string '${l}' has a return type so cannot be called`);
                    else {
                        h = this._runtime;
                        l = h.GetEventSheetManager();
                        var q = l.GetCurrentEvent();
                        p = q.GetSolModifiersIncludingParents();
                        var r = 0 < p.length;
                        r && l.PushCleanSol(p);
                        var u = [];
                        if (q = l.FindFirstFunctionBlockParent(q)) {
                            q = q.GetFunctionParameters();
                            for (let x = m, y = q.length; x < y; ++x) u.push(q[x].GetValue())
                        }
                        m = t.GetFunctionParameters();
                        for (let x = u.length, y = m.length; x <
                            y; ++x) u.push(m[x].GetInitialValue());
                        return h.IsDebugging() ? this._DebugDoCallMappedFunction(l, t, u, r, p) : this._DoCallMappedFunction(l, t, u, r, p)
                    }
            } else console.warn(`[Construct 3] Call mapped function: map name '${h}' not found; call ignored`)
        }
    }
}
"use strict";
{
    const d = self.C3;
    d.Plugins.System.Exps = {
        int: function(b) {
            "string" === typeof b && (b = parseInt(b, 10), isNaN(b) && (b = 0));
            return Math.floor(b)
        },
        float: function(b) {
            "string" === typeof b && (b = parseFloat(b), isNaN(b) && (b = 0));
            return b
        },
        str(b) {
            return b.toString()
        },
        len(b) {
            return "string" === typeof b ? b.length : 0
        },
        random(b, a) {
            return "undefined" === typeof a ? this._runtime.Random() * b : this._runtime.Random() * (a - b) + b
        },
        choose(...b) {
            const a = Math.floor(this._runtime.Random() * b.length);
            return b[a]
        },
        pi() {
            return Math.PI
        },
        infinity() {
            return Infinity
        },
        sqrt(b) {
            return Math.sqrt(b)
        },
        abs(b) {
            return Math.abs(b)
        },
        round(b) {
            return Math.round(b)
        },
        floor(b) {
            return Math.floor(b)
        },
        ceil(b) {
            return Math.ceil(b)
        },
        sign(b) {
            return Math.sign(b)
        },
        sin(b) {
            return Math.sin(d.toRadians(b))
        },
        cos(b) {
            return Math.cos(d.toRadians(b))
        },
        tan(b) {
            return Math.tan(d.toRadians(b))
        },
        asin(b) {
            return d.toDegrees(Math.asin(b))
        },
        acos(b) {
            return d.toDegrees(Math.acos(b))
        },
        atan(b) {
            return d.toDegrees(Math.atan(b))
        },
        exp(b) {
            return Math.exp(b)
        },
        ln(b) {
            return Math.log(b)
        },
        log10(b) {
            return Math.log(b) /
                Math.LN10
        },
        max(...b) {
            let a = b[0];
            "number" !== typeof a && (a = 0);
            for (let f = 1, c = b.length; f < c; ++f) {
                let e = b[f];
                "number" === typeof e && a < e && (a = e)
            }
            return a
        },
        min(...b) {
            let a = b[0];
            "number" !== typeof a && (a = 0);
            for (let f = 1, c = b.length; f < c; ++f) {
                let e = b[f];
                "number" === typeof e && a > e && (a = e)
            }
            return a
        },
        clamp(b, a, f) {
            return d.clamp(b, a, f)
        },
        distance(b, a, f, c) {
            return d.distanceTo(b, a, f, c)
        },
        angle(b, a, f, c) {
            return d.toDegrees(d.angleTo(b, a, f, c))
        },
        lerp(b, a, f) {
            return d.lerp(b, a, f)
        },
        unlerp(b, a, f) {
            return d.unlerp(b, a, f)
        },
        qarp(b, a, f, c) {
            return d.qarp(b,
                a, f, c)
        },
        cubic(b, a, f, c, e) {
            return d.cubic(b, a, f, c, e)
        },
        cosp(b, a, f) {
            return d.cosp(b, a, f)
        },
        anglediff(b, a) {
            return d.toDegrees(d.angleDiff(d.toRadians(b), d.toRadians(a)))
        },
        anglelerp(b, a, f) {
            return d.toDegrees(d.angleLerp(d.toRadians(b), d.toRadians(a), f))
        },
        anglerotate(b, a, f) {
            return d.toDegrees(d.angleRotate(d.toRadians(b), d.toRadians(a), d.toRadians(f)))
        },
        setbit(b, a, f) {
            a |= 0;
            return (b | 0) & ~(1 << a) | (0 !== f ? 1 : 0) << a
        },
        togglebit(b, a) {
            return (b | 0) ^ 1 << (a | 0)
        },
        getbit(b, a) {
            return (b | 0) & 1 << (a | 0) ? 1 : 0
        },
        newline() {
            return "\n"
        },
        uppercase(b) {
            return "string" ===
                typeof b ? b.toUpperCase() : ""
        },
        lowercase(b) {
            return "string" === typeof b ? b.toLowerCase() : ""
        },
        left(b, a) {
            return "string" === typeof b ? b.substr(0, a) : ""
        },
        mid(b, a, f) {
            return "string" !== typeof b ? "" : 0 > f ? b.substr(a) : b.substr(a, f)
        },
        right(b, a) {
            return "string" === typeof b ? b.substr(b.length - a) : ""
        },
        trim(b) {
            return "string" === typeof b ? b.trim() : ""
        },
        tokenat(b, a, f) {
            if ("string" !== typeof b || "string" !== typeof f) return "";
            b = b.split(f);
            a = Math.floor(a);
            return 0 > a || a >= b.length ? "" : b[a]
        },
        tokencount(b, a) {
            return "string" === typeof b && "string" ===
                typeof a && b.length ? b.split(a).length : 0
        },
        find(b, a) {
            return "string" === typeof b && "string" === typeof a ? b.search(new RegExp(d.EscapeRegex(a), "i")) : -1
        },
        findcase(b, a) {
            return "string" === typeof b && "string" === typeof a ? b.search(new RegExp(d.EscapeRegex(a), "")) : -1
        },
        replace(b, a, f) {
            return "string" === typeof b && "string" === typeof a && "string" === typeof f ? b.replace(new RegExp(d.EscapeRegex(a), "gi"), f) : "string" === typeof b ? b : ""
        },
        regexsearch(b, a, f) {
            a = this.GetRegex(a, f);
            return b ? b.search(a) : -1
        },
        regexreplace(b, a, f, c) {
            a = this.GetRegex(a,
                f);
            return b ? b.replace(a, c) : ""
        },
        regexmatchcount(b, a, f) {
            return (b = this.GetRegexMatches(b.toString(), a, f)) ? b.length : 0
        },
        regexmatchat(b, a, f, c) {
            c = Math.floor(c);
            b = this.GetRegexMatches(b.toString(), a, f);
            return !b || 0 > c || c >= b.length ? "" : b[c]
        },
        zeropad(b, a) {
            let f = 0 > b ? "-" : "";
            0 > b && (b = -b);
            f += "0".repeat(Math.max(a - b.toString().length, 0));
            return f + b.toString()
        },
        urlencode(b) {
            return encodeURIComponent(b)
        },
        urldecode(b) {
            return decodeURIComponent(b)
        },
        dt() {
            return this._runtime._GetDtFast()
        },
        timescale() {
            return this._runtime.GetTimeScale()
        },
        wallclocktime() {
            return (Date.now() - this._runtime.GetStartTime()) / 1E3
        },
        unixtime() {
            return Date.now()
        },
        time() {
            return this._runtime.GetGameTime()
        },
        tickcount() {
            return this._runtime.GetTickCount()
        },
        objectcount() {
            return this._runtime.GetObjectCount()
        },
        fps() {
            return this._runtime.GetFPS()
        },
        cpuutilisation() {
            return this._runtime.GetMainThreadTime()
        },
        gpuutilisation() {
            return this._runtime.GetGPUUtilisation()
        },
        windowwidth() {
            return this._runtime.GetCanvasManager().GetDeviceWidth()
        },
        windowheight() {
            return this._runtime.GetCanvasManager().GetDeviceHeight()
        },
        originalwindowwidth() {
            return this._runtime.GetOriginalViewportWidth()
        },
        originalwindowheight() {
            return this._runtime.GetOriginalViewportHeight()
        },
        originalviewportwidth() {
            return this._runtime.GetOriginalViewportWidth()
        },
        originalviewportheight() {
            return this._runtime.GetOriginalViewportHeight()
        },
        scrollx() {
            return this._runtime.GetCurrentLayout().GetScrollX()
        },
        scrolly() {
            return this._runtime.GetCurrentLayout().GetScrollY()
        },
        layoutname() {
            return this._runtime.GetCurrentLayout().GetName()
        },
        layoutscale() {
            return this._runtime.GetCurrentLayout().GetScale()
        },
        layoutangle() {
            return d.toDegrees(this._runtime.GetCurrentLayout().GetAngle())
        },
        layoutwidth() {
            return this._runtime.GetCurrentLayout().GetWidth()
        },
        layoutheight() {
            return this._runtime.GetCurrentLayout().GetHeight()
        },
        viewportleft(b) {
            return (b = this._runtime.GetCurrentLayout().GetLayer(b)) ? b.GetViewport().getLeft() : 0
        },
        viewporttop(b) {
            return (b = this._runtime.GetCurrentLayout().GetLayer(b)) ? b.GetViewport().getTop() : 0
        },
        viewportright(b) {
            return (b = this._runtime.GetCurrentLayout().GetLayer(b)) ? b.GetViewport().getRight() :
                0
        },
        viewportbottom(b) {
            return (b = this._runtime.GetCurrentLayout().GetLayer(b)) ? b.GetViewport().getBottom() : 0
        },
        viewportwidth(b) {
            return (b = this._runtime.GetCurrentLayout().GetLayer(b)) ? b.GetViewport().width() : 0
        },
        viewportheight(b) {
            return (b = this._runtime.GetCurrentLayout().GetLayer(b)) ? b.GetViewport().height() : 0
        },
        canvastolayerx(b, a, f) {
            return (b = this._runtime.GetCurrentLayout().GetLayer(b)) ? b.CanvasCssToLayer(a, f)[0] : 0
        },
        canvastolayery(b, a, f) {
            return (b = this._runtime.GetCurrentLayout().GetLayer(b)) ? b.CanvasCssToLayer(a,
                f)[1] : 0
        },
        layertocanvasx(b, a, f) {
            return (b = this._runtime.GetCurrentLayout().GetLayer(b)) ? b.LayerToCanvasCss(a, f)[0] : 0
        },
        layertocanvasy(b, a, f) {
            return (b = this._runtime.GetCurrentLayout().GetLayer(b)) ? b.LayerToCanvasCss(a, f)[1] : 0
        },
        layerscale(b) {
            return (b = this._runtime.GetCurrentLayout().GetLayer(b)) ? b.GetOwnScale() : 0
        },
        layerangle(b) {
            return (b = this._runtime.GetCurrentLayout().GetLayer(b)) ? d.toDegrees(b.GetOwnAngle()) : 0
        },
        layeropacity(b) {
            return (b = this._runtime.GetCurrentLayout().GetLayer(b)) ? 100 * b.GetOpacity() :
                0
        },
        layerscalerate(b) {
            return (b = this._runtime.GetCurrentLayout().GetLayer(b)) ? b.GetScaleRate() : 0
        },
        layerparallaxx(b) {
            return (b = this._runtime.GetCurrentLayout().GetLayer(b)) ? 100 * b.GetParallaxX() : 0
        },
        layerparallaxy(b) {
            return (b = this._runtime.GetCurrentLayout().GetLayer(b)) ? 100 * b.GetParallaxY() : 0
        },
        layerzelevation(b) {
            return (b = this._runtime.GetCurrentLayout().GetLayer(b)) ? b.GetZElevation() : 0
        },
        layerindex(b) {
            return (b = this._runtime.GetCurrentLayout().GetLayer(b)) ? b.GetIndex() : -1
        },
        canvassnapshot() {
            const b = this._runtime.GetCanvasManager();
            return b ? b.GetCanvasSnapshotUrl() : ""
        },
        loopindex(b) {
            const a = this._loopStack;
            return a.IsInLoop() ? b ? (b = a.FindByName(b)) ? b.GetIndex() : 0 : a.GetCurrent().GetIndex() : 0
        },
        savestatejson() {
            return this._runtime.GetLastSaveJsonString()
        },
        callmapped(b, a, ...f) {
            var c = this._GetFunctionMap(b.toLowerCase(), !1);
            if (!c) return console.warn(`[Construct 3] Call mapped function: map name '${b}' not found; returning 0`), 0;
            var e = c.strMap.get(a.toLowerCase());
            if (!e)
                if (c.defaultFunc) e = c.defaultFunc;
                else return console.warn(`[Construct 3] Call mapped function: no function associated with map '${b}' string '${a}'; returning 0 (consider setting a default)`),
                    0;
            c = e.GetReturnType();
            const g = e.GetDefaultReturnValue();
            if (0 === c) return console.warn(`[Construct 3] Call mapped function: map '${b}' string '${a}' has no return type so cannot be called from an expression; returning 0`), 0;
            if (!e.IsEnabled()) return g;
            b = this._runtime.GetEventSheetManager();
            a = b.GetCurrentEvent().GetSolModifiersIncludingParents();
            const h = 0 < a.length;
            h && b.PushCleanSol(a);
            const l = e.GetFunctionParameters();
            for (let m = f.length, p = l.length; m < p; ++m) f.push(l[m].GetInitialValue());
            e = e.GetEventBlock();
            f = e.RunAsExpressionFunctionCall(e.GetSolModifiersIncludingParents(), c, g, ...f);
            h && b.PopSol(a);
            return f
        },
        loadingprogress() {
            return this._runtime.GetAssetManager().GetLoadProgress()
        },
        imageloadingprogress() {
            return 0 === this._imagesLoadingTotal ? 1 : this._imagesLoadingComplete / this._imagesLoadingTotal
        },
        renderer() {
            return "webgl"
        },
        rendererdetail() {
            return this._runtime.GetWebGLRenderer().GetUnmaskedRenderer()
        },
        imagememoryusage() {
            let b = this._runtime.GetWebGLRenderer().GetEstimatedTextureMemoryUsage();
            return Math.round(100 *
                b / 1048576) / 100
        },
        rgb(b, a, f) {
            return d.PackRGB(b, a, f)
        },
        rgbex(b, a, f) {
            return d.PackRGBEx(b / 100, a / 100, f / 100)
        },
        rgba(b, a, f, c) {
            return d.PackRGBAEx(b / 100, a / 100, f / 100, c / 100)
        },
        rgbex255(b, a, f) {
            return d.PackRGBEx(b / 255, a / 255, f / 255)
        },
        rgba255(b, a, f, c) {
            return d.PackRGBAEx(b / 255, a / 255, f / 255, c / 255)
        },
        projectname() {
            return this._runtime.GetProjectName()
        },
        projectversion() {
            return this._runtime.GetProjectVersion()
        },
        currenteventsheetname() {
            return this._runtime.GetCurrentEvent().GetEventSheet().GetName()
        },
        currenteventnumber() {
            return this._runtime.GetCurrentEvent().GetDisplayNumber()
        }
    }
}
"use strict";
{
    const d = self.C3;
    d.Plugins.TiledBg = class extends d.SDKPluginBase {
        constructor(b) {
            super(b)
        }
        Release() {
            super.Release()
        }
    }
}
"use strict";
{
    const d = self.C3;

    function b(a) {
        switch (a) {
            case 0:
                return "clamp-to-edge";
            case 2:
                return "mirror-repeat"
        }
        return "repeat"
    }
    d.Plugins.TiledBg.Type = class extends d.SDKTypeBase {
        constructor(a, f) {
            super(a);
            this._wrapY = this._wrapX = "repeat";
            f && (this._wrapX = b(f[0]), this._wrapY = b(f[1]))
        }
        Release() {
            super.Release()
        }
        OnCreate() {
            this.GetImageInfo().LoadAsset(this._runtime)
        }
        LoadTextures(a) {
            return this.GetImageInfo().LoadStaticTexture(a, {
                sampling: this._runtime.GetSampling(),
                wrapX: this._wrapX,
                wrapY: this._wrapY
            })
        }
        ReleaseTextures() {
            this.GetImageInfo().ReleaseTexture()
        }
    }
}
"use strict";
{
    const d = self.C3,
        b = d.New(d.Rect),
        a = d.New(d.Quad),
        f = d.New(d.Rect),
        c = d.New(d.Quad);
    d.Plugins.TiledBg.Instance = class extends d.SDKWorldInstanceBase {
        constructor(g, h) {
            super(g);
            this._imageOffsetY = this._imageOffsetX = 0;
            this._imageScaleY = this._imageScaleX = 1;
            this._imageAngle = 0;
            this._ownImageInfo = null;
            h && (this.GetWorldInfo().SetVisible(!!h[0]), this._imageOffsetX = h[4], this._imageOffsetY = h[5], this._imageScaleX = h[6], this._imageScaleY = h[7], this._imageAngle = d.toRadians(h[8]))
        }
        Release() {
            this._ReleaseOwnImage();
            super.Release()
        }
        _ReleaseOwnImage() {
            this._ownImageInfo &&
                (this._ownImageInfo.Release(), this._ownImageInfo = null)
        }
        Draw(g) {
            var h = this.GetCurrentImageInfo(),
                l = h.GetTexture();
            if (null !== l) {
                g.SetTexture(l);
                l = h.GetWidth();
                h = h.GetHeight();
                var m = this._imageOffsetX / l,
                    p = this._imageOffsetY / h,
                    t = this.GetWorldInfo();
                f.set(0, 0, t.GetWidth() / (l * this._imageScaleX), t.GetHeight() / (h * this._imageScaleY));
                f.offset(-m, -p);
                t.HasMesh() ? this._DrawMesh(t, g) : this._DrawStandard(t, g)
            }
        }
        _DrawStandard(g, h) {
            let l = g.GetBoundingQuad();
            this._runtime.IsPixelRoundingEnabled() && (l = g.PixelRoundQuad(l));
            0 === this._imageAngle ? h.Quad3(l, f) : (c.setFromRotatedRect(f, -this._imageAngle), h.Quad4(l, c))
        }
        _DrawMesh(g, h) {
            const l = g.GetTransformedMesh();
            if (g.IsMeshChanged()) {
                g.CalculateBbox(b, a, !1);
                let m = a;
                this._runtime.IsPixelRoundingEnabled() && (m = g.PixelRoundQuad(m));
                let p = f;
                0 !== this._imageAngle && (c.setFromRotatedRect(f, -this._imageAngle), p = c);
                l.CalculateTransformedMesh(g.GetSourceMesh(), m, p);
                g.SetMeshChanged(!1)
            }
            l.Draw(h)
        }
        GetCurrentImageInfo() {
            return this._ownImageInfo || this._objectClass.GetImageInfo()
        }
        _SetMeshChanged() {
            this.GetWorldInfo().SetMeshChanged(!0)
        }
        _SetImageOffsetX(g) {
            this._imageOffsetX !==
                g && (this._imageOffsetX = g, this._runtime.UpdateRender(), this._SetMeshChanged())
        }
        _GetImageOffsetX() {
            return this._imageOffsetX
        }
        _SetImageOffsetY(g) {
            this._imageOffsetY !== g && (this._imageOffsetY = g, this._runtime.UpdateRender(), this._SetMeshChanged())
        }
        _GetImageOffsetY() {
            return this._imageOffsetY
        }
        _SetImageScaleX(g) {
            this._imageScaleX !== g && (this._imageScaleX = g, this._runtime.UpdateRender(), this._SetMeshChanged())
        }
        _GetImageScaleX() {
            return this._imageScaleX
        }
        _SetImageScaleY(g) {
            this._imageScaleY !== g && (this._imageScaleY =
                g, this._runtime.UpdateRender(), this._SetMeshChanged())
        }
        _GetImageScaleY() {
            return this._imageScaleY
        }
        _SetImageAngle(g) {
            this._imageAngle !== g && (this._imageAngle = g, this._runtime.UpdateRender(), this._SetMeshChanged())
        }
        _GetImageAngle() {
            return this._imageAngle
        }
        GetPropertyValueByIndex(g) {
            switch (g) {
                case 4:
                    return this._GetImageOffsetX();
                case 5:
                    return this._GetImageOffsetY();
                case 6:
                    return this._GetImageScaleX();
                case 7:
                    return this._GetImageScaleY();
                case 8:
                    return this._GetImageAngle()
            }
        }
        SetPropertyValueByIndex(g,
            h) {
            switch (g) {
                case 4:
                    this._SetImageOffsetX(h);
                    break;
                case 5:
                    this._SetImageOffsetY(h);
                    break;
                case 6:
                    this._SetImageScaleX(h);
                    break;
                case 7:
                    this._SetImageScaleY(h);
                    break;
                case 8:
                    this._SetImageAngle(h)
            }
        }
        GetScriptInterfaceClass() {
            return self.ITiledBackgroundInstance
        }
    };
    const e = new WeakMap;
    self.ITiledBackgroundInstance = class extends self.IWorldInstance {
        constructor() {
            super();
            e.set(this, self.IInstance._GetInitInst().GetSdkInstance())
        }
        set imageOffsetX(g) {
            e.get(this)._SetImageOffsetX(g)
        }
        get imageOffsetX() {
            return e.get(this)._GetImageOffsetX()
        }
        set imageOffsetY(g) {
            e.get(this)._SetImageOffsetY(g)
        }
        get imageOffsetY() {
            return e.get(this)._GetImageOffsetY()
        }
        set imageScaleX(g) {
            e.get(this)._SetImageScaleX(g)
        }
        get imageScaleX() {
            return e.get(this)._GetImageScaleX()
        }
        set imageScaleY(g) {
            e.get(this)._SetImageScaleY(g)
        }
        get imageScaleY() {
            return e.get(this)._GetImageScaleY()
        }
        set imageAngle(g) {
            e.get(this)._SetImageAngle(g)
        }
        get imageAngle() {
            return e.get(this)._GetImageAngle()
        }
        set imageAngleDegrees(g) {
            e.get(this)._SetImageAngle(d.toRadians(g))
        }
        get imageAngleDegrees() {
            return d.toDegrees(e.get(this)._GetImageAngle())
        }
    }
}
"use strict";
self.C3.Plugins.TiledBg.Cnds = {
    OnURLLoaded() {
        return !0
    },
    OnURLFailed() {
        return !0
    }
};
"use strict";
{
    const d = self.C3;
    d.Plugins.TiledBg.Acts = {
        SetImageOffsetX(b) {
            this._SetImageOffsetX(b)
        },
        SetImageOffsetY(b) {
            this._SetImageOffsetY(b)
        },
        SetImageScaleX(b) {
            this._SetImageScaleX(b / 100)
        },
        SetImageScaleY(b) {
            this._SetImageScaleY(b / 100)
        },
        SetImageAngle(b) {
            this._SetImageAngle(d.toRadians(b))
        },
        SetEffect(b) {
            this.GetWorldInfo().SetBlendMode(b);
            this._runtime.UpdateRender()
        },
        async LoadURL(b, a) {
            if (!this._ownImageInfo || this._ownImageInfo.GetURL() !== b) {
                a = this._runtime;
                var f = d.New(d.ImageInfo);
                await f.LoadDynamicAsset(a,
                    b);
                if (f.IsLoaded()) {
                    if (this.WasReleased()) return f.Release(), null;
                    await f.LoadStaticTexture(a.GetWebGLRenderer(), {
                        sampling: this._runtime.GetSampling(),
                        wrapX: "repeat",
                        wrapY: "repeat"
                    }) && (this.WasReleased() ? f.Release() : (this._ReleaseOwnImage(), this._ownImageInfo = f, a.UpdateRender(), await this.TriggerAsync(d.Plugins.TiledBg.Cnds.OnURLLoaded)))
                } else this.Trigger(d.Plugins.TiledBg.Cnds.OnURLFailed)
            }
        }
    }
}
"use strict";
{
    const d = self.C3;
    d.Plugins.TiledBg.Exps = {
        ImageWidth() {
            return this.GetCurrentImageInfo().GetWidth()
        },
        ImageHeight() {
            return this.GetCurrentImageInfo().GetHeight()
        },
        ImageOffsetX() {
            return this._imageOffsetX
        },
        ImageOffsetY() {
            return this._imageOffsetY
        },
        ImageScaleX() {
            return 100 * this._imageScaleX
        },
        ImageScaleY() {
            return 100 * this._imageScaleY
        },
        ImageAngle() {
            return d.toDegrees(this._imageAngle)
        }
    }
}
"use strict";
{
    const d = self.C3;
    d.Plugins.Sprite = class extends d.SDKPluginBase {
        constructor(b) {
            super(b)
        }
        Release() {
            super.Release()
        }
    }
}
"use strict";
{
    const d = self.C3;
    d.Plugins.Sprite.Type = class extends d.SDKTypeBase {
        constructor(b) {
            super(b);
            this._animations = b.GetAnimations()
        }
        Release() {
            d.clearArray(this._animations);
            super.Release()
        }
        OnCreate() {
            for (const b of this._animations) b.LoadAllAssets(this._runtime)
        }
        LoadTextures(b) {
            const a = {
                sampling: this._runtime.GetSampling()
            };
            return Promise.all(this._animations.map(f => f.LoadAllTextures(b, a)))
        }
        ReleaseTextures() {
            for (const b of this._animations) b.ReleaseAllTextures()
        }
        OnDynamicTextureLoadComplete() {
            this._UpdateAllCurrentTexture()
        }
        _UpdateAllCurrentTexture() {
            for (const b of this._objectClass.instancesIncludingPendingCreate()) b.GetSdkInstance()._UpdateCurrentTexture()
        }
        FinishCondition(b) {
            d.Plugins.Sprite._FinishCondition(this,
                b)
        }
    }
}
"use strict";
{
    const d = self.C3,
        b = d.New(d.Rect),
        a = d.New(d.Quad),
        f = d.New(d.Vector2);
    d.Plugins.Sprite.Instance = class extends d.SDKWorldInstanceBase {
        constructor(g, h) {
            super(g);
            let l = !0,
                m = "",
                p = 0,
                t = !0;
            h && (l = !!h[0], m = h[1], p = h[2], t = h[3]);
            this._currentAnimation = this._objectClass.GetAnimationByName(m) || this._objectClass.GetAnimations()[0];
            this._currentFrameIndex = d.clamp(p, 0, this._currentAnimation.GetFrameCount() - 1);
            this._currentAnimationFrame = this._currentAnimation.GetFrameAt(this._currentFrameIndex);
            h = this._currentAnimationFrame.GetImageInfo();
            this._currentTexture = h.GetTexture();
            this._currentRcTex = h.GetTexRect();
            this.HandleWebGLContextLoss();
            g.SetFlag(2, !0);
            g.SetFlag(1, 0 <= this._currentAnimation.GetSpeed());
            this._currentAnimationSpeed = Math.abs(this._currentAnimation.GetSpeed());
            this._currentAnimationRepeatTo = this._currentAnimation.GetRepeatTo();
            this._animationTimer = d.New(d.KahanSum);
            this._animationRepeats = this._frameStartTime = 0;
            this._animTriggerName = "";
            this._changeAnimFrameIndex = -1;
            this._changeAnimationName = "";
            this._changeAnimationFrom =
                0;
            g = this.GetWorldInfo();
            this._bquadRef = g.GetBoundingQuad();
            g.SetVisible(l);
            g.SetCollisionEnabled(t);
            g.SetOriginX(this._currentAnimationFrame.GetOriginX());
            g.SetOriginY(this._currentAnimationFrame.GetOriginY());
            g.SetSourceCollisionPoly(this._currentAnimationFrame.GetCollisionPoly());
            g.SetBboxChanged();
            1 === this._objectClass.GetAnimationCount() && 1 === this._objectClass.GetAnimations()[0].GetFrameCount() || 0 === this._currentAnimationSpeed || this._StartTicking()
        }
        Release() {
            this._animationTimer = this._currentTexture =
                this._currentAnimationFrame = this._currentAnimation = null;
            super.Release()
        }
        GetCurrentImageInfo() {
            return this._currentAnimationFrame.GetImageInfo()
        }
        OnWebGLContextLost() {
            this._currentTexture = null
        }
        OnWebGLContextRestored() {
            this._UpdateCurrentTexture()
        }
        Draw(g) {
            var h = this._currentTexture;
            null !== h && (g.SetTexture(h), h = this.GetWorldInfo(), h.HasMesh() ? this._DrawMesh(h, g) : this._DrawStandard(h, g))
        }
        _DrawStandard(g, h) {
            let l = this._bquadRef;
            this._runtime.IsPixelRoundingEnabled() && (l = g.PixelRoundQuad(l));
            h.Quad3(l, this._currentRcTex)
        }
        _DrawMesh(g,
            h) {
            const l = g.GetTransformedMesh();
            if (g.IsMeshChanged()) {
                g.CalculateBbox(b, a, !1);
                let m = a;
                this._runtime.IsPixelRoundingEnabled() && (m = g.PixelRoundQuad(m));
                l.CalculateTransformedMesh(g.GetSourceMesh(), m, this._currentRcTex);
                g.SetMeshChanged(!1)
            }
            l.Draw(h)
        }
        GetAnimationTime() {
            return this._animationTimer.Get()
        }
        IsAnimationPlaying() {
            return this._inst.GetFlag(2)
        }
        SetAnimationPlaying(g) {
            this._inst.SetFlag(2, g)
        }
        IsPlayingForwards() {
            return this._inst.GetFlag(1)
        }
        SetPlayingForwards(g) {
            this._inst.SetFlag(1, g)
        }
        IsInAnimationTrigger() {
            return this._inst.GetFlag(4)
        }
        SetInAnimationTrigger(g) {
            this._inst.SetFlag(4,
                g)
        }
        Tick() {
            this._changeAnimationName && this._DoChangeAnimation();
            0 <= this._changeAnimFrameIndex && this._DoChangeAnimFrame();
            const g = this._currentAnimationSpeed;
            if (this.IsAnimationPlaying() && 0 !== g) {
                var h = this._runtime.GetDt(this._inst);
                this._animationTimer.Add(h);
                h = this.GetAnimationTime();
                var l = this._currentAnimationFrame,
                    m = l.GetDuration() / g;
                if (!(h < this._frameStartTime + m)) {
                    var p = this._currentAnimation,
                        t = this._currentAnimationRepeatTo,
                        q = p.GetFrameCount(),
                        r = p.GetRepeatCount(),
                        u = p.IsLooping(),
                        x = p.IsPingPong();
                    this.IsPlayingForwards() ? this._currentFrameIndex++ : this._currentFrameIndex--;
                    this._frameStartTime += m;
                    this._currentFrameIndex >= q && (x ? (this.SetPlayingForwards(!1), this._currentFrameIndex = q - 2) : u ? this._currentFrameIndex = t : (this._animationRepeats++, this._animationRepeats >= r ? this._FinishAnimation(!1) : this._currentFrameIndex = t));
                    0 > this._currentFrameIndex && (x ? (this._currentFrameIndex = 1, this.SetPlayingForwards(!0), u || (this._animationRepeats++, this._animationRepeats >= r && this._FinishAnimation(!0))) : u ? this._currentFrameIndex =
                        t : (this._animationRepeats++, this._animationRepeats >= r ? this._FinishAnimation(!0) : this._currentFrameIndex = t));
                    this._currentFrameIndex = d.clamp(this._currentFrameIndex, 0, q - 1);
                    m = p.GetFrameAt(this._currentFrameIndex);
                    h > this._frameStartTime + m.GetDuration() / g && (this._frameStartTime = h);
                    this._OnFrameChanged(l, m)
                }
            } else this._StopTicking()
        }
        _FinishAnimation(g) {
            this._currentFrameIndex = g ? 0 : this._currentAnimation.GetFrameCount() - 1;
            this.SetAnimationPlaying(!1);
            this._animTriggerName = this._currentAnimation.GetName();
            this.SetInAnimationTrigger(!0);
            this.Trigger(d.Plugins.Sprite.Cnds.OnAnyAnimFinished);
            this.Trigger(d.Plugins.Sprite.Cnds.OnAnimFinished);
            this.SetInAnimationTrigger(!1);
            this._animationRepeats = 0
        }
        _OnFrameChanged(g, h) {
            if (g !== h) {
                var l = this.GetWorldInfo(),
                    m = g.GetImageInfo(),
                    p = h.GetImageInfo(),
                    t = m.GetWidth();
                m = m.GetHeight();
                var q = p.GetWidth(),
                    r = p.GetHeight();
                t !== q && l.SetWidth(l.GetWidth() * (q / t));
                m !== r && l.SetHeight(l.GetHeight() * (r / m));
                l.SetOriginX(h.GetOriginX());
                l.SetOriginY(h.GetOriginY());
                l.SetSourceCollisionPoly(h.GetCollisionPoly());
                l.SetBboxChanged();
                this._currentAnimationFrame = h;
                this._currentTexture = p.GetTexture();
                this._currentRcTex = p.GetTexRect();
                l = this.GetInstance().GetBehaviorInstances();
                for (let u = 0, x = l.length; u < x; ++u) l[u].OnSpriteFrameChanged(g, h);
                this.Trigger(d.Plugins.Sprite.Cnds.OnFrameChanged);
                this._runtime.UpdateRender()
            }
        }
        _StartAnim(g) {
            this.SetAnimationPlaying(!0);
            this._frameStartTime = this.GetAnimationTime();
            1 === g && 0 !== this._currentFrameIndex && (this._changeAnimFrameIndex = 0, this.IsInAnimationTrigger() || this._DoChangeAnimFrame());
            this._StartTicking()
        }
        _SetAnim(g, h) {
            this._changeAnimationName = g;
            this._changeAnimationFrom = h;
            this._StartTicking();
            this.IsInAnimationTrigger() || this._DoChangeAnimation()
        }
        _GetCurrentAnimationName() {
            return this._changeAnimationName ? this._changeAnimationName : this._currentAnimation.GetName()
        }
        _SetAnimFrame(g) {
            isFinite(g) && (this._changeAnimFrameIndex = g, this.IsInAnimationTrigger() || this._DoChangeAnimFrame())
        }
        _GetAnimFrame() {
            return this._currentFrameIndex
        }
        _SetAnimSpeed(g) {
            this._currentAnimationSpeed = Math.abs(g);
            this.SetPlayingForwards(0 <= g);
            0 < this._currentAnimationSpeed && this._StartTicking()
        }
        _GetAnimSpeed() {
            return this.IsPlayingForwards() ? this._currentAnimationSpeed : -this._currentAnimationSpeed
        }
        _SetAnimRepeatToFrame(g) {
            this._currentAnimationRepeatTo = g = d.clamp(Math.floor(g), 0, this._currentAnimation.GetFrameCount() - 1)
        }
        _GetAnimRepeatToFrame() {
            return this._currentAnimationRepeatTo
        }
        _DoChangeAnimation() {
            const g = this._currentAnimationFrame;
            var h = this._objectClass.GetAnimationByName(this._changeAnimationName);
            this._changeAnimationName =
                "";
            !h || h === this._currentAnimation && this.IsAnimationPlaying() || (this._currentAnimation = h, this.SetPlayingForwards(0 <= h.GetSpeed()), this._currentAnimationSpeed = Math.abs(h.GetSpeed()), this._currentAnimationRepeatTo = h.GetRepeatTo(), this._currentFrameIndex = d.clamp(this._currentFrameIndex, 0, this._currentAnimation.GetFrameCount() - 1), 1 === this._changeAnimationFrom && (this._currentFrameIndex = 0), this.SetAnimationPlaying(!0), this._frameStartTime = this.GetAnimationTime(), h = this._currentAnimation.GetFrameAt(this._currentFrameIndex),
                this._OnFrameChanged(g, h))
        }
        _DoChangeAnimFrame() {
            const g = this._currentAnimationFrame;
            var h = this._currentFrameIndex;
            this._currentFrameIndex = d.clamp(Math.floor(this._changeAnimFrameIndex), 0, this._currentAnimation.GetFrameCount() - 1);
            this._changeAnimFrameIndex = -1;
            h !== this._currentFrameIndex && (h = this._currentAnimation.GetFrameAt(this._currentFrameIndex), this._OnFrameChanged(g, h), this._frameStartTime = this.GetAnimationTime())
        }
        _UpdateCurrentTexture() {
            const g = this._currentAnimationFrame.GetImageInfo();
            this._currentTexture =
                g.GetTexture();
            this._currentRcTex = g.GetTexRect();
            this.GetWorldInfo().SetMeshChanged(!0)
        }
        GetImagePointCount() {
            return this._currentAnimationFrame.GetImagePointCount()
        }
        GetImagePoint(g) {
            const h = this._currentAnimationFrame,
                l = this.GetWorldInfo();
            if ("string" === typeof g) g = h.GetImagePointByName(g);
            else if ("number" === typeof g) g = h.GetImagePointByIndex(g - 1);
            else throw new TypeError("expected string or number");
            if (!g) return [l.GetX(), l.GetY()];
            f.copy(g.GetVec2());
            if (l.HasMesh()) {
                const [m, p] = l.GetSourceMesh().TransformPoint(f.getX(),
                    f.getY());
                f.set(m, p)
            }
            f.offset(-h.GetOriginX(), -h.GetOriginY());
            f.scale(l.GetWidth(), l.GetHeight());
            f.rotate(l.GetAngle());
            f.offset(l.GetX(), l.GetY());
            return [f.getX(), f.getY()]
        }
        GetCollisionPolyPointCount() {
            return this.GetWorldInfo().GetTransformedCollisionPoly().pointCount()
        }
        GetCollisionPolyPoint(g) {
            g = Math.floor(g);
            const h = this.GetWorldInfo();
            var l = h.GetTransformedCollisionPoly();
            const m = l.pointCount();
            g === m && (g = 0);
            if (0 > g || g >= m) return [0, 0];
            l = l.pointsArr();
            return [l[2 * g] + h.GetX(), l[2 * g + 1] + h.GetY()]
        }
        GetDebuggerProperties() {
            const g =
                d.Plugins.Sprite.Acts;
            return [{
                title: "plugins.sprite.debugger.animation-properties.title",
                properties: [{
                    name: "plugins.sprite.debugger.animation-properties.current-animation",
                    value: this._currentAnimation.GetName(),
                    onedit: h => this.CallAction(g.SetAnim, h, 0)
                }, {
                    name: "plugins.sprite.debugger.animation-properties.current-frame",
                    value: this._currentFrameIndex,
                    onedit: h => this.CallAction(g.SetAnimFrame, h)
                }, {
                    name: "plugins.sprite.debugger.animation-properties.is-playing",
                    value: this.IsAnimationPlaying(),
                    onedit: h =>
                        h ? this.CallAction(g.StartAnim, 0) : this.CallAction(g.StopAnim)
                }, {
                    name: "plugins.sprite.debugger.animation-properties.speed",
                    value: this._currentAnimationSpeed,
                    onedit: h => this.CallAction(g.SetAnimSpeed, h)
                }, {
                    name: "plugins.sprite.debugger.animation-properties.repeats",
                    value: this._animationRepeats,
                    onedit: h => this._animationRepeats = h
                }]
            }]
        }
        SaveToJson() {
            const g = {
                a: this._currentAnimation.GetSID()
            };
            0 !== this._frameStartTime && (g.fs = this._frameStartTime);
            var h = this.GetAnimationTime();
            0 !== h && (g.at = h);
            0 !== this._currentFrameIndex &&
                (g.f = this._currentFrameIndex);
            0 !== this._currentAnimationSpeed && (g.cas = this._currentAnimationSpeed);
            1 !== this._animationRepeats && (g.ar = this._animationRepeats);
            0 !== this._currentAnimationRepeatTo && (g.rt = this._currentAnimationRepeatTo);
            this.IsAnimationPlaying() || (g.ap = this.IsAnimationPlaying());
            this.IsPlayingForwards() || (g.af = this.IsPlayingForwards());
            h = this.GetWorldInfo();
            h.IsCollisionEnabled() && (g.ce = h.IsCollisionEnabled());
            return g
        }
        LoadFromJson(g) {
            var h = this.GetObjectClass().GetAnimationBySID(g.a);
            h && (this._currentAnimation = h);
            this._frameStartTime = g.hasOwnProperty("fs") ? g.fs : 0;
            this._animationTimer.Set(g.hasOwnProperty("at") ? g.at : 0);
            h = g.hasOwnProperty("f") ? g.f : 0;
            this._currentFrameIndex = d.clamp(h, 0, this._currentAnimation.GetFrameCount() - 1);
            this._currentAnimationSpeed = g.hasOwnProperty("cas") ? g.cas : 0;
            this._animationRepeats = g.hasOwnProperty("ar") ? g.ar : 1;
            h = g.hasOwnProperty("rt") ? g.rt : 0;
            this._currentAnimationRepeatTo = d.clamp(h, 0, this._currentAnimation.GetFrameCount() - 1);
            this.SetAnimationPlaying(g.hasOwnProperty("ap") ?
                !!g.ap : !0);
            this.SetPlayingForwards(g.hasOwnProperty("af") ? !!g.af : !0);
            this._currentAnimationFrame = h = this._currentAnimation.GetFrameAt(this._currentFrameIndex);
            this._UpdateCurrentTexture();
            const l = this.GetWorldInfo();
            l.SetOriginX(h.GetOriginX());
            l.SetOriginY(h.GetOriginY());
            l.SetSourceCollisionPoly(h.GetCollisionPoly());
            l.SetCollisionEnabled(!!g.ce)
        }
        GetPropertyValueByIndex(g) {
            const h = this.GetWorldInfo();
            switch (g) {
                case 3:
                    return h.IsCollisionEnabled();
                case 2:
                    return d.clamp(this._currentFrameIndex, 0, this._currentAnimation.GetFrameCount() -
                        1)
            }
        }
        SetPropertyValueByIndex(g, h) {
            var l = this.GetWorldInfo();
            switch (g) {
                case 3:
                    l.SetCollisionEnabled(!!h);
                    break;
                case 2:
                    this.SetAnimationPlaying(!1);
                    g = this._currentAnimation.GetFrameCount() - 1;
                    l = h = d.clamp(h, 0, g);
                    h = this._currentAnimation.GetFrameAt(this._currentFrameIndex);
                    const m = this._currentAnimation.GetFrameAt(l);
                    this._OnFrameChanged(h, m);
                    this._currentFrameIndex = d.clamp(l, 0, g)
            }
        }
        GetScriptInterfaceClass() {
            return self.ISpriteInstance
        }
    };
    const c = new WeakMap,
        e = new Map([
            ["current-frame", 0],
            ["beginning", 1]
        ]);
    self.ISpriteInstance = class extends self.IWorldInstance {
        constructor() {
            super();
            c.set(this, self.IInstance._GetInitInst().GetSdkInstance())
        }
        getImagePointCount() {
            return c.get(this).GetImagePointCount()
        }
        getImagePointX(g) {
            if ("string" !== typeof g && "number" !== typeof g) throw new TypeError("expected string or number");
            return c.get(this).GetImagePoint(g)[0]
        }
        getImagePointY(g) {
            if ("string" !== typeof g && "number" !== typeof g) throw new TypeError("expected string or number");
            return c.get(this).GetImagePoint(g)[1]
        }
        getImagePoint(g) {
            if ("string" !==
                typeof g && "number" !== typeof g) throw new TypeError("expected string or number");
            return c.get(this).GetImagePoint(g)
        }
        getPolyPointCount() {
            return c.get(this).GetCollisionPolyPointCount()
        }
        getPolyPointX(g) {
            return c.get(this).GetCollisionPolyPoint(g)[0]
        }
        getPolyPointY(g) {
            return c.get(this).GetCollisionPolyPoint(g)[1]
        }
        getPolyPoint(g) {
            return c.get(this).GetCollisionPolyPoint(g)
        }
        stopAnimation() {
            c.get(this).SetAnimationPlaying(!1)
        }
        startAnimation(g = "current-frame") {
            g = e.get(g);
            if ("undefined" === typeof g) throw Error("invalid mode");
            c.get(this)._StartAnim(g)
        }
        setAnimation(g, h = "beginning") {
            h = e.get(h);
            if ("undefined" === typeof h) throw Error("invalid mode");
            c.get(this)._SetAnim(g, h)
        }
        get animationName() {
            return c.get(this)._GetCurrentAnimationName()
        }
        set animationFrame(g) {
            c.get(this)._SetAnimFrame(g)
        }
        get animationFrame() {
            return c.get(this)._GetAnimFrame()
        }
        set animationSpeed(g) {
            c.get(this)._SetAnimSpeed(g)
        }
        get animationSpeed() {
            return c.get(this)._GetAnimSpeed()
        }
        set animationRepeatToFrame(g) {
            c.get(this)._SetAnimRepeatToFrame(g)
        }
        get animationRepeatToFrame() {
            return c.get(this)._GetAnimRepeatToFrame()
        }
        get imageWidth() {
            return c.get(this).GetCurrentImageInfo().GetWidth()
        }
        get imageHeight() {
            return c.get(this).GetCurrentImageInfo().GetHeight()
        }
    }
}
"use strict";
{
    const d = self.C3,
        b = d.New(d.Rect),
        a = [],
        f = [];
    let c = !1,
        e = null,
        g = !1;
    const h = new Set;

    function l(u, x, y, C) {
        const w = x.GetUID(),
            A = y.GetUID();
        w < A ? u.Set(x, y, C) : u.Set(y, x, C)
    }

    function m(u, x, y) {
        const C = x.GetUID(),
            w = y.GetUID();
        C < w ? u.Delete(x, y) : u.Delete(y, x)
    }

    function p(u, x) {
        u.DeleteEither(x)
    }

    function t(u, x, y) {
        const C = x.GetUID(),
            w = y.GetUID();
        return C < w ? u.Get(x, y) : u.Get(y, x)
    }

    function q(u, x, y, C) {
        if (!x) return !1;
        u = u.GetInstance();
        const w = 0 !== y || 0 !== C,
            A = u.GetWorldInfo(),
            E = u.GetRuntime(),
            K = E.GetCollisionEngine();
        var O =
            E.GetCurrentCondition();
        const G = O.GetEventBlock().IsOrBlock();
        var J = O.GetObjectClass();
        O = O.IsInverted();
        const P = x.GetCurrentSol();
        J = J !== x;
        e = x;
        c = J && !O;
        g = !1;
        let R = 0,
            T = 0,
            X = !1;
        P.IsSelectAll() ? (b.copy(A.GetBoundingBox()), b.offset(y, C), K.GetCollisionCandidates(A.GetLayer(), x, b, f), x = f) : G ? E.IsCurrentConditionFirst() && !P._GetOwnElseInstances().length && P._GetOwnInstances().length ? x = P._GetOwnInstances() : (x = P._GetOwnElseInstances(), g = !0) : x = P._GetOwnInstances();
        w && (R = A.GetX(), T = A.GetY(), A.OffsetXY(y, C), A.SetBboxChanged());
        for (const aa of x)
            if (K.TestOverlap(u, aa)) {
                X = !0;
                if (O) break;
                J && h.add(aa)
            } w && (A.SetXY(R, T), A.SetBboxChanged());
        d.clearArray(f);
        return X
    }

    function r(u) {
        u = u.GetRuntime().GetCurrentEvent().IsOrBlock();
        const x = e.GetCurrentSol(),
            y = x._GetOwnInstances(),
            C = x._GetOwnElseInstances();
        x.IsSelectAll() ? (x.SetSetPicked(h), u && (d.clearArray(C), x.AddElseInstances(h, e.GetInstances()))) : u ? g ? x.TransferElseInstancesToOwn(h) : (x.AddElseInstances(h, y), x.SetSetPicked(h)) : x.SetSetPicked(h);
        e.ApplySolToContainer()
    }
    d.Plugins.Sprite._FinishCondition =
        function(u, x) {
            c && (x && r(u), h.clear(), e = null, c = !1)
        };
    d.Plugins.Sprite.Cnds = {
        OnCollision(u) {
            if (this._runtime.IsDebugging()) return d.Plugins.Sprite.Cnds.DebugOnCollision.call(this, u);
            if (!u) return !1;
            var x = this._runtime;
            const y = x.GetCollisionEngine(),
                C = x.GetEventSheetManager(),
                w = C.GetEventStack();
            var A = C.GetCurrentCondition();
            const E = A.GetObjectClass();
            var K = A.GetSavedDataMap(),
                O = A.GetUnsavedDataMap();
            A = w.GetCurrentStackFrame();
            const G = x.GetTickCount(),
                J = G - 1,
                P = A.GetCurrentEvent(),
                R = w.Push(P);
            let T = K.get("collmemory");
            T || (T = d.New(d.PairMap), K.set("collmemory", T));
            O.get("spriteCreatedDestroyCallback") || (O.set("spriteCreatedDestroyCallback", !0), x.Dispatcher().addEventListener("instancedestroy", sa => p(T, sa.instance)));
            K = E.GetCurrentSol();
            x = u.GetCurrentSol();
            K = K.GetInstances();
            O = null;
            for (let sa = 0; sa < K.length; ++sa) {
                const ia = K[sa];
                x.IsSelectAll() ? (y.GetCollisionCandidates(ia.GetWorldInfo().GetLayer(), u, ia.GetWorldInfo().GetBoundingBox(), a), O = a, y.AddRegisteredCollisionCandidates(ia, u, O)) : O = x.GetInstances();
                for (let Aa =
                        0; Aa < O.length; ++Aa) {
                    const ua = O[Aa];
                    if (y.TestOverlap(ia, ua) || y.CheckRegisteredCollision(ia, ua)) {
                        var X = t(T, ia, ua),
                            aa = !1,
                            ea = -2;
                        "number" === typeof X && (aa = !0, ea = X);
                        X = !aa || ea < J;
                        l(T, ia, ua, G);
                        X && (X = P.GetSolModifiers(), C.PushCopySol(X), ea = E.GetCurrentSol(), aa = u.GetCurrentSol(), ea._SetSelectAll(!1), aa._SetSelectAll(!1), E === u ? (aa = ea._GetOwnInstances(), d.clearArray(aa), aa.push(ia), aa.push(ua), E.ApplySolToContainer()) : (ea = ea._GetOwnInstances(), aa = aa._GetOwnInstances(), d.clearArray(ea), d.clearArray(aa), ea.push(ia),
                            aa.push(ua), E.ApplySolToContainer(), u.ApplySolToContainer()), P.Retrigger(A, R), C.PopSol(X))
                    } else m(T, ia, ua)
                }
                d.clearArray(a)
            }
            w.Pop();
            return !1
        },
        * DebugOnCollision(u) {
            if (!u) return !1;
            var x = this._runtime;
            const y = x.GetCollisionEngine(),
                C = x.GetEventSheetManager(),
                w = C.GetEventStack(),
                A = w.GetCurrentStackFrame(),
                E = x.GetTickCount(),
                K = E - 1,
                O = A.GetCurrentEvent(),
                G = w.Push(O);
            var J = C.GetCurrentCondition();
            const P = J.GetObjectClass();
            var R = J.GetSavedDataMap();
            J = J.GetUnsavedDataMap();
            let T = R.get("collmemory");
            T || (T = d.New(d.PairMap),
                R.set("collmemory", T));
            J.get("spriteCreatedDestroyCallback") || (J.set("spriteCreatedDestroyCallback", !0), x.Dispatcher().addEventListener("instancedestroy", sa => p(T, sa.instance)));
            R = P.GetCurrentSol();
            x = u.GetCurrentSol();
            R = R.GetInstances();
            J = null;
            for (let sa = 0; sa < R.length; ++sa) {
                const ia = R[sa];
                x.IsSelectAll() ? (y.GetCollisionCandidates(ia.GetWorldInfo().GetLayer(), u, ia.GetWorldInfo().GetBoundingBox(), a), J = a, y.AddRegisteredCollisionCandidates(ia, u, J)) : J = x.GetInstances();
                for (let Aa = 0; Aa < J.length; ++Aa) {
                    const ua =
                        J[Aa];
                    if (y.TestOverlap(ia, ua) || y.CheckRegisteredCollision(ia, ua)) {
                        var X = t(T, ia, ua),
                            aa = !1,
                            ea = -2;
                        "number" === typeof X && (aa = !0, ea = X);
                        X = !aa || ea < K;
                        l(T, ia, ua, E);
                        X && (X = O.GetSolModifiers(), C.PushCopySol(X), ea = P.GetCurrentSol(), aa = u.GetCurrentSol(), ea._SetSelectAll(!1), aa._SetSelectAll(!1), P === u ? (aa = ea._GetOwnInstances(), d.clearArray(aa), aa.push(ia), aa.push(ua), P.ApplySolToContainer()) : (ea = ea._GetOwnInstances(), aa = aa._GetOwnInstances(), d.clearArray(ea), d.clearArray(aa), ea.push(ia), aa.push(ua), P.ApplySolToContainer(),
                            u.ApplySolToContainer()), yield* O.DebugRetrigger(A, G), C.PopSol(X))
                    } else m(T, ia, ua)
                }
                d.clearArray(a)
            }
            w.Pop();
            return !1
        },
        IsOverlapping(u) {
            return q(this, u, 0, 0)
        },
        IsOverlappingOffset(u, x, y) {
            return q(this, u, x, y)
        },
        IsAnimPlaying(u) {
            return d.equalsNoCase(this._GetCurrentAnimationName(), u)
        },
        CompareFrame(u, x) {
            return d.compare(this._currentFrameIndex, u, x)
        },
        CompareAnimSpeed(u, x) {
            return d.compare(this._GetAnimSpeed(), u, x)
        },
        OnAnimFinished(u) {
            return d.equalsNoCase(this._animTriggerName, u)
        },
        OnAnyAnimFinished() {
            return !0
        },
        OnFrameChanged() {
            return !0
        },
        IsMirrored() {
            return 0 > this.GetWorldInfo().GetWidth()
        },
        IsFlipped() {
            return 0 > this.GetWorldInfo().GetHeight()
        },
        OnURLLoaded() {
            return !0
        },
        OnURLFailed() {
            return !0
        },
        IsCollisionEnabled() {
            return this.GetWorldInfo().IsCollisionEnabled()
        }
    }
}
"use strict";
{
    const d = self.C3;
    d.Plugins.Sprite.Acts = {
        Spawn(b, a, f, c) {
            if (b && a) {
                var [e, g] = this.GetImagePoint(f);
                if (f = this._runtime.CreateInstance(b, a, e, g, c)) {
                    c && a.SortAndAddSceneGraphInstancesByZIndex(f);
                    b.GetPlugin().IsRotatable() && (a = f.GetWorldInfo(), a.SetAngle(this.GetWorldInfo().GetAngle()), a.SetBboxChanged());
                    a = this._runtime.GetEventSheetManager();
                    a.BlockFlushingInstances(!0);
                    f._TriggerOnCreatedOnSelfAndRelated();
                    a.BlockFlushingInstances(!1);
                    c = this._runtime.GetCurrentAction().GetSavedDataMap();
                    a = !1;
                    if (!c.has("Spawn_LastExec") ||
                        c.get("Spawn_LastExec") < this._runtime.GetExecCount()) a = !0, c.set("Spawn_LastExec", this._runtime.GetExecCount());
                    if (b !== this.GetObjectClass() && (b = b.GetCurrentSol(), b._SetSelectAll(!1), b = b._GetOwnInstances(), a && d.clearArray(b), b.push(f), f.IsInContainer()))
                        for (const h of f.siblings()) f = h.GetObjectClass().GetCurrentSol(), a ? f.SetSinglePicked(h) : (f._SetSelectAll(!1), f._PushInstance(h))
                }
            }
        },
        StopAnim() {
            this.SetAnimationPlaying(!1)
        },
        StartAnim(b) {
            this._StartAnim(b)
        },
        SetAnim(b, a) {
            this._SetAnim(b, a)
        },
        SetAnimFrame(b) {
            this._SetAnimFrame(b)
        },
        SetAnimSpeed(b) {
            this._SetAnimSpeed(b)
        },
        SetAnimRepeatToFrame(b) {
            this._SetAnimRepeatToFrame(b)
        },
        SetMirrored(b) {
            const a = this.GetWorldInfo(),
                f = a.GetWidth();
            b = Math.abs(f) * (0 === b ? -1 : 1);
            f !== b && (a.SetWidth(b), a.SetBboxChanged())
        },
        SetFlipped(b) {
            const a = this.GetWorldInfo(),
                f = a.GetHeight();
            b = Math.abs(f) * (0 === b ? -1 : 1);
            f !== b && (a.SetHeight(b), a.SetBboxChanged())
        },
        SetScale(b) {
            const a = this._currentAnimationFrame.GetImageInfo(),
                f = this.GetWorldInfo();
            var c = 0 > f.GetWidth() ? -1 : 1;
            const e = 0 > f.GetHeight() ? -1 : 1;
            c *= a.GetWidth() *
                b;
            b = a.GetHeight() * b * e;
            if (f.GetWidth() !== c || f.GetHeight() !== b) f.SetSize(c, b), f.SetBboxChanged()
        },
        async LoadURL(b, a, f) {
            f = this._currentAnimationFrame.GetImageInfo();
            const c = this.GetWorldInfo(),
                e = this._runtime;
            if (f.GetURL() === b) 0 === a && (c.SetSize(f.GetWidth(), f.GetHeight()), c.SetBboxChanged()), this.Trigger(d.Plugins.Sprite.Cnds.OnURLLoaded);
            else {
                var g = d.New(d.ImageInfo);
                await g.LoadDynamicAsset(e, b);
                g.IsLoaded() ? (await g.LoadStaticTexture(e.GetWebGLRenderer(), {
                        sampling: this._runtime.GetSampling()
                    }), f.ReplaceWith(g),
                    this._sdkType._UpdateAllCurrentTexture(), this.WasReleased() || 0 !== a || (c.SetSize(f.GetWidth(), f.GetHeight()), c.SetBboxChanged()), e.UpdateRender(), this.WasReleased() || await this.TriggerAsync(d.Plugins.Sprite.Cnds.OnURLLoaded)) : this.Trigger(d.Plugins.Sprite.Cnds.OnURLFailed)
            }
        },
        SetCollisions(b) {
            this.GetWorldInfo().SetCollisionEnabled(b)
        },
        SetSolidCollisionFilter(b, a) {
            this.GetWorldInfo().SetSolidCollisionFilter(0 === b, a)
        },
        SetEffect(b) {
            this.GetWorldInfo().SetBlendMode(b);
            this._runtime.UpdateRender()
        }
    }
}
"use strict";
self.C3.Plugins.Sprite.Exps = {
    AnimationFrame() {
        return this._currentFrameIndex
    },
    AnimationFrameCount() {
        return this._currentAnimation.GetFrameCount()
    },
    AnimationName() {
        return this._currentAnimation.GetName()
    },
    AnimationSpeed() {
        return this._GetAnimSpeed()
    },
    OriginalAnimationSpeed() {
        return this._currentAnimation.GetSpeed()
    },
    ImagePointX(d) {
        return this.GetImagePoint(d)[0]
    },
    ImagePointY(d) {
        return this.GetImagePoint(d)[1]
    },
    ImagePointCount() {
        return this.GetImagePointCount()
    },
    ImageWidth() {
        return this.GetCurrentImageInfo().GetWidth()
    },
    ImageHeight() {
        return this.GetCurrentImageInfo().GetHeight()
    },
    PolyPointXAt(d) {
        return this.GetCollisionPolyPoint(d)[0]
    },
    PolyPointYAt(d) {
        return this.GetCollisionPolyPoint(d)[1]
    },
    PolyPointCount() {
        return this.GetCollisionPolyPointCount()
    }
};
"use strict";
{
    const d = self.C3;
    d.Plugins.Text = class extends d.SDKPluginBase {
        constructor(b) {
            super(b)
        }
        Release() {
            super.Release()
        }
    }
}
"use strict";
{
    const d = self.C3;
    d.Plugins.Text.Type = class extends d.SDKTypeBase {
        constructor(b) {
            super(b)
        }
        Release() {
            super.Release()
        }
        OnCreate() {}
        LoadTextures(b) {}
        ReleaseTextures() {}
    }
}
"use strict";
{
    const d = self.C3,
        b = [0, 0, 0],
        a = ["left", "center", "right"],
        f = ["top", "center", "bottom"],
        c = new d.Rect,
        e = new d.Quad;
    d.Plugins.Text.Instance = class extends d.SDKWorldInstanceBase {
        constructor(p, t) {
            super(p);
            this._text = "";
            this._enableBBcode = !0;
            this._faceName = "Arial";
            this._ptSize = 12;
            this._lineHeightOffset = 0;
            this._isItalic = this._isBold = !1;
            this._color = d.New(d.Color);
            this._verticalAlign = this._horizontalAlign = 0;
            this._wrapByWord = !0;
            this._typewriterEndTime = this._typewriterStartTime = -1;
            this._typewriterLength = 0;
            this._rendererText =
                d.New(d.Gfx.RendererText, this._runtime.GetRenderer(), {
                    timeout: 5
                });
            this._rendererText.ontextureupdate = () => this._runtime.UpdateRender();
            this._rendererText.SetIsAsync(!1);
            t && (this._text = t[0], this._enableBBcode = !!t[1], this._faceName = t[2], this._ptSize = t[3], this._lineHeightOffset = t[4], this._isBold = !!t[5], this._isItalic = !!t[6], this._horizontalAlign = t[8], this._verticalAlign = t[9], this._wrapByWord = 0 === t[10], p = t[7], this._color.setRgb(p[0], p[1], p[2]), this.GetWorldInfo().SetVisible(t[11]));
            this._UpdateTextSettings()
        }
        Release() {
            this._CancelTypewriter();
            this._rendererText.Release();
            this._rendererText = null;
            super.Release()
        }
        _UpdateTextSettings() {
            const p = this._rendererText;
            // console.log("IDDQD _UpdateTextSettings " + this._text)
            p.SetText(this._text);
            p.SetBBCodeEnabled(this._enableBBcode);
            p.SetFontName(this._faceName);
            p.SetLineHeight(this._lineHeightOffset);
            p.SetBold(this._isBold);
            p.SetItalic(this._isItalic);
            p.SetColor(this._color);
            p.SetHorizontalAlignment(a[this._horizontalAlign]);
            p.SetVerticalAlignment(f[this._verticalAlign]);
            p.SetWordWrapMode(this._wrapByWord ? "word" : "character")
        }
        _UpdateTextSize() {
            const p =
                this.GetWorldInfo();
            this._rendererText.SetFontSize(this._ptSize * p.GetSceneGraphScale());
            var t = p.GetLayer();
            t = t.GetRenderScale() * t.Get2DScaleFactorToZ(p.GetTotalZElevation());
            this._rendererText.SetSize(p.GetWidth(), p.GetHeight(), t)
        }
        Draw(p) {
            var t = this.GetWorldInfo();
            this._UpdateTextSize();
            const q = this._rendererText.GetTexture();
            if (q) {
                var r = t.GetLayer();
                if (0 !== t.GetAngle() || 0 !== t.GetLayer().GetAngle() || 0 !== t.GetTotalZElevation() || t.HasMesh()) p.SetTexture(q), t.HasMesh() ? this._DrawMesh(t, p) : this._DrawStandard(t,
                    p);
                else {
                    t = t.GetBoundingQuad();
                    const [u, x] = r.LayerToDrawSurface(t.getTlx(), t.getTly()), [y, C] = r.LayerToDrawSurface(t.getBrx(), t.getBry());
                    t = u - Math.round(u);
                    const w = x - Math.round(x);
                    c.set(u, x, y, C);
                    c.offset(-t, -w);
                    e.setFromRect(c);
                    const [A, E] = p.GetRenderTargetSize(p.GetRenderTarget());
                    this._runtime.GetCanvasManager().SetDeviceTransform(p, A, E);
                    p.SetTexture(q);
                    p.Quad3(e, this._rendererText.GetTexRect());
                    r._SetTransform(p)
                }
            }
        }
        _DrawStandard(p, t) {
            p = p.GetBoundingQuad();
            this._runtime.IsPixelRoundingEnabled() &&
                (p = this._PixelRoundQuad(p));
            t.Quad3(p, this._rendererText.GetTexRect())
        }
        _DrawMesh(p, t) {
            const q = p.GetTransformedMesh();
            if (p.IsMeshChanged()) {
                p.CalculateBbox(c, e, !1);
                let r = e;
                this._runtime.IsPixelRoundingEnabled() && (r = this._PixelRoundQuad(r));
                q.CalculateTransformedMesh(p.GetSourceMesh(), r, this._rendererText.GetTexRect());
                p.SetMeshChanged(!1)
            }
            q.Draw(t)
        }
        _PixelRoundQuad(p) {
            const t = p.getTlx() - Math.round(p.getTlx()),
                q = p.getTly() - Math.round(p.getTly());
            if (0 === t && 0 === q) return p;
            e.copy(p);
            e.offset(-t, -q);
            return e
        }
        SaveToJson() {
            const p = {
                t: this._text,
                c: this._color.toJSON(),
                fn: this._faceName,
                ps: this._ptSize
            };
            this._enableBBcode && (p.bbc = this._enableBBcode);
            0 !== this._horizontalAlign && (p.ha = this._horizontalAlign);
            0 !== this._verticalAlign && (p.va = this._verticalAlign);
            this._wrapByWord || (p.wr = this._wrapByWord);
            0 !== this._lineHeightOffset && (p.lho = this._lineHeightOffset);
            this._isBold && (p.b = this._isBold);
            this._isItalic && (p.i = this._isItalic); - 1 !== this._typewriterEndTime && (p.tw = {
                st: this._typewriterStartTime,
                en: this._typewriterEndTime,
                l: this._typewriterLength
            });
            return p
        }
        LoadFromJson(p) {
            this._CancelTypewriter();
            this._text = p.t;
            this._color.setFromJSON(p.c);
            this._faceName = p.fn;
            this._ptSize = p.ps;
            this._enableBBcode = p.hasOwnProperty("bbc") ? p.bbc : !1;
            this._horizontalAlign = p.hasOwnProperty("ha") ? p.ha : 0;
            this._verticalAlign = p.hasOwnProperty("va") ? p.va : 0;
            this._wrapByWord = p.hasOwnProperty("wr") ? p.wr : !0;
            this._lineHeightOffset = p.hasOwnProperty("lho") ? p.lho : 0;
            this._isBold = p.hasOwnProperty("b") ? p.b : !1;
            this._isItalic = p.hasOwnProperty("i") ? p.i : !1;
            p.hasOwnProperty("tw") && (p =
                p.tw, this._typewriterStartTime = p.st, this._typewriterEndTime = p.en, this._typewriterLength = p.l);
            this._UpdateTextSettings(); - 1 !== this._typewriterEndTime && this._StartTicking()
        }
        GetPropertyValueByIndex(p) {
            switch (p) {
                case 0:
                    return this._text;
                case 1:
                    return this._enableBBcode;
                case 2:
                    return this._faceName;
                case 3:
                    return this._ptSize;
                case 4:
                    return this._lineHeightOffset;
                case 5:
                    return this._isBold;
                case 6:
                    return this._isItalic;
                case 7:
                    return b[0] = this._color.getR(), b[1] = this._color.getG(), b[2] = this._color.getB(),
                        b;
                case 8:
                    return this._horizontalAlign;
                case 9:
                    return this._verticalAlign;
                case 10:
                    return this._wrapByWord ? 1 : 0
            }
        }
        SetPropertyValueByIndex(p, t) {
            switch (p) {
                case 0:
                    if (this._text === t) break;
                    this._text = t;
                    this._UpdateTextSettings();
                    break;
                case 1:
                    if (this._enableBBcode === !!t) break;
                    this._enableBBcode = !!t;
                    this._UpdateTextSettings();
                    break;
                case 2:
                    if (this._faceName === t) break;
                    this._faceName = t;
                    this._UpdateTextSettings();
                    break;
                case 3:
                    if (this._ptSize === t) break;
                    this._ptSize = t;
                    this._UpdateTextSettings();
                    break;
                case 4:
                    if (this._lineHeightOffset ===
                        t) break;
                    this._lineHeightOffset = t;
                    this._UpdateTextSettings();
                    break;
                case 5:
                    if (this._isBold === !!t) break;
                    this._isBold = !!t;
                    this._UpdateTextSettings();
                    break;
                case 6:
                    if (this._isItalic === !!t) break;
                    this._isItalic = !!t;
                    this._UpdateTextSettings();
                    break;
                case 7:
                    p = this._color;
                    if (p.getR() === t[0] && p.getG() === t[1] && p.getB() === t[2]) break;
                    this._color.setRgb(t[0], t[1], t[2]);
                    this._UpdateTextSettings();
                    break;
                case 8:
                    if (this._horizontalAlign === t) break;
                    this._horizontalAlign = t;
                    this._UpdateTextSettings();
                    break;
                case 9:
                    if (this._verticalAlign ===
                        t) break;
                    this._verticalAlign = t;
                    this._UpdateTextSettings();
                    break;
                case 10:
                    this._wrapByWord !== (0 === t) && (this._wrapByWord = 0 === t, this._UpdateTextSettings())
            }
        }
        SetPropertyColorOffsetValueByIndex(p, t, q, r) {
            if (0 !== t || 0 !== q || 0 !== r) switch (p) {
                case 7:
                    this._color.addRgb(t, q, r), this._UpdateTextSettings()
            }
        }
        _SetText(p) {
            // console.log("IDDQD t. this._text !== p && (this._text = p, this._rendererText.SetText(p), this._runtime.UpdateRender())(p) " + p)
            this._text !== p && (this._text = p, this._rendererText.SetText(p), this._runtime.UpdateRender())
        }
        GetText() {
            return this._text
        }
        _StartTypewriter(p, t) {
            // console.log("IDDQD t._StartTypewriter(p, t)(p) " + p)
            this._SetText(p);
            this._typewriterStartTime = this._runtime.GetWallTime();
            this._typewriterEndTime = this._typewriterStartTime + t / this.GetInstance().GetActiveTimeScale();
            this._typewriterLength = d.BBString.StripAnyTags(p).length;
            this._rendererText.SetDrawMaxCharacterCount(0);
            this._StartTicking()
        }
        _CancelTypewriter() {
            this._typewriterEndTime = this._typewriterStartTime = -1;
            this._typewriterLength = 0;
            this._rendererText.SetDrawMaxCharacterCount(-1);
            this._StopTicking()
        }
        _FinishTypewriter() {
            -1 !== this._typewriterEndTime && (this._CancelTypewriter(), this.Trigger(d.Plugins.Text.Cnds.OnTypewriterTextFinished),
                this._runtime.UpdateRender())
        }
        _SetFontFace(p) {
            this._faceName !== p && (this._faceName = p, this._rendererText.SetFontName(p), this._runtime.UpdateRender())
        }
        _GetFontFace() {
            return this._faceName
        }
        _SetBold(p) {
            p = !!p;
            this._isBold !== p && (this._isBold = p, this._rendererText.SetBold(p), this._runtime.UpdateRender())
        }
        _IsBold() {
            return this._isBold
        }
        _SetItalic(p) {
            p = !!p;
            this._isItalic !== p && (this._isItalic = p, this._rendererText.SetItalic(p), this._runtime.UpdateRender())
        }
        _IsItalic() {
            return this._isItalic
        }
        _SetFontSize(p) {
            this._ptSize !==
                p && (this._ptSize = p, this._runtime.UpdateRender())
        }
        _GetFontSize() {
            return this._ptSize
        }
        _SetLineHeight(p) {
            this._lineHeightOffset !== p && (this._lineHeightOffset = p, this._UpdateTextSettings(), this._runtime.UpdateRender())
        }
        _GetLineHeight() {
            return this._lineHeightOffset
        }
        _SetHAlign(p) {
            this._horizontalAlign !== p && (this._horizontalAlign = p, this._UpdateTextSettings(), this._runtime.UpdateRender())
        }
        _GetHAlign() {
            return this._horizontalAlign
        }
        _SetVAlign(p) {
            this._verticalAlign !== p && (this._verticalAlign = p, this._UpdateTextSettings(),
                this._runtime.UpdateRender())
        }
        _GetVAlign() {
            return this._verticalAlign
        }
        _SetWrapByWord(p) {
            p = !!p;
            this._wrapByWord !== p && (this._wrapByWord = p, this._UpdateTextSettings(), this._runtime.UpdateRender())
        }
        _IsWrapByWord() {
            return this._wrapByWord
        }
        Tick() {
            var p = this._runtime.GetWallTime();
            p >= this._typewriterEndTime ? (this._CancelTypewriter(), this.Trigger(d.Plugins.Text.Cnds.OnTypewriterTextFinished), this._runtime.UpdateRender()) : (p = d.relerp(this._typewriterStartTime, this._typewriterEndTime, p, 0, this._typewriterLength),
                p = Math.floor(p), p !== this._rendererText.GetDrawMaxCharacterCount() && (this._rendererText.SetDrawMaxCharacterCount(p), this._runtime.UpdateRender()))
        }
        GetDebuggerProperties() {
            return [{
                title: "plugins.text.name",
                properties: [{
                    name: "plugins.text.properties.text.name",
                    value: this._text,
                    onedit: p => this._SetText(p)
                }]
            }]
        }
        GetScriptInterfaceClass() {
            return self.ITextInstance
        }
    };
    const g = new WeakMap,
        h = new Map([
            ["left", 0],
            ["center", 1],
            ["right", 2]
        ]),
        l = new Map([
            ["top", 0],
            ["center", 1],
            ["bottom", 2]
        ]),
        m = new Map([
            ["word", !0],
            ["character", !1]
        ]);
    self.ITextInstance = class extends self.IWorldInstance {
        constructor() {
            super();
            g.set(this, self.IInstance._GetInitInst().GetSdkInstance())
        }
        get text() {
            return g.get(this).GetText()
        }
        set text(p) {
            const t = g.get(this);
            t._CancelTypewriter();
            // console.log("IDDQD t._SetText(p) " + a.toString())
            t._SetText(p)
        }
        typewriterText(p, t) {
            const q = g.get(this);
            q._CancelTypewriter();
            q._StartTypewriter(p, t)
        }
        typewriterFinish() {
            g.get(this)._FinishTypewriter()
        }
        set fontFace(p) {
            g.get(this)._SetFontFace(p)
        }
        get fontFace() {
            return g.get(this)._GetFontFace()
        }
        set isBold(p) {
            g.get(this)._SetBold(p)
        }
        get isBold() {
            return g.get(this)._IsBold()
        }
        set isItalic(p) {
            g.get(this)._SetItalic(p)
        }
        get isItalic() {
            return g.get(this)._IsItalic()
        }
        set sizePt(p) {
            g.get(this)._SetFontSize(p)
        }
        get sizePt() {
            return g.get(this)._GetFontSize()
        }
        set lineHeight(p) {
            g.get(this)._SetLineHeight(p)
        }
        get lineHeight() {
            return g.get(this)._GetLineHeight()
        }
        set horizontalAlign(p) {
            p =
                h.get(p);
            if ("undefined" === typeof p) throw Error("invalid mode");
            g.get(this)._SetHAlign(p)
        }
        get horizontalAlign() {
            return a[g.get(this)._GetHAlign()]
        }
        set verticalAlign(p) {
            p = l.get(p);
            if ("undefined" === typeof p) throw Error("invalid mode");
            g.get(this)._SetVAlign(p)
        }
        get verticalAlign() {
            return f[g.get(this)._GetVAlign()]
        }
        set wordWrapMode(p) {
            p = m.get(p);
            if ("undefined" === typeof p) throw Error("invalid mode");
            g.get(this)._SetWrapByWord(p)
        }
        get wordWrapMode() {
            return g.get(this)._IsWrapByWord() ? "word" : "character"
        }
    }
}
"use strict";
{
    const d = self.C3;
    d.Plugins.Text.Cnds = {
        CompareText(b, a) {
            return a ? this._text === b : d.equalsNoCase(this._text, b)
        },
        IsRunningTypewriterText() {
            return -1 !== this._typewriterEndTime
        },
        OnTypewriterTextFinished() {
            return !0
        }
    }
}
"use strict";
{
    const d = self.C3,
        b = d.New(d.Color);
    d.Plugins.Text.Acts = {
        SetText(a) {
            this._CancelTypewriter();
            "number" === typeof a && 1E9 > a && (a = Math.round(1E10 * a) / 1E10);
            // console.log("IDDQD sett1 " + a.toString())
            this._SetText(a.toString())
        },
        AppendText(a) {
            // console.log("IDDQD h3 " + a)
            this._CancelTypewriter();
            "number" === typeof a && 1E9 > a && (a = Math.round(1E10 * a) / 1E10);
            (a = a.toString()) && this._SetText(this._text + a)
        },
        TypewriterText(a, f) {
            this._CancelTypewriter();
            "number" === typeof a && 1E9 > a && (a = Math.round(1E10 * a) / 1E10);
            this._StartTypewriter(a.toString(), f)
        },
        SetFontFace(a, f) {
            let c = !1,
                e = !1;
            switch (f) {
                case 1:
                    c = !0;
                    break;
                case 2:
                    e = !0;
                    break;
                case 3:
                    e = c = !0
            }
            if (a !== this._faceName || c !== this._isBold || e !== this._isItalic) this._SetFontFace(a), this._SetBold(c), this._SetItalic(e)
        },
        SetFontSize(a) {
            this._SetFontSize(a)
        },
        SetFontColor(a) {
            b.setFromRgbValue(a);
            b.clamp();
            this._color.equalsIgnoringAlpha(b) || (this._color.copyRgb(b), this._rendererText.SetColor(this._color), this._runtime.UpdateRender())
        },
        SetWebFont(a, f) {
            console.warn("[Text] 'Set web font' action is deprecated and no longer has any effect")
        },
        SetEffect(a) {
            this.GetWorldInfo().SetBlendMode(a);
            this._runtime.UpdateRender()
        },
        TypewriterFinish() {
            this._FinishTypewriter()
        },
        SetLineHeight(a) {
            this._SetLineHeight(a)
        },
        SetHAlign(a) {
            this._SetHAlign(a)
        },
        SetVAlign(a) {
            this._SetVAlign(a)
        },
        SetWrapping(a) {
            this._SetWrapByWord(0 === a)
        }
    }
}
"use strict";
{
    const d = self.C3;
    d.Plugins.Text.Exps = {
        Text() {
            return this._text
        },
        PlainText() {
            return this._enableBBcode ? d.BBString.StripAnyTags(this._text) : this._text
        },
        FaceName() {
            return this._faceName
        },
        FaceSize() {
            return this._ptSize
        },
        TextWidth() {
            this._UpdateTextSize();
            return this._rendererText.GetTextWidth()
        },
        TextHeight() {
            this._UpdateTextSize();
            return this._rendererText.GetTextHeight()
        },
        LineHeight() {
            return this._lineHeightOffset
        }
    }
}
"use strict";
{
    const d = self.C3;
    d.Plugins.Keyboard = class extends d.SDKPluginBase {
        constructor(b) {
            super(b)
        }
        Release() {
            super.Release()
        }
    }
}
"use strict";
{
    const d = self.C3;
    d.Plugins.Keyboard.Type = class extends d.SDKTypeBase {
        constructor(f) {
            super(f)
        }
        Release() {
            super.Release()
        }
        OnCreate() {}
        GetScriptInterfaceClass() {
            return self.IKeyboardObjectType
        }
    };
    let b = null;

    function a() {
        return b.GetSingleGlobalInstance().GetSdkInstance()
    }
    self.IKeyboardObjectType = class extends self.IObjectClass {
        constructor(f) {
            super(f);
            b = f;
            f.GetRuntime()._GetCommonScriptInterfaces().keyboard = this
        }
        isKeyDown(f) {
            const c = a();
            if ("string" === typeof f) return c.IsKeyDown(f);
            if ("number" === typeof f) return c.IsKeyCodeDown(f);
            throw new TypeError("expected string or number");
        }
    }
}
"use strict";
{
    const d = self.C3;
    d.Plugins.Keyboard.Instance = class extends d.SDKInstanceBase {
        constructor(b, a) {
            super(b);
            this._keysDownByString = new Set;
            this._keysDownByWhich = new Set;
            this._triggerWhich = 0;
            this._triggerTypedKey = this._triggerString = "";
            b = this.GetRuntime().Dispatcher();
            this._disposables = new d.CompositeDisposable(d.Disposable.From(b, "keydown", f => this._OnKeyDown(f.data)), d.Disposable.From(b, "keyup", f => this._OnKeyUp(f.data)), d.Disposable.From(b, "window-blur", () => this._OnWindowBlur()))
        }
        Release() {
            super.Release()
        }
        _OnKeyDown(b) {
            const a =
                b.which,
                f = b.code || a.toString();
            b = b.key;
            this._keysDownByString.has(f) || (this._keysDownByString.add(f), this._keysDownByWhich.add(a), this._triggerString = f, this._triggerWhich = a, this._triggerTypedKey = b, this.Trigger(d.Plugins.Keyboard.Cnds.OnAnyKey), this.Trigger(d.Plugins.Keyboard.Cnds.OnKey), this.Trigger(d.Plugins.Keyboard.Cnds.OnLeftRightKeyPressed), this.Trigger(d.Plugins.Keyboard.Cnds.OnKeyCode))
        }
        _OnKeyUp(b) {
            const a = b.which,
                f = b.code || a.toString();
            b = b.key;
            this._keysDownByString.delete(f);
            this._keysDownByWhich.delete(a);
            this._triggerString = f;
            this._triggerWhich = a;
            this._triggerTypedKey = b;
            this.Trigger(d.Plugins.Keyboard.Cnds.OnAnyKeyReleased);
            this.Trigger(d.Plugins.Keyboard.Cnds.OnKeyReleased);
            this.Trigger(d.Plugins.Keyboard.Cnds.OnLeftRightKeyReleased);
            this.Trigger(d.Plugins.Keyboard.Cnds.OnKeyCodeReleased)
        }
        _OnWindowBlur() {
            for (const b of this._keysDownByWhich) this._keysDownByWhich.delete(b), this._triggerWhich = b, this.Trigger(d.Plugins.Keyboard.Cnds.OnAnyKeyReleased), this.Trigger(d.Plugins.Keyboard.Cnds.OnKeyReleased),
                this.Trigger(d.Plugins.Keyboard.Cnds.OnKeyCodeReleased);
            this._keysDownByString.clear()
        }
        IsKeyDown(b) {
            return this._keysDownByString.has(b)
        }
        IsKeyCodeDown(b) {
            return this._keysDownByWhich.has(b)
        }
        SaveToJson() {
            return {
                tk: this._triggerWhich,
                tkk: this._triggerTypedKey
            }
        }
        LoadFromJson(b) {
            this._triggerWhich = b.tk;
            b.hasOwnProperty("tkk") && (this._triggerTypedKey = b.tkk)
        }
        GetDebuggerProperties() {
            return [{
                title: "plugins.keyboard.name",
                properties: [{
                        name: "plugins.keyboard.debugger.last-key-code",
                        value: this._triggerWhich
                    },
                    {
                        name: "plugins.keyboard.debugger.last-key-string",
                        value: d.Plugins.Keyboard.Exps.StringFromKeyCode(this._triggerWhich)
                    }, {
                        name: "plugins.keyboard.debugger.last-typed-key",
                        value: this._triggerTypedKey
                    }
                ]
            }]
        }
    }
}
"use strict";
{
    const d = "ShiftLeft ShiftRight ControlLeft ControlRight AltLeft AltRight MetaLeft MetaRight".split(" ");
    self.C3.Plugins.Keyboard.Cnds = {
        IsKeyDown(b) {
            return this._keysDownByWhich.has(b)
        },
        OnKey(b) {
            return this._triggerWhich === b
        },
        OnAnyKey() {
            return !0
        },
        OnAnyKeyReleased() {
            return !0
        },
        OnKeyReleased(b) {
            return this._triggerWhich === b
        },
        IsKeyCodeDown(b) {
            b = Math.floor(b);
            return this._keysDownByWhich.has(b)
        },
        OnKeyCode(b) {
            return this._triggerWhich === b
        },
        OnKeyCodeReleased(b) {
            return this._triggerWhich === b
        },
        OnLeftRightKeyPressed(b) {
            return this._triggerString ===
                d[b]
        },
        OnLeftRightKeyReleased(b) {
            return this._triggerString === d[b]
        },
        IsLeftRightKeyDown(b) {
            return this._keysDownByString.has(d[b])
        }
    }
}
"use strict";
self.C3.Plugins.Keyboard.Acts = {};
"use strict";
{
    function d(b) {
        b = Math.floor(b);
        switch (b) {
            case 8:
                return "backspace";
            case 9:
                return "tab";
            case 13:
                return "enter";
            case 16:
                return "shift";
            case 17:
                return "control";
            case 18:
                return "alt";
            case 19:
                return "pause";
            case 20:
                return "capslock";
            case 27:
                return "esc";
            case 33:
                return "pageup";
            case 34:
                return "pagedown";
            case 35:
                return "end";
            case 36:
                return "home";
            case 37:
                return "\u2190";
            case 38:
                return "\u2191";
            case 39:
                return "\u2192";
            case 40:
                return "\u2193";
            case 45:
                return "insert";
            case 46:
                return "del";
            case 91:
                return "left window key";
            case 92:
                return "right window key";
            case 93:
                return "select";
            case 96:
                return "numpad 0";
            case 97:
                return "numpad 1";
            case 98:
                return "numpad 2";
            case 99:
                return "numpad 3";
            case 100:
                return "numpad 4";
            case 101:
                return "numpad 5";
            case 102:
                return "numpad 6";
            case 103:
                return "numpad 7";
            case 104:
                return "numpad 8";
            case 105:
                return "numpad 9";
            case 106:
                return "numpad *";
            case 107:
                return "numpad +";
            case 109:
                return "numpad -";
            case 110:
                return "numpad .";
            case 111:
                return "numpad /";
            case 112:
                return "F1";
            case 113:
                return "F2";
            case 114:
                return "F3";
            case 115:
                return "F4";
            case 116:
                return "F5";
            case 117:
                return "F6";
            case 118:
                return "F7";
            case 119:
                return "F8";
            case 120:
                return "F9";
            case 121:
                return "F10";
            case 122:
                return "F11";
            case 123:
                return "F12";
            case 144:
                return "numlock";
            case 145:
                return "scroll lock";
            case 186:
                return ";";
            case 187:
                return "=";
            case 188:
                return ",";
            case 189:
                return "-";
            case 190:
                return ".";
            case 191:
                return "/";
            case 192:
                return "'";
            case 219:
                return "[";
            case 220:
                return "\\";
            case 221:
                return "]";
            case 222:
                return "#";
            case 223:
                return "`";
            default:
                return String.fromCharCode(b)
        }
    }
    self.C3.Plugins.Keyboard.Exps = {
        LastKeyCode() {
            return this._triggerWhich
        },
        StringFromKeyCode(b) {
            return d(b)
        },
        TypedKey() {
            return this._triggerTypedKey
        }
    }
}
"use strict";
{
    const d = self.C3;
    d.Plugins.Particles = class extends d.SDKPluginBase {
        constructor(b) {
            super(b)
        }
        Release() {
            super.Release()
        }
    }
}
"use strict";
{
    const d = self.C3;
    d.Plugins.Particles.Type = class extends d.SDKTypeBase {
        constructor(b) {
            super(b)
        }
        Release() {
            super.Release()
        }
        OnCreate() {
            this.GetImageInfo().LoadAsset(this._runtime)
        }
        LoadTextures(b) {
            return this.GetImageInfo().LoadStaticTexture(b, {
                sampling: this._runtime.GetSampling()
            })
        }
        ReleaseTextures() {
            this.GetImageInfo().ReleaseTexture()
        }
    }
}
"use strict";
{
    const d = self.C3,
        b = d.New(d.Rect);
    d.Plugins.Particles.Instance = class extends d.SDKWorldInstanceBase {
        constructor(a, f) {
            super(a);
            this._isFirstTick = !0;
            this._particleEngine = a = d.New(self.ParticleEngine);
            a.ononeshotfinish = () => this._OnOneShotFinish();
            this._spawnObjectClass = null;
            this._particleUpdateCallback = (e, g, h, l, m, p) => this._OnParticleUpdate(e, g, h, l, m, p);
            this._particleDestroyCallback = e => this._OnParticleDestroy(e);
            this._hasAnyDefaultParticle = !0;
            f && (a.SetRate(f[0]), a.SetSprayCone(d.toRadians(f[1])), a.SetSprayType(f[2] ?
                "one-shot" : "continuous-spray"), this._SetParticleObjectClass(this._runtime.GetObjectClassBySID(f[3])), a.SetInitSpeed(f[4]), a.SetInitSize(f[5]), a.SetInitOpacity(f[6] / 100), a.SetGrowRate(f[7]), a.SetInitXRandom(f[8]), a.SetInitYRandom(f[9]), a.SetInitSpeedRandom(f[10]), a.SetInitSizeRandom(f[11]), a.SetGrowRandom(f[12]), a.SetAcceleration(f[13]), a.SetGravity(f[14]), a.SetLifeAngleRandom(f[15]), a.SetLifeSpeedRandom(f[16]), a.SetLifeOpacityRandom(f[17]), a.SetDestroyModeIndex(f[18]), a.SetTimeout(f[19]));
            this._UpdateEngineParameters();
            this._spawnObjectClass && (this._hasAnyDefaultParticle = !1);
            "one-shot" === a.GetSprayType() ? a.CreateOneShotSpray() : a.SetSpraying(!0);
            const c = this.GetWorldInfo();
            c.SetBboxChangeEventEnabled(!0);
            this._inst.Dispatcher().addEventListener("bboxchange", () => {
                c.OverwriteBoundingBox(this._particleEngine.GetBoundingBox())
            });
            this.GetRuntime().GetRenderer().IsWebGPU() && c.SetUsePointsShaderProgram();
            this._StartTicking()
        }
        Release() {
            this._particleEngine.Release();
            this._particleDestroyCallback = this._particleUpdateCallback =
                this._particleEngine = null;
            super.Release()
        }
        _SetParticleObjectClass(a) {
            a === this.GetObjectClass() && (a = null);
            this._spawnObjectClass = a;
            this._particleEngine.onparticlecreate = a ? f => this._OnParticleCreate(f) : null;
            this._spawnObjectClass || (this._hasAnyDefaultParticle = !0)
        }
        _UpdateEngineParameters() {
            const a = this._particleEngine,
                f = this.GetWorldInfo();
            a.SetMasterOpacity(f.GetOpacity());
            a.SetPixelRounding(this._runtime.IsPixelRoundingEnabled());
            a.SetSpawnX(f.GetX());
            a.SetSpawnY(f.GetY());
            a.SetSpawnAngle(f.GetAngle());
            a.SetInitSizeScale(f.GetSceneGraphScale())
        }
        _OnOneShotFinish() {
            this._runtime.DestroyInstance(this._inst)
        }
        Draw(a) {
            if (this._hasAnyDefaultParticle) {
                var f = this._objectClass.GetImageInfo(),
                    c = f.GetTexture();
                if (c) {
                    var e = this.GetWorldInfo(),
                        g = e.GetLayer();
                    g.GetViewportForZ(e.GetTotalZElevation(), b);
                    a.SetTexture(c);
                    c = g.Get2DScaleFactorToZ(e.GetTotalZElevation());
                    this._particleEngine.SetParticleScale(g.GetRenderScale() * c);
                    this._particleEngine.Draw(a, f.GetTexRect(), b)
                }
            }
        }
        SaveToJson() {
            const a = this._particleEngine;
            return {
                r: a.GetRate(),
                sc: a.GetSprayCone(),
                st: a.GetSprayType(),
                isp: a.GetInitSpeed(),
                isz: a.GetInitSize(),
                io: a.GetInitOpacity(),
                gr: a.GetGrowRate(),
                xr: a.GetInitXRandom(),
                yr: a.GetInitYRandom(),
                spr: a.GetInitSpeedRandom(),
                szr: a.GetInitSizeRandom(),
                grnd: a.GetGrowRandom(),
                acc: a.GetAcceleration(),
                g: a.GetGravity(),
                lar: a.GetLifeAngleRandom(),
                lsr: a.GetLifeSpeedRandom(),
                lor: a.GetLifeOpacityRandom(),
                dm: a.GetDestroyModeIndex(),
                to: a.GetTimeout(),
                s: a.IsSpraying(),
                pcc: a._GetCreateCounter(),
                ft: this._isFirstTick,
                p: a.GetParticles().map(f =>
                    f.toJSON())
            }
        }
        LoadFromJson(a) {
            var f = this._particleEngine;
            f.SetRate(a.r);
            f.SetSprayCone(a.sc);
            f.SetSprayType(a.st);
            f.SetInitSpeed(a.isp);
            f.SetInitSize(a.isz);
            f.SetInitOpacity(a.io);
            f.SetGrowRate(a.gr);
            f.SetInitXRandom(a.xr);
            f.SetInitYRandom(a.yr);
            f.SetInitSpeedRandom(a.spr);
            f.SetInitSizeRandom(a.szr);
            f.SetGrowRandom(a.grnd);
            f.SetAcceleration(a.acc);
            f.SetGravity(a.g);
            f.SetLifeAngleRandom(a.lar);
            f.SetLifeSpeedRandom(a.lsr);
            f.SetLifeOpacityRandom(a.lor);
            f.SetDestroyModeIndex(a.dm);
            f.SetTimeout(a.to);
            f.SetSpraying(a.s);
            f._SetCreateCounter(a.pcc);
            this._isFirstTick = a.ft;
            a = a.p;
            f.SetParticleCount(a.length);
            f = f.GetParticles();
            for (let c = 0, e = f.length; c < e; ++c) f[c].setFromJSON(a[c])
        }
        Tick() {
            const a = this._runtime.GetDt(this._inst);
            this._UpdateEngineParameters();
            this._isFirstTick && "one-shot" === this._particleEngine.GetSprayType() && this._particleEngine.ReInitAllParticles();
            this._particleEngine.Tick(a);
            this._particleEngine.IsSpraying() && this._runtime.UpdateRender();
            this.GetWorldInfo().SetBboxChanged();
            this._isFirstTick = !1
        }
        _OnParticleCreate(a) {
            const f =
                this._runtime.CreateInstance(this._spawnObjectClass, this.GetWorldInfo().GetLayer(), a.GetX(), a.GetY()),
                c = f.GetWorldInfo();
            c.SetSize(a.GetSize(), a.GetSize());
            c.SetAngle(a.GetAngle());
            c.SetOpacity(a.GetOpacity());
            c.SetUnpremultipliedColor(this.GetWorldInfo().GetUnpremultipliedColor());
            c.SetBboxChanged();
            c.ZOrderMoveAdjacentToInstance(this.GetInstance(), !0);
            f._TriggerOnCreated();
            a.SetUpdateCallback(this._particleUpdateCallback);
            a.SetDestroyCallback(this._particleDestroyCallback);
            return f
        }
        _OnParticleUpdate(a,
            f, c, e, g, h) {
            a.IsDestroyed() || (a = a.GetWorldInfo(), a.OffsetXY(f, c), a.SetSize(a.GetWidth() + e, a.GetHeight() + e), a.SetAngle(a.GetAngle() + g), a.SetOpacity(a.GetOpacity() + h), a.SetBboxChanged())
        }
        _OnParticleDestroy(a) {
            a.IsDestroyed() || this._runtime.DestroyInstance(a)
        }
        GetPropertyValueByIndex(a) {
            const f = this._particleEngine;
            switch (a) {
                case 0:
                    return f.GetRate();
                case 1:
                    return d.toDegrees(f.GetSprayCone());
                case 2:
                    return "one-shot" === f.GetSprayType() ? 1 : 0;
                case 4:
                    return f.GetInitSpeed();
                case 5:
                    return f.GetInitSize();
                case 6:
                    return 100 *
                        f.GetInitOpacity();
                case 7:
                    return f.GetGrowRate();
                case 8:
                    return f.GetInitXRandom();
                case 9:
                    return f.GetInitYRandom();
                case 10:
                    return f.GetInitSpeedRandom();
                case 11:
                    return f.GetInitSizeRandom();
                case 12:
                    return f.GetGrowRandom();
                case 13:
                    return f.GetAcceleration();
                case 14:
                    return f.GetGravity();
                case 15:
                    return f.GetLifeAngleRandom();
                case 16:
                    return f.GetLifeSpeedRandom();
                case 17:
                    return f.GetLifeOpacityRandom();
                case 18:
                    return f.GetDestroyModeIndex();
                case 19:
                    return f.GetTimeout()
            }
        }
        SetPropertyValueByIndex(a, f) {
            const c =
                this._particleEngine;
            switch (a) {
                case 0:
                    c.SetRate(f);
                    break;
                case 1:
                    c.SetSprayCone(d.toRadians(f));
                    break;
                case 2:
                    c.SetSprayType(f ? "one-shot" : "continuous-spray");
                    break;
                case 4:
                    c.SetInitSpeed(f);
                    break;
                case 5:
                    c.SetInitSize(f);
                    break;
                case 6:
                    c.SetInitOpacity(f / 100);
                    break;
                case 7:
                    c.SetGrowRate(f);
                    break;
                case 8:
                    c.SetInitXRandom(f);
                    break;
                case 9:
                    c.SetInitYRandom(f);
                    break;
                case 10:
                    c.SetInitSpeedRandom(f);
                    break;
                case 11:
                    c.SetInitSizeRandom(f);
                    break;
                case 12:
                    c.SetGrowRandom(f);
                    break;
                case 13:
                    c.SetAcceleration(f);
                    break;
                case 14:
                    c.SetGravity(f);
                    break;
                case 15:
                    c.SetLifeAngleRandom(f);
                    break;
                case 16:
                    c.SetLifeSpeedRandom(f);
                    break;
                case 17:
                    c.SetLifeOpacityRandom(f);
                    break;
                case 18:
                    c.SetDestroyModeIndex(f);
                    break;
                case 19:
                    c.SetTimeout(f)
            }
        }
        GetDebuggerProperties() {
            const a = this._particleEngine;
            return [{
                title: "plugins.particles.name",
                properties: [{
                        name: "plugins.particles.debugger.particle-count",
                        value: a.GetParticleCount()
                    }, {
                        name: "plugins.particles.properties.type.name",
                        value: ["plugins.particles.properties.type.items." + a.GetSprayType()]
                    }, {
                        name: "plugins.particles.debugger.is-spraying",
                        value: a.IsSpraying(),
                        onedit: f => a.SetSpraying(f)
                    }, {
                        name: "plugins.particles.properties.rate.name",
                        value: a.GetRate(),
                        onedit: f => a.SetRate(f)
                    }, {
                        name: "plugins.particles.properties.spray-cone.name",
                        value: d.toDegrees(a.GetSprayCone()),
                        onedit: f => a.SetSprayCone(d.toRadians(f))
                    }, {
                        name: "plugins.particles.properties.speed.name",
                        value: a.GetInitSpeed(),
                        onedit: f => a.SetInitSpeed(f)
                    }, {
                        name: "plugins.particles.properties.size.name",
                        value: a.GetInitSize(),
                        onedit: f => a.SetInitSize(f)
                    }, {
                        name: "plugins.particles.properties.opacity.name",
                        value: a.GetInitOpacity(),
                        onedit: f => a.SetInitOpacity(f)
                    }, {
                        name: "plugins.particles.properties.grow-rate.name",
                        value: a.GetGrowRate(),
                        onedit: f => a.SetGrowRate(f)
                    }, {
                        name: "plugins.particles.properties.x-randomiser.name",
                        value: a.GetInitXRandom(),
                        onedit: f => a.SetInitXRandom(f)
                    }, {
                        name: "plugins.particles.properties.y-randomiser.name",
                        value: a.GetInitYRandom(),
                        onedit: f => a.SetInitYRandom(f)
                    }, {
                        name: "plugins.particles.properties.initial-speed-randomiser.name",
                        value: a.GetInitSpeedRandom(),
                        onedit: f => a.SetInitSpeedRandom(f)
                    },
                    {
                        name: "plugins.particles.properties.size-randomiser.name",
                        value: a.GetInitSizeRandom(),
                        onedit: f => a.SetInitSizeRandom(f)
                    }, {
                        name: "plugins.particles.properties.grow-rate-randomiser.name",
                        value: a.GetGrowRandom(),
                        onedit: f => a.SetGrowRandom(f)
                    }, {
                        name: "plugins.particles.properties.acceleration.name",
                        value: a.GetAcceleration(),
                        onedit: f => a.SetAcceleration(f)
                    }, {
                        name: "plugins.particles.properties.gravity.name",
                        value: a.GetGravity(),
                        onedit: f => a.SetGravity(f)
                    }, {
                        name: "plugins.particles.properties.angle-randomiser.name",
                        value: a.GetLifeAngleRandom(),
                        onedit: f => a.SetLifeAngleRandom(f)
                    }, {
                        name: "plugins.particles.properties.life-speed-randomiser.name",
                        value: a.GetLifeSpeedRandom(),
                        onedit: f => a.SetLifeSpeedRandom(f)
                    }, {
                        name: "plugins.particles.properties.opacity-randomiser.name",
                        value: a.GetLifeOpacityRandom(),
                        onedit: f => a.SetLifeOpacityRandom(f)
                    }, {
                        name: "plugins.particles.properties.timeout.name",
                        value: a.GetTimeout(),
                        onedit: f => a.SetTimeout(f)
                    }
                ]
            }]
        }
    }
}
"use strict";
self.C3.Plugins.Particles.Cnds = {
    IsSpraying() {
        return this._particleEngine.IsSpraying()
    }
};
"use strict";
{
    const d = self.C3;
    d.Plugins.Particles.Acts = {
        SetSpraying(b) {
            this._particleEngine.SetSpraying(0 !== b)
        },
        SetRate(b) {
            this._particleEngine.SetRate(b);
            "one-shot" === this._particleEngine.GetSprayType() && this._isFirstTick && this._particleEngine.SetParticleCount(b)
        },
        SetParticleObject(b) {
            this._SetParticleObjectClass(b)
        },
        UnsetParticleObject() {
            this._SetParticleObjectClass(null)
        },
        SetSprayCone(b) {
            this._particleEngine.SetSprayCone(d.toRadians(b))
        },
        SetInitSpeed(b) {
            this._particleEngine.SetInitSpeed(b)
        },
        SetInitSize(b) {
            this._particleEngine.SetInitSize(b)
        },
        SetInitOpacity(b) {
            this._particleEngine.SetInitOpacity(b /
                100)
        },
        SetGrowRate(b) {
            this._particleEngine.SetGrowRate(b)
        },
        SetXRandomiser(b) {
            this._particleEngine.SetInitXRandom(b)
        },
        SetYRandomiser(b) {
            this._particleEngine.SetInitYRandom(b)
        },
        SetSpeedRandomiser(b) {
            this._particleEngine.SetInitSpeedRandom(b)
        },
        SetSizeRandomiser(b) {
            this._particleEngine.SetInitSizeRandom(b)
        },
        SetGrowRateRandomiser(b) {
            this._particleEngine.SetGrowRandom(b)
        },
        SetParticleAcc(b) {
            this._particleEngine.SetAcceleration(b)
        },
        SetGravity(b) {
            this._particleEngine.SetGravity(b)
        },
        SetAngleRandomiser(b) {
            this._particleEngine.SetLifeAngleRandom(b)
        },
        SetLifeSpeedRandomiser(b) {
            this._particleEngine.SetLifeSpeedRandom(b)
        },
        SetOpacityRandomiser(b) {
            this._particleEngine.SetLifeOpacityRandom(b)
        },
        SetTimeout(b) {
            this._particleEngine.SetTimeout(b)
        },
        SetEffect(b) {
            this.GetWorldInfo().SetBlendMode(b);
            this._runtime.UpdateRender()
        }
    }
}
"use strict";
{
    const d = self.C3;
    d.Plugins.Particles.Exps = {
        ParticleCount() {
            return this._particleEngine.GetParticleCount()
        },
        Rate() {
            return this._particleEngine.GetRate()
        },
        SprayCone() {
            return d.toDegrees(this._particleEngine.GetSprayCone())
        },
        InitSpeed() {
            return this._particleEngine.GetInitSpeed()
        },
        InitSize() {
            return this._particleEngine.GetInitSize()
        },
        InitOpacity() {
            return 100 * this._particleEngine.GetInitOpacity()
        },
        InitGrowRate() {
            return this._particleEngine.GetGrowRate()
        },
        XRandom() {
            return this._particleEngine.GetInitXRandom()
        },
        YRandom() {
            return this._particleEngine.GetInitYRandom()
        },
        InitSpeedRandom() {
            return this._particleEngine.GetInitSpeedRandom()
        },
        InitGrowRandom() {
            return this._particleEngine.GetGrowRandom()
        },
        ParticleAcceleration() {
            return this._particleEngine.GetAcceleration()
        },
        Gravity() {
            return this._particleEngine.GetGravity()
        },
        ParticleAngleRandom() {
            return this._particleEngine.GetLifeAngleRandom()
        },
        ParticleSpeedRandom() {
            return this._particleEngine.GetLifeSpeedRandom()
        },
        ParticleOpacityRandom() {
            return this._particleEngine.GetLifeOpacityRandom()
        },
        Timeout() {
            return this._particleEngine.GetTimeout()
        }
    }
}
"use strict";
{
    const d = self.C3,
        b = [],
        a = new Set(["continuous-spray", "one-shot"]),
        f = ["fade-to-invisible", "timeout-expired", "particle-stopped"];
    self.ParticleEngine = class {
        constructor() {
            this._sprayCone = this._rate = 0;
            this._sprayType = "continuous-spray";
            this._isSpraying = !1;
            this._masterOpacity = 0;
            this._isPixelRounding = !1;
            this._initSize = this._initSpeed = this._spawnAngle = this._spawnY = this._spawnX = 0;
            this._initSizeScale = 1;
            this._createCounter = this._timeout = this._destroyMode = this._lifeOpacityRandom = this._lifeSpeedRandom = this._lifeAngleRandom =
                this._gravity = this._acceleration = this._growRandom = this._initSizeRandom = this._initSpeedRandom = this._yRandom = this._xRandom = this._growRate = this._initOpacity = 0;
            this._particleScale = 1;
            this.onparticlecreate = this.ononeshotfinish = null;
            this._particles = [];
            this._boundingBox = new d.Rect;
            this._color = new d.Color
        }
        Release() {
            this.Cancel();
            d.clearArray(this._particles);
            this._color = this._boundingBox = this.onparticlecreate = this.ononeshotfinish = this._particles = null
        }
        Cancel() {
            const c = this._particles;
            for (let e = 0, g = c.length; e <
                g; ++e) c[e].Destroy();
            d.appendArray(b, c);
            d.clearArray(c);
            1E3 < b.length && d.truncateArray(b, 1E3);
            this._isSpraying = !1
        }
        CreateOneShotSpray() {
            for (let c = 0, e = this._rate; c < e; ++c) this._CreateParticle();
            this._particles.length && (this._isSpraying = !0)
        }
        _CreateParticle() {
            let c;
            b.length ? (c = b.pop(), c.SetEngine(this)) : c = d.New(self.Particle, this);
            this._particles.push(c);
            c.Init(this.onparticlecreate);
            return c
        }
        ReInitAllParticles() {
            const c = this._particles,
                e = this.onparticlecreate;
            for (let g = 0, h = c.length; g < h; ++g) c[g].Init(e)
        }
        SetParticleCount(c) {
            var e =
                this._particles;
            if (c < e.length) {
                c = e.length - c;
                for (let g = 0; g < c; ++g) {
                    const h = e.pop();
                    h.Destroy();
                    b.push(h)
                }
                1E3 < b.length && d.truncateArray(b, 1E3)
            } else if (c > e.length)
                for (e = c - e.length, c = 0; c < e; ++c) this._CreateParticle()
        }
        GetParticles() {
            return this._particles
        }
        GetParticleCount() {
            return this._particles.length
        }
        Tick(c) {
            this._SpawnContinuous(c);
            this._TickParticles(c);
            this._MaybeFinishOneShot()
        }
        _SpawnContinuous(c) {
            if ("continuous-spray" === this._sprayType && this._isSpraying) {
                this._createCounter += c * this._rate;
                c = Math.floor(this._createCounter);
                this._createCounter -= c;
                for (let e = 0; e < c; ++e) this._CreateParticle()
            }
        }
        _SetCreateCounter(c) {
            this._createCounter = c
        }
        _GetCreateCounter() {
            return this._createCounter
        }
        _TickParticles(c) {
            const e = this._boundingBox;
            e.set(this._spawnX, this._spawnY, this._spawnX, this._spawnY);
            const g = this._particles;
            let h = 0;
            for (let l = 0, m = g.length; l < m; ++l) {
                const p = g[l];
                g[h] = p;
                p.Tick(c);
                p.IsActive() ? (++h, e.expandToContain(p.GetBoundingBox())) : (p.Destroy(), b.push(p))
            }
            d.truncateArray(g, h);
            1E3 < b.length && d.truncateArray(b, 1E3)
        }
        _MaybeFinishOneShot() {
            if ("one-shot" ===
                this._sprayType && 0 === this._particles.length && this._isSpraying) {
                if (this.ononeshotfinish) this.ononeshotfinish();
                this._isSpraying = !1
            }
        }
        Draw(c, e, g) {
            c.StartRenderingPoints(e);
            this._color.copy(c.GetColor());
            const h = this._particles;
            for (let l = 0, m = h.length; l < m; ++l) {
                const p = h[l];
                g.intersectsRect(p.GetBoundingBox()) && p.Draw(c, e)
            }
            c.FinishRenderingPoints()
        }
        GetColor() {
            return this._color
        }
        SetRate(c) {
            this._rate = +c
        }
        GetRate() {
            return this._rate
        }
        SetSprayCone(c) {
            this._sprayCone = +c
        }
        GetSprayCone() {
            return this._sprayCone
        }
        SetSprayType(c) {
            if (!a.has(c)) throw Error("invalid spray type");
            this._sprayType = c
        }
        GetSprayType() {
            return this._sprayType
        }
        SetSpraying(c) {
            this._isSpraying = !!c
        }
        IsSpraying() {
            return this._isSpraying
        }
        SetMasterOpacity(c) {
            this._masterOpacity = +c
        }
        GetMasterOpacity() {
            return this._masterOpacity
        }
        SetPixelRounding(c) {
            this._isPixelRounding = !!c
        }
        IsPixelRounding() {
            return this._isPixelRounding
        }
        SetSpawnX(c) {
            this._spawnX = +c
        }
        GetSpawnX() {
            return this._spawnX
        }
        SetSpawnY(c) {
            this._spawnY = +c
        }
        GetSpawnY() {
            return this._spawnY
        }
        SetSpawnAngle(c) {
            this._spawnAngle = +c
        }
        GetInitAngle() {
            return this._spawnAngle
        }
        SetInitSpeed(c) {
            this._initSpeed = +c
        }
        GetInitSpeed() {
            return this._initSpeed
        }
        SetInitSize(c) {
            this._initSize = +c
        }
        GetInitSize() {
            return this._initSize
        }
        SetInitSizeScale(c) {
            this._initSizeScale = +c
        }
        GetInitSizeScale() {
            return this._initSizeScale
        }
        SetInitOpacity(c) {
            this._initOpacity = +c
        }
        GetInitOpacity() {
            return this._initOpacity
        }
        SetGrowRate(c) {
            this._growRate = +c
        }
        GetGrowRate() {
            return this._growRate
        }
        SetInitXRandom(c) {
            this._xRandom = +c
        }
        GetInitXRandom() {
            return this._xRandom
        }
        SetInitYRandom(c) {
            this._yRandom = +c
        }
        GetInitYRandom() {
            return this._yRandom
        }
        SetInitSpeedRandom(c) {
            this._initSpeedRandom = +c
        }
        GetInitSpeedRandom() {
            return this._initSpeedRandom
        }
        SetInitSizeRandom(c) {
            this._initSizeRandom = +c
        }
        GetInitSizeRandom() {
            return this._initSizeRandom
        }
        SetGrowRandom(c) {
            this._growRandom = +c
        }
        GetGrowRandom() {
            return this._growRandom
        }
        SetAcceleration(c) {
            this._acceleration = +c
        }
        GetAcceleration() {
            return this._acceleration
        }
        SetGravity(c) {
            this._gravity = +c
        }
        GetGravity() {
            return this._gravity
        }
        SetLifeAngleRandom(c) {
            this._lifeAngleRandom = +c
        }
        GetLifeAngleRandom() {
            return this._lifeAngleRandom
        }
        SetLifeSpeedRandom(c) {
            this._lifeSpeedRandom = +c
        }
        GetLifeSpeedRandom() {
            return this._lifeSpeedRandom
        }
        SetLifeOpacityRandom(c) {
            this._lifeOpacityRandom = +c
        }
        GetLifeOpacityRandom() {
            return this._lifeOpacityRandom
        }
        SetDestroyMode(c) {
            c = f.indexOf(c);
            if (-1 === c) throw Error("invalid destroy mode");
            this._destroyMode = c
        }
        SetDestroyModeIndex(c) {
            this.SetDestroyMode(f[c])
        }
        GetDestroyMode() {
            return f[this._destroyMode]
        }
        GetDestroyModeIndex() {
            return this._destroyMode
        }
        SetTimeout(c) {
            this._timeout = +c
        }
        GetTimeout() {
            return this._timeout
        }
        SetParticleScale(c) {
            this._particleScale = +c
        }
        GetParticleScale() {
            return this._particleScale
        }
        GetBoundingBox() {
            return this._boundingBox
        }
    }
}
"use strict";
{
    const d = self.C3;

    function b(g) {
        return Math.random() * g - g / 2
    }
    const a = new d.Quad,
        f = new d.Color,
        c = self.devicePixelRatio || 1;
    let e = !1;
    self.Particle = class {
        constructor(g) {
            this._engine = g;
            this._isActive = !1;
            this._angle = this._speed = this._y = this._x = 0;
            this._opacity = 1;
            this._age = this._gs = this._halfSize = this._size = this._grow = this._lastOpacity = 0;
            this._bbox = new d.Rect;
            this._destroyCallback = this._updateCallback = this._userData = null
        }
        SetEngine(g) {
            this._engine = g
        }
        Init(g) {
            const h = this._engine;
            this._isActive = !0;
            this._x = h.GetSpawnX() +
                b(h.GetInitXRandom());
            this._y = h.GetSpawnY() + b(h.GetInitYRandom());
            this._speed = h.GetInitSpeed() + b(h.GetInitSpeedRandom());
            this._angle = h.GetInitAngle() + b(h.GetSprayCone());
            this._lastOpacity = this._opacity = h.GetInitOpacity();
            this._size = (h.GetInitSize() + b(h.GetInitSizeRandom())) * h.GetInitSizeScale();
            this._halfSize = this._size / 2;
            this._grow = h.GetGrowRate() + b(h.GetGrowRandom());
            this._age = this._gs = 0;
            this._UpdateBoundingBox();
            g ? this._userData || (this._userData = g(this)) : this._destroyCallback = this._updateCallback =
                this._userData = null
        }
        SetUpdateCallback(g) {
            this._updateCallback = g
        }
        SetDestroyCallback(g) {
            this._destroyCallback = g
        }
        Destroy() {
            const g = this._destroyCallback;
            g && g(this._userData);
            this._destroyCallback = this._updateCallback = this._userData = null
        }
        toJSON() {
            return [this._x, this._y, this._speed, this._angle, this._opacity, this._grow, this._size, this._gs, this._age]
        }
        setFromJSON(g) {
            this._x = g[0];
            this._y = g[1];
            this._speed = g[2];
            this._angle = g[3];
            this._opacity = g[4];
            this._grow = g[5];
            this._size = g[6];
            this._gs = g[7];
            this._age = g[8];
            this._halfSize = this._size / 2;
            this._UpdateBoundingBox()
        }
        Tick(g) {
            var h = this._engine,
                l = this._speed * g,
                m = this._angle;
            const p = Math.cos(m) * l;
            l = Math.sin(m) * l + this._gs * g;
            this._x += p;
            this._y += l;
            m = this._grow * g;
            this._size += m;
            this._halfSize = this._size / 2;
            this._speed += h.GetAcceleration() * g;
            this._gs += h.GetGravity() * g;
            this._age += g;
            this._UpdateBoundingBox();
            var t = h.GetLifeAngleRandom(),
                q = h.GetLifeSpeedRandom();
            const r = h.GetLifeOpacityRandom();
            let u = 0;
            0 !== t && (u = b(t * g), this._angle += u);
            0 !== q && (this._speed += b(q * g));
            0 !==
                r && (this._opacity = d.clamp(this._opacity + b(r * g), 0, 1));
            g = 1 <= this._size && (2 === h.GetDestroyModeIndex() ? 0 < this._speed : this._age < h.GetTimeout());
            (t = this._updateCallback) && g && (q = h.GetMasterOpacity() * this._opacity, 0 === h.GetDestroyModeIndex() && (q *= 1 - this._age / h.GetTimeout()), h = q - this._lastOpacity, this._lastOpacity = q, t(this._userData, p, l, m, u, h));
            this._isActive = g
        }
        IsActive() {
            return this._isActive
        }
        GetBoundingBox() {
            return this._bbox
        }
        _UpdateBoundingBox() {
            const g = this._x,
                h = this._y,
                l = this._halfSize;
            this._bbox.set(g -
                l, h - l, g + l, h + l)
        }
        Draw(g, h) {
            if (!this._userData) {
                var l = this._engine,
                    m = l.GetMasterOpacity() * this._opacity;
                0 === l.GetDestroyModeIndex() && (m *= 1 - this._age / l.GetTimeout());
                if (!(0 >= m)) {
                    var p = this._size,
                        t = p * l.GetParticleScale() * c;
                    if (!(1 > t)) {
                        var q = this._x,
                            r = this._y;
                        l.IsPixelRounding() && (q = q + .5 | 0, r = r + .5 | 0);
                        g.IsWebGPU() ? g.Point(q, r, p, m) : t > g.GetMaxPointSize() || t < g.GetMinPointSize() ? (f.copy(l.GetColor()), f.multiplyAlpha(m), g.SetColor(f), e = !0, a.setFromRect(this._bbox), g.Quad3(a, h)) : (e && (g.SetColor(l.GetColor()), e = !1), g.Point(q, r, t, m))
                    }
                }
            }
        }
        GetUserData() {
            return this._userData
        }
        GetX() {
            return this._x
        }
        GetY() {
            return this._y
        }
        GetSize() {
            return this._size
        }
        GetAngle() {
            return this._angle
        }
        GetOpacity() {
            return this._opacity
        }
    }
}
"use strict";
{
    const d = self.C3;
    d.Plugins.Touch = class extends d.SDKPluginBase {
        constructor(b) {
            super(b)
        }
        Release() {
            super.Release()
        }
    }
}
"use strict";
{
    const d = self.C3;
    d.Plugins.Touch.Type = class extends d.SDKTypeBase {
        constructor(f) {
            super(f)
        }
        Release() {
            super.Release()
        }
        OnCreate() {}
        GetScriptInterfaceClass() {
            return self.ITouchObjectType
        }
    };
    let b = null;

    function a() {
        return b.GetSingleGlobalInstance().GetSdkInstance()
    }
    self.ITouchObjectType = class extends self.IObjectClass {
        constructor(f) {
            super(f);
            b = f;
            f.GetRuntime()._GetCommonScriptInterfaces().touch = this
        }
        requestPermission(f) {
            const c = a();
            if ("orientation" === f) return c._RequestPermission(0);
            if ("motion" === f) return c._RequestPermission(1);
            throw Error("invalid type");
        }
    }
}
"use strict";
{
    const d = self.C3;
    d.Plugins.Touch.Instance = class extends d.SDKInstanceBase {
        constructor(b, a) {
            super(b, "touch");
            this._touches = new Map;
            this._isMouseDown = this._useMouseInput = !1;
            this._getTouchIndex = this._curTouchY = this._curTouchX = this._triggerPermission = this._triggerId = this._triggerIndex = this._accWithGZ = this._accWithGY = this._accWithGX = this._accZ = this._accY = this._accX = this._orientGamma = this._orientBeta = this._orientAlpha = this._orientCompassHeading = 0;
            this._permissionPromises = [];
            a && (this._useMouseInput = a[0]);
            this.AddDOMMessageHandler("permission-result", f => this._OnPermissionResult(f));
            b = this.GetRuntime().Dispatcher();
            this._disposables = new d.CompositeDisposable(d.Disposable.From(b, "pointerdown", f => this._OnPointerDown(f.data)), d.Disposable.From(b, "pointermove", f => this._OnPointerMove(f.data)), d.Disposable.From(b, "pointerup", f => this._OnPointerUp(f.data, !1)), d.Disposable.From(b, "pointercancel", f => this._OnPointerUp(f.data, !0)), d.Disposable.From(b, "deviceorientation", f => this._OnDeviceOrientation(f.data)), d.Disposable.From(b,
                "deviceorientationabsolute", f => this._OnDeviceOrientationAbsolute(f.data)), d.Disposable.From(b, "devicemotion", f => this._OnDeviceMotion(f.data)), d.Disposable.From(b, "tick2", f => this._OnTick2()))
        }
        Release() {
            this._touches.clear();
            super.Release()
        }
        _OnPointerDown(b) {
            if ("mouse" === b.pointerType)
                if (this._useMouseInput) this._isMouseDown = !0;
                else return;
            const a = b.pointerId;
            if (!this._touches.has(a)) {
                var f = b.pageX - this._runtime.GetCanvasClientX();
                b = b.pageY - this._runtime.GetCanvasClientY();
                var c = performance.now(),
                    e =
                    this._touches.size;
                this._triggerIndex = e;
                this._triggerId = a;
                var g = d.New(d.Plugins.Touch.TouchInfo);
                g.Init(c, f, b, a, e);
                this._touches.set(a, g);
                this.Trigger(d.Plugins.Touch.Cnds.OnNthTouchStart);
                this.Trigger(d.Plugins.Touch.Cnds.OnTouchStart);
                this._curTouchX = f;
                this._curTouchY = b;
                this.Trigger(d.Plugins.Touch.Cnds.OnTouchObject)
            }
        }
        _OnPointerMove(b) {
            if ("mouse" !== b.pointerType || this._isMouseDown) {
                var a = this._touches.get(b.pointerId);
                if (a) {
                    var f = performance.now();
                    if (!(2 > f - a.GetTime())) {
                        var c = b.pageX - this._runtime.GetCanvasClientX(),
                            e = b.pageY - this._runtime.GetCanvasClientY();
                        a.Update(f, c, e, b.width, b.height, b.pressure)
                    }
                }
            }
        }
        _OnPointerUp(b, a) {
            if ("mouse" === b.pointerType)
                if (this._isMouseDown) this._isMouseDown = !1;
                else return;
            const f = performance.now();
            b = b.pointerId;
            const c = this._touches.get(b);
            c && (this._triggerIndex = c.GetStartIndex(), this._triggerId = c.GetId(), this.Trigger(d.Plugins.Touch.Cnds.OnNthTouchEnd), this.Trigger(d.Plugins.Touch.Cnds.OnTouchEnd), a || (a = c.ShouldTriggerTap(f), "single-tap" === a ? (this.Trigger(d.Plugins.Touch.Cnds.OnTapGesture),
                this._curTouchX = c.GetX(), this._curTouchY = c.GetY(), this.Trigger(d.Plugins.Touch.Cnds.OnTapGestureObject)) : "double-tap" === a && (this.Trigger(d.Plugins.Touch.Cnds.OnDoubleTapGesture), this._curTouchX = c.GetX(), this._curTouchY = c.GetY(), this.Trigger(d.Plugins.Touch.Cnds.OnDoubleTapGestureObject))), c.Release(), this._touches.delete(b))
        }
        _RequestPermission(b) {
            this._PostToDOMMaybeSync("request-permission", {
                type: b
            });
            return new Promise((a, f) => {
                this._permissionPromises.push({
                    type: b,
                    resolve: a,
                    reject: f
                })
            })
        }
        _OnPermissionResult(b) {
            const a =
                b.result,
                f = b.type;
            this._triggerPermission = f;
            b = this._permissionPromises.filter(c => c.type === f);
            for (const c of b) c.resolve(a ? "granted" : "denied");
            this._permissionPromises = this._permissionPromises.filter(c => c.type !== f);
            a ? (this.Trigger(d.Plugins.Touch.Cnds.OnPermissionGranted), 0 === f ? this._runtime.RequestDeviceOrientationEvent() : this._runtime.RequestDeviceMotionEvent()) : this.Trigger(d.Plugins.Touch.Cnds.OnPermissionDenied)
        }
        _OnDeviceOrientation(b) {
            "number" === typeof b.webkitCompassHeading ? this._orientCompassHeading =
                b.webkitCompassHeading : b.absolute && (this._orientCompassHeading = b.alpha);
            this._orientAlpha = b.alpha;
            this._orientBeta = b.beta;
            this._orientGamma = b.gamma
        }
        _OnDeviceOrientationAbsolute(b) {
            this._orientCompassHeading = b.alpha
        }
        _OnDeviceMotion(b) {
            const a = b.acceleration;
            a && (this._accX = a.x, this._accY = a.y, this._accZ = a.z);
            if (b = b.accelerationIncludingGravity) this._accWithGX = b.x, this._accWithGY = b.y, this._accWithGZ = b.z
        }
        _OnTick2() {
            const b = performance.now();
            let a = 0;
            for (const f of this._touches.values()) f.GetTime() <= b -
                50 && f._SetLastTime(b), f.ShouldTriggerHold(b) && (this._triggerIndex = f.GetStartIndex(), this._triggerId = f.GetId(), this._getTouchIndex = a, this.Trigger(d.Plugins.Touch.Cnds.OnHoldGesture), this._curTouchX = f.GetX(), this._curTouchY = f.GetY(), this.Trigger(d.Plugins.Touch.Cnds.OnHoldGestureObject), this._getTouchIndex = 0), ++a
        }
        _GetTouchByIndex(b) {
            b = Math.floor(b);
            for (const a of this._touches.values()) {
                if (0 === b) return a;
                --b
            }
            return null
        }
        _IsClientPosOnCanvas(b, a) {
            return 0 <= b && 0 <= a && b < this._runtime.GetCanvasCssWidth() &&
                a < this._runtime.GetCanvasCssHeight()
        }
        GetDebuggerProperties() {
            return [{
                title: "plugins.touch.debugger.touches",
                properties: [...this._touches.values()].map(b => ({
                    name: "$" + b.GetId(),
                    value: b.GetX() + ", " + b.GetY()
                }))
            }]
        }
    }
}
"use strict";
{
    const d = self.C3,
        b = [];
    d.Plugins.Touch.Cnds = {
        OnTouchStart() {
            return !0
        },
        OnTouchEnd() {
            return !0
        },
        IsInTouch() {
            return 0 < this._touches.size
        },
        OnTouchObject(a) {
            return a && this._IsClientPosOnCanvas(this._curTouchX, this._curTouchY) ? this._runtime.GetCollisionEngine().TestAndSelectCanvasPointOverlap(a, this._curTouchX, this._curTouchY, !1) : !1
        },
        IsTouchingObject(a) {
            if (!a) return !1;
            const f = a.GetCurrentSol();
            var c = f.GetInstances();
            for (const e of c) {
                c = e.GetWorldInfo();
                const g = c.GetLayer();
                for (const h of this._touches.values()) {
                    if (!this._IsClientPosOnCanvas(h.GetX(),
                            h.GetY())) continue;
                    const [l, m] = g.CanvasCssToLayer(h.GetX(), h.GetY(), c.GetTotalZElevation());
                    if (c.ContainsPoint(l, m)) {
                        b.push(e);
                        break
                    }
                }
            }
            return b.length ? (f.SetArrayPicked(b), a.ApplySolToContainer(), d.clearArray(b), !0) : !1
        },
        CompareTouchSpeed(a, f, c) {
            return (a = this._GetTouchByIndex(a)) ? d.compare(a.GetSpeed(), f, c) : !1
        },
        OrientationSupported() {
            return !0
        },
        MotionSupported() {
            return !0
        },
        CompareOrientation(a, f, c) {
            this._runtime.RequestDeviceOrientationEvent();
            return d.compare(0 === a ? this._orientAlpha : 1 === a ? this._orientBeta :
                this._orientGamma, f, c)
        },
        CompareAcceleration(a, f, c) {
            this._runtime.RequestDeviceMotionEvent();
            return d.compare(0 === a ? this._accWithGX : 1 === a ? this._accWithGY : 2 === a ? this._accWithGZ : 3 === a ? this._accX : 4 === a ? this._accY : this._accZ, f, c)
        },
        OnNthTouchStart(a) {
            a = Math.floor(a);
            return a === this._triggerIndex
        },
        OnNthTouchEnd(a) {
            a = Math.floor(a);
            return a === this._triggerIndex
        },
        HasNthTouch(a) {
            a = Math.floor(a);
            return this._touches.size >= a + 1
        },
        OnHoldGesture() {
            return !0
        },
        OnTapGesture() {
            return !0
        },
        OnDoubleTapGesture() {
            return !0
        },
        OnHoldGestureObject(a) {
            return a && this._IsClientPosOnCanvas(this._curTouchX, this._curTouchY) ? this._runtime.GetCollisionEngine().TestAndSelectCanvasPointOverlap(a, this._curTouchX, this._curTouchY, !1) : !1
        },
        OnTapGestureObject(a) {
            return a && this._IsClientPosOnCanvas(this._curTouchX, this._curTouchY) ? this._runtime.GetCollisionEngine().TestAndSelectCanvasPointOverlap(a, this._curTouchX, this._curTouchY, !1) : !1
        },
        OnDoubleTapGestureObject(a) {
            return a && this._IsClientPosOnCanvas(this._curTouchX, this._curTouchY) ? this._runtime.GetCollisionEngine().TestAndSelectCanvasPointOverlap(a,
                this._curTouchX, this._curTouchY, !1) : !1
        },
        OnPermissionGranted(a) {
            return this._triggerPermission === a
        },
        OnPermissionDenied(a) {
            return this._triggerPermission === a
        }
    }
}
"use strict";
self.C3.Plugins.Touch.Acts = {
    RequestPermission(d) {
        this._RequestPermission(d)
    }
};
"use strict";
{
    const d = self.C3;
    d.Plugins.Touch.Exps = {
        TouchCount() {
            return this._touches.size
        },
        X(b) {
            const a = this._GetTouchByIndex(this._getTouchIndex);
            return a ? a.GetPositionForLayer(this._runtime.GetCurrentLayout(), b, !0) : 0
        },
        Y(b) {
            const a = this._GetTouchByIndex(this._getTouchIndex);
            return a ? a.GetPositionForLayer(this._runtime.GetCurrentLayout(), b, !1) : 0
        },
        XAt(b, a) {
            return (b = this._GetTouchByIndex(b)) ? b.GetPositionForLayer(this._runtime.GetCurrentLayout(), a, !0) : 0
        },
        YAt(b, a) {
            return (b = this._GetTouchByIndex(b)) ? b.GetPositionForLayer(this._runtime.GetCurrentLayout(),
                a, !1) : 0
        },
        XForID(b, a) {
            return (b = this._touches.get(b)) ? b.GetPositionForLayer(this._runtime.GetCurrentLayout(), a, !0) : 0
        },
        YForID(b, a) {
            return (b = this._touches.get(b)) ? b.GetPositionForLayer(this._runtime.GetCurrentLayout(), a, !1) : 0
        },
        AbsoluteX() {
            const b = this._GetTouchByIndex(0);
            return b ? b.GetX() : 0
        },
        AbsoluteY() {
            const b = this._GetTouchByIndex(0);
            return b ? b.GetY() : 0
        },
        AbsoluteXAt(b) {
            return (b = this._GetTouchByIndex(b)) ? b.GetX() : 0
        },
        AbsoluteYAt(b) {
            return (b = this._GetTouchByIndex(b)) ? b.GetY() : 0
        },
        AbsoluteXForID(b) {
            return (b =
                this._touches.get(b)) ? b.GetX() : 0
        },
        AbsoluteYForID(b) {
            return (b = this._touches.get(b)) ? b.GetY() : 0
        },
        SpeedAt(b) {
            return (b = this._GetTouchByIndex(b)) ? b.GetSpeed() : 0
        },
        SpeedForID(b) {
            return (b = this._touches.get(b)) ? b.GetSpeed() : 0
        },
        AngleAt(b) {
            return (b = this._GetTouchByIndex(b)) ? d.toDegrees(b.GetAngle()) : 0
        },
        AngleForID(b) {
            return (b = this._touches.get(b)) ? d.toDegrees(b.GetAngle()) : 0
        },
        CompassHeading() {
            this._runtime.RequestDeviceOrientationEvent();
            return this._orientCompassHeading
        },
        Alpha() {
            this._runtime.RequestDeviceOrientationEvent();
            return this._orientAlpha
        },
        Beta() {
            this._runtime.RequestDeviceOrientationEvent();
            return this._orientBeta
        },
        Gamma() {
            this._runtime.RequestDeviceOrientationEvent();
            return this._orientGamma
        },
        AccelerationXWithG() {
            this._runtime.RequestDeviceMotionEvent();
            return this._accWithGX
        },
        AccelerationYWithG() {
            this._runtime.RequestDeviceMotionEvent();
            return this._accWithGY
        },
        AccelerationZWithG() {
            this._runtime.RequestDeviceMotionEvent();
            return this._accWithGZ
        },
        AccelerationX() {
            this._runtime.RequestDeviceMotionEvent();
            return this._accX
        },
        AccelerationY() {
            this._runtime.RequestDeviceMotionEvent();
            return this._accY
        },
        AccelerationZ() {
            this._runtime.RequestDeviceMotionEvent();
            return this._accZ
        },
        TouchIndex() {
            return this._triggerIndex
        },
        TouchID() {
            return this._triggerId
        },
        WidthForID(b) {
            return (b = this._touches.get(b)) ? b.GetWidth() : 0
        },
        HeightForID(b) {
            return (b = this._touches.get(b)) ? b.GetHeight() : 0
        },
        PressureForID(b) {
            return (b = this._touches.get(b)) ? b.GetPressure() : 0
        }
    }
}
"use strict";
{
    const d = self.C3;
    let b = -1E3,
        a = -1E3,
        f = -1E4;
    d.Plugins.Touch.TouchInfo = class extends d.DefendedBase {
        constructor() {
            super();
            this._pressure = this._height = this._width = this._lastY = this._lastX = this._y = this._x = this._startY = this._startX = this._lastTime = this._time = this._startTime = this._startIndex = this._pointerId = 0;
            this._isTooFarForHold = this._hasTriggeredHold = !1
        }
        Release() {}
        Init(c, e, g, h, l) {
            this._pointerId = h;
            this._startIndex = l;
            this._startTime = this._lastTime = this._time = c;
            this._startX = e;
            this._startY = g;
            this._x = e;
            this._y =
                g;
            this._lastX = e;
            this._lastY = g
        }
        Update(c, e, g, h, l, m) {
            this._lastTime = this._time;
            this._time = c;
            this._lastX = this._x;
            this._lastY = this._y;
            this._x = e;
            this._y = g;
            this._width = h;
            this._height = l;
            this._pressure = m;
            !this._isTooFarForHold && 15 <= d.distanceTo(this._startX, this._startY, this._x, this._y) && (this._isTooFarForHold = !0)
        }
        GetId() {
            return this._pointerId
        }
        GetStartIndex() {
            return this._startIndex
        }
        GetTime() {
            return this._time
        }
        _SetLastTime(c) {
            this._lastTime = c
        }
        GetX() {
            return this._x
        }
        GetY() {
            return this._y
        }
        GetSpeed() {
            const c =
                d.distanceTo(this._x, this._y, this._lastX, this._lastY),
                e = (this._time - this._lastTime) / 1E3;
            return 0 < e ? c / e : 0
        }
        GetAngle() {
            return d.angleTo(this._lastX, this._lastY, this._x, this._y)
        }
        GetWidth() {
            return this._width
        }
        GetHeight() {
            return this._height
        }
        GetPressure() {
            return this._pressure
        }
        ShouldTriggerHold(c) {
            return this._hasTriggeredHold ? !1 : 500 <= c - this._startTime && !this._isTooFarForHold && 15 > d.distanceTo(this._startX, this._startY, this._x, this._y) ? this._hasTriggeredHold = !0 : !1
        }
        ShouldTriggerTap(c) {
            if (this._hasTriggeredHold) return "";
            if (333 >= c - this._startTime && !this._isTooFarForHold && 15 > d.distanceTo(this._startX, this._startY, this._x, this._y)) {
                if (666 >= c - f && 25 > d.distanceTo(b, a, this._x, this._y)) return a = b = -1E3, f = -1E4, "double-tap";
                b = this._x;
                a = this._y;
                f = c;
                return "single-tap"
            }
            return ""
        }
        GetPositionForLayer(c, e, g) {
            return "undefined" === typeof e ? c.GetLayerByIndex(0).CanvasCssToLayer_DefaultTransform(this._x, this._y)[g ? 0 : 1] : (c = c.GetLayer(e)) ? c.CanvasCssToLayer(this._x, this._y)[g ? 0 : 1] : 0
        }
    }
}
"use strict";
{
    const d = self.C3;
    d.Plugins.Browser = class extends d.SDKPluginBase {
        constructor(b) {
            super(b)
        }
        Release() {
            super.Release()
        }
    }
}
"use strict";
{
    const d = self.C3;
    d.Plugins.Browser.Type = class extends d.SDKTypeBase {
        constructor(b) {
            super(b)
        }
        Release() {
            super.Release()
        }
        OnCreate() {}
    }
}
"use strict";
{
    const d = self.C3;
    d.Plugins.Browser.Instance = class extends d.SDKInstanceBase {
        constructor(b, a) {
            super(b, "browser");
            this._initLocationStr = "";
            this._isOnline = !1;
            this._docTitle = this._referrer = "";
            this._isCookieEnabled = !1;
            this._windowOuterHeight = this._windowOuterWidth = this._screenHeight = this._screenWidth = 0;
            this._isScirraArcade = !1;
            this.AddDOMMessageHandlers([
                ["online-state", f => this._OnOnlineStateChanged(f)],
                ["backbutton", () => this._OnBackButton()],
                ["sw-message", f => this._OnSWMessage(f)],
                ["hashchange", f => this._OnHashChange(f)]
            ]);
            b = this.GetRuntime().Dispatcher();
            this._disposables = new d.CompositeDisposable(d.Disposable.From(b, "afterfirstlayoutstart", () => this._OnAfterFirstLayoutStart()), d.Disposable.From(b, "window-resize", () => this._OnWindowResize()), d.Disposable.From(b, "suspend", () => this._OnSuspend()), d.Disposable.From(b, "resume", () => this._OnResume()));
            this._runtime.AddLoadPromise(this.PostToDOMAsync("get-initial-state", {
                exportType: this._runtime.GetExportType()
            }).then(f => {
                this._initLocationStr = f.location;
                this._isOnline = f.isOnline;
                this._referrer = f.referrer;
                this._docTitle = f.title;
                this._isCookieEnabled = f.isCookieEnabled;
                this._screenWidth = f.screenWidth;
                this._screenHeight = f.screenHeight;
                this._windowOuterWidth = f.windowOuterWidth;
                this._windowOuterHeight = f.windowOuterHeight;
                this._isScirraArcade = f.isScirraArcade
            }))
        }
        Release() {
            super.Release()
        }
        _OnAfterFirstLayoutStart() {
            this.PostToDOM("ready-for-sw-messages")
        }
        async _OnOnlineStateChanged(b) {
            b = !!b.isOnline;
            this._isOnline !== b && ((this._isOnline = b) ? await this.TriggerAsync(d.Plugins.Browser.Cnds.OnOnline) :
                await this.TriggerAsync(d.Plugins.Browser.Cnds.OnOffline))
        }
        async _OnWindowResize() {
            await this.TriggerAsync(d.Plugins.Browser.Cnds.OnResize)
        }
        _OnSuspend() {
            this.Trigger(d.Plugins.Browser.Cnds.OnPageHidden)
        }
        _OnResume() {
            this.Trigger(d.Plugins.Browser.Cnds.OnPageVisible)
        }
        async _OnBackButton() {
            await this.TriggerAsync(d.Plugins.Browser.Cnds.OnBackButton)
        }
        _OnSWMessage(b) {
            b = b.type;
            "downloading-update" === b ? this.Trigger(d.Plugins.Browser.Cnds.OnUpdateFound) : "update-ready" === b || "update-pending" === b ? this.Trigger(d.Plugins.Browser.Cnds.OnUpdateReady) :
                "offline-ready" === b && this.Trigger(d.Plugins.Browser.Cnds.OnOfflineReady)
        }
        _OnHashChange(b) {
            this._initLocationStr = b.location;
            this.Trigger(d.Plugins.Browser.Cnds.OnHashChange)
        }
        GetDebuggerProperties() {
            return [{
                title: "plugins.browser.name",
                properties: [{
                    name: "plugins.browser.debugger.user-agent",
                    value: navigator.userAgent
                }, {
                    name: "plugins.browser.debugger.is-online",
                    value: this._isOnline
                }, {
                    name: "plugins.browser.debugger.is-fullscreen",
                    value: this._runtime.GetCanvasManager().IsDocumentFullscreen()
                }]
            }]
        }
    }
}
"use strict";
self.C3.Plugins.Browser.Cnds = {
    IsOnline() {
        return this._isOnline
    },
    OnOnline() {
        return !0
    },
    OnOffline() {
        return !0
    },
    OnResize() {
        return !0
    },
    CookiesEnabled() {
        return this._isCookieEnabled
    },
    IsFullscreen() {
        return this._runtime.GetCanvasManager().IsDocumentFullscreen()
    },
    OnBackButton() {
        return !0
    },
    IsPortraitLandscape(d) {
        const b = this._runtime.GetCanvasManager().GetLastWidth(),
            a = this._runtime.GetCanvasManager().GetLastHeight();
        return (b <= a ? 0 : 1) === d
    },
    OnUpdateFound() {
        return !0
    },
    OnUpdateReady() {
        return !0
    },
    OnOfflineReady() {
        return !0
    },
    OnHashChange() {
        return !0
    },
    PageVisible() {
        return !this._runtime.IsSuspended()
    },
    OnPageHidden() {
        return !0
    },
    OnPageVisible() {
        return !0
    },
    HasJava() {
        return !1
    },
    IsDownloadingUpdate() {
        return !1
    },
    OnMenuButton() {
        return !1
    },
    OnSearchButton() {
        return !1
    },
    IsMetered() {
        return !1
    },
    IsCharging() {
        return !0
    },
    SupportsFullscreen() {
        return !0
    }
};
"use strict";
{
    const d = self.C3,
        b = "portrait landscape portrait-primary portrait-secondary landscape-primary landscape-secondary".split(" ");
    d.Plugins.Browser.Acts = {
        Alert(a) {
            this.PostToDOM("alert", {
                message: a.toString()
            })
        },
        Close() {
            this._isScirraArcade || (this._runtime.IsDebug() ? self.C3Debugger.CloseWindow() : this.PostToDOM("close"))
        },
        Focus() {
            this.PostToDOM("set-focus", {
                isFocus: !0
            })
        },
        Blur() {
            this.PostToDOM("set-focus", {
                isFocus: !1
            })
        },
        GoBack() {
            this._isScirraArcade || this.PostToDOM("navigate", {
                type: "back"
            })
        },
        GoForward() {
            this._isScirraArcade ||
                this.PostToDOM("navigate", {
                    type: "forward"
                })
        },
        GoHome() {
            // console.log("IDDQD GoHome")
            this._isScirraArcade || this.PostToDOM("navigate", {
                type: "home"
            })
        },
        Reload() {
            // console.log("IDDQD reload")
            this._isScirraArcade || (this._runtime.IsDebug() ? this._runtime.PostToDebugger({
                type: "reload"
            }) : this.PostToDOM("navigate", {
                type: "reload"
            }))
        },
        GoToURL(a, f) {
            this._PostToDOMMaybeSync("navigate", {
                type: "url",
                url: a,
                target: f,
                exportType: this._runtime.GetExportType()
            })
        },
        GoToURLWindow(a, f) {
            this._PostToDOMMaybeSync("navigate", {
                type: "new-window",
                url: a,
                tag: f,
                exportType: this._runtime.GetExportType()
            })
        },
        RequestFullScreen(a, f) {
            2 <= a && (a += 1);
            6 === a && (a = 2);
            1 === a && (a = 0);
            a = d.CanvasManager._FullscreenModeNumberToString(a);
            this._runtime.GetCanvasManager().SetDocumentFullscreenMode(a);
            this._PostToDOMMaybeSync("request-fullscreen", {
                navUI: f
            })
        },
        CancelFullScreen() {
            this._PostToDOMMaybeSync("exit-fullscreen")
        },
        Vibrate(a) {
            a = a.split(",");
            for (let f = 0, c = a.length; f < c; ++f) a[f] = parseInt(a[f], 10);
            this._PostToDOMMaybeSync("vibrate", {
                pattern: a
            })
        },
        async InvokeDownload(a, f) {
            f && (a = await this._runtime.GetAssetManager().GetProjectFileUrl(a),
                this._runtime.InvokeDownload(a, f))
        },
        InvokeDownloadString(a, f, c) {
            c && (a = `data:${f},${encodeURIComponent(a)}`, this._runtime.InvokeDownload(a, c))
        },
        ConsoleLog(a, f) {
            f = f.toString();
            0 === a ? console.log(f) : 1 === a ? console.warn(f) : 2 === a && console.error(f)
        },
        ConsoleGroup(a) {
            console.group(a)
        },
        ConsoleGroupEnd() {
            console.groupEnd()
        },
        ExecJs(a) {
            console.log("IDDQD ExecJs:" + a)
            // console.log("IDDQD " + this.SaveToJson())
            console.log("IDDQD " + this._runtime._SaveToJsonString())
            // const getCircularReplacer = () => {
            //     const seen = new WeakSet();
            //     return (key, value) => {
            //       if (typeof value === "object" && value !== null) {
            //         if (seen.has(value)) {
            //           return;
            //         }
            //         if("life" in value) {
            //         console.log("IDDQD value " + value)
            //         }
            //         seen.add(value);

            //       }
            //       return value;
            //     };
            //   };
              
            //   const stringified = JSON.stringify(this, getCircularReplacer());
              
            //   console.log("IDDQD stringified " + stringified);
            try {
                eval(a)
            } catch (f) {
                console.error("Error executing JavaScript: ", f)
            }
        },
        LockOrientation(a) {
            a = Math.floor(a);
            0 > a || a >= b.length || this._PostToDOMMaybeSync("lock-orientation", {
                orientation: b[a]
            })
        },
        UnlockOrientation() {
            this._PostToDOMMaybeSync("unlock-orientation")
        },
        LoadStyleSheet(a) {
            this._runtime.GetAssetManager().LoadStyleSheet(a)
        },
        SetHash(a) {
            this.PostToDOM("set-hash", {
                hash: a
            })
        }
    }
}
"use strict";
self.C3.Plugins.Browser.Exps = {
    URL() {
        return this._runtime.IsInWorker() ? this._initLocationStr : location.toString()
    },
    Protocol() {
        return this._runtime.IsInWorker() ? (new URL(this._initLocationStr)).protocol : location.protocol
    },
    Domain() {
        return this._runtime.IsInWorker() ? (new URL(this._initLocationStr)).hostname : location.hostname
    },
    Port() {
        return this._runtime.IsInWorker() ? (new URL(this._initLocationStr)).port : location.port
    },
    PathName() {
        return this._runtime.IsInWorker() ? (new URL(this._initLocationStr)).pathname :
            location.pathname
    },
    Hash() {
        return this._runtime.IsInWorker() ? (new URL(this._initLocationStr)).hash : location.hash
    },
    QueryString() {
        return this._runtime.IsInWorker() ? (new URL(this._initLocationStr)).search : location.search
    },
    QueryParam(d) {
        const b = this._runtime.IsInWorker() ? (new URL(this._initLocationStr)).search : location.search;
        return (d = RegExp("[?&]" + d + "=([^&]*)").exec(b)) ? decodeURIComponent(d[1].replace(/\+/g, " ")) : ""
    },
    Referrer() {
        return this._referrer
    },
    Title() {
        return this._docTitle
    },
    Language() {
        return navigator.language
    },
    Platform() {
        return navigator.platform
    },
    UserAgent() {
        return navigator.userAgent
    },
    ExecJS(d) {
        let b = 0;
        try {
            b = eval(d)
        } catch (a) {
            console.error("Error executing JavaScript: ", a)
        }
        return "number" === typeof b || "string" === typeof b ? b : "boolean" === typeof b ? b ? 1 : 0 : 0
    },
    Name() {
        return navigator.appName
    },
    Version() {
        return navigator.appVersion
    },
    Product() {
        return navigator.product
    },
    Vendor() {
        return navigator.vendor
    },
    BatteryLevel() {
        return 1
    },
    BatteryTimeLeft() {
        return Infinity
    },
    Bandwidth() {
        const d = navigator.connection;
        return d ? d.downlink ||
            d.downlinkMax || d.bandwidth || Infinity : Infinity
    },
    ConnectionType() {
        const d = navigator.connection;
        return d ? d.type || "unknown" : "unknown"
    },
    DevicePixelRatio() {
        return self.devicePixelRatio
    },
    ScreenWidth() {
        return this._screenWidth
    },
    ScreenHeight() {
        return this._screenHeight
    },
    WindowInnerWidth() {
        return this._runtime.GetCanvasManager().GetLastWidth()
    },
    WindowInnerHeight() {
        return this._runtime.GetCanvasManager().GetLastHeight()
    },
    WindowOuterWidth() {
        return this._windowOuterWidth
    },
    WindowOuterHeight() {
        return this._windowOuterWidth
    }
};
"use strict";
{
    const d = self.C3;
    d.Plugins.Spritefont2 = class extends d.SDKPluginBase {
        constructor(b) {
            super(b)
        }
        Release() {
            super.Release()
        }
    }
}
"use strict";
{
    const d = self.C3;
    d.Plugins.Spritefont2.Type = class extends d.SDKTypeBase {
        constructor(b) {
            super(b);
            this._spriteFont = d.New(self.SpriteFont)
        }
        Release() {
            super.Release()
        }
        OnCreate() {
            this.GetImageInfo().LoadAsset(this._runtime)
        }
        LoadTextures(b) {
            return this.GetImageInfo().LoadStaticTexture(b, {
                sampling: this._runtime.GetSampling()
            })
        }
        ReleaseTextures() {
            this.GetImageInfo().ReleaseTexture()
        }
        GetSpriteFont() {
            return this._spriteFont
        }
        UpdateSettings(b, a, f, c) {
            const e = this.GetImageInfo(),
                g = this._spriteFont;
            g.SetWidth(e.GetWidth());
            g.SetHeight(e.GetHeight());
            g.SetCharacterWidth(b);
            g.SetCharacterHeight(a);
            g.SetCharacterSet(f);
            g.SetSpacingData(c);
            g.UpdateCharacterMap()
        }
    }
}
"use strict";
{
    const d = self.C3,
        b = ["left", "center", "right"],
        a = ["top", "center", "bottom"];
    d.Plugins.Spritefont2.Instance = class extends d.SDKWorldInstanceBase {
        constructor(h, l) {
            super(h);
            this._text = "";
            this._enableBBcode = !0;
            this._characterHeight = this._characterWidth = 16;
            this._characterSet = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789.,;:?!-_~#\"'&()[]|`\\/@\u00b0+=*$\u00a3\u20ac<>";
            h = "";
            this._characterScale = 1;
            this._verticalAlign = this._horizontalAlign = this._lineHeight = this._characterSpacing = 0;
            this._wrapByWord = !0;
            this._spriteFontText = null;
            this._typewriterEndTime = this._typewriterStartTime = -1;
            this._typewriterLength = 0;
            l && (this._text = l[0], this._enableBBcode = l[1], this._characterWidth = l[2], this._characterHeight = l[3], this._characterSet = l[4], h = l[5], this._characterScale = l[6], this._characterSpacing = l[7], this._lineHeight = l[8], this._horizontalAlign = l[9], this._verticalAlign = l[10], this._wrapByWord = 0 === l[11], this.GetWorldInfo().SetVisible(l[12]));
            this._sdkType.UpdateSettings(this._characterWidth, this._characterHeight,
                this._characterSet, h);
            this._spriteFontText = d.New(self.SpriteFontText, this._sdkType.GetSpriteFont());
            l = this.GetWorldInfo();
            this._spriteFontText.SetSize(l.GetWidth(), l.GetHeight());
            this._UpdateSettings()
        }
        Release(v) {
            
// sdfsfsddf
            // console.log("IDDQD release" + v)
            this._CancelTypewriter();
            this._spriteFontText.Release();
            this._spriteFontText = null;
            super.Release()
        }
        _UpdateSettings() {
            // console.log("IDDQD update sett " + this._text)
            const h = this._spriteFontText;
            h && (h.SetBBCodeEnabled(this._enableBBcode), h.SetText(this._text), h.SetWordWrapMode(this._wrapByWord ? "word" : "character"), h.SetHorizontalAlign(b[this._horizontalAlign]),
                h.SetVerticalAlign(a[this._verticalAlign]), h.SetSpacing(this._characterSpacing), h.SetLineHeight(this._lineHeight))
        }
        Draw(h) {
            const l = this._objectClass.GetImageInfo();
            var m = l.GetTexture();
            if (m) {
                h.SetTexture(m);
                m = this.GetWorldInfo();
                var p = m.GetBoundingQuad(),
                    t = this._spriteFontText;
                t.SetScale(this._characterScale * m.GetSceneGraphScale());
                this._runtime.IsPixelRoundingEnabled() && (p = m.PixelRoundQuad(p));
                t.SetSize(m.GetWidth(), m.GetHeight());
                t.GetSpriteFont().SetTexRect(l.GetTexRect());
                t.SetColor(m.GetUnpremultipliedColor());
                t.Draw(h, p.getTlx(), p.getTly(), m.GetAngle())
            }
        }
        SaveToJson() {
            // console.log("IDDQD SaveToJson()")
            const h = {
                t: this._text,
                ebbc: this._enableBBcode,
                csc: this._characterScale,
                csp: this._characterSpacing,
                lh: this._lineHeight,
                ha: this._horizontalAlign,
                va: this._verticalAlign,
                w: this._wrapByWord,
                cw: this._sdkType.GetSpriteFont().GetCharacterWidth(),
                ch: this._sdkType.GetSpriteFont().GetCharacterHeight(),
                cs: this._sdkType.GetSpriteFont().GetCharacterSet(),
                sd: this._sdkType.GetSpriteFont().GetSpacingData()
            }; - 1 !== this._typewriterEndTime && (h.tw = {
                st: this._typewriterStartTime,
                en: this._typewriterEndTime,
                l: this._typewriterLength
            });
            return h
        }
        LoadFromJson(h) {
            // console.log("IDDQD LoadFromJson()")
            this._CancelTypewriter();
            this._text = h.t;
            this._enableBBcode = h.ebbc;
            this._characterScale = h.csc;
            this._characterSpacing = h.csp;
            this._lineHeight = h.lh;
            this._horizontalAlign = h.ha;
            this._verticalAlign = h.va;
            this._wrapByWord = h.w;
            if (h.hasOwnProperty("tw")) {
                var l = h.tw;
                this._typewriterStartTime = l.st;
                this._typewriterEndTime = l.en;
                this._typewriterLength = h.l
            }
            l = this._sdkType.GetSpriteFont();
            l.SetCharacterWidth(h.cw);
            l.SetCharacterHeight(h.ch);
            l.SetCharacterSet(h.cs);
            l.SetSpacingData(h.sd);
            this._UpdateSettings(); - 1 !== this._typewriterEndTime && this._StartTicking()
        }
        GetPropertyValueByIndex(h) {
            // console.log("IDDQD GetPropertyValueByIndex()" + h)
            switch (h) {
                case 0:
                    return this._text;
                case 1:
                    return this._enableBBcode;
                case 2:
                    return this._sdkType.GetSpriteFont().GetCharacterWidth();
                case 3:
                    return this._sdkType.GetSpriteFont().GetCharacterHeight();
                case 4:
                    return this._sdkType.GetSpriteFont().GetCharacterSet();
                case 5:
                    return this._sdkType.GetSpriteFont().GetSpacingData();
                case 6:
                    return this._characterScale;
                case 7:
                    return this._characterSpacing;
                case 8:
                    return this._lineHeight;
                case 9:
                    return this._horizontalAlign;
                case 10:
                    return this._verticalAlign;
                case 11:
                    return this._wrapByWord ? 1 : 0
            }
        }
        SetPropertyValueByIndex(h, l) {
            // console.log("IDDQD SetPropertyValueByIndex()" + h + " " + l)
            switch (h) {
                case 0:
                    if (this._text === l) break;
                    this._text = l;
                    this._UpdateSettings();
                    break;
                case 1:
                    if (this._enableBBcode === !!l) break;
                    this._enableBBcode = !!l;
                    this._UpdateSettings();
                    break;
                case 2:
                    this._sdkType.GetSpriteFont().SetCharacterWidth(l);
                    break;
                case 3:
                    this._sdkType.GetSpriteFont().SetCharacterHeight(l);
                    break;
                case 4:
                    this._sdkType.GetSpriteFont().SetCharacterSet(l);
                    break;
                case 5:
                    this._sdkType.GetSpriteFont().SetSpacingData(l);
                    break;
                case 6:
                    if (this._characterScale === l) break;
                    this._characterScale = l;
                    this._UpdateSettings();
                    break;
                case 7:
                    if (this._characterSpacing === l) break;
                    this._characterSpacing = l;
                    this._UpdateSettings();
                    break;
                case 8:
                    if (this._lineHeight === l) break;
                    this._lineHeight = l;
                    this._UpdateSettings();
                    break;
                case 9:
                    if (this._horizontalAlign === l) break;
                    this._horizontalAlign = l;
                    this._UpdateSettings();
                    break;
                case 10:
                    if (this._verticalAlign ===
                        l) break;
                    this._verticalAlign = l;
                    this._UpdateSettings();
                    break;
                case 11:
                    this._wrapByWord !== (0 === l) && (this._wrapByWord = 0 === l, this._UpdateSettings())
            }
        }
        _SetText(h) {
            // console.log("IDDQD h1 " + h)
        
            this._text !== h && (this._text = h, this._spriteFontText.SetText(h), this._runtime.UpdateRender())
        }
        GetText() {
            return this._text
        }
        _StartTypewriter(h, l) {
            // console.log("IDDQD h2 " + h)
            this._SetText(h);
            this._typewriterStartTime = this._runtime.GetWallTime();
            this._typewriterEndTime = this._typewriterStartTime + l / this.GetInstance().GetActiveTimeScale();
            this._typewriterLength = d.BBString.StripAnyTags(h).length;
            this._spriteFontText.SetDrawMaxCharacterCount(0);
            this._StartTicking()
        }
        _CancelTypewriter() {
            this._typewriterEndTime = this._typewriterStartTime = -1;
            this._typewriterLength = 0;
            this._spriteFontText.SetDrawMaxCharacterCount(-1);
            this._StopTicking()
        }
        _FinishTypewriter() {
            -1 !== this._typewriterEndTime && (this._CancelTypewriter(), this.Trigger(d.Plugins.Spritefont2.Cnds.OnTypewriterTextFinished), this._runtime.UpdateRender())
        }
        _SetScale(h) {
            this._characterScale !== h && (this._characterScale = h, this._spriteFontText.SetScale(this._characterScale),
                this._runtime.UpdateRender())
        }
        _GetScale() {
            return this._characterScale
        }
        _SetCharacterSpacing(h) {
            this._characterSpacing !== h && (this._characterSpacing = h, this._spriteFontText.SetSpacing(this._characterSpacing), this._runtime.UpdateRender())
        }
        _GetCharacterSpacing() {
            return this._characterSpacing
        }
        _SetLineHeight(h) {
            this._lineHeight !== h && (this._lineHeight = h, this._spriteFontText.SetLineHeight(this._lineHeight), this._runtime.UpdateRender())
        }
        _GetLineHeight() {
            return this._lineHeight
        }
        _SetHAlign(h) {
            this._horizontalAlign !==
                h && (this._horizontalAlign = h, this._UpdateSettings(), this._runtime.UpdateRender())
        }
        _GetHAlign() {
            return this._horizontalAlign
        }
        _SetVAlign(h) {
            this._verticalAlign !== h && (this._verticalAlign = h, this._UpdateSettings(), this._runtime.UpdateRender())
        }
        _GetVAlign() {
            return this._verticalAlign
        }
        _SetWrapByWord(h) {
            h = !!h;
            this._wrapByWord !== h && (this._wrapByWord = h, this._UpdateSettings(), this._runtime.UpdateRender())
        }
        _IsWrapByWord() {
            return this._wrapByWord
        }
        Tick() {
            var h = this._runtime.GetWallTime();
            h >= this._typewriterEndTime ?
                (this._CancelTypewriter(), this.Trigger(d.Plugins.Spritefont2.Cnds.OnTypewriterTextFinished), this._runtime.UpdateRender()) : (h = d.relerp(this._typewriterStartTime, this._typewriterEndTime, h, 0, this._typewriterLength), h = Math.floor(h), h !== this._spriteFontText.GetDrawMaxCharacterCount() && (this._spriteFontText.SetDrawMaxCharacterCount(h), this._runtime.UpdateRender()))
        }
        GetDebuggerProperties() {
            // console.log("IDDQD GetDebuggerProperties " + this._text)
            return [{
                title: "plugins.spritefont2.name",
                properties: [{
                    name: "plugins.spritefont2.properties.text.name",
                    value: this._text,
                    onedit: h => this._SetText(h)
                }]
            }]
        }
        GetScriptInterfaceClass() {
            return self.ISpriteFontInstance
        }
    };
    const f = new WeakMap,
        c = new Map([
            ["left", 0],
            ["center", 1],
            ["right", 2]
        ]),
        e = new Map([
            ["top", 0],
            ["center", 1],
            ["bottom", 2]
        ]),
        g = new Map([
            ["word", !0],
            ["character", !1]
        ]);
    self.ISpriteFontInstance = class extends self.IWorldInstance {
        constructor() {
            super();
            f.set(this, self.IInstance._GetInitInst().GetSdkInstance())
        }
        get text() {
            return f.get(this).GetText()
        }
        set text(h) {
            // console.log("IDDQD h4 " + h)
            const l = f.get(this);
            l._CancelTypewriter();
            l._SetText(h)
        }
        typewriterText(h,
            l) {
            const m = f.get(this);
            m._CancelTypewriter();
            m._StartTypewriter(h, l)
        }
        typewriterFinish() {
            f.get(this)._FinishTypewriter()
        }
        set characterScale(h) {
            f.get(this)._SetScale(h)
        }
        get characterScale() {
            return f.get(this)._GetScale()
        }
        set characterSpacing(h) {
            f.get(this)._SetCharacterSpacing(h)
        }
        get characterSpacing() {
            return f.get(this)._GetCharacterSpacing()
        }
        set lineHeight(h) {
            f.get(this)._SetLineHeight(h)
        }
        get lineHeight() {
            return f.get(this)._GetLineHeight()
        }
        set horizontalAlign(h) {
            h = c.get(h);
            if ("undefined" === typeof h) throw Error("invalid mode");
            f.get(this)._SetHAlign(h)
        }
        get horizontalAlign() {
            return b[f.get(this)._GetHAlign()]
        }
        set verticalAlign(h) {
            h = e.get(h);
            if ("undefined" === typeof h) throw Error("invalid mode");
            f.get(this)._SetVAlign(h)
        }
        get verticalAlign() {
            return a[f.get(this)._GetVAlign()]
        }
        set wordWrapMode(h) {
            h = g.get(h);
            if ("undefined" === typeof h) throw Error("invalid mode");
            f.get(this)._SetWrapByWord(h)
        }
        get wordWrapMode() {
            return f.get(this)._IsWrapByWord() ? "word" : "character"
        }
    }
}
"use strict";
{
    const d = self.C3;
    d.Plugins.Spritefont2.Cnds = {
        CompareText(b, a) {
            // console.log("IDDQD compare 1")
            return a ? this._text === b : d.equalsNoCase(this._text, b)
        },
        IsRunningTypewriterText() {
            // console.log("IDDQD compare 2")
            return -1 !== this._typewriterEndTime
        },
        OnTypewriterTextFinished() {
            // console.log("IDDQD compare 3")
            return !0
        }
    }
}
"use strict";
var ttttt = false
self.C3.Plugins.Spritefont2.Acts = {
    SetText(d) {
        this._CancelTypewriter();
        "number" === typeof d && 1E9 > d && (d = Math.round(1E10 * d) / 1E10);
        // console.log("IDDQD2 settext" + d.toString())
        if(!ttttt) {
            // console.log("IDDQD2 settext" + d.toString() + ttttt)
        }
        ttttt = true
        this._SetText(d.toString())
    },
    AppendText(d) {
        // console.log("IDDQD h5 " + d)
        this._CancelTypewriter();
        "number" === typeof d && 1E9 > d && (d = Math.round(1E10 * d) / 1E10);
        (d = d.toString()) && this._SetText(this._text + d)
    },
    TypewriterText(d, b) {
        this._CancelTypewriter();
        "number" === typeof d && 1E9 > d && (d = Math.round(1E10 * d) / 1E10);
        this._StartTypewriter(d.toString(), b)
    },
    TypewriterFinish() {
        this._FinishTypewriter()
    },
    SetScale(d) {
        this._SetScale(d)
    },
    SetCharacterSpacing(d) {
        this._SetCharacterSpacing(d)
    },
    SetLineHeight(d) {
        this._SetLineHeight(d)
    },
    SetCharacterWidth(d, b) {
        let a = !1;
        const f = this._sdkType.GetSpriteFont();
        for (const c of d)
            if (" " === c) f.SetSpaceWidth(b), a = !0;
            else if (d = f.GetCharacter(c)) d.SetDisplayWidth(b), a = !0;
        a && f.SetCharacterWidthsChanged();
        this._runtime.UpdateRender()
    },
    SetEffect(d) {
        this.GetWorldInfo().SetBlendMode(d);
        this._runtime.UpdateRender()
    },
    SetHAlign(d) {
        this._SetHAlign(d)
    },
    SetVAlign(d) {
        this._SetVAlign(d)
    },
    SetWrapping(d) {
        this._SetWrapByWord(0 ===
            d)
    }
};
"use strict";
{
    const d = self.C3;
    d.Plugins.Spritefont2.Exps = {
        CharacterWidth(b) {
            return (b = this._sdkType.GetSpriteFont().GetCharacter(b)) ? b.GetDisplayWidth() : this._sdkType.GetSpriteFont().GetCharacterWidth()
        },
        CharacterHeight() {
            return this._characterHeight
        },
        CharacterScale() {
            return this._characterScale
        },
        CharacterSpacing() {
            return this._characterSpacing
        },
        LineHeight() {
            return this._lineHeight
        },
        Text() {
            return this._text
        },
        PlainText() {
            return this._enableBBcode ? d.BBString.StripAnyTags(this._text) : this._text
        },
        TextWidth() {
            const b =
                this.GetWorldInfo();
            this._spriteFontText.SetSize(b.GetWidth(), b.GetHeight());
            return this._spriteFontText.GetTextWidth()
        },
        TextHeight() {
            const b = this.GetWorldInfo();
            this._spriteFontText.SetSize(b.GetWidth(), b.GetHeight());
            return this._spriteFontText.GetTextHeight()
        }
    }
}
"use strict";
{
    const d = self.C3;
    self.SpriteFontCharacter = class {
        constructor(b, a, f, c) {
            let e = b.GetCharacterWidth(),
                g = b.GetCharacterHeight();
            this._spriteFont = b;
            this._char = a;
            this._pxRect = new d.Rect(f, c, f + e, c + g);
            this._texRect = new d.Rect;
            this._displayWidth = -1;
            this._UpdateTexRect()
        }
        Release() {
            this._texRect = this._pxRect = this._spriteFont = null
        }
        _UpdateTexRect() {
            let b = this._spriteFont.GetWidth(),
                a = this._spriteFont.GetHeight();
            this._texRect.copy(this._pxRect);
            this._texRect.divide(b, a);
            this._texRect.lerpInto(this._spriteFont.GetTexRect())
        }
        GetSpriteFont() {
            return this._spriteFont
        }
        GetChar() {
            return this._char
        }
        GetTexRect() {
            return this._texRect
        }
        SetDisplayWidth(b) {
            this._displayWidth =
                b
        }
        GetDisplayWidth() {
            return 0 > this._displayWidth ? this._spriteFont.GetCharacterWidth() : this._displayWidth
        }
    }
}
"use strict";
{
    const d = self.C3,
        b = new d.Rect,
        a = new d.Quad,
        f = new d.Color,
        c = new Set(["left", "center", "right"]),
        e = new Set(["top", "center", "bottom"]),
        g = new Set(["word", "character"]);
    self.SpriteFontText = class {
        constructor(h) {
            this._spriteFont = h;
            this._cssHeight = this._cssWidth = 0;
            this._text = "";
            this._isBBcodeEnabled = !1;
            this._bbString = null;
            this._wrappedText = d.New(d.WordWrap);
            this._wrapMode = "word";
            this._wrapChanged = !1;
            this._horizontalAlign = "left";
            this._verticalAlign = "top";
            this._scale = 1;
            this._lineHeight = this._spacing = 0;
            this._color =
                d.New(d.Color);
            this._drawMaxCharCount = -1;
            this._drawCharCount = 0;
            this._measureTextCallback = (l, m) => this._MeasureText(l, m);
            this._spriteFont._AddSpriteFontText(this)
        }
        Release() {
            this._spriteFont._RemoveSpriteFontText(this);
            this._measureTextCallback = this._color = null;
            this._wrappedText.Clear();
            this._bbString = this._spriteFont = this._wrappedText = null
        }
        _MeasureText(h, l) {
            var m = this._GetStyleTag(l, "scale"),
                p = m ? parseFloat(m.param) : this._scale;
            m = this._GetStyleTag(l, "scalex");
            m = (m ? parseFloat(m.param) : 1) * p;
            l = this._GetStyleTag(l,
                "scaley");
            l = (l ? parseFloat(l.param) : 1) * p;
            l = this._spriteFont.GetCharacterHeight() * l + this._lineHeight;
            const t = this.GetSpriteFont();
            p = t.GetCharacterWidth() * m;
            const q = this.GetSpacing();
            if (t.HasAnyCustomWidths()) {
                let u = 0,
                    x = 0;
                for (var r of h) {
                    h = p;
                    const y = t.GetCharacter(r);
                    y ? h = y.GetDisplayWidth() * m : " " === r && (h = t.GetSpaceWidth() * m);
                    x += h;
                    ++u
                }
                return {
                    width: x + u * q,
                    height: l
                }
            }
            r = [...h].length;
            return {
                width: p * r + Math.max(r, 0) * q,
                height: l
            }
        }
        _SetWrapChanged() {
            this._wrapChanged = !0;
            this._wrappedText.Clear()
        }
        SetSize(h, l) {
            0 >=
                h || 0 >= l || this._cssWidth === h && this._cssHeight === l || (this._cssWidth !== h && this._SetWrapChanged(), this._cssWidth = h, this._cssHeight = l)
        }
        SetDrawMaxCharacterCount(h) {
            this._drawMaxCharCount = Math.floor(h)
        }
        GetDrawMaxCharacterCount() {
            return this._drawMaxCharCount
        }
        _GetStyleTag(h, l) {
            for (let m = h.length - 1; 0 <= m; --m) {
                const p = h[m];
                if (p.tag === l) return p
            }
            return null
        }
        _HasStyleTag(h, l) {
            return !!this._GetStyleTag(h, l)
        }
        _MaybeWrapText() {
            if (this._wrapChanged) {
                !this._isBBcodeEnabled || this._bbString && this._bbString.toString() ===
                    this._text || (this._bbString = new d.BBString(this._text, {
                        noEscape: !0
                    }));
                var h = -this.GetSpacing();
                this._wrappedText.WordWrap(this._isBBcodeEnabled ? this._bbString.toFragmentList() : this._text, this._measureTextCallback, this._cssWidth, this._wrapMode, h);
                this._wrapChanged = !1
            }
        }
        Draw(h, l, m, p) {
            this._MaybeWrapText();
            let t = this._drawCharCount = 0;
            const q = this._lineHeight,
                r = d.cloneArray(this._wrappedText.GetLines()),
                u = Math.sin(p);
            p = Math.cos(p);
            var x = r.reduce((y, C) => y + C.height, 0) - q;
            "center" === this._verticalAlign ? t =
                Math.max(Math.floor(this._cssHeight / 2 - x / 2), 0) : "bottom" === this._verticalAlign && (t = Math.floor(this._cssHeight - x));
            for (let y = 0, C = r.length; y < C; ++y) {
                x = r[y];
                const w = x.height;
                if (0 < y && t > this._cssHeight - (w - q)) break;
                0 <= t && this._DrawLine(h, x, l, m, t, u, p);
                t += w
            }
        }
        _DrawLine(h, l, m, p, t, q, r) {
            const u = l.height;
            let x = 0;
            "center" === this._horizontalAlign ? x = Math.max(Math.floor((this._cssWidth - l.width) / 2), 0) : "right" === this._horizontalAlign && (x = Math.max(Math.floor(this._cssWidth - l.width), 0));
            for (const y of l.fragments) this._DrawFragment(h,
                y, m, p, x, t, q, r, u), x += y.width
        }
        _DrawFragment(h, l, m, p, t, q, r, u, x) {
            var y = l.text,
                C = l.width,
                w = l.styles;
            if (-1 !== this._drawMaxCharCount) {
                if (this._drawCharCount >= this._drawMaxCharCount) return;
                this._drawCharCount + y.length > this._drawMaxCharCount && (y = y.substr(0, this._drawMaxCharCount - this._drawCharCount), C = this._MeasureText(y, w).width);
                this._drawCharCount += y.length
            }
            var A = this._GetStyleTag(w, "background");
            if (!(d.IsStringAllWhitespace(y) && !A || this._HasStyleTag(w, "hide"))) {
                var E = (l = this._GetStyleTag(w, "scale")) ? parseFloat(l.param) :
                    this._scale;
                l = this._GetStyleTag(w, "scalex");
                l = (l ? parseFloat(l.param) : 1) * E;
                var K = this._GetStyleTag(w, "scaley");
                E *= K ? parseFloat(K.param) : 1;
                E *= this._spriteFont.GetCharacterHeight();
                q += x - this._lineHeight - E;
                x = this._GetStyleTag(w, "offsetx");
                t += x ? parseFloat(x.param) : 0;
                x = this._GetStyleTag(w, "offsety");
                q += x ? parseFloat(x.param) : 0;
                A && (h.SetColorFillMode(), f.parseString(A.param), f.setA(1), h.SetColor(f), b.set(t, q, t + C, q + E), b.getRight() > this._cssWidth && b.setRight(this._cssWidth), a.setFromRotatedRectPrecalc(b, r,
                    u), a.offset(m, p), h.Quad(a), h.SetTextureFillMode());
                (C = this._GetStyleTag(w, "color")) ? (f.parseString(C.param), f.setA(this._color.getA())) : f.copy(this._color);
                (C = this._GetStyleTag(w, "opacity")) && f.setA(f.getA() * parseFloat(C.param) / 100);
                f.premultiply();
                h.SetColor(f);
                C = this._spriteFont.GetCharacterWidth() * l;
                w = Math.abs(this.GetSpacing());
                for (const O of y)
                    if (y = this._spriteFont.GetCharacter(O)) {
                        A = y.GetDisplayWidth() * l;
                        if (t + A > this._cssWidth + w + 1E-5) break;
                        b.set(t, q, t + C, q + E);
                        a.setFromRotatedRectPrecalc(b, r, u);
                        a.offset(m, p);
                        h.Quad3(a, y.GetTexRect());
                        t += A + this._spacing
                    } else t += this._spriteFont.GetSpaceWidth() * l + this._spacing
            }
        }
        GetSpriteFont() {
            return this._spriteFont
        }
        SetBBCodeEnabled(h) {
            h = !!h;
            this._isBBcodeEnabled !== h && (this._isBBcodeEnabled = h, this._SetWrapChanged())
        }
        IsBBCodeEnabled() {
            return this._isBBcodeEnabled
        }
        SetText(h) {
            this._text !== h && (this._text = h, this._SetWrapChanged())
        }
        SetWordWrapMode(h) {
            if (!g.has(h)) throw Error("invalid word wrap mode");
            this._wrapMode !== h && (this._wrapMode = h, this._SetWrapChanged())
        }
        SetHorizontalAlign(h) {
            if (!c.has(h)) throw Error("invalid alignment");
            this._horizontalAlign = h
        }
        SetVerticalAlign(h) {
            if (!e.has(h)) throw Error("invalid alignment");
            this._verticalAlign = h
        }
        SetScale(h) {
            this._scale !== h && (this._scale = h, this._SetWrapChanged())
        }
        GetScale() {
            return this._scale
        }
        SetSpacing(h) {
            this._spacing !== h && (this._spacing = h, this._SetWrapChanged())
        }
        GetSpacing() {
            return this._spacing
        }
        SetLineHeight(h) {
            this._lineHeight = h;
            this._SetWrapChanged()
        }
        GetLineHeight() {
            return this._lineHeight
        }
        SetOpacity(h) {
            h = d.clamp(h, 0, 1);
            this._color.a = h
        }
        SetColor(h) {
            this._color.equals(h) || this._color.copy(h)
        }
        GetColor() {
            return this._color
        }
        GetTextWidth() {
            this._MaybeWrapText();
            return this._wrappedText.GetMaxLineWidth()
        }
        GetTextHeight() {
            this._MaybeWrapText();
            var h = this._spriteFont.GetCharacterHeight() * this._scale;
            const l = this._lineHeight;
            h += l;
            return this._wrappedText.GetLineCount() * h - l
        }
    }
}
"use strict";
{
    const d = self.C3,
        b = {
            width: 256,
            height: 256,
            characterWidth: 16,
            characterHeight: 16,
            characterSet: ""
        };
    self.SpriteFont = class {
        constructor(a) {
            a = Object.assign({}, b, a);
            if (0 >= a.width || 0 >= a.height || 0 >= a.characterWidth || 0 >= a.characterHeight) throw Error("invalid size");
            this._width = a.width;
            this._height = a.height;
            this._characterWidth = a.characterWidth;
            this._characterHeight = a.characterHeight;
            this._characterSet = a.characterSet;
            this._spacingData = "";
            this._spacingParsed = null;
            this._hasAnyCustomWidths = !1;
            this._spaceWidth = -1;
            this._texRect = new d.Rect(0, 0, 1, 1);
            this._characterMap = new Map;
            this._mapChanged = !0;
            this._allTexts = new Set
        }
        Release() {
            this._texRect = null;
            this._ReleaseCharacters();
            this._characterMap = null;
            this._allTexts && this._allTexts.clear();
            this._allTexts = null
        }
        _ReleaseCharacters() {
            for (let a of this._characterMap.values()) a.Release();
            this._characterMap.clear()
        }
        _AddSpriteFontText(a) {
            this._allTexts.add(a)
        }
        _RemoveSpriteFontText(a) {
            this._allTexts.delete(a)
        }
        UpdateCharacterMap() {
            if (this._mapChanged) {
                this._ReleaseCharacters();
                var a = [...this._characterSet],
                    f = Math.floor(this._width / this._characterWidth),
                    c = f * Math.floor(this._height / this._characterHeight);
                for (let e = 0, g = a.length; e < g && !(e >= c); ++e) {
                    let h = a[e];
                    this._characterMap.set(h, d.New(self.SpriteFontCharacter, this, h, e % f * this._characterWidth, Math.floor(e / f) * this._characterHeight))
                }
                this._hasAnyCustomWidths = !1;
                this._spaceWidth = -1;
                if (Array.isArray(this._spacingParsed))
                    for (let e of this._spacingParsed)
                        if (Array.isArray(e) && 2 === e.length && (a = e[0], f = e[1], "number" === typeof a && isFinite(a) &&
                                "string" === typeof f && a !== this._characterWidth))
                            for (let g of f)(f = this._characterMap.get(g)) ? (f.SetDisplayWidth(a), this._hasAnyCustomWidths = !0) : " " === g && (this._spaceWidth = a, this._hasAnyCustomWidths = !0);
                this._mapChanged = !1;
                for (let e of this._allTexts) e._SetWrapChanged()
            }
        }
        SetCharacterWidthsChanged() {
            this._hasAnyCustomWidths = !0;
            for (const a of this._allTexts) a._SetWrapChanged()
        }
        GetCharacter(a) {
            this.UpdateCharacterMap();
            return this._characterMap.get(a) || null
        }
        HasAnyCustomWidths() {
            return this._hasAnyCustomWidths
        }
        SetWidth(a) {
            a =
                Math.floor(a);
            if (0 >= a) throw Error("invalid size");
            this._width !== a && (this._width = a, this._mapChanged = !0)
        }
        GetWidth() {
            return this._width
        }
        SetHeight(a) {
            a = Math.floor(a);
            if (0 >= a) throw Error("invalid size");
            this._height !== a && (this._height = a, this._mapChanged = !0)
        }
        GetHeight() {
            return this._height
        }
        SetTexRect(a) {
            if (!this._texRect.equals(a)) {
                this._texRect.copy(a);
                for (const f of this._characterMap.values()) f._UpdateTexRect()
            }
        }
        GetTexRect() {
            return this._texRect
        }
        SetCharacterWidth(a) {
            a = Math.floor(a);
            if (0 >= a) throw Error("invalid size");
            this._characterWidth !== a && (this._characterWidth = a, this._mapChanged = !0)
        }
        GetCharacterWidth() {
            return this._characterWidth
        }
        SetCharacterHeight(a) {
            a = Math.floor(a);
            if (0 >= a) throw Error("invalid size");
            this._characterHeight !== a && (this._characterHeight = a, this._mapChanged = !0)
        }
        GetCharacterHeight() {
            return this._characterHeight
        }
        SetCharacterSet(a) {
            this._characterSet !== a && (this._characterSet = a, this._mapChanged = !0)
        }
        GetCharacterSet() {
            return this._characterSet
        }
        SetSpacingData(a) {
            if (this._spacingData !== a && (this._spacingData =
                    a, this._mapChanged = !0, this._spacingParsed = null, this._spacingData.length)) try {
                this._spacingParsed = JSON.parse(this._spacingData)
            } catch (f) {
                this._spacingParsed = null
            }
        }
        GetSpacingData() {
            return this._spacingData
        }
        SetSpaceWidth(a) {
            0 > a && (a = -1);
            this._spaceWidth !== a && (this._spaceWidth = a, 0 <= this._spaceWidth && (this._hasAnyCustomWidths = !0))
        }
        GetSpaceWidth() {
            return 0 > this._spaceWidth ? this._characterWidth : this._spaceWidth
        }
    }
}
"use strict";
{
    const d = self.C3;
    d.Plugins.LocalStorage = class extends d.SDKPluginBase {
        constructor(b) {
            super(b)
        }
        Release() {
            super.Release()
        }
    }
}
"use strict";
{
    const d = self.C3;
    d.Plugins.LocalStorage.Type = class extends d.SDKTypeBase {
        constructor(b) {
            super(b)
        }
        Release() {
            super.Release()
        }
        OnCreate() {}
    }
}
"use strict";
{
    const d = self.C3;
    d.Plugins.LocalStorage.Instance = class extends d.SDKInstanceBase {
        constructor(b, a) {
            super(b);
            this._lastValue = this._currentKey = "";
            this._keyNamesList = [];
            this._errorMessage = "";
            this._pendingSets = this._pendingGets = 0;
            this._storage = this._runtime._GetProjectStorage();
            this._debugCache = new Map;
            this._isLoadingDebugCache = !1
        }
        Release() {
            super.Release()
        }
        async _TriggerStorageError(b) {
            this._errorMessage = this._GetErrorString(b);
            await this.TriggerAsync(d.Plugins.LocalStorage.Cnds.OnError)
        }
        _GetErrorString(b) {
            return b ?
                "string" === typeof b ? b : "string" === typeof b.message ? b.message : "string" === typeof b.name ? b.name : "string" === typeof b.data ? b.data : "unknown error" : "unknown error"
        }
        GetDebuggerProperties() {
            this._isLoadingDebugCache || this._DebugCacheStorage();
            return [{
                title: "plugins.localstorage.name",
                properties: [...this._debugCache.entries()].map(b => ({
                    name: "$" + b[0],
                    value: b[1],
                    onedit: a => this._storage.setItem(b[0], a)
                }))
            }]
        }
        async _DebugCacheStorage() {
            this._isLoadingDebugCache = !0;
            try {
                const b = await this._storage.keys();
                b.sort((f,
                    c) => {
                    f = f.toLowerCase();
                    c = c.toLowerCase();
                    return f < c ? -1 : c < f ? 1 : 0
                });
                const a = await Promise.all(b.map(f => this._storage.getItem(f)));
                this._debugCache.clear();
                for (let f = 0, c = b.length; f < c; ++f) this._debugCache.set(b[f], a[f])
            } catch (b) {
                console.warn("[C3 debugger] Error displaying local storage: ", b)
            } finally {
                this._isLoadingDebugCache = !1
            }
        }
    }
}
"use strict";
{
    const d = self.C3;
    d.Plugins.LocalStorage.Cnds = {
        OnItemSet(b) {
            return this._currentKey === b
        },
        OnAnyItemSet() {
            return !0
        },
        OnItemGet(b) {
            return this._currentKey === b
        },
        OnAnyItemGet() {
            return !0
        },
        OnItemRemoved(b) {
            return this._currentKey === b
        },
        OnAnyItemRemoved() {
            return !0
        },
        OnCleared() {
            return !0
        },
        OnAllKeyNamesLoaded() {
            return !0
        },
        OnError() {
            return !0
        },
        OnItemExists(b) {
            return this._currentKey === b
        },
        OnItemMissing(b) {
            return this._currentKey === b
        },
        CompareKey(b, a) {
            return d.compare(this._currentKey, b, a)
        },
        CompareValue(b, a) {
            return d.compare(this._lastValue,
                b, a)
        },
        IsProcessingSets() {
            return 0 < this._pendingSets
        },
        IsProcessingGets() {
            return 0 < this._pendingGets
        },
        OnAllSetsComplete() {
            return !0
        },
        OnAllGetsComplete() {
            return !0
        }
    }
}
"use strict";
{
    const d = self.C3;

    function b(a) {
        return "string" === typeof a || "number" === typeof a
    }
    d.Plugins.LocalStorage.Acts = {
        async SetItem(a, f) {
            this._pendingSets++;
            try {
                const c = await this._storage.setItem(a, f);
                await this.ScheduleTriggers(async () => {
                    this._currentKey = a;
                    this._lastValue = c;
                    await this.TriggerAsync(d.Plugins.LocalStorage.Cnds.OnAnyItemSet);
                    await this.TriggerAsync(d.Plugins.LocalStorage.Cnds.OnItemSet)
                })
            } catch (c) {
                await this._TriggerStorageError(c)
            } finally {
                this._pendingSets--, 0 === this._pendingSets && await this.TriggerAsync(d.Plugins.LocalStorage.Cnds.OnAllSetsComplete)
            }
        },
        async SetBinaryItem(a, f) {
            if (f && (f = f.GetFirstPicked(this._inst)) && (f = f.GetSdkInstance())) {
                f = f.GetArrayBufferReadOnly();
                this._pendingSets++;
                try {
                    await this._storage.setItem(a, f), await this.ScheduleTriggers(async () => {
                        this._currentKey = a;
                        this._lastValue = "";
                        await this.TriggerAsync(d.Plugins.LocalStorage.Cnds.OnAnyItemSet);
                        await this.TriggerAsync(d.Plugins.LocalStorage.Cnds.OnItemSet)
                    })
                } catch (c) {
                    await this._TriggerStorageError(c)
                } finally {
                    this._pendingSets--, 0 === this._pendingSets && await this.TriggerAsync(d.Plugins.LocalStorage.Cnds.OnAllSetsComplete)
                }
            }
        },
        async GetItem(a) {
            this._pendingGets++;
            try {
                const f = await this._storage.getItem(a);
                await this.ScheduleTriggers(async () => {
                    this._currentKey = a;
                    this._lastValue = b(f) ? f : "";
                    await this.TriggerAsync(d.Plugins.LocalStorage.Cnds.OnAnyItemGet);
                    await this.TriggerAsync(d.Plugins.LocalStorage.Cnds.OnItemGet)
                })
            } catch (f) {
                await this._TriggerStorageError(f)
            } finally {
                this._pendingGets--, 0 === this._pendingGets && await this.TriggerAsync(d.Plugins.LocalStorage.Cnds.OnAllGetsComplete)
            }
        },
        async GetBinaryItem(a, f) {
            if (f && (f = f.GetFirstPicked(this._inst))) {
                var c =
                    f.GetSdkInstance();
                this._pendingGets++;
                try {
                    let e = await this._storage.getItem(a);
                    e = e instanceof ArrayBuffer ? e : new ArrayBuffer(0);
                    await this.ScheduleTriggers(async () => {
                        this._lastValue = "";
                        this._currentKey = a;
                        c.SetArrayBufferTransfer(e);
                        await this.TriggerAsync(d.Plugins.LocalStorage.Cnds.OnAnyItemGet);
                        await this.TriggerAsync(d.Plugins.LocalStorage.Cnds.OnItemGet)
                    })
                } catch (e) {
                    await this._TriggerStorageError(e)
                } finally {
                    this._pendingGets--, 0 === this._pendingGets && await this.TriggerAsync(d.Plugins.LocalStorage.Cnds.OnAllGetsComplete)
                }
            }
        },
        async CheckItemExists(a) {
            try {
                const f = await this._storage.getItem(a);
                await this.ScheduleTriggers(async () => {
                    this._currentKey = a;
                    "undefined" === typeof f || null === f ? (this._lastValue = "", await this.TriggerAsync(d.Plugins.LocalStorage.Cnds.OnItemMissing)) : (this._lastValue = b(f) ? f : "", await this.TriggerAsync(d.Plugins.LocalStorage.Cnds.OnItemExists))
                })
            } catch (f) {
                await this._TriggerStorageError(f)
            }
        },
        async RemoveItem(a) {
            try {
                await this._storage.removeItem(a), await this.ScheduleTriggers(async () => {
                    this._currentKey =
                        a;
                    this._lastValue = "";
                    await this.TriggerAsync(d.Plugins.LocalStorage.Cnds.OnAnyItemRemoved);
                    await this.TriggerAsync(d.Plugins.LocalStorage.Cnds.OnItemRemoved)
                })
            } catch (f) {
                await this._TriggerStorageError(f)
            }
        },
        async ClearStorage() {
            try {
                await this._storage.clear(), await this.ScheduleTriggers(async () => {
                    this._lastValue = this._currentKey = "";
                    d.clearArray(this._keyNamesList);
                    await this.TriggerAsync(d.Plugins.LocalStorage.Cnds.OnCleared)
                })
            } catch (a) {
                await this._TriggerStorageError(a)
            }
        },
        async GetAllKeyNames() {
            try {
                const a =
                    await this._storage.keys();
                await this.ScheduleTriggers(async () => {
                    this._keyNamesList = a;
                    await this.TriggerAsync(d.Plugins.LocalStorage.Cnds.OnAllKeyNamesLoaded)
                })
            } catch (a) {
                await this._TriggerStorageError(a)
            }
        }
    }
}
"use strict";
self.C3.Plugins.LocalStorage.Exps = {
    ItemValue() {
        return this._lastValue
    },
    Key() {
        return this._currentKey
    },
    KeyCount() {
        return this._keyNamesList.length
    },
    KeyAt(d) {
        d = Math.floor(d);
        return 0 > d || d >= this._keyNamesList.length ? "" : this._keyNamesList[d]
    },
    ErrorMessage() {
        return this._errorMessage
    }
};
"use strict";
{
    const d = self.C3;
    d.Plugins.Audio = class extends d.SDKPluginBase {
        constructor(b) {
            super(b)
        }
        Release() {
            super.Release()
        }
    }
}
"use strict";
{
    const d = self.C3;
    d.Plugins.Audio.Type = class extends d.SDKTypeBase {
        constructor(a) {
            super(a)
        }
        Release() {
            super.Release()
        }
        OnCreate() {}
        GetScriptInterfaceClass() {
            return self.IAudioObjectType
        }
    };

    function b() {
        if (self.C3Audio_DOMInterface) return self.C3Audio_DOMInterface;
        throw Error("audio scripting API cannot be used here - make sure the project is using DOM mode, not worker mode");
    }
    self.IAudioObjectType = class extends self.IObjectClass {
        constructor(a) {
            super(a)
        }
        get audioContext() {
            return b().GetAudioContext()
        }
        get destinationNode() {
            return b().GetDestinationNode()
        }
    }
}
"use strict";
{
    const d = self.C3,
        b = ["interactive", "balanced", "playback"];
    d.Plugins.Audio.Instance = class extends d.SDKInstanceBase {
        constructor(a, f) {
            super(a, "audio");
            this._nextPlayTime = 0;
            this._triggerTag = "";
            this._saveLoadMode = this._timeScaleMode = 0;
            this._playInBackground = !1;
            this._distanceModel = this._panningModel = 1;
            this._listenerX = this._runtime.GetViewportWidth() / 2;
            this._listenerY = this._runtime.GetViewportHeight() / 2;
            this._listenerZ = -600;
            this._referenceDistance = 600;
            this._maxDistance = 1E4;
            this._rolloffFactor = 1;
            this._listenerInst =
                null;
            this._loadListenerUid = -1;
            this._masterVolume = 1;
            this._isSilent = !1;
            this._sampleRate = 0;
            this._effectCount = new Map;
            this._preloadCount = this._preloadTotal = 0;
            this._remoteUrls = new Map;
            a = "interactive";
            f && (this._timeScaleMode = f[0], this._saveLoadMode = f[1], this._playInBackground = f[2], a = b[f[3]], this._panningModel = f[4], this._distanceModel = f[5], this._listenerZ = -f[6], this._referenceDistance = f[7], this._maxDistance = f[8], this._rolloffFactor = f[9]);
            this._lastAIState = [];
            this._lastFxState = [];
            this._lastAnalysersData = [];
            this.AddDOMMessageHandlers([
                ["state", c => this._OnUpdateState(c)],
                ["fxstate", c => this._OnUpdateFxState(c)],
                ["trigger", c => this._OnTrigger(c)]
            ]);
            f = this.GetRuntime().Dispatcher();
            this._disposables = new d.CompositeDisposable(d.Disposable.From(f, "instancedestroy", c => this._OnInstanceDestroyed(c.instance)), d.Disposable.From(f, "afterload", () => this._OnAfterLoad()), d.Disposable.From(f, "suspend", () => this._OnSuspend()), d.Disposable.From(f, "resume", () => this._OnResume()));
            this._runtime.AddLoadPromise(this.PostToDOMAsync("create-audio-context", {
                preloadList: this._runtime.GetAssetManager().GetAudioToPreload().map(c => ({
                    originalUrl: c.originalUrl,
                    url: c.url,
                    type: c.type,
                    fileSize: c.fileSize
                })),
                isiOSCordova: this._runtime.IsiOSCordova(),
                timeScaleMode: this._timeScaleMode,
                latencyHint: a,
                panningModel: this._panningModel,
                distanceModel: this._distanceModel,
                refDistance: this._referenceDistance,
                maxDistance: this._maxDistance,
                rolloffFactor: this._rolloffFactor,
                listenerPos: [this._listenerX, this._listenerY, this._listenerZ]
            }).then(c => {
                this._sampleRate = c.sampleRate
            }));
            this._StartTicking()
        }
        Release() {
            this._listenerInst = null;
            super.Release()
        }
        _OnInstanceDestroyed(a) {
            this._listenerInst === a && (this._listenerInst = null)
        }
        DbToLinearNoCap(a) {
            return Math.pow(10, a / 20)
        }
        DbToLinear(a) {
            a = this.DbToLinearNoCap(a);
            return isFinite(a) ? Math.max(Math.min(a, 1), 0) : 0
        }
        LinearToDbNoCap(a) {
            return Math.log(a) / Math.log(10) * 20
        }
        LinearToDb(a) {
            return this.LinearToDbNoCap(Math.max(Math.min(a, 1), 0))
        }
        _OnSuspend() {
            this._playInBackground || this.PostToDOM("set-suspended", {
                isSuspended: !0
            })
        }
        _OnResume() {
            this._playInBackground ||
                this.PostToDOM("set-suspended", {
                    isSuspended: !1
                })
        }
        _OnUpdateState(a) {
            // console.log("IDDQD _OnUpdateState " + JSON.stringify(a))
            const f = a.tickCount,
                c = this._lastAIState.filter(e => e.hasOwnProperty("placeholder") && (e.placeholder > f || -1 === e.placeholder));
            this._lastAIState = a.audioInstances;
            this._lastAnalysersData = a.analysers;
            0 < c.length && d.appendArray(this._lastAIState, c)
        }
        _OnUpdateFxState(a) {
            this._lastFxState = a.fxstate
        }
        _GetFirstAudioStateByTag(a) {
            for (const f of this._lastAIState)
                if (d.equalsNoCase(f.tag, a)) return f;
            return null
        }
        _IsTagPlaying(a) {
            return this._lastAIState.some(f =>
                d.equalsNoCase(a, f.tag) && f.isPlaying)
        }
        _MaybeMarkAsPlaying(a, f, c, e) {
            if (this._IsTagPlaying(a)) return null;
            a = {
                tag: a,
                duration: 0,
                volume: e,
                isPlaying: !0,
                playbackTime: 0,
                playbackRate: 1,
                uid: -1,
                bufferOriginalUrl: "",
                bufferUrl: "",
                bufferType: "",
                isMusic: f,
                isLooping: c,
                isMuted: !1,
                resumePosition: 0,
                pan: null,
                placeholder: -1
            };
            this._lastAIState.push(a);
            return a
        }
        async _OnTrigger(a) {
            const f = a.type;
            this._triggerTag = a.tag;
            a = a.aiid;
            // console.log("IDDQD _OnTrigger 1 " + this._lastAIState);
            // console.log("IDDQD _OnTrigger 2 " + JSON.stringify( this._lastAIState));
            if ("ended" === f) {
                for (const c of this._lastAIState)
                    
                    if (c.aiid === a) {
                        c.isPlaying = !1;
                        break
                    } await this.TriggerAsync(d.Plugins.Audio.Cnds.OnEnded)
            } else "fade-ended" ===
                f && await this.TriggerAsync(d.Plugins.Audio.Cnds.OnFadeEnded)
        }
        Tick() {
            const a = {
                timeScale: this._runtime.GetTimeScale(),
                gameTime: this._runtime.GetGameTime(),
                instPans: this.GetInstancePans(),
                tickCount: this._runtime.GetTickCountNoSave()
            };
            if (this._listenerInst) {
                const f = this._listenerInst.GetWorldInfo();
                this._listenerX = f.GetX();
                this._listenerY = f.GetY();
                a.listenerPos = [this._listenerX, this._listenerY, this._listenerZ]
            }
            this.PostToDOM("tick", a)
        }
        rotatePtAround(a, f, c, e, g) {
            if (0 === c) return [a, f];
            const h = Math.sin(c);
            c = Math.cos(c);
            a -= e;
            f -= g;
            const l = a * h;
            a = a * c - f * h;
            return [a + e, f * c + l + g]
        }
        GetInstancePans() {
            return this._lastAIState.filter(a => -1 !== a.uid).map(a => this._runtime.GetInstanceByUID(a.uid)).filter(a => a).map(a => {
                const f = a.GetWorldInfo(),
                    c = f.GetLayer().GetAngle(),
                    [e, g] = this.rotatePtAround(f.GetX(), f.GetY(), -c, this._listenerX, this._listenerY);
                return {
                    uid: a.GetUID(),
                    x: e,
                    y: g,
                    angle: f.GetAngle() - c
                }
            })
        }
        GetAnalyserData(a, f) {
            for (const c of this._lastAnalysersData)
                if (c.index === f && d.equalsNoCase(c.tag, a)) return c;
            return null
        }
        _IncrementEffectCount(a) {
            // console.log("IDDQD _IncrementEffectCount " + a)
            this._effectCount.set(a,
                (this._effectCount.get(a) || 0) + 1)
        }
        _ShouldSave(a) {
            return a.hasOwnProperty("placeholder") || 3 === this._saveLoadMode ? !1 : a.isMusic && 1 === this._saveLoadMode ? !1 : a.isMusic || 2 !== this._saveLoadMode ? !0 : !1
        }
        SaveToJson() {
            return {
                isSilent: this._isSilent,
                masterVolume: this._masterVolume,
                listenerZ: this._listenerZ,
                listenerUid: this._listenerInst ? this._listenerInst.GetUID() : -1,
                remoteUrls: [...this._remoteUrls.entries()],
                playing: this._lastAIState.filter(a => this._ShouldSave(a)),
                effects: this._lastFxState,
                analysers: this._lastAnalysersData
            }
        }
        LoadFromJson(a) {
            this._isSilent =
                a.isSilent;
            this._masterVolume = a.masterVolume;
            this._listenerZ = a.listenerZ;
            this._listenerInst = null;
            this._loadListenerUid = a.listenerUid;
            this._remoteUrls.clear();
            if (a.remoteUrls)
                for (const [f, c] of a.remoteUrls) this._remoteUrls.set(f, c);
            this._lastAIState = a.playing;
            this._lastFxState = a.effects;
            this._lastAnalysersData = a.analysers
        }
        _OnAfterLoad() {
            if (-1 !== this._loadListenerUid && (this._listenerInst = this._runtime.GetInstanceByUID(this._loadListenerUid), this._loadListenerUid = -1, this._listenerInst)) {
                var a = this._listenerInst.GetWorldInfo();
                this._listenerX = a.GetX();
                this._listenerY = a.GetY()
            }
            for (var f of this._lastAIState)(a = this._runtime.GetAssetManager().GetProjectAudioFileUrl(f.bufferOriginalUrl)) ? (f.bufferUrl = a.url, f.bufferType = a.type) : f.bufferUrl = null;
            for (const c of Object.values(this._lastFxState))
                for (const e of c) e.hasOwnProperty("bufferOriginalUrl") && (f = this._runtime.GetAssetManager().GetProjectAudioFileUrl(e.bufferOriginalUrl)) && (e.bufferUrl = f.url, e.bufferType = f.type);
            this.PostToDOM("load-state", {
                saveLoadMode: this._saveLoadMode,
                timeScale: this._runtime.GetTimeScale(),
                gameTime: this._runtime.GetGameTime(),
                listenerPos: [this._listenerX, this._listenerY, this._listenerZ],
                isSilent: this._isSilent,
                masterVolume: this._masterVolume,
                playing: this._lastAIState.filter(c => null !== c.bufferUrl),
                effects: this._lastFxState
            })
        }
        GetDebuggerProperties() {
            const a = [];
            for (const [f, c] of Object.entries(this._lastFxState)) a.push({
                name: "$" + f,
                value: c.map(e => e.type).join(", ")
            });
            return [{
                title: "plugins.audio.debugger.tag-effects",
                properties: a
            }, {
                title: "plugins.audio.debugger.currently-playing",
                properties: [{
                    name: "plugins.audio.debugger.currently-playing-count",
                    value: this._lastAIState.length
                }, ...this._lastAIState.map((f, c) => ({
                    name: "$#" + c,
                    value: `${f.bufferOriginalUrl} ("${f.tag}") ${Math.round(10 * f.playbackTime) / 10} / ${Math.round(10 * f.duration) / 10}`
                }))]
            }]
        }
    }
}
"use strict";
{
    const d = self.C3;
    d.Plugins.Audio.Cnds = {
        OnEnded(b) {
            return d.equalsNoCase(this._triggerTag, b)
        },
        OnFadeEnded(b) {
            return d.equalsNoCase(this._triggerTag, b)
        },
        PreloadsComplete() {
            return this._preloadCount === this._preloadTotal
        },
        AdvancedAudioSupported() {
            return !0
        },
        IsSilent() {
            return this._isSilent
        },
        IsAnyPlaying() {
            for (const b of this._lastAIState)
                if (b.isPlaying) return !0;
            return !1
        },
        IsTagPlaying(b) {
            return this._IsTagPlaying(b)
        }
    }
}
"use strict";
{
    const d = self.C3,
        b = "lowpass highpass bandpass lowshelf highshelf peaking notch allpass".split(" ");
    d.Plugins.Audio.Acts = {
        async Play(a, f, c, e) {
            if (!this._isSilent) {
                var g = a[1],
                    h = this._runtime.GetAssetManager().GetProjectAudioFileUrl(a[0]);
                if (h) {
                    var l = this._nextPlayTime;
                    this._nextPlayTime = 0;
                    var m = this._MaybeMarkAsPlaying(e.toLowerCase(), g, 0 !== f, this.DbToLinear(c));
                    try {
                        await this.PostToDOMAsync("play", {
                            originalUrl: a[0],
                            url: h.url,
                            type: h.type,
                            isMusic: g,
                            tag: e.toLowerCase(),
                            isLooping: 0 !== f,
                            vol: this.DbToLinear(c),
                            pos: 0,
                            off: l,
                            trueClock: !!self.C3_GetAudioContextCurrentTime
                        })
                    } finally {
                        m && (m.placeholder = this._runtime.GetTickCountNoSave())
                    }
                }
            }
        },
        async PlayAtPosition(a, f, c, e, g, h, l, m, p, t) {
            if (!this._isSilent) {
                var q = a[1],
                    r = this._runtime.GetAssetManager().GetProjectAudioFileUrl(a[0]);
                if (r) {
                    var u = this._nextPlayTime;
                    this._nextPlayTime = 0;
                    var x = this._MaybeMarkAsPlaying(t.toLowerCase(), q, 0 !== f, this.DbToLinear(c));
                    try {
                        await this.PostToDOMAsync("play", {
                            originalUrl: a[0],
                            url: r.url,
                            type: r.type,
                            isMusic: q,
                            tag: t.toLowerCase(),
                            isLooping: 0 !==
                                f,
                            vol: this.DbToLinear(c),
                            pos: 0,
                            off: u,
                            trueClock: !!self.C3_GetAudioContextCurrentTime,
                            panning: {
                                x: e,
                                y: g,
                                angle: d.toRadians(h),
                                innerAngle: d.toRadians(l),
                                outerAngle: d.toRadians(m),
                                outerGain: this.DbToLinear(p)
                            }
                        })
                    } finally {
                        x && (x.placeholder = this._runtime.GetTickCountNoSave())
                    }
                }
            }
        },
        async PlayAtObject(a, f, c, e, g, h, l, m) {
            // console.log("IDDQD playat " + JSON.stringify(e.GetWorldInfo()))
            if (!this._isSilent && e && (e = e.GetFirstPicked()) && e.GetWorldInfo()) {
                var p = e.GetWorldInfo(),
                    t = p.GetLayer().GetAngle(),
                    [q, r] = this.rotatePtAround(p.GetX(), p.GetY(), -t, this._listenerX, this._listenerY),
                    u = a[1],
                    x = this._runtime.GetAssetManager().GetProjectAudioFileUrl(a[0]);
                if (x) {
                    var y = this._nextPlayTime;
                    this._nextPlayTime = 0;
                    var C = this._MaybeMarkAsPlaying(m.toLowerCase(), u, 0 !== f, this.DbToLinear(c));
                    try {
                        await this.PostToDOMAsync("play", {
                            originalUrl: a[0],
                            url: x.url,
                            type: x.type,
                            isMusic: u,
                            tag: m.toLowerCase(),
                            isLooping: 0 !== f,
                            vol: this.DbToLinear(c),
                            pos: 0,
                            off: y,
                            trueClock: !!self.C3_GetAudioContextCurrentTime,
                            panning: {
                                x: q,
                                y: r,
                                angle: p.GetAngle() - t,
                                innerAngle: d.toRadians(g),
                                outerAngle: d.toRadians(h),
                                outerGain: this.DbToLinear(l),
                                uid: e.GetUID()
                            }
                        })
                    } finally {
                        C && (C.placeholder = this._runtime.GetTickCountNoSave())
                    }
                }
            }
        },
        async PlayByName(a, f, c, e, g) {
            if (!this._isSilent) {
                a = 1 === a;
                var h = this._runtime.GetAssetManager().GetProjectAudioFileUrl(f) || this._remoteUrls.get(f.toLowerCase());
                if (h) {
                    var l = this._nextPlayTime;
                    this._nextPlayTime = 0;
                    var m = this._MaybeMarkAsPlaying(g.toLowerCase(), a, 0 !== c, this.DbToLinear(e));
                    try {
                        await this.PostToDOMAsync("play", {
                            originalUrl: f,
                            url: h.url,
                            type: h.type,
                            isMusic: a,
                            tag: g.toLowerCase(),
                            isLooping: 0 !== c,
                            vol: this.DbToLinear(e),
                            pos: 0,
                            off: l,
                            trueClock: !!self.C3_GetAudioContextCurrentTime
                        })
                    } finally {
                        m && (m.placeholder = this._runtime.GetTickCountNoSave())
                    }
                }
            }
        },
        async PlayAtPositionByName(a, f, c, e, g, h, l, m, p, t, q) {
            if (!this._isSilent) {
                a = 1 === a;
                var r = this._runtime.GetAssetManager().GetProjectAudioFileUrl(f) || this._remoteUrls.get(f.toLowerCase());
                if (r) {
                    var u = this._nextPlayTime;
                    this._nextPlayTime = 0;
                    var x = this._MaybeMarkAsPlaying(q.toLowerCase(), a, 0 !== c, this.DbToLinear(e));
                    try {
                        await this.PostToDOMAsync("play", {
                            originalUrl: f,
                            url: r.url,
                            type: r.type,
                            isMusic: a,
                            tag: q.toLowerCase(),
                            isLooping: 0 !== c,
                            vol: this.DbToLinear(e),
                            pos: 0,
                            off: u,
                            trueClock: !!self.C3_GetAudioContextCurrentTime,
                            panning: {
                                x: g,
                                y: h,
                                angle: d.toRadians(l),
                                innerAngle: d.toRadians(m),
                                outerAngle: d.toRadians(p),
                                outerGain: this.DbToLinear(t)
                            }
                        })
                    } finally {
                        x && (x.placeholder = this._runtime.GetTickCountNoSave())
                    }
                }
            }
        },
        async PlayAtObjectByName(a, f, c, e, g, h, l, m, p) {
            if (!this._isSilent && !this._isSilent && g && (g = g.GetFirstPicked()) && g.GetWorldInfo()) {
                var t = g.GetWorldInfo(),
                    q = t.GetLayer().GetAngle(),
                    [r, u] = this.rotatePtAround(t.GetX(),
                        t.GetY(), -q, this._listenerX, this._listenerY);
                a = 1 === a;
                var x = this._runtime.GetAssetManager().GetProjectAudioFileUrl(f) || this._remoteUrls.get(f.toLowerCase());
                if (x) {
                    var y = this._nextPlayTime;
                    this._nextPlayTime = 0;
                    var C = this._MaybeMarkAsPlaying(p.toLowerCase(), a, 0 !== c, this.DbToLinear(e));
                    try {
                        await this.PostToDOMAsync("play", {
                            originalUrl: f,
                            url: x.url,
                            type: x.type,
                            isMusic: a,
                            tag: p.toLowerCase(),
                            isLooping: 0 !== c,
                            vol: this.DbToLinear(e),
                            pos: 0,
                            off: y,
                            trueClock: !!self.C3_GetAudioContextCurrentTime,
                            panning: {
                                x: r,
                                y: u,
                                angle: t.GetAngle() - q,
                                innerAngle: d.toRadians(h),
                                outerAngle: d.toRadians(l),
                                outerGain: this.DbToLinear(m),
                                uid: g.GetUID()
                            }
                        })
                    } finally {
                        C && (C.placeholder = this._runtime.GetTickCountNoSave())
                    }
                }
            }
        },
        SetLooping(a, f) {
            this.PostToDOM("set-looping", {
                tag: a.toLowerCase(),
                isLooping: 0 === f
            })
        },
        SetMuted(a, f) {
            this.PostToDOM("set-muted", {
                tag: a.toLowerCase(),
                isMuted: 0 === f
            })
        },
        SetVolume(a, f) {
            this.PostToDOM("set-volume", {
                tag: a.toLowerCase(),
                vol: this.DbToLinear(f)
            })
        },
        FadeVolume(a, f, c, e) {
            this.PostToDOM("fade-volume", {
                tag: a.toLowerCase(),
                vol: this.DbToLinear(f),
                duration: c,
                stopOnEnd: 0 === e
            })
        },
        async Preload(a) {
            const f = a[1],
                c = this._runtime.GetAssetManager().GetProjectAudioFileUrl(a[0]);
            c && (this._preloadTotal++, await this.PostToDOMAsync("preload", {
                originalUrl: a[0],
                url: c.url,
                type: c.type,
                isMusic: f
            }), this._preloadCount++)
        },
        async PreloadByName(a, f) {
            a = 1 === a;
            const c = this._runtime.GetAssetManager().GetProjectAudioFileUrl(f) || this._remoteUrls.get(f.toLowerCase());
            c && (this._preloadTotal++, await this.PostToDOMAsync("preload", {
                originalUrl: f,
                url: c.url,
                type: c.type,
                isMusic: a
            }), this._preloadCount++)
        },
        SetPlaybackRate(a, f) {
            this.PostToDOM("set-playback-rate", {
                tag: a.toLowerCase(),
                rate: Math.max(f, 0)
            })
        },
        Stop(a) {
            this.PostToDOM("stop", {
                tag: a.toLowerCase()
            })
        },
        StopAll() {
            this.PostToDOM("stop-all")
        },
        SetPaused(a, f) {
            this.PostToDOM("set-paused", {
                tag: a.toLowerCase(),
                paused: 0 === f
            })
        },
        Seek(a, f) {
            this.PostToDOM("seek", {
                tag: a.toLowerCase(),
                pos: f
            })
        },
        SetSilent(a) {
            2 === a && (a = this._isSilent ? 1 : 0);
            a = 0 === a;
            this._isSilent !== a && (this._isSilent = a, this.PostToDOM("set-silent", {
                isSilent: a
            }))
        },
        SetMasterVolume(a) {
            a = this.DbToLinear(a);
            this._masterVolume !== a && (this._masterVolume = a, this.PostToDOM("set-master-volume", {
                vol: a
            }))
        },
        AddFilterEffect(a, f, c, e, g, h, l) {
            a = a.toLowerCase();
            f = b[f];
            this._IncrementEffectCount(a);
            this.PostToDOM("add-effect", {
                type: "filter",
                tag: a,
                params: [f, c, e, g, h, d.clamp(l / 100, 0, 1)]
            })
        },
        AddDelayEffect(a, f, c, e) {
            a = a.toLowerCase();
            this._IncrementEffectCount(a);
            this.PostToDOM("add-effect", {
                type: "delay",
                tag: a,
                params: [f, this.DbToLinear(c), d.clamp(e / 100, 0, 1)]
            })
        },
        AddFlangerEffect(a, f,
            c, e, g, h) {
            a = a.toLowerCase();
            this._IncrementEffectCount(a);
            this.PostToDOM("add-effect", {
                type: "flanger",
                tag: a,
                params: [f / 1E3, c / 1E3, e, g / 100, d.clamp(h / 100, 0, 1)]
            })
        },
        AddPhaserEffect(a, f, c, e, g, h, l) {
            a = a.toLowerCase();
            this._IncrementEffectCount(a);
            this.PostToDOM("add-effect", {
                type: "phaser",
                tag: a,
                params: [f, c, e, g, h, d.clamp(l / 100, 0, 1)]
            })
        },
        AddConvolutionEffect(a, f, c, e) {
            a = a.toLowerCase();
            const g = this._runtime.GetAssetManager().GetProjectAudioFileUrl(f[0]);
            g && (this._IncrementEffectCount(a), this.PostToDOM("add-effect", {
                type: "convolution",
                tag: a,
                bufferOriginalUrl: f[0],
                bufferUrl: g.url,
                bufferType: g.type,
                params: [0 === c, d.clamp(e / 100, 0, 1)]
            }))
        },
        AddGainEffect(a, f) {
            a = a.toLowerCase();
            this._IncrementEffectCount(a);
            this.PostToDOM("add-effect", {
                type: "gain",
                tag: a,
                params: [this.DbToLinear(f)]
            })
        },
        AddMuteEffect(a) {
            a = a.toLowerCase();
            this._IncrementEffectCount(a);
            this.PostToDOM("add-effect", {
                type: "gain",
                tag: a,
                params: [0]
            })
        },
        AddTremoloEffect(a, f, c) {
            a = a.toLowerCase();
            this._IncrementEffectCount(a);
            this.PostToDOM("add-effect", {
                type: "tremolo",
                tag: a,
                params: [f, d.clamp(c / 100, 0, 1)]
            })
        },
        AddRingModEffect(a, f, c) {
            a = a.toLowerCase();
            this._IncrementEffectCount(a);
            this.PostToDOM("add-effect", {
                type: "ringmod",
                tag: a,
                params: [f, d.clamp(c / 100, 0, 1)]
            })
        },
        AddDistortionEffect(a, f, c, e, g, h) {
            a = a.toLowerCase();
            this._IncrementEffectCount(a);
            this.PostToDOM("add-effect", {
                type: "distortion",
                tag: a,
                params: [this.DbToLinearNoCap(f), this.DbToLinearNoCap(c), e, this.DbToLinearNoCap(g), d.clamp(h / 100, 0, 1)]
            })
        },
        AddCompressorEffect(a, f, c, e, g, h) {
            a = a.toLowerCase();
            this._IncrementEffectCount(a);
            this.PostToDOM("add-effect", {
                type: "compressor",
                tag: a,
                params: [f, c, e, g / 1E3, h / 1E3]
            })
        },
        AddAnalyserEffect(a, f, c) {
            a = a.toLowerCase();
            this._IncrementEffectCount(a);
            this.PostToDOM("add-effect", {
                type: "analyser",
                tag: a,
                params: [f, c]
            })
        },
        RemoveEffects(a) {
            a = a.toLowerCase();
            this._effectCount.set(a, 0);
            this.PostToDOM("remove-effects", {
                tag: a
            });
            this._lastFxState = {}
        },
        SetEffectParameter(a, f, c, e, g, h) {
            this.PostToDOM("set-effect-param", {
                tag: a.toLowerCase(),
                index: Math.floor(f),
                param: c,
                value: e,
                ramp: g,
                time: h
            })
        },
        SetListenerObject(a) {
            a &&
                (a = a.GetFirstPicked()) && a.GetWorldInfo() && (this._listenerInst = a)
        },
        SetListenerZ(a) {
            this._listenerZ = a
        },
        ScheduleNextPlay(a) {
            this._nextPlayTime = Math.max(a, 0)
        },
        UnloadAudio(a) {
            const f = a[1];
            (a = this._runtime.GetAssetManager().GetProjectAudioFileUrl(a[0])) && this.PostToDOM("unload", {
                url: a.url,
                type: a.type,
                isMusic: f
            })
        },
        UnloadAudioByName(a, f) {
            a = 1 === a;
            (f = this._runtime.GetAssetManager().GetProjectAudioFileUrl(f) || this._remoteUrls.get(f.toLowerCase())) && this.PostToDOM("unload", {
                url: f.url,
                type: f.type,
                isMusic: a
            })
        },
        UnloadAll() {
            this.PostToDOM("unload-all")
        },
        AddRemoteURL(a, f, c) {
            this._remoteUrls.set(c.toLowerCase(), {
                url: a,
                type: f
            })
        }
    }
}
"use strict";
self.C3.Plugins.Audio.Exps = {
    Duration(d) {
        return (d = this._GetFirstAudioStateByTag(d)) ? d.duration : 0
    },
    PlaybackTime(d) {
        return (d = this._GetFirstAudioStateByTag(d)) ? d.playbackTime : 0
    },
    PlaybackRate(d) {
        return (d = this._GetFirstAudioStateByTag(d)) ? d.playbackRate : 0
    },
    Volume(d) {
        return (d = this._GetFirstAudioStateByTag(d)) ? this.LinearToDb(d.volume) : 0
    },
    MasterVolume() {
        return this.LinearToDb(this._masterVolume)
    },
    EffectCount(d) {
        return this._effectCount.get(d.toLowerCase()) || 0
    },
    AnalyserFreqBinCount(d, b) {
        return (d = this.GetAnalyserData(d,
            Math.floor(b))) ? d.binCount : 0
    },
    AnalyserFreqBinAt(d, b, a) {
        d = this.GetAnalyserData(d, Math.floor(b));
        if (!d) return 0;
        a = Math.floor(a);
        return 0 > a || a >= d.binCount ? 0 : d.freqBins[a]
    },
    AnalyserPeakLevel(d, b) {
        return (d = this.GetAnalyserData(d, Math.floor(b))) ? d.peak : 0
    },
    AnalyserRMSLevel(d, b) {
        return (d = this.GetAnalyserData(d, Math.floor(b))) ? d.rms : 0
    },
    SampleRate() {
        return this._sampleRate
    },
    CurrentTime() {
        return self.C3_GetAudioContextCurrentTime ? self.C3_GetAudioContextCurrentTime() : performance.now() / 1E3
    }
};
"use strict";
{
    const d = self.C3;
    d.Plugins.Arr = class extends d.SDKPluginBase {
        constructor(b) {
            super(b)
        }
        Release() {
            super.Release()
        }
    }
}
"use strict";
{
    const d = self.C3;
    d.Plugins.Arr.Type = class extends d.SDKTypeBase {
        constructor(b) {
            super(b)
        }
        Release() {
            super.Release()
        }
        OnCreate() {}
    }
}
"use strict";
{
    const d = self.C3,
        b = self.IInstance;

    function a(c, e, g) {
        if (e < c.length) d.truncateArray(c, e);
        else if (e > c.length)
            if ("function" === typeof g)
                for (var h = c.length; h < e; ++h) c.push(g());
            else
                for (h = c.length; h < e; ++h) c.push(g)
    }
    d.Plugins.Arr.Instance = class extends d.SDKInstanceBase {
        constructor(c, e) {
            super(c);
            this._cx = 10;
            this._cz = this._cy = 1;
            this._arr = null;
            this._forX = [];
            this._forY = [];
            this._forZ = [];
            this._forDepth = -1;
            e && (this._cx = e[0], this._cy = e[1], this._cz = e[2]);
            this._arr = d.MakeFilledArray(this._cx, () => d.MakeFilledArray(this._cy,
                () => d.MakeFilledArray(this._cz, 0)))
        }
        Release() {
            this._arr = null;
            super.Release()
        }
        At(c, e, g) {
            c = Math.floor(c);
            e = Math.floor(e);
            g = Math.floor(g);
            return 0 <= c && c < this._cx && 0 <= e && e < this._cy && 0 <= g && g < this._cz ? this._arr[c][e][g] : 0
        }
        Set(c, e, g, h) {
            c = Math.floor(c);
            e = Math.floor(e);
            g = Math.floor(g);
            0 <= c && c < this._cx && 0 <= e && e < this._cy && 0 <= g && g < this._cz && (this._arr[c][e][g] = h)
        }
        SetSize(c, e, g) {
            c = Math.floor(c);
            e = Math.floor(e);
            g = Math.floor(g);
            0 > c && (c = 0);
            0 > e && (e = 0);
            0 > g && (g = 0);
            if (this._cx !== c || this._cy !== e || this._cz !== g) {
                this._cx =
                    c;
                this._cy = e;
                this._cz = g;
                var h = this._arr;
                a(h, c, () => d.MakeFilledArray(e, () => d.MakeFilledArray(g, 0)));
                for (let l = 0; l < c; ++l) {
                    a(h[l], e, () => d.MakeFilledArray(g, 0));
                    for (let m = 0; m < e; ++m) a(h[l][m], g, 0)
                }
            }
        }
        GetWidth() {
            return this._cx
        }
        GetHeight() {
            return this._cy
        }
        GetDepth() {
            return this._cz
        }
        GetDebuggerProperties() {
            const c = [{
                    title: "plugins.arr.debugger.array-properties.title",
                    properties: [{
                        name: "plugins.arr.properties.width.name",
                        value: this._cx,
                        onedit: g => this.SetSize(g, this._cy, this._cz)
                    }, {
                        name: "plugins.arr.properties.height.name",
                        value: this._cy,
                        onedit: g => this.SetSize(this._cx, g, this._cz)
                    }, {
                        name: "plugins.arr.properties.depth.name",
                        value: this._cz,
                        onedit: g => this.SetSize(this._cx, this._cy, g)
                    }, {
                        name: "plugins.arr.properties.elements.name",
                        value: this._cx * this._cy * this._cz
                    }]
                }],
                e = [];
            if (1 === this._cy && 1 === this._cz)
                for (let g = 0; g < this._cx; ++g) e.push({
                    name: "$" + g,
                    value: this._arr[g][0][0],
                    onedit: h => this._arr[g][0][0] = h
                });
            else
                for (let g = 0; g < this._cx; ++g) e.push({
                    name: "$" + g,
                    value: this._arr[g].toString()
                });
            e.length && c.push({
                title: "plugins.arr.debugger.array-data.title",
                properties: e
            });
            return c
        }
        GetAsJsonString() {
            return JSON.stringify({
                c2array: !0,
                size: [this._cx, this._cy, this._cz],
                data: this._arr
            })
        }
        SaveToJson() {
            return {
                size: [this._cx, this._cy, this._cz],
                data: this._arr
            }
        }
        LoadFromJson(c) {
            const e = c.size;
            this._cx = e[0];
            this._cy = e[1];
            this._cz = e[2];
            this._arr = c.data
        }
        _GetForX() {
            return 0 <= this._forDepth && this._forDepth < this._forX.length ? this._forX[this._forDepth] : 0
        }
        _GetForY() {
            return 0 <= this._forDepth && this._forDepth < this._forY.length ? this._forY[this._forDepth] : 0
        }
        _GetForZ() {
            return 0 <=
                this._forDepth && this._forDepth < this._forZ.length ? this._forZ[this._forDepth] : 0
        }
        GetScriptInterfaceClass() {
            return self.IArrayInstance
        }
    };
    const f = new WeakMap;
    self.IArrayInstance = class extends b {
        constructor() {
            super();
            f.set(this, b._GetInitInst().GetSdkInstance())
        }
        get width() {
            return f.get(this).GetWidth()
        }
        get height() {
            return f.get(this).GetHeight()
        }
        get depth() {
            return f.get(this).GetDepth()
        }
        setSize(c, e = 1, g = 1) {
            f.get(this).SetSize(c, e, g)
        }
        getAt(c, e = 0, g = 0) {
            return f.get(this).At(c, e, g)
        }
        setAt(c, e, g = 0, h = 0) {
            if ("number" !==
                typeof c && "string" !== typeof c) throw new TypeError("invalid type");
            f.get(this).Set(e, g, h, c)
        }
    }
}
"use strict";
{
    const d = self.C3;

    function b(a, f, c, e, g) {
        a.PushCopySol(c);
        f.Retrigger(e, g);
        a.PopSol(c)
    }
    d.Plugins.Arr.Cnds = {
        CompareX(a, f, c) {
            return d.compare(this.At(a, 0, 0), f, c)
        },
        CompareXY(a, f, c, e) {
            return d.compare(this.At(a, f, 0), c, e)
        },
        CompareXYZ(a, f, c, e, g) {
            return d.compare(this.At(a, f, c), e, g)
        },
        ArrForEach(a) {
            const f = this._runtime,
                c = f.GetEventSheetManager(),
                e = f.GetCurrentEvent(),
                g = e.GetSolModifiers(),
                h = f.GetEventStack(),
                l = h.GetCurrentStackFrame(),
                m = h.Push(e),
                p = ++this._forDepth,
                t = this._forX;
            var q = this._forY,
                r = this._forZ;
            const u = this._cx,
                x = this._cy;
            var y = this._cz;
            p === this._forX.length ? (t.push(0), q.push(0), r.push(0)) : (t[p] = 0, q[p] = 0, r[p] = 0);
            f.SetDebuggingEnabled(!1);
            if (0 === a)
                for (a = 0; a < u; ++a)
                    for (let C = 0; C < x; ++C)
                        for (let w = 0; w < y; ++w) t[p] = a, q[p] = C, r[p] = w, b(c, e, g, l, m);
            else if (1 === a)
                for (r = 0; r < u; ++r)
                    for (y = 0; y < x; ++y) t[p] = r, q[p] = y, b(c, e, g, l, m);
            else
                for (q = 0; q < u; ++q) t[p] = q, b(c, e, g, l, m);
            f.SetDebuggingEnabled(!0);
            this._forDepth--;
            h.Pop();
            return !1
        },
        CompareCurrent(a, f) {
            return d.compare(this.At(this._GetForX(), this._GetForY(), this._GetForZ()),
                a, f)
        },
        Contains(a) {
            const f = this._cx,
                c = this._cy,
                e = this._cz,
                g = this._arr;
            for (let h = 0; h < f; ++h)
                for (let l = 0; l < c; ++l)
                    for (let m = 0; m < e; ++m)
                        if (g[h][l][m] === a) return !0;
            return !1
        },
        IsEmpty() {
            return 0 === this._cx || 0 === this._cy || 0 === this._cz
        },
        CompareSize(a, f, c) {
            let e = 0;
            switch (a) {
                case 0:
                    e = this._cx;
                    break;
                case 1:
                    e = this._cy;
                    break;
                case 2:
                    e = this._cz
            }
            return d.compare(e, f, c)
        }
    }
}
"use strict";
{
    const d = self.C3;

    function b(a, f) {
        if ("number" === typeof a && "number" === typeof f) return a - f;
        a = a.toString();
        f = f.toString();
        return a < f ? -1 : a > f ? 1 : 0
    }
    d.Plugins.Arr.Acts = {
        Clear(a) {
            const f = this._cx,
                c = this._cy,
                e = this._cz,
                g = this._arr;
            for (let h = 0; h < f; ++h)
                for (let l = 0; l < c; ++l)
                    for (let m = 0; m < e; ++m) g[h][l][m] = a
        },
        SetSize(a, f, c) {
            this.SetSize(a, f, c)
        },
        SetX(a, f) {
            this.Set(a, 0, 0, f)
        },
        SetXY(a, f, c) {
            this.Set(a, f, 0, c)
        },
        SetXYZ(a, f, c, e) {
            this.Set(a, f, c, e)
        },
        Push(a, f, c) {
            var e = this._cx,
                g = this._cy;
            const h = this._cz,
                l = this._arr;
            if (0 === c) e =
                d.MakeFilledArray(g, () => d.MakeFilledArray(h, f)), 0 === a ? l.push(e) : l.unshift(e), this._cx++;
            else if (1 === c) {
                for (g = 0; g < e; ++g) c = d.MakeFilledArray(h, f), 0 === a ? l[g].push(c) : l[g].unshift(c);
                this._cy++
            } else {
                for (c = 0; c < e; ++c)
                    for (let m = 0; m < g; ++m) 0 === a ? l[c][m].push(f) : l[c][m].unshift(f);
                this._cz++
            }
        },
        Pop(a, f) {
            const c = this._cx;
            var e = this._cy,
                g = this._cz;
            const h = this._arr;
            if (0 === f) 0 !== c && (0 === a ? h.pop() : h.shift(), this._cx--);
            else if (1 === f) {
                if (0 !== e) {
                    for (e = 0; e < c; ++e) 0 === a ? h[e].pop() : h[e].shift();
                    this._cy--
                }
            } else if (0 !==
                g) {
                for (f = 0; f < c; ++f)
                    for (g = 0; g < e; ++g) 0 === a ? h[f][g].pop() : h[f][g].shift();
                this._cz--
            }
        },
        Reverse(a) {
            const f = this._cx;
            var c = this._cy,
                e = this._cz;
            const g = this._arr;
            if (0 !== f && 0 !== c && 0 !== e)
                if (0 === a) g.reverse();
                else if (1 === a)
                for (c = 0; c < f; ++c) g[c].reverse();
            else
                for (a = 0; a < f; ++a)
                    for (e = 0; e < c; ++e) g[a][e].reverse()
        },
        Sort(a) {
            const f = this._cx;
            var c = this._cy,
                e = this._cz;
            const g = this._arr;
            if (0 !== f && 0 !== c && 0 !== e)
                if (0 === a) g.sort((h, l) => b(h[0][0], l[0][0]));
                else if (1 === a)
                for (c = 0; c < f; ++c) g[c].sort((h, l) => b(h[0], l[0]));
            else
                for (a =
                    0; a < f; ++a)
                    for (e = 0; e < c; ++e) g[a][e].sort(b)
        },
        Delete(a, f) {
            a = Math.floor(a);
            if (!(0 > a)) {
                var c = this._cx,
                    e = this._cy,
                    g = this._cz,
                    h = this._arr;
                if (0 === f) a >= c || (h.splice(a, 1), this._cx--);
                else if (1 === f) {
                    if (!(a >= e)) {
                        for (e = 0; e < c; ++e) h[e].splice(a, 1);
                        this._cy--
                    }
                } else if (!(a >= g)) {
                    for (f = 0; f < c; ++f)
                        for (g = 0; g < e; ++g) h[f][g].splice(a, 1);
                    this._cz--
                }
            }
        },
        Insert(a, f, c) {
            f = Math.floor(f);
            if (!(0 > f)) {
                var e = this._cx,
                    g = this._cy,
                    h = this._cz,
                    l = this._arr;
                if (0 === c) f > e || (l.splice(f, 0, d.MakeFilledArray(g, () => d.MakeFilledArray(h, a))), this._cx++);
                else if (1 === c) {
                    if (!(f > g)) {
                        for (g = 0; g < e; ++g) l[g].splice(f, 0, d.MakeFilledArray(h, a));
                        this._cy++
                    }
                } else if (!(f > h)) {
                    for (c = 0; c < e; ++c)
                        for (let m = 0; m < g; ++m) l[c][m].splice(f, 0, a);
                    this._cz++
                }
            }
        },
        JSONLoad(a) {
            let f = null;
            try {
                f = JSON.parse(a)
            } catch (c) {
                console.error("[Construct 3] Failed to parse JSON: ", c);
                return
            }
            f.c2array && (a = f.size, this._cx = a[0], this._cy = a[1], this._cz = a[2], this._arr = f.data)
        },
        JSONDownload(a) {
            const f = URL.createObjectURL(new Blob([this.GetAsJsonString()], {
                type: "application/json"
            }));
            this._runtime.InvokeDownload(f,
                a)
        }
    }
}
"use strict";
self.C3.Plugins.Arr.Exps = {
    At(d, b, a) {
        return this.At(d, b || 0, a || 0)
    },
    Width() {
        return this._cx
    },
    Height() {
        return this._cy
    },
    Depth() {
        return this._cz
    },
    CurX() {
        return this._GetForX()
    },
    CurY() {
        return this._GetForY()
    },
    CurZ() {
        return this._GetForZ()
    },
    CurValue() {
        return this.At(this._GetForX(), this._GetForY(), this._GetForZ())
    },
    Front() {
        return this.At(0, 0, 0)
    },
    Back() {
        return this.At(this._cx - 1, 0, 0)
    },
    IndexOf(d) {
        const b = this._arr;
        for (let a = 0, f = this._cx; a < f; ++a)
            if (b[a][0][0] === d) return a;
        return -1
    },
    LastIndexOf(d) {
        const b = this._arr;
        for (let a = this._cx - 1; 0 <= a; --a)
            if (b[a][0][0] === d) return a;
        return -1
    },
    AsJSON() {
        return this.GetAsJsonString()
    }
};
"use strict";
{
    const d = self.C3;
    d.Plugins.AJAX = class extends d.SDKPluginBase {
        constructor(b) {
            super(b)
        }
        Release() {
            super.Release()
        }
    }
}
"use strict";
{
    const d = self.C3;
    d.Plugins.AJAX.Type = class extends d.SDKTypeBase {
        constructor(b) {
            super(b)
        }
        Release() {
            super.Release()
        }
        OnCreate() {}
    }
}
"use strict";
{
    const d = self.C3;
    d.Plugins.AJAX.Instance = class extends d.SDKInstanceBase {
        constructor(b, a) {
            super(b);
            this._curTag = this._lastData = "";
            this._progress = 0;
            this._timeout = -1;
            this._nextRequestHeaders = new Map;
            this._nextReponseBinaryData = null;
            this._nextRequestOverrideMimeType = "";
            this._nwjsAppFolder = this._nwjsPath = this._nwjsFs = null;
            if (this._isNWjs = "nwjs" === this._runtime.GetExportType()) this._nwjsFs = require("fs"), this._nwjsPath = require("path"), this._nwjsAppFolder = this._nwjsPath.dirname((self.process || nw.process).execPath) +
                "\\"
        }
        Release() {
            super.Release()
        }
        async _TriggerError(b, a, f) {
            console.error(`[Construct 3] AJAX request to '${a}' (tag '${b}') failed: `, f);
            this._curTag = b;
            await this.TriggerAsync(d.Plugins.AJAX.Cnds.OnAnyError);
            await this.TriggerAsync(d.Plugins.AJAX.Cnds.OnError)
        }
        async _TriggerComplete(b) {
            this._curTag = b;
            await this.TriggerAsync(d.Plugins.AJAX.Cnds.OnAnyComplete);
            await this.TriggerAsync(d.Plugins.AJAX.Cnds.OnComplete)
        }
        async _OnProgress(b, a) {
            a.lengthComputable && (this._progress = a.loaded / a.total, this._curTag =
                b, await this.TriggerAsync(d.Plugins.AJAX.Cnds.OnProgress))
        }
        _OnError(b, a, f) {
            if (this._isNWjs) {
                var c = this._nwjsFs,
                    e = this._nwjsAppFolder + a;
                c.existsSync(e) ? c.readFile(e, {
                    encoding: "utf8"
                }, (g, h) => {
                    g ? this._TriggerError(b, a, g) : (this._lastData = h.replace(/\r\n/g, "\n"), this._TriggerComplete(b))
                }) : this._TriggerError(b, a, f)
            } else this._TriggerError(b, a, f)
        }
        async _DoCordovaRequest(b, a) {
            const f = this._runtime.GetAssetManager(),
                c = this._nextReponseBinaryData;
            this._nextReponseBinaryData = null;
            try {
                if (c) {
                    const e = await f.CordovaFetchLocalFileAsArrayBuffer(a);
                    c.SetArrayBufferTransfer(e);
                    this._lastData = ""
                } else this._lastData = (await f.CordovaFetchLocalFileAsText(a)).replace(/\r\n/g, "\n");
                this._TriggerComplete(b)
            } catch (e) {
                this._TriggerError(b, a, e)
            }
        }
        _DoRequest(b, a, f, c) {
            return new Promise(e => {
                const g = l => {
                        this._OnError(b, a, l);
                        e()
                    },
                    h = this._nextReponseBinaryData;
                this._nextReponseBinaryData = null;
                try {
                    const l = new XMLHttpRequest;
                    l.onreadystatechange = () => {
                        if (4 === l.readyState) {
                            this._lastData = h ? "" : (l.responseText || "").replace(/\r\n/g, "\n");
                            if (400 <= l.status) this._TriggerError(b,
                                a, l.status + l.statusText);
                            else {
                                const m = this._lastData.length || h && l.response instanceof ArrayBuffer;
                                this._isNWjs && !m || !this._isNWjs && 0 === l.status && !m || (h && h.SetArrayBufferTransfer(l.response), this._TriggerComplete(b))
                            }
                            e()
                        }
                    };
                    l.onerror = g;
                    l.ontimeout = g;
                    l.onabort = g;
                    l.onprogress = m => this._OnProgress(b, m);
                    l.open(f, a);
                    0 <= this._timeout && "undefined" !== typeof l.timeout && (l.timeout = this._timeout);
                    l.responseType = h ? "arraybuffer" : "text";
                    c && !this._nextRequestHeaders.has("Content-Type") && ("string" !== typeof c ? l.setRequestHeader("Content-Type",
                        "application/octet-stream") : l.setRequestHeader("Content-Type", "application/x-www-form-urlencoded"));
                    for (const [m, p] of this._nextRequestHeaders) try {
                        l.setRequestHeader(m, p)
                    } catch (t) {
                        console.error(`[Construct 3] AJAX: Failed to set header '${m}: ${p}': `, t)
                    }
                    this._nextRequestHeaders.clear();
                    if (this._nextRequestOverrideMimeType) {
                        try {
                            l.overrideMimeType(this._nextRequestOverrideMimeType)
                        } catch (m) {
                            console.error("[Construct 3] AJAX: failed to override MIME type: ", m)
                        }
                        this._nextRequestOverrideMimeType = ""
                    }
                    c ?
                        l.send(c) : l.send()
                } catch (l) {
                    g(l)
                }
            })
        }
        GetDebuggerProperties() {
            return [{
                title: "plugins.ajax.debugger.title",
                properties: [{
                    name: "plugins.ajax.debugger.last-data",
                    value: this._lastData
                }]
            }]
        }
        SaveToJson() {
            return {
                lastData: this._lastData
            }
        }
        LoadFromJson(b) {
            this._lastData = b.lastData;
            this._curTag = "";
            this._progress = 0
        }
    }
}
"use strict";
{
    const d = self.C3;
    d.Plugins.AJAX.Cnds = {
        OnComplete(b) {
            return d.equalsNoCase(this._curTag, b)
        },
        OnAnyComplete() {
            return !0
        },
        OnError(b) {
            return d.equalsNoCase(this._curTag, b)
        },
        OnAnyError() {
            return !0
        },
        OnProgress(b) {
            return d.equalsNoCase(this._curTag, b)
        }
    }
}
"use strict";
{
    const d = self.C3;
    d.Plugins.AJAX.Acts = {
        async Request(b, a) {
            this._runtime.IsCordova() && d.IsRelativeURL(a) && "file:" === location.protocol ? await this._DoCordovaRequest(b, a) : this._runtime.IsPreview() && d.IsRelativeURL(a) ? (a = this._runtime.GetAssetManager().GetLocalUrlAsBlobUrl(a.toLowerCase()), await this._DoRequest(b, a, "GET", null)) : await this._DoRequest(b, a, "GET", null)
        },
        async RequestFile(b, a) {
            this._runtime.IsCordova() && "file:" === location.protocol ? await this._DoCordovaRequest(b, a) : await this._DoRequest(b, this._runtime.GetAssetManager().GetLocalUrlAsBlobUrl(a),
                "GET", null)
        },
        async Post(b, a, f, c) {
            await this._DoRequest(b, a, c, f)
        },
        async PostBinary(b, a, f, c) {
            f && (f = f.GetFirstPicked(this._inst)) && (f = f.GetSdkInstance().GetArrayBufferReadOnly(), await this._DoRequest(b, a, c, f))
        },
        SetTimeout(b) {
            this._timeout = 1E3 * b
        },
        SetHeader(b, a) {
            this._nextRequestHeaders.set(b, a)
        },
        SetResponseBinary(b) {
            b && (b = b.GetFirstPicked(this._inst)) && (this._nextReponseBinaryData = b.GetSdkInstance())
        },
        OverrideMIMEType(b) {
            this._nextRequestOverrideMimeType = b
        }
    }
}
"use strict";
self.C3.Plugins.AJAX.Exps = {
    LastData() {
        return this._lastData
    },
    Progress() {
        return this._progress
    },
    Tag() {
        return this._curTag
    }
};
"use strict";
{
    const d = self.C3;
    d.Behaviors.solid = class extends d.SDKBehaviorBase {
        constructor(b) {
            super(b)
        }
        Release() {
            super.Release()
        }
    }
}
"use strict";
{
    const d = self.C3;
    d.Behaviors.solid.Type = class extends d.SDKBehaviorTypeBase {
        constructor(b) {
            super(b)
        }
        Release() {
            super.Release()
        }
        OnCreate() {}
    }
}
"use strict";
{
    const d = self.C3,
        b = new Set;
    d.Behaviors.solid.Instance = class extends d.SDKBehaviorInstanceBase {
        constructor(a, f) {
            super(a);
            this.SetEnabled(!0);
            f && (this.SetEnabled(f[0]), this.SetTags(f[1]))
        }
        Release() {
            super.Release()
        }
        SetEnabled(a) {
            this._inst._SetSolidEnabled(!!a)
        }
        IsEnabled() {
            return this._inst._IsSolidEnabled()
        }
        SetTags(a) {
            const f = this._inst.GetSavedDataMap();
            if (a.trim()) {
                var c = f.get("solidTags");
                c || (c = new Set, f.set("solidTags", c));
                c.clear();
                for (const e of a.split(" ")) e && c.add(e.toLowerCase())
            } else f.delete("solidTags")
        }
        GetTags() {
            return this._inst.GetSavedDataMap().get("solidTags") ||
                b
        }
        SaveToJson() {
            return {
                e: this.IsEnabled()
            }
        }
        LoadFromJson(a) {
            this.SetEnabled(a.e)
        }
        GetPropertyValueByIndex(a) {
            switch (a) {
                case 0:
                    return this.IsEnabled()
            }
        }
        SetPropertyValueByIndex(a, f) {
            switch (a) {
                case 0:
                    this.SetEnabled(f)
            }
        }
        GetDebuggerProperties() {
            return [{
                title: "$" + this.GetBehaviorType().GetName(),
                properties: [{
                    name: "behaviors.solid.properties.enabled.name",
                    value: this.IsEnabled(),
                    onedit: a => this.SetEnabled(a)
                }]
            }]
        }
    }
}
"use strict";
self.C3.Behaviors.solid.Cnds = {
    IsEnabled() {
        return this.IsEnabled()
    }
};
"use strict";
self.C3.Behaviors.solid.Acts = {
    SetEnabled(d) {
        this.SetEnabled(d)
    },
    SetTags(d) {
        this.SetTags(d)
    }
};
"use strict";
self.C3.Behaviors.solid.Exps = {};
"use strict";
{
    const d = self.C3;
    d.Behaviors.Platform = class extends d.SDKBehaviorBase {
        constructor(b) {
            super(b)
        }
        Release() {
            super.Release()
        }
    }
}
"use strict";
{
    const d = self.C3;
    d.Behaviors.Platform.Type = class extends d.SDKBehaviorTypeBase {
        constructor(b) {
            super(b)
        }
        Release() {
            super.Release()
        }
        OnCreate() {}
    }
}
"use strict";
{
    const d = self.C3,
        b = self.IBehaviorInstance;

    function a(e, g, h, l, m) {
        return d.clamp(e * m + .5 * l * m * m, g * m, h * m)
    }
    d.Behaviors.Platform.Instance = class extends d.SDKBehaviorInstanceBase {
        constructor(e, g) {
            super(e);
            this._keyboardDisposables = null;
            this._simJump = this._simRight = this._simLeft = this._ignoreInput = this._canDoubleJump = this._doubleJumped = this._jumped = this._jumpKey = this._rightKey = this._leftKey = !1;
            this._lastFloorObject = null;
            this._loadFloorUid = -1;
            this._lastFloorY = this._lastFloorX = 0;
            this._wasOnFloor = this._floorIsJumpthru = !1;
            this._wasOverJumpthru = !!this._runtime.GetCollisionEngine().TestOverlapJumpthru(this._inst);
            this._loadJumpthruUid = -1;
            this._animMode = "stopped";
            this._fallThrough = 0;
            this._isFirstTick = !0;
            this._rightY = this._rightX = this._downY = this._downX = this._dy = this._dx = 0;
            this._g1 = this._g = 1500;
            this._ga = d.toRadians(90);
            this._maxSpeed = 330;
            this._dec = this._acc = 1500;
            this._jumpStrength = 650;
            this._maxFall = 1E3;
            this._enableDoubleJump = !1;
            this._sustainTime = this._jumpSustain = 0;
            this._defaultControls = !0;
            this._ceilingCollisionMode =
                0;
            this._isEnabled = !0;
            g && (this._maxSpeed = g[0], this._acc = g[1], this._dec = g[2], this._jumpStrength = g[3], this._g = g[4], this._maxFall = g[5], this._enableDoubleJump = !!g[6], this._jumpSustain = g[7] / 1E3, this._defaultControls = !!g[8], this._isEnabled = !!g[9]);
            e = this._runtime.Dispatcher();
            this._disposables = new d.CompositeDisposable(d.Disposable.From(e, "instancedestroy", h => this._OnInstanceDestroyed(h.instance)), d.Disposable.From(e, "afterload", h => this._OnAfterLoad()));
            this._defaultControls && this._BindEvents();
            this._isEnabled &&
                this._StartPostTicking();
            this._UpdateGravity();
            this._inst.GetUnsavedDataMap().set("isPlatformBehavior", !0)
        }
        Release() {
            this._keyboardDisposables && (this._keyboardDisposables.Release(), this._keyboardDisposables = null);
            this._wasOverJumpthru = this._lastFloorObject = null;
            super.Release()
        }
        _BindEvents() {
            if (!this._keyboardDisposables) {
                var e = this._runtime.Dispatcher();
                this._keyboardDisposables = new d.CompositeDisposable(d.Disposable.From(e, "keydown", g => this._OnKeyDown(g.data)), d.Disposable.From(e, "keyup", g => this._OnKeyUp(g.data)),
                    d.Disposable.From(e, "window-blur", () => this._OnWindowBlur()))
            }
        }
        _UnBindEvents() {
            this._keyboardDisposables && (this._keyboardDisposables.Release(), this._keyboardDisposables = null)
        }
        _OnInstanceDestroyed(e) {
            this._lastFloorObject === e && (this._lastFloorObject = null);
            this._wasOverJumpthru === e && (this._wasOverJumpthru = null)
        }
        _OnKeyDown(e) {
            switch (e.key) {
                case "ArrowLeft":
                    this._leftKey = !0;
                    break;
                case "ArrowRight":
                    this._rightKey = !0;
                    break;
                case "ArrowUp":
                    this._jumpKey = !0
            }
        }
        _OnKeyUp(e) {
            switch (e.key) {
                case "ArrowLeft":
                    this._leftKey = !1;
                    break;
                case "ArrowRight":
                    this._rightKey = !1;
                    break;
                case "ArrowUp":
                    this._jumped = this._jumpKey = !1
            }
        }
        _OnWindowBlur() {
            this._jumped = this._jumpKey = this._rightKey = this._leftKey = !1
        }
        SaveToJson() {
            return {
                ii: this._ignoreInput,
                lfx: this._lastFloorX,
                lfy: this._lastFloorY,
                lfo: this._lastFloorObject ? this._lastFloorObject.GetUID() : -1,
                am: this._animMode,
                en: this._isEnabled,
                fall: this._fallThrough,
                ft: this._isFirstTick,
                dx: this._dx,
                dy: this._dy,
                ms: this._maxSpeed,
                acc: this._acc,
                dec: this._dec,
                js: this._jumpStrength,
                g: this._g,
                g1: this._g1,
                mf: this._maxFall,
                wof: this._wasOnFloor,
                woj: this._wasOverJumpthru ? this._wasOverJumpthru.GetUID() : -1,
                ga: this._ga,
                edj: this._enableDoubleJump,
                cdj: this._canDoubleJump,
                dj: this._doubleJumped,
                sus: this._jumpSustain,
                dc: this._defaultControls,
                cc: this._ceilingCollisionMode
            }
        }
        LoadFromJson(e) {
            this._ignoreInput = e.ii;
            this._lastFloorX = e.lfx;
            this._lastFloorY = e.lfy;
            this._loadFloorUid = e.lfo;
            this._animMode = e.am;
            const g = e.en;
            this._fallThrough = e.fall;
            this._isFirstTick = e.ft;
            this._dx = e.dx;
            this._dy = e.dy;
            this._maxSpeed = e.ms;
            this._acc =
                e.acc;
            this._dec = e.dec;
            this._jumpStrength = e.js;
            this._g = e.g;
            this._g1 = e.g1;
            this._maxFall = e.mf;
            this._wasOnFloor = e.wof;
            this._loadJumpthruUid = e.woj;
            this._ga = e.ga;
            this._enableDoubleJump = e.edj;
            this._canDoubleJump = e.cdj;
            this._doubleJumped = e.dj;
            this._jumpSustain = e.sus;
            this._defaultControls = e.dc;
            this._ceilingCollisionMode = e.cc || 0;
            this._simJump = this._simRight = this._simLeft = this._jumped = this._jumpKey = this._rightKey = this._leftKey = !1;
            this._sustainTime = 0;
            this._defaultControls ? this._BindEvents() : this._UnBindEvents();
            this._SetEnabled(g);
            this._UpdateGravity()
        }
        _OnAfterLoad() {
            this._lastFloorObject = -1 === this._loadFloorUid ? null : this._runtime.GetInstanceByUID(this._loadFloorUid);
            this._wasOverJumpthru = -1 === this._loadJumpthruUid ? null : this._runtime.GetInstanceByUID(this._loadJumpthruUid)
        }
        _UpdateGravity() {
            this._downX = Math.cos(this._ga);
            this._downY = Math.sin(this._ga);
            this._rightX = Math.cos(this._ga - Math.PI / 2);
            this._rightY = Math.sin(this._ga - Math.PI / 2);
            this._downX = d.round6dp(this._downX);
            this._downY = d.round6dp(this._downY);
            this._rightX = d.round6dp(this._rightX);
            this._rightY = d.round6dp(this._rightY);
            this._g1 = this._g;
            0 > this._g && (this._downX *= -1, this._downY *= -1, this._g = Math.abs(this._g))
        }
        _GetGDir() {
            return 0 > this._g ? -1 : 1
        }
        _IsOnFloor() {
            var e = this._inst.GetWorldInfo();
            const g = this._runtime.GetCollisionEngine(),
                h = this._inst;
            var l = this._lastFloorObject;
            const m = e.GetX(),
                p = e.GetY();
            e.OffsetXY(this._downX, this._downY);
            e.SetBboxChanged();
            if (l && g.TestOverlap(h, l) && (!l.GetObjectClass().HasSolidBehavior() || g.IsSolidCollisionAllowed(l,
                    h))) return e.SetXY(m, p), e.SetBboxChanged(), l;
            {
                let t = g.TestOverlapSolid(h);
                l = null;
                t || 0 !== this._fallThrough || (l = g.TestOverlapJumpthru(h, !0));
                e.SetXY(m, p);
                e.SetBboxChanged();
                if (t) {
                    if (g.TestOverlap(h, t)) return null;
                    this._floorIsJumpthru = !1;
                    return t
                }
                if (l && l.length) {
                    e = 0;
                    for (let q = 0, r = l.length; q < r; ++q) l[e] = l[q], g.TestOverlap(h, l[q]) || ++e;
                    if (1 <= e) return this._floorIsJumpthru = !0, l[0]
                }
                return null
            }
        }
        PostTick() {
            if (this._isEnabled) {
                var e = this._runtime.GetDt(this._inst);
                this._jumpKey || this._simJump || (this._jumped = !1);
                var g = this._leftKey || this._simLeft,
                    h = this._rightKey || this._simRight,
                    l = this._jumpKey || this._simJump,
                    m = l && !this._jumped;
                this._simJump = this._simRight = this._simLeft = !1;
                this._ignoreInput && (m = l = h = g = !1);
                l || (this._sustainTime = 0);
                this._HandleFirstTick();
                var [p, , t] = this._TrackMovingPlatform(), q = this._IsOnFloor(), r = q && !this._wasOnFloor, u;
                [u, q] = this._MaybePushOutSolid(q);
                if (!u) {
                    this._TrackFloor(q, t, p, l);
                    m = this._HandleJump(q, m, l);
                    q || this._ApplyJumpGravity(m, l, e);
                    this._wasOnFloor = !!q;
                    g = this._ApplyHorizontalAcceleration(g,
                        h, e);
                    h = !1;
                    l = 0;
                    0 !== this._dx && (h = this._HandleHorizontalMovement(e, g, q, m));
                    if (0 !== this._dy) {
                        const [x, y] = this._HandleVerticalMovement(e, q);
                        h = h || x;
                        l = y
                    }!h && r && 0 > this._dy && 0 < l && (this._dy = 0, h = !0);
                    this._HandleAnimationTriggers(q, h, m);
                    0 < this._fallThrough && this._fallThrough--;
                    this._wasOverJumpthru = this._runtime.GetCollisionEngine().TestOverlapJumpthru(this._inst)
                }
            }
        }
        _HandleFirstTick() {
            if (this._isFirstTick) {
                var e = this._inst,
                    g = this._runtime.GetCollisionEngine();
                (g.TestOverlapSolid(e) || g.TestOverlapJumpthru(e)) &&
                g.PushOutSolid(e, -this._downX, -this._downY, 4, !0);
                this._isFirstTick = !1
            }
        }
        _TrackMovingPlatform() {
            var e = this._lastFloorObject,
                g = e ? e.GetWorldInfo() : null;
            let h = 0,
                l = 0;
            var m = !1;
            if (e && 0 === this._dy && (g.GetY() !== this._lastFloorY || g.GetX() !== this._lastFloorX)) {
                e = this._inst;
                m = e.GetWorldInfo();
                const p = this._runtime.GetCollisionEngine(),
                    t = g.GetX();
                g = g.GetY();
                h = t - this._lastFloorX;
                l = g - this._lastFloorY;
                m.OffsetXY(h, l);
                m.SetBboxChanged();
                this._lastFloorX = t;
                this._lastFloorY = g;
                m = !0;
                p.TestOverlapSolid(e) && p.PushOutSolid(e,
                    -h, -l, 2.5 * Math.hypot(h, l))
            }
            return [h, l, m]
        }
        _MaybePushOutSolid(e) {
            let g = !1;
            var h = this._inst,
                l = h.GetWorldInfo();
            const m = this._runtime.GetCollisionEngine(),
                p = m.TestOverlapSolid(h);
            if (!p) return [!1, e];
            const t = Math.abs(l.GetWidth());
            l = Math.abs(l.GetHeight());
            h.GetSavedDataMap().get("inputPredicted") ? m.PushOutSolid(h, -this._downX, -this._downY, 10, !1) : m.PushOutSolidAxis(h, -this._downX, -this._downY, l / 8) ? (m.RegisterCollision(h, p), this._lastFloorObject = e = p, h = p.GetWorldInfo(), this._lastFloorX = h.GetX(), this._lastFloorY =
                h.GetY(), this._floorIsJumpthru = !1) : m.PushOutSolidAxis(h, this._rightX, this._rightY, t / 2) || m.PushOutSolidAxis(h, this._downX, this._downY, l / 2) || m.PushOutSolidNearest(h, Math.max(t, l) / 2) ? m.RegisterCollision(h, p) : g = !0;
            return [g, e]
        }
        _TrackFloor(e, g, h, l) {
            const m = this._inst,
                p = this._runtime.GetCollisionEngine();
            if (e) {
                l = this._downX;
                const t = this._downY,
                    q = this._rightX,
                    r = this._rightY;
                this._canDoubleJump = this._doubleJumped = !1;
                0 < this._dy && (this._wasOnFloor || (p.PushInFractional(m, -l, -t, e, 16), this._wasOnFloor = !0), this._dy =
                    0);
                this._lastFloorObject !== e ? (this._lastFloorObject = e, h = e.GetWorldInfo(), this._lastFloorX = h.GetX(), this._lastFloorY = h.GetY(), p.RegisterCollision(m, e)) : g && (e = p.TestOverlapSolid(m)) && (p.RegisterCollision(m, e), 0 !== h && (0 < h ? p.PushOutSolid(m, -q, -r) : p.PushOutSolid(m, q, r)), p.PushOutSolid(m, -l, -t))
            } else l || (this._canDoubleJump = !0)
        }
        _HandleJump(e, g, h) {
            if (e && g || !e && this._enableDoubleJump && h && this._canDoubleJump && !this._doubleJumped) {
                g = this._inst;
                h = g.GetWorldInfo();
                const l = this._runtime.GetCollisionEngine(),
                    m =
                    h.GetX(),
                    p = h.GetY();
                h.OffsetXY(-this._downX, -this._downY);
                h.SetBboxChanged();
                l.TestOverlapSolid(g) ? g = !1 : (this._sustainTime = this._jumpSustain, this.Trigger(d.Behaviors.Platform.Cnds.OnJump), this._animMode = "jumping", this._dy = -this._jumpStrength, g = !0, e ? this._jumped = !0 : this._doubleJumped = !0);
                h.SetXY(m, p);
                h.SetBboxChanged()
            }
            return g
        }
        _ApplyJumpGravity(e, g, h) {
            g && 0 < this._sustainTime ? (this._dy = -this._jumpStrength, this._sustainTime -= h) : (this._lastFloorObject = null, this._dy += this._g * h, this._dy > this._maxFall &&
                (this._dy = this._maxFall));
            e && (this._jumped = !0)
        }
        _ApplyHorizontalAcceleration(e, g, h) {
            const l = this._acc,
                m = this._dec;
            e === g && (0 > this._dx ? (this._dx += m * h, 0 < this._dx && (this._dx = 0)) : 0 < this._dx && (this._dx -= m * h, 0 > this._dx && (this._dx = 0)));
            let p = 0;
            e && !g && (p = 0 < this._dx ? -(l + m) : -l);
            g && !e && (p = 0 > this._dx ? l + m : l);
            this._dx += p * h;
            this._dx = d.clamp(this._dx, -this._maxSpeed, this._maxSpeed);
            return p
        }
        _HandleHorizontalMovement(e, g, h, l) {
            const m = this._inst;
            var p = m.GetWorldInfo();
            const t = this._runtime.GetCollisionEngine(),
                q = this._downX,
                r = this._downY,
                u = this._rightX,
                x = this._rightY;
            var y = this._maxSpeed;
            let C = !1;
            var w = p.GetX();
            let A = p.GetY();
            var E = a(this._dx, -y, y, g, e) * u;
            const K = a(this._dx, -y, y, g, e) * x;
            p.OffsetXY(u * (1 < this._dx ? 1 : -1) - q, x * (1 < this._dx ? 1 : -1) - r);
            p.SetBboxChanged();
            g = !1;
            y = t.TestOverlapSolid(m);
            p.SetXY(w + E, A + K);
            p.SetBboxChanged();
            let O = t.TestOverlapSolid(m);
            !O && h && (O = t.TestOverlapJumpthru(m)) && (p.SetXY(w, A), p.SetBboxChanged(), t.TestOverlap(m, O) ? (O = null, g = !1) : g = !0, p.SetXY(w + E, A + K), p.SetBboxChanged());
            O ? (E = Math.abs(this._dx * e) +
                2, y || !t.PushOutSolid(m, -q, -r, E, g, O)) ? (t.RegisterCollision(m, O), E = Math.max(Math.abs(this._dx * e * 2.5), 30), t.PushOutSolid(m, u * (0 > this._dx ? 1 : -1), x * (0 > this._dx ? 1 : -1), E, !1) ? !h || g || this._floorIsJumpthru || (w = p.GetX(), A = p.GetY(), p.OffsetXY(q, r), t.TestOverlapSolid(m) ? t.PushOutSolid(m, -q, -r, 3, !1) || (p.SetXY(w, A), p.SetBboxChanged()) : (p.SetXY(w, A), p.SetBboxChanged())) : (p.SetXY(w, A), p.SetBboxChanged()), g || (this._dx = 0)) : !y && !l && Math.abs(this._dy) < Math.abs(this._jumpStrength / 4) && (this._dy = 0, h || (C = !0)) : (w = this._IsOnFloor(),
                h && !w ? (e = Math.ceil(Math.abs(this._dx * e)) + 2, w = p.GetX(), A = p.GetY(), p.OffsetXY(q * e, r * e), p.SetBboxChanged(), t.TestOverlapSolid(m) || t.TestOverlapJumpthru(m) ? t.PushOutSolid(m, -q, -r, e + 2, !0) : (p.SetXY(w, A), p.SetBboxChanged())) : w && (!h && this._floorIsJumpthru && (this._lastFloorObject = w, p = w.GetWorldInfo(), this._lastFloorX = p.GetX(), this._lastFloorY = p.GetY(), this._dy = 0, C = !0), 0 === this._dy && t.PushInFractional(m, -q, -r, w, 16)));
            return C
        }
        _HandleVerticalMovement(e, g) {
            const h = this._inst,
                l = h.GetWorldInfo(),
                m = this._runtime.GetCollisionEngine(),
                p = this._downX,
                t = this._downY;
            let q = !1,
                r = l.GetX(),
                u = l.GetY();
            const x = a(this._dy, -Infinity, this._maxFall, this._g, e);
            l.OffsetXY(x * p, x * t);
            var y = l.GetX();
            const C = l.GetY();
            l.SetBboxChanged();
            let w = m.TestOverlapSolid(h);
            var A = !1;
            if (!w && 0 < this._dy && !g) {
                if ((A = 0 < this._fallThrough ? null : m.TestOverlapJumpthru(h, !0)) && A.length) {
                    if (this._wasOverJumpthru) {
                        l.SetXY(r, u);
                        l.SetBboxChanged();
                        g = 0;
                        for (let E = 0, K = A.length; E < K; ++E) A[g] = A[E], m.TestOverlap(h, A[E]) || ++g;
                        d.truncateArray(A, g);
                        l.SetXY(y, C);
                        l.SetBboxChanged()
                    }
                    1 <=
                        A.length && (w = A[0])
                }
                A = !!w
            }
            if (w)
                if (m.RegisterCollision(h, w), this._sustainTime = 0, y = 1.1, A && !this._wasOverJumpthru && (y = 2), m.PushOutSolid(h, p * (0 > this._dy ? 1 : -1), t * (0 > this._dy ? 1 : -1), Math.max(Math.abs(this._dy * e * y), 2), A, w)) {
                    this._lastFloorObject = w;
                    e = w.GetWorldInfo();
                    this._lastFloorX = e.GetX();
                    this._lastFloorY = e.GetY();
                    (this._floorIsJumpthru = A) && (q = !0);
                    if (0 < this._dy || 0 === this._ceilingCollisionMode) this._dy = 0;
                    0 > this._dy && 1 === this._ceilingCollisionMode && m.PushInFractional(h, p, t, w, 32)
                } else l.SetXY(r, u), l.SetBboxChanged(),
                    this._wasOnFloor = !0, A || (this._dy = 0);
            return [q, x]
        }
        _HandleAnimationTriggers(e, g, h) {
            "falling" !== this._animMode && 0 < this._dy && !e && (this.Trigger(d.Behaviors.Platform.Cnds.OnFall), this._animMode = "falling");
            (e || g) && 0 <= this._dy && ("falling" === this._animMode || g || h && 0 === this._dy ? (this.Trigger(d.Behaviors.Platform.Cnds.OnLand), this._animMode = 0 === this._dx && 0 === this._dy ? "stopped" : "moving") : ("stopped" !== this._animMode && 0 === this._dx && 0 === this._dy && (this.Trigger(d.Behaviors.Platform.Cnds.OnStop), this._animMode = "stopped"),
                "moving" === this._animMode || 0 === this._dx && 0 === this._dy || h || (this.Trigger(d.Behaviors.Platform.Cnds.OnMove), this._animMode = "moving")))
        }
        _CheckIfStandingOnFloor() {
            if (0 !== this._dy) return !1;
            const e = this._inst;
            var g = this.GetWorldInfo();
            const h = this._runtime.GetCollisionEngine(),
                l = g.GetX(),
                m = g.GetY();
            g.OffsetXY(this._downX, this._downY);
            g.SetBboxChanged();
            const p = h.TestOverlapSolid(e);
            let t = null;
            p || 0 !== this._fallThrough || (t = h.TestOverlapJumpthru(e, !0));
            g.SetXY(l, m);
            g.SetBboxChanged();
            if (p) return !h.TestOverlap(e,
                p);
            if (t && t.length) {
                g = 0;
                for (let q = 0, r = t.length; q < r; ++q) t[g] = t[q], h.TestOverlap(e, t[q]) || g++;
                if (1 <= g) return !0
            }
            return !1
        }
        _IsByWall(e) {
            const g = this._inst,
                h = this.GetWorldInfo(),
                l = this._runtime.GetCollisionEngine(),
                m = h.GetX(),
                p = h.GetY();
            0 === e ? h.OffsetXY(2 * -this._rightX, 2 * -this._rightY) : h.OffsetXY(2 * this._rightX, 2 * this._rightY);
            h.SetBboxChanged();
            if (!l.TestOverlapSolid(g)) return h.SetXY(m, p), h.SetBboxChanged(), !1;
            h.OffsetXY(3 * -this._downX, 3 * -this._downY);
            h.SetBboxChanged();
            e = !!l.TestOverlapSolid(g);
            h.SetXY(m,
                p);
            h.SetBboxChanged();
            return e
        }
        _FallThroughJumpThru() {
            const e = this.GetWorldInfo(),
                g = e.GetX(),
                h = e.GetY();
            e.OffsetXY(this._downX, this._downY);
            e.SetBboxChanged();
            const l = this._runtime.GetCollisionEngine().TestOverlapJumpthru(this._inst, !1);
            e.SetXY(g, h);
            e.SetBboxChanged();
            l && (this._fallThrough = 3, this._lastFloorObject = null)
        }
        _ResetDoubleJump(e) {
            this._doubleJumped = !e
        }
        _GetSpeed() {
            return Math.hypot(this._dx, this._dy)
        }
        _GetMovingAngle() {
            return Math.atan2(this._dy, this._dx)
        }
        _IsJumping() {
            return 0 > this._dy
        }
        _IsFalling() {
            return 0 <
                this._dy
        }
        _SetMaxSpeed(e) {
            this._maxSpeed = Math.max(e, 0)
        }
        _GetMaxSpeed() {
            return this._maxSpeed
        }
        _SetAcceleration(e) {
            this._acc = Math.max(e, 0)
        }
        _GetAcceleration() {
            return this._acc
        }
        _SetDeceleration(e) {
            this._dec = Math.max(e, 0)
        }
        _GetDeceleration() {
            return this._dec
        }
        _SetJumpStrength(e) {
            this._jumpStrength = Math.max(e, 0)
        }
        _GetJumpStrength() {
            return this._jumpStrength
        }
        _SetMaxFallSpeed(e) {
            this._maxFall = Math.max(e, 0)
        }
        _GetMaxFallSpeed() {
            return this._maxFall
        }
        _SetGravity(e) {
            if (this._g1 !== e) {
                this._g = e;
                this._UpdateGravity();
                e = this._runtime.GetCollisionEngine();
                var g = this.GetWorldInfo();
                e.TestOverlapSolid(this._inst) && (e.PushOutSolid(this._inst, this._downX, this._downY, 10), g.OffsetXY(2 * this._downX, 2 * this._downY), g.SetBboxChanged());
                this._lastFloorObject = null
            }
        }
        _GetGravity() {
            return this._g
        }
        _SetGravityAngle(e) {
            e = d.clampAngle(e);
            this._ga !== e && (this._ga = e, this._UpdateGravity(), this._lastFloorObject = null)
        }
        _GetGravityAngle() {
            return this._ga
        }
        _SetDoubleJumpEnabled(e) {
            this._enableDoubleJump = !!e
        }
        _IsDoubleJumpEnabled() {
            return this._enableDoubleJump
        }
        _SetJumpSustain(e) {
            this._jumpSustain =
                e
        }
        _GetJumpSustain() {
            return this._jumpSustain
        }
        _SetCeilingCollisionMode(e) {
            this._ceilingCollisionMode = e
        }
        _GetCeilingCollisionMode() {
            return this._ceilingCollisionMode
        }
        _SetVectorX(e) {
            this._dx = e
        }
        _GetVectorX() {
            return this._dx
        }
        _SetVectorY(e) {
            this._dy = e
        }
        _GetVectorY() {
            return this._dy
        }
        _SimulateControl(e) {
            if (this._isEnabled) switch (e) {
                case 0:
                    this._simLeft = !0;
                    break;
                case 1:
                    this._simRight = !0;
                    break;
                case 2:
                    this._simJump = !0
            }
        }
        _SetDefaultControls(e) {
            e = !!e;
            this._defaultControls !== e && ((this._defaultControls = e) ? this._BindEvents() :
                (this._UnBindEvents(), this._OnWindowBlur()))
        }
        _IsDefaultControls() {
            return this._defaultControls
        }
        _SetIgnoreInput(e) {
            this._ignoreInput = !!e
        }
        _IsIgnoreInput() {
            return this._ignoreInput
        }
        _SetEnabled(e) {
            e = !!e;
            this._isEnabled !== e && ((this._isEnabled = e) ? this._StartPostTicking() : (this._StopPostTicking(), this._lastFloorObject = null, this._simJump = this._simRight = this._simLeft = !1))
        }
        _IsEnabled() {
            return this._isEnabled
        }
        GetPropertyValueByIndex(e) {
            switch (e) {
                case 0:
                    return this._GetMaxSpeed();
                case 1:
                    return this._GetAcceleration();
                case 2:
                    return this._GetDeceleration();
                case 3:
                    return this._GetJumpStrength();
                case 4:
                    return this._GetGravity();
                case 5:
                    return this._GetMaxFallSpeed();
                case 6:
                    return this._IsDoubleJumpEnabled();
                case 7:
                    return 1E3 * this._GetJumpSustain();
                case 8:
                    return this._IsDefaultControls();
                case 9:
                    return this._IsEnabled()
            }
        }
        SetPropertyValueByIndex(e, g) {
            switch (e) {
                case 0:
                    this._SetMaxSpeed(g);
                    break;
                case 1:
                    this._SetAcceleration(g);
                    break;
                case 2:
                    this._SetDeceleration(g);
                    break;
                case 3:
                    this._SetJumpStrength(g);
                    break;
                case 4:
                    this._SetGravity(g);
                    break;
                case 5:
                    this._SetMaxFallSpeed(g);
                    break;
                case 6:
                    this._SetDoubleJumpEnabled(!!g);
                    break;
                case 7:
                    this._SetJumpSustain(g / 1E3);
                    break;
                case 8:
                    this._SetDefaultControls(!!g);
                    break;
                case 9:
                    this._SetEnabled(!!g)
            }
        }
        GetDebuggerProperties() {
            return [{
                title: "$" + this.GetBehaviorType().GetName(),
                properties: [{
                    name: "behaviors.platform.debugger.vector-x",
                    value: this._GetVectorX(),
                    onedit: e => this._SetVectorX(e)
                }, {
                    name: "behaviors.platform.debugger.vector-y",
                    value: this._GetVectorY(),
                    onedit: e => this._SetVectorY(e)
                }, {
                    name: "behaviors.platform.properties.max-speed.name",
                    value: this._GetMaxSpeed(),
                    onedit: e => this._SetMaxSpeed(e)
                }, {
                    name: "behaviors.platform.properties.acceleration.name",
                    value: this._GetAcceleration(),
                    onedit: e => this._SetAcceleration(e)
                }, {
                    name: "behaviors.platform.properties.deceleration.name",
                    value: this._GetDeceleration(),
                    onedit: e => this._SetDeceleration(e)
                }, {
                    name: "behaviors.platform.properties.jump-strength.name",
                    value: this._GetJumpStrength(),
                    onedit: e => this._SetJumpStrength(e)
                }, {
                    name: "behaviors.platform.properties.gravity.name",
                    value: this._GetGravity(),
                    onedit: e => this._SetGravity(e)
                }, {
                    name: "behaviors.platform.debugger.gravity-angle",
                    value: d.toDegrees(this._GetGravityAngle()),
                    onedit: e => this._SetGravityAngle(d.toRadians(e))
                }, {
                    name: "behaviors.platform.properties.max-fall-speed.name",
                    value: this._GetMaxFallSpeed(),
                    onedit: e => this._SetMaxFallSpeed(e)
                }, {
                    name: "behaviors.platform.debugger.animation-mode",
                    value: ["behaviors.platform.debugger.anim-" + this._animMode]
                }, {
                    name: "behaviors.platform.properties.enabled.name",
                    value: this._IsEnabled(),
                    onedit: e => this._SetEnabled(e)
                }]
            }]
        }
        GetScriptInterfaceClass() {
            return self.IPlatformBehaviorInstance
        }
    };
    const f = new WeakMap,
        c = new Map([
            ["left", 0],
            ["right", 1],
            ["jump", 2]
        ]);
    self.IPlatformBehaviorInstance = class extends b {
        constructor() {
            super();
            f.set(this, b._GetInitInst().GetSdkInstance())
        }
        fallThrough() {
            f.get(this)._FallThroughJumpThru()
        }
        resetDoubleJump(e) {
            f.get(this)._ResetDoubleJump(!!e)
        }
        simulateControl(e) {
            e = c.get(e);
            if ("number" !== typeof e) throw Error("invalid control");
            f.get(this)._SimulateControl(e)
        }
        get speed() {
            return f.get(this)._GetSpeed()
        }
        get maxSpeed() {
            return f.get(this)._GetMaxSpeed()
        }
        set maxSpeed(e) {
            f.get(this)._SetMaxSpeed(e)
        }
        get acceleration() {
            return f.get(this)._GetAcceleration()
        }
        set acceleration(e) {
            f.get(this)._SetAcceleration(e)
        }
        get deceleration() {
            return f.get(this)._GetDeceleration()
        }
        set deceleration(e) {
            f.get(this)._SetDeceleration(e)
        }
        get jumpStrength() {
            return f.get(this)._GetJumpStrength()
        }
        set jumpStrength(e) {
            f.get(this)._SetJumpStrength(e)
        }
        get maxFallSpeed() {
            return f.get(this)._GetMaxFallSpeed()
        }
        set maxFallSpeed(e) {
            f.get(this)._SetMaxFallSpeed(e)
        }
        get gravity() {
            return f.get(this)._GetGravity()
        }
        set gravity(e) {
            f.get(this)._SetGravity(e)
        }
        get gravityAngle() {
            return f.get(this)._GetGravityAngle()
        }
        set gravityAngle(e) {
            f.get(this)._SetGravityAngle(e)
        }
        get isDoubleJumpEnabled() {
            return f.get(this)._IsDoubleJumpEnabled()
        }
        set isDoubleJumpEnabled(e) {
            f.get(this)._SetDoubleJumpEnabled(!!e)
        }
        get jumpSustain() {
            return f.get(this)._GetJumpSustain()
        }
        set jumpSustain(e) {
            f.get(this)._SetJumpSustain(e)
        }
        get ceilingCollisionMode() {
            return 0 ===
                f.get(this)._GetCeilingCollisionMode() ? "stop" : "preserve-momentum"
        }
        set ceilingCollisionMode(e) {
            const g = f.get(this);
            if ("stop" === e) g._SetCeilingCollisionMode(0);
            else if ("preserve-momentum" === e) g._SetCeilingCollisionMode(1);
            else throw Error("invalid mode");
        }
        get isOnFloor() {
            return f.get(this)._CheckIfStandingOnFloor()
        }
        isByWall(e) {
            const g = f.get(this);
            if ("left" === e) return g._IsByWall(0);
            if ("right" === e) return g._IsByWall(1);
            throw Error("invalid side");
        }
        get isJumping() {
            return f.get(this)._IsJumping()
        }
        get isFalling() {
            return f.get(this)._IsFalling()
        }
        get vectorX() {
            return f.get(this)._GetVectorX()
        }
        set vectorX(e) {
            f.get(this)._SetVectorX(e)
        }
        get vectorY() {
            return f.get(this)._GetVectorY()
        }
        set vectorY(e) {
            f.get(this)._SetVectorY(e)
        }
        get isDefaultControls() {
            return f.get(this)._IsDefaultControls()
        }
        set isDefaultControls(e) {
            f.get(this)._SetDefaultControls(!!e)
        }
        get isIgnoringInput() {
            return f.get(this)._IsIgnoreInput()
        }
        set isIgnoringInput(e) {
            f.get(this)._SetIgnoreInput(!!e)
        }
        get isEnabled() {
            return f.get(this)._IsEnabled()
        }
        set isEnabled(e) {
            f.get(this)._SetEnabled(!!e)
        }
    }
}
"use strict";
{
    const d = self.C3;
    d.Behaviors.Platform.Cnds = {
        IsMoving() {
            return 0 !== this._GetVectorX() || 0 !== this._GetVectorY()
        },
        CompareSpeed(b, a) {
            return d.compare(this._GetSpeed(), b, a)
        },
        IsOnFloor() {
            return this._CheckIfStandingOnFloor()
        },
        IsByWall(b) {
            return this._IsByWall(b)
        },
        IsJumping() {
            return this._IsJumping()
        },
        IsFalling() {
            return this._IsFalling()
        },
        IsDoubleJumpEnabled() {
            return this._IsDoubleJumpEnabled()
        },
        OnJump() {
            return !0
        },
        OnFall() {
            return !0
        },
        OnStop() {
            return !0
        },
        OnMove() {
            return !0
        },
        OnLand() {
            return !0
        },
        IsEnabled() {
            return this._IsEnabled()
        }
    }
}
"use strict";
{
    const d = self.C3;
    d.Behaviors.Platform.Acts = {
        SetMaxSpeed(b) {
            this._SetMaxSpeed(b)
        },
        SetAcceleration(b) {
            this._SetAcceleration(b)
        },
        SetDeceleration(b) {
            this._SetDeceleration(b)
        },
        SetJumpStrength(b) {
            this._SetJumpStrength(b)
        },
        SetMaxFallSpeed(b) {
            this._SetMaxFallSpeed(b)
        },
        SetGravity(b) {
            this._SetGravity(b)
        },
        SimulateControl(b) {
            this._SimulateControl(b)
        },
        SetIgnoreInput(b) {
            this._SetIgnoreInput(!!b)
        },
        SetVectorX(b) {
            this._SetVectorX(b)
        },
        SetVectorY(b) {
            this._SetVectorY(b)
        },
        SetGravityAngle(b) {
            this._SetGravityAngle(d.toRadians(b))
        },
        SetEnabled(b) {
            this._SetEnabled(0 !== b)
        },
        FallThrough() {
            this._FallThroughJumpThru()
        },
        SetDoubleJumpEnabled(b) {
            this._SetDoubleJumpEnabled(0 !== b)
        },
        SetJumpSustain(b) {
            this._SetJumpSustain(b / 1E3)
        },
        SetCeilingCollision(b) {
            this._SetCeilingCollisionMode(b)
        },
        SetDefaultControls(b) {
            this._SetDefaultControls(b)
        },
        ResetDoubleJump(b) {
            this._ResetDoubleJump(b)
        }
    }
}
"use strict";
{
    const d = self.C3;
    d.Behaviors.Platform.Exps = {
        Speed() {
            return this._GetSpeed()
        },
        MaxSpeed() {
            return this._GetMaxSpeed()
        },
        Acceleration() {
            return this._GetAcceleration()
        },
        Deceleration() {
            return this._GetDeceleration()
        },
        JumpStrength() {
            return this._GetJumpStrength()
        },
        Gravity() {
            return this._GetGravity()
        },
        GravityAngle() {
            return d.toDegrees(this._GetGravityAngle())
        },
        MaxFallSpeed() {
            return this._GetMaxFallSpeed()
        },
        MovingAngle() {
            return d.toDegrees(this._GetMovingAngle())
        },
        VectorX() {
            return this._GetVectorX()
        },
        VectorY() {
            return this._GetVectorY()
        },
        JumpSustain() {
            return 1E3 * this._GetJumpSustain()
        }
    }
}
"use strict";
{
    const d = self.C3;
    d.Behaviors.Rotate = class extends d.SDKBehaviorBase {
        constructor(b) {
            super(b)
        }
        Release() {
            super.Release()
        }
    }
}
"use strict";
{
    const d = self.C3;
    d.Behaviors.Rotate.Type = class extends d.SDKBehaviorTypeBase {
        constructor(b) {
            super(b)
        }
        Release() {
            super.Release()
        }
        OnCreate() {}
    }
}
"use strict";
{
    const d = self.C3;
    d.Behaviors.Rotate.Instance = class extends d.SDKBehaviorInstanceBase {
        constructor(b, a) {
            super(b);
            this._acceleration = this._speed = 0;
            this._isEnabled = !0;
            a && (this._speed = d.toRadians(a[0]), this._acceleration = d.toRadians(a[1]), this._isEnabled = a[2]);
            this._isEnabled && this._StartTicking()
        }
        Release() {
            super.Release()
        }
        SaveToJson() {
            return {
                s: this._speed,
                a: this._acceleration,
                e: this._isEnabled
            }
        }
        LoadFromJson(b) {
            this._speed = b.s;
            this._acceleration = b.a;
            this._SetEnabled(b.e)
        }
        Tick() {
            if (this._isEnabled) {
                var b =
                    this._runtime.GetDt(this._inst);
                if (0 !== b && (0 !== this._acceleration && (this._speed += this._acceleration * b), 0 !== this._speed)) {
                    const a = this._inst.GetWorldInfo();
                    a.SetAngle(a.GetAngle() + this._speed * b);
                    a.SetBboxChanged()
                }
            }
        }
        GetPropertyValueByIndex(b) {
            switch (b) {
                case 0:
                    return d.toDegrees(this._speed);
                case 1:
                    return d.toDegrees(this._acceleration);
                case 2:
                    return this._isEnabled
            }
        }
        SetPropertyValueByIndex(b, a) {
            switch (b) {
                case 0:
                    this._speed = d.toRadians(a);
                    break;
                case 1:
                    this._acceleration = d.toRadians(a);
                    break;
                case 2:
                    this._SetEnabled(a)
            }
        }
        _SetEnabled(b) {
            (this._isEnabled = !!b) ? this._StartTicking(): this._StopTicking()
        }
        GetDebuggerProperties() {
            return [{
                title: "$" + this.GetBehaviorType().GetName(),
                properties: [{
                    name: "behaviors.rotate.properties.speed.name",
                    value: d.toDegrees(this._speed),
                    onedit: b => this._speed = d.toRadians(b)
                }, {
                    name: "behaviors.rotate.properties.acceleration.name",
                    value: d.toDegrees(this._acceleration),
                    onedit: b => this._acceleration = d.toRadians(b)
                }, {
                    name: "behaviors.rotate.properties.enabled.name",
                    value: this._isEnabled,
                    onedit: b => this._SetEnabled(b)
                }]
            }]
        }
    }
}
"use strict";
self.C3.Behaviors.Rotate.Cnds = {
    IsEnabled() {
        return this._isEnabled
    }
};
"use strict";
{
    const d = self.C3;
    d.Behaviors.Rotate.Acts = {
        SetSpeed(b) {
            this._speed = d.toRadians(b)
        },
        SetAcceleration(b) {
            this._acceleration = d.toRadians(b)
        },
        SetEnabled(b) {
            this._SetEnabled(b)
        }
    }
}
"use strict";
{
    const d = self.C3;
    d.Behaviors.Rotate.Exps = {
        Speed() {
            return d.toDegrees(this._speed)
        },
        Acceleration() {
            return d.toDegrees(this._acceleration)
        }
    }
}
"use strict";
globalThis.easeOutBounceArray = [];
globalThis.easeInElasticArray = [];
globalThis.easeOutElasticArray = [];
globalThis.easeInOutElasticArray = [];
globalThis.easeInCircle = [];
globalThis.easeOutCircle = [];
globalThis.easeInOutCircle = [];
globalThis.easeInBack = [];
globalThis.easeOutBack = [];
globalThis.easeInOutBack = [];
globalThis.litetween_precision = 1E4;
globalThis.updateLimit = 0;
globalThis.easeOutBouncefunc = function(d) {
    return result = (d /= 1) < 1 / 2.75 ? 7.5625 * d * d : d < 2 / 2.75 ? 7.5625 * (d -= 1.5 / 2.75) * d + .75 : d < 2.5 / 2.75 ? 7.5625 * (d -= 2.25 / 2.75) * d + .9375 : 7.5625 * (d -= 2.625 / 2.75) * d + .984375
};
globalThis.do_cmp = function(d, b, a) {
    if ("undefined" === typeof d || "undefined" === typeof a) return !1;
    switch (b) {
        case 0:
            return d === a;
        case 1:
            return d !== a;
        case 2:
            return d < a;
        case 3:
            return d <= a;
        case 4:
            return d > a;
        case 5:
            return d >= a;
        default:
            return !1
    }
};
globalThis.integerize = function(d, b) {
    return Math.round(d / b * litetween_precision)
};
globalThis.easeFunc = function(d, b, a, f, c, e, g) {
    var h = 0;
    switch (d) {
        case 0:
            h = f * b / c + a;
            break;
        case 1:
            h = f * (b /= c) * b + a;
            break;
        case 2:
            h = -f * (b /= c) * (b - 2) + a;
            break;
        case 3:
            h = 1 > (b /= c / 2) ? f / 2 * b * b + a : -f / 2 * (--b * (b - 2) - 1) + a;
            break;
        case 4:
            h = f * (b /= c) * b * b + a;
            break;
        case 5:
            h = f * ((b = b / c - 1) * b * b + 1) + a;
            break;
        case 6:
            h = 1 > (b /= c / 2) ? f / 2 * b * b * b + a : f / 2 * ((b -= 2) * b * b + 2) + a;
            break;
        case 7:
            h = f * (b /= c) * b * b * b + a;
            break;
        case 8:
            h = -f * ((b = b / c - 1) * b * b * b - 1) + a;
            break;
        case 9:
            h = 1 > (b /= c / 2) ? f / 2 * b * b * b * b + a : -f / 2 * ((b -= 2) * b * b * b - 2) + a;
            break;
        case 10:
            h = f * (b /= c) * b * b * b * b + a;
            break;
        case 11:
            h =
                f * ((b = b / c - 1) * b * b * b * b + 1) + a;
            break;
        case 12:
            h = 1 > (b /= c / 2) ? f / 2 * b * b * b * b * b + a : f / 2 * ((b -= 2) * b * b * b * b + 2) + a;
            break;
        case 13:
            h = g.optimized ? easeInCircle[integerize(b, c)] : -(Math.sqrt(1 - b * b) - 1);
            break;
        case 14:
            h = g.optimized ? easeOutCircle[integerize(b, c)] : Math.sqrt(1 - (b - 1) * (b - 1));
            break;
        case 15:
            h = g.optimized ? easeInOutCircle[integerize(b, c)] : 1 > (b /= c / 2) ? -f / 2 * (Math.sqrt(1 - b * b) - 1) + a : f / 2 * (Math.sqrt(1 - (b -= 2) * b) + 1) + a;
            break;
        case 16:
            g.optimized ? h = easeInBack[integerize(b, c)] : (g = g.s, h = f * (b /= c) * b * ((g + 1) * b - g) + a);
            break;
        case 17:
            g.optimized ?
                h = easeOutBack[integerize(b, c)] : (g = g.s, h = f * ((b = b / c - 1) * b * ((g + 1) * b + g) + 1) + a);
            break;
        case 18:
            g.optimized ? h = easeInOutBack[integerize(b, c)] : (g = g.s, h = 1 > (b /= c / 2) ? f / 2 * b * b * (((g *= 1.525) + 1) * b - g) + a : f / 2 * ((b -= 2) * b * (((g *= 1.525) + 1) * b + g) + 2) + a);
            break;
        case 19:
            g.optimized ? h = easeInElasticArray[integerize(b, c)] : (h = g.a, d = g.p, b /= c, 0 == d && (d = .3 * c), 0 == h || h < Math.abs(f) ? (h = f, g = d / 4) : g = d / (2 * Math.PI) * Math.asin(f / h), h = -(h * Math.pow(2, 10 * --b) * Math.sin(2 * (b * c - g) * Math.PI / d)) + a);
            break;
        case 20:
            g.optimized ? h = easeOutElasticArray[integerize(b,
                c)] : (h = g.a, d = g.p, b /= c, 0 == d && (d = .3 * c), 0 == h || h < Math.abs(f) ? (h = f, g = d / 4) : g = d / (2 * Math.PI) * Math.asin(f / h), h = h * Math.pow(2, -10 * b) * Math.sin(2 * (b * c - g) * Math.PI / d) + f + a);
            break;
        case 21:
            g.optimized ? h = easeInOutElasticArray[integerize(b, c)] : (h = g.a, d = g.p, b /= c / 2, 0 == d && (d = .3 * c * 1.5), 0 == h || h < Math.abs(f) ? (h = f, g = d / 4) : g = d / (2 * Math.PI) * Math.asin(f / h), h = 1 > b ? -.5 * h * Math.pow(2, 10 * --b) * Math.sin(2 * (b * c - g) * Math.PI / d) + a : h * Math.pow(2, -10 * --b) * Math.sin(2 * (b * c - g) * Math.PI / d) * .5 + f + a);
            break;
        case 22:
            h = g.optimized ? f - easeOutBounceArray[integerize(c -
                b, c)] + a : f - easeOutBouncefunc(c - b / c) + a;
            break;
        case 23:
            h = g.optimized ? easeOutBounceArray[integerize(b, c)] : easeOutBouncefunc(b / c);
            break;
        case 24:
            h = g.optimized ? b < c / 2 ? .5 * (f - easeOutBounceArray[integerize(c - 2 * b, c)] + a) + a : .5 * easeOutBounceArray[integerize(2 * b - c, c)] + .5 * f + a : b < c / 2 ? .5 * (f - easeOutBouncefunc(c - 2 * b) + a) + a : .5 * easeOutBouncefunc((2 * b - c) / c) + .5 * f + a;
            break;
        case 25:
            b = b / c / 2;
            h = 2 * b * b * (3 - 2 * b);
            break;
        case 26:
            b = (b / c + 1) / 2;
            h = 2 * b * b * (3 - 2 * b) - 1;
            break;
        case 27:
            b /= c, h = b * b * (3 - 2 * b)
    }
    return e ? f - a - h : h
};
globalThis.preCalculateArray = function() {
    for (var d, b, a, f, c = 0; c <= litetween_precision; c++) a = c / litetween_precision, d = (a /= 1) < 1 / 2.75 ? 7.5625 * a * a : a < 2 / 2.75 ? 7.5625 * (a -= 1.5 / 2.75) * a + .75 : a < 2.5 / 2.75 ? 7.5625 * (a -= 2.25 / 2.75) * a + .9375 : 7.5625 * (a -= 2.625 / 2.75) * a + .984375, easeOutBounceArray[c] = d, a = c / litetween_precision, b = d = 0, a /= 1, 0 == b && (b = .3), 0 == d || 1 > d ? (d = 1, f = b / 4) : f = b / (2 * Math.PI) * Math.asin(1 / d), d = -(d * Math.pow(2, 10 * --a) * Math.sin(2 * (1 * a - f) * Math.PI / b)), easeInElasticArray[c] = d, a = c / litetween_precision, b = d = 0, a /= 1, 0 == b && (b = .3),
        0 == d || 1 > d ? (d = 1, f = b / 4) : f = b / (2 * Math.PI) * Math.asin(1 / d), d = d * Math.pow(2, -10 * a) * Math.sin(2 * (1 * a - f) * Math.PI / b) + 1, easeOutElasticArray[c] = d, a = c / litetween_precision, b = d = 0, a /= .5, 0 == b && (b = .3 * 1.5), 0 == d || 1 > d ? (d = 1, f = b / 4) : f = b / (2 * Math.PI) * Math.asin(1 / d), d = 1 > a ? -.5 * d * Math.pow(2, 10 * --a) * Math.sin(2 * (1 * a - f) * Math.PI / b) : d * Math.pow(2, -10 * --a) * Math.sin(2 * (1 * a - f) * Math.PI / b) * .5 + 1, easeInOutElasticArray[c] = d, a = c / litetween_precision, easeInCircle[c] = -(Math.sqrt(1 - a * a) - 1), a = c / litetween_precision, easeOutCircle[c] = Math.sqrt(1 - (a -
            1) * (a - 1)), a = c / litetween_precision, d = 1 > (a /= .5) ? -.5 * (Math.sqrt(1 - a * a) - 1) : .5 * (Math.sqrt(1 - (a -= 2) * a) + 1), easeInOutCircle[c] = d, a = c / litetween_precision, f = 0, 0 == f && (f = 1.70158), d = (a /= 1) * a * ((f + 1) * a - f), easeInBack[c] = d, a = c / litetween_precision, f = 0, 0 == f && (f = 1.70158), d = (a = a / 1 - 1) * a * ((f + 1) * a + f) + 1, easeOutBack[c] = d, a = c / litetween_precision, f = 0, 0 == f && (f = 1.70158), d = 1 > (a /= .5) ? .5 * a * a * (((f *= 1.525) + 1) * a - f) : .5 * ((a -= 2) * a * (((f *= 1.525) + 1) * a + f) + 2), easeInOutBack[c] = d
}();
globalThis.TweenObject = function() {
    return function(d, b, a, f, c, e, g) {
        this.name = d;
        this.value = 0;
        this.setInitial(f);
        this.setTarget(c);
        this.easefunc = a;
        this.tweened = b;
        this.duration = e;
        this.state = this.progress = 0;
        this.onReverseEnd = this.onReverseStart = this.onEnd = this.onStart = !1;
        this.lastKnownValue2 = this.lastKnownValue = 0;
        this.enforce = g;
        this.pingpong = 1;
        this.flipEase = !1;
        this.easingparam = [];
        this.lastState = 1;
        for (d = 0; 28 > d; d++) this.easingparam[d] = {}, this.easingparam[d].a = 0, this.easingparam[d].p = 0, this.easingparam[d].t =
            0, this.easingparam[d].s = 0, this.easingparam[d].optimized = !0
    }
}();
(function() {
    TweenObject.prototype = {};
    TweenObject.prototype.flipTarget = function() {
        var d = this.initialparam1,
            b = this.initialparam2;
        this.initialparam1 = this.targetparam1;
        this.initialparam2 = this.targetparam2;
        this.targetparam1 = d;
        this.targetparam2 = b;
        this.lastKnownValue2 = this.lastKnownValue = 0
    };
    TweenObject.prototype.setInitial = function(d) {
        this.initialparam1 = parseFloat(d.split(",")[0]);
        this.initialparam2 = parseFloat(d.split(",")[1]);
        this.lastKnownValue2 = this.lastKnownValue = 0
    };
    TweenObject.prototype.setTarget = function(d) {
        this.targetparam1 =
            parseFloat(d.split(",")[0]);
        this.targetparam2 = parseFloat(d.split(",")[1]);
        isNaN(this.targetparam2) && (this.targetparam2 = this.targetparam1)
    };
    TweenObject.prototype.OnTick = function(d) {
        if (0 === this.state) return -1;
        1 === this.state && (this.progress += d);
        2 === this.state && (this.progress -= d);
        3 === this.state && (this.state = 0);
        if (4 === this.state || 6 === this.state) this.progress += d * this.pingpong;
        5 === this.state && (this.progress += d * this.pingpong);
        return 0 > this.progress ? (this.progress = 0, 4 === this.state ? this.pingpong = 1 : 6 === this.state ?
            (this.pingpong = 1, this.flipEase = !1) : this.state = 0, this.onReverseEnd = !0, 0) : this.progress > this.duration ? (this.progress = this.duration, 4 === this.state ? this.pingpong = -1 : 6 === this.state ? (this.pingpong = -1, this.flipEase = !0) : 5 === this.state ? this.progress = 0 : this.state = 0, this.onEnd = !0, 1) : this.flipEase ? easeFunc(this.easefunc, this.duration - this.progress, 0, 1, this.duration, this.flipEase, this.easingparam[this.easefunc]) : easeFunc(this.easefunc, this.progress, 0, 1, this.duration, this.flipEase, this.easingparam[this.easefunc])
    }
})();
globalThis.trim = function(d) {
    return d.replace(/^\s\s*/, "").replace(/\s\s*$/, "")
};
TweenObject.Load = function(d, b, a, f, c, e, g, h) {
    b = new TweenObject(b, a, f, c, e, g, h);
    for (var l in d) b[l] = d[l];
    return b
};
C3.Behaviors.lunarray_LiteTween = class extends C3.SDKBehaviorBase {
    constructor(d) {
        super(d)
    }
    Release() {
        super.Release()
    }
};
"use strict";
C3.Behaviors.lunarray_LiteTween.Type = class extends C3.SDKBehaviorTypeBase {
    constructor(d) {
        super(d)
    }
    Release() {
        super.Release()
    }
    OnCreate() {}
};
"use strict";
C3.Behaviors.lunarray_LiteTween.Instance = class extends C3.SDKBehaviorInstanceBase {
    constructor(d, b) {
        super(d);
        this.i = 0;
        this.inst = this._inst.GetWorldInfo();
        // console.log("IDDQD " + this.SaveToJson())
        b && (this.playmode = b[0], this.active = 1 == this.playmode || 2 == this.playmode || 3 == this.playmode || 4 == this.playmode, this.tweened = b[1], this.easing = b[2], this.target = b[3], this.targetmode = b[4], this.useCurrent = !1, 1 === this.targetmode && (this.target = "relative(" + this.target + ")"), this.duration = b[5], this.enforce = 1 === b[6], this.value = 0, this.tween_list = {}, this.addToTweenList("default",
            this.tweened, this.easing, "current", this.target, this.duration, this.enforce), 1 === b[0] && this.startTween(0), 2 === b[0] && this.startTween(2), 3 === b[0] && this.startTween(3), 4 === b[0] && this.startTween(4));
        this._StartTicking()
    }
    Release() {
        super.Release()
    }
    SaveToJson() {
        JSON.stringify(this.tween_list["default"]);
        return {
            playmode: this.playmode,
            active: this.active,
            tweened: this.tweened,
            easing: this.easing,
            target: this.target,
            targetmode: this.targetmode,
            useCurrent: this.useCurrent,
            duration: this.duration,
            enforce: this.enforce,
            value: this.value,
            tweenlist: JSON.stringify(this.tween_list["default"])
        }
    }
    LoadFromJson(d) {
        var b = JSON.parse(d.tweenlist);
        b = TweenObject.Load(b, b.name, b.tweened, b.easefunc, b.initialparam1 + "," + b.initialparam2, b.targetparam1 + "," + b.targetparam2, b.duration, b.enforce);
        this.tween_list["default"] = b;
        this.playmode = d.playmode;
        this.active = d.active;
        this.movement = d.tweened;
        this.easing = d.easing;
        this.target = d.target;
        this.targetmode = d.targetmode;
        this.useCurrent = d.useCurrent;
        this.duration = d.duration;
        this.enforce = d.enforce;
        this.value = d.value
    }
    parseCurrent(d, b) {
        void 0 === b && (b = "current");
        var a = trim(b);
        b = trim(b);
        var f = this.value;
        if ("current" === b) switch (d) {
            case 0:
                a = this.inst.GetX() + "," + this.inst.GetY();
                break;
            case 1:
                a = this.inst.GetWidth() + "," + this.inst.GetHeight();
                break;
            case 2:
                a = this.inst.GetWidth() + "," + this.inst.GetHeight();
                break;
            case 3:
                a = this.inst.GetWidth() + "," + this.inst.GetHeight();
                break;
            case 4:
                a = C3.toDegrees(this.inst.GetAngle()) + "," + C3.toDegrees(this.inst.GetAngle());
                break;
            case 5:
                a = 100 * this.inst.GetOpacity() + "," + 100 *
                    this.inst.GetOpacity();
                break;
            case 6:
                a = f + "," + f;
                break;
            case 7:
                a = this.inst.GetX() + "," + this.inst.GetY();
                break;
            case 8:
                a = this.inst.GetX() + "," + this.inst.GetY();
                break;
            case 9:
                a = null !== this._inst.GetSdkInstance() ? this._inst.GetWorldInfo().GetWidth() / this._inst.GetSdkInstance().GetCurrentImageInfo().GetWidth() + "," + this._inst.GetWorldInfo().GetHeight() / this._inst.GetSdkInstance().GetCurrentImageInfo().GetHeight() : "1,1"
        }
        if ("relative" === b.substring(0, 8)) {
            if (b = b.match(/\((.*?)\)/)) var c = parseFloat(b[1].split(",")[0]),
                e = parseFloat(b[1].split(",")[1]);
            isNaN(c) && (c = 0);
            isNaN(e) && (e = 0);
            switch (d) {
                case 0:
                    a = this.inst.GetX() + c + "," + (this.inst.GetY() + e);
                    break;
                case 1:
                    a = this.inst.GetWidth() + c + "," + (this.inst.GetHeight() + e);
                    break;
                case 2:
                    a = this.inst.GetWidth() + c + "," + (this.inst.GetHeight() + e);
                    break;
                case 3:
                    a = this.inst.GetWidth() + c + "," + (this.inst.GetHeight() + e);
                    break;
                case 4:
                    a = C3.toDegrees(this.inst.GetAngle()) + c + "," + (C3.toDegrees(this.inst.GetAngle()) + e);
                    break;
                case 5:
                    a = 100 * this.inst.GetOpacity() + c + "," + (100 * this.inst.GetOpacity() +
                        e);
                    break;
                case 6:
                    a = f + c + "," + f + c;
                    break;
                case 7:
                    a = this.inst.GetX() + c + "," + this.inst.GetY();
                    break;
                case 8:
                    a = this.inst.GetX() + "," + (this.inst.GetY() + c);
                    break;
                case 9:
                    a = c + "," + e
            }
        }
        return a
    }
    addToTweenList(d, b, a, f, c, e, g) {
        f = this.parseCurrent(b, f);
        c = this.parseCurrent(b, c);
        void 0 !== this.tween_list[d] && delete this.tween_list[d];
        this.tween_list[d] = new TweenObject(d, b, a, f, c, e, g);
        this.tween_list[d].dt = 0
    }
    setProgressTo(d) {
        1 < d && (d = 1);
        0 > d && (d = 0);
        for (var b in this.tween_list) {
            var a = this.tween_list[b];
            a.lastKnownValue = 0;
            a.lastKnownValue2 =
                0;
            a.state = 3;
            a.progress = d * a.duration;
            var f = a.OnTick(0);
            this.updateTween(a, f)
        }
    }
    startTween(d) {
        for (var b in this.tween_list) {
            var a = this.tween_list[b];
            if (this.useCurrent) {
                var f = this.parseCurrent(a.tweened, "current"),
                    c = this.parseCurrent(a.tweened, this.target);
                a.setInitial(f);
                a.setTarget(c)
            }
            0 === d && (a.progress = 1E-6, a.lastKnownValue = 0, a.lastKnownValue2 = 0, a.onStart = !0, a.state = 1);
            1 === d && (a.state = a.lastState);
            if (2 === d || 4 === d) a.progress = 1E-6, a.lastKnownValue = 0, a.lastKnownValue2 = 0, a.onStart = !0, 2 == d && (a.state = 4),
                4 == d && (a.state = 6);
            3 === d && (a.progress = 1E-6, a.lastKnownValue = 0, a.lastKnownValue2 = 0, a.onStart = !0, a.state = 5)
        }
    }
    stopTween(d) {
        for (var b in this.tween_list) {
            var a = this.tween_list[b];
            3 != a.state && 0 != a.state && (a.lastState = a.state);
            1 === d && (a.progress = 0);
            2 === d && (a.progress = a.duration);
            a.state = 3;
            var f = a.OnTick(0);
            this.updateTween(a, f)
        }
    }
    reverseTween(d) {
        for (var b in this.tween_list) {
            var a = this.tween_list[b];
            1 === d && (a.progress = a.duration, a.lastKnownValue = 0, a.lastKnownValue2 = 0, a.onReverseStart = !0);
            a.state = 2
        }
    }
    updateTween(d,
        b) {
        if (0 === d.tweened) d.enforce ? (this.inst.SetX(d.initialparam1 + (d.targetparam1 - d.initialparam1) * b), this.inst.SetY(d.initialparam2 + (d.targetparam2 - d.initialparam2) * b)) : (this.inst.SetX(this.inst.GetX() + (d.targetparam1 - d.initialparam1) * b - d.lastKnownValue), this.inst.SetY(this.inst.GetY() + (d.targetparam2 - d.initialparam2) * b - d.lastKnownValue2), d.lastKnownValue = (d.targetparam1 - d.initialparam1) * b, d.lastKnownValue2 = (d.targetparam2 - d.initialparam2) * b);
        else if (1 === d.tweened) d.enforce ? (this.inst.SetWidth(d.initialparam1 +
            (d.targetparam1 - d.initialparam1) * b), this.inst.SetHeight(d.initialparam2 + (d.targetparam2 - d.initialparam2) * b)) : (this.inst.SetWidth(this.inst.GetWidth() + (d.targetparam1 - d.initialparam1) * b - d.lastKnownValue), this.inst.SetHeight(this.inst.GetHeight() + (d.targetparam2 - d.initialparam2) * b - d.lastKnownValue2), d.lastKnownValue = (d.targetparam1 - d.initialparam1) * b, d.lastKnownValue2 = (d.targetparam2 - d.initialparam2) * b);
        else if (2 === d.tweened) d.enforce ? this.inst.SetWidth(d.initialparam1 + (d.targetparam1 - d.initialparam1) *
            b) : (this.inst.SetWidth(this.inst.GetWidth() + (d.targetparam1 - d.initialparam1) * b - d.lastKnownValue), d.lastKnownValue = (d.targetparam1 - d.initialparam1) * b);
        else if (3 === d.tweened) d.enforce ? this.inst.SetHeight(d.initialparam2 + (d.targetparam2 - d.initialparam2) * b) : (this.inst.SetHeight(this.inst.GetHeight() + (d.targetparam2 - d.initialparam2) * b - d.lastKnownValue2), d.lastKnownValue2 = (d.targetparam2 - d.initialparam2) * b);
        else if (4 === d.tweened)
            if (d.enforce) {
                var a = d.initialparam1 + (d.targetparam1 - d.initialparam1) * b;
                this.inst.SetAngle(C3.clampAngle(C3.toRadians(a)))
            } else a =
                (d.targetparam1 - d.initialparam1) * b - d.lastKnownValue, this.inst.SetAngle(C3.clampAngle(this.inst.angle + C3.toRadians(a))), d.lastKnownValue = (d.targetparam1 - d.initialparam1) * b;
        else if (5 === d.tweened) d.enforce ? this.inst.SetOpacity((d.initialparam1 + (d.targetparam1 - d.initialparam1) * b) / 100) : (this.inst.SetOpacity(this.inst.GetOpacity() + ((d.targetparam1 - d.initialparam1) * b - d.lastKnownValue) / 100), d.lastKnownValue = (d.targetparam1 - d.initialparam1) * b);
        else if (6 === d.tweened) d.enforce ? this.value = d.initialparam1 + (d.targetparam1 -
            d.initialparam1) * b : (this.value += (d.targetparam1 - d.initialparam1) * b - d.lastKnownValue, d.lastKnownValue = (d.targetparam1 - d.initialparam1) * b);
        else if (7 === d.tweened) d.enforce ? this.inst.SetX(d.initialparam1 + (d.targetparam1 - d.initialparam1) * b) : (this.inst.SetX(this.inst.GetX() + (d.targetparam1 - d.initialparam1) * b - d.lastKnownValue), d.lastKnownValue = (d.targetparam1 - d.initialparam1) * b);
        else if (8 === d.tweened) d.enforce ? this.inst.SetY(d.initialparam2 + (d.targetparam2 - d.initialparam2) * b) : (this.inst.SetY(this.inst.GetY() +
            (d.targetparam2 - d.initialparam2) * b - d.lastKnownValue2), d.lastKnownValue2 = (d.targetparam2 - d.initialparam2) * b);
        else if (9 === d.tweened) {
            a = d.initialparam1 + (d.targetparam1 - d.initialparam1) * b;
            var f = d.initialparam2 + (d.targetparam2 - d.initialparam2) * b;
            0 > this.inst.GetWidth() && (a = d.initialparam1 + (d.targetparam1 + d.initialparam1) * -b);
            0 > this.inst.GetHeight() && (f = d.initialparam2 + (d.targetparam2 + d.initialparam2) * -b);
            d.enforce ? (this.inst.SetWidth(this._inst.GetWorldInfo().GetInstance().GetCurrentImageInfo().GetWidth() *
                a), this.inst.SetHeight(this._inst.GetWorldInfo().GetInstance().GetCurrentImageInfo().GetHeight() * f)) : (0 > this.inst.GetWidth() ? (this.inst.SetWidth(a * (this.inst.GetWidth() / (-1 + d.lastKnownValue))), d.lastKnownValue = a + 1) : (this.inst.SetWidth(a * (this.inst.GetWidth() / (1 + d.lastKnownValue))), d.lastKnownValue = a - 1), 0 > this.inst.GetHeight() ? (this.inst.SetHeight(f * (this.inst.GetHeight() / (-1 + d.lastKnownValue2))), d.lastKnownValue2 = f + 1) : (this.inst.SetHeight(f * (this.inst.GetHeight() / (1 + d.lastKnownValue2))), d.lastKnownValue2 =
                f - 1))
        }
        this.inst.SetBboxChanged()
    }
    Tick() {
        var d = this._runtime.GetDt(this._inst);
        this._inst.GetWorldInfo();
        var b = this.tween_list["default"];
        0 !== b.state && (b.onStart && (this.Trigger(C3.Behaviors.lunarray_LiteTween.Cnds.OnStart, this.inst), b.onStart = !1), b.onReverseStart && (this.Trigger(C3.Behaviors.lunarray_LiteTween.Cnds.OnReverseStart, this.inst), b.onReverseStart = !1), this.active = 1 == b.state || 2 == b.state || 4 == b.state || 5 == b.state || 6 == b.state, d = b.OnTick(d), this.updateTween(b, d), b.onEnd && (this.Trigger(C3.Behaviors.lunarray_LiteTween.Cnds.OnEnd,
            this.inst), b.onEnd = !1), b.onReverseEnd && (this.Trigger(C3.Behaviors.lunarray_LiteTween.Cnds.OnReverseEnd, this.inst), b.onReverseEnd = !1))
    }
};
"use strict";
C3.Behaviors.lunarray_LiteTween.Cnds = {
    IsActive() {
        // console.log("IDDQD isactive " + this.tween_list["default"])
        return 0 !== this.tween_list["default"].state
    },
    IsReversing() {
        // console.log("IDDQD IsReversing " + this.tween_list["default"])
        return 2 == this.tween_list["default"].state
    },
    CompareProgress(d, b) {
        // console.log("IDDQD CompareProgress " + this.tween_list["default"])
        var a = this.tween_list["default"];
        return do_cmp(a.progress / a.duration, d, b)
    },
    OnThreshold(d, b) {
        var a = this.tween_list["default"];
        this.threshold = do_cmp(a.progress / a.duration, d, b);
        if (d = this.oldthreshold != this.threshold && this.threshold) this.oldthreshold = this.threshold;
        return d
    },
    OnStart() {
        // console.log("IDDQD OnStart " + this.tween_list["default"])
        return void 0 === this.tween_list["default"] ? !1 :
            this.tween_list["default"].onStart
    },
    OnReverseStart() {
        // console.log("IDDQD OnReverseStart " + this.tween_list["default"])
        return void 0 === this.tween_list["default"] ? !1 : this.tween_list["default"].onReverseStart
    },
    OnEnd() {
        // console.log("IDDQD OnEnd " + this.tween_list["default"])
        return void 0 === this.tween_list["default"] ? !1 : this.tween_list["default"].onEnd
    },
    OnReverseEnd() {
        // console.log("IDDQD OnReverseEnd " + this.tween_list["default"])
        return void 0 === this.tween_list["default"] ? !1 : this.tween_list["default"].onReverseEnd
    }
};
"use strict";
C3.Behaviors.lunarray_LiteTween.Acts = {
    Start(d, b) {
        this.oldthreshold = this.threshold = !1;
        this.useCurrent = 1 == b;
        this.startTween(d)
    },
    Stop(d) {
        this.stopTween(d)
    },
    Reverse(d) {
        this.oldthreshold = this.threshold = !1;
        this.reverseTween(d)
    },
    ProgressTo(d) {
        this.setProgressTo(d)
    },
    SetDuration(d) {
        isNaN(d) || 0 > d || void 0 === this.tween_list["default"] || (this.tween_list["default"].duration = d)
    },
    SetEnforce(d) {
        void 0 !== this.tween_list["default"] && (this.tween_list["default"].enforce = 1 === d)
    },
    SetInitial(d) {
        void 0 !== this.tween_list["default"] &&
            (d = this.parseCurrent(this.tween_list["default"].tweened, d), this.tween_list["default"].setInitial(d))
    },
    SetTarget(d, b, a) {
        if (void 0 !== this.tween_list["default"] && !isNaN(a)) {
            var f = this.tween_list["default"],
                c = a + "";
            this.targetmode = b;
            var e = "",
                g = "";
            if (1 === b) {
                this.target = "relative(" + c + ")";
                switch (d) {
                    case 0:
                        e = this.inst.GetX() + a;
                        g = f.targetparam2;
                        break;
                    case 1:
                        e = f.targetparam1;
                        g = this.inst.GetY() + a;
                        break;
                    case 2:
                        g = e = "" + C3.toDegrees(this.inst.GetAngle() + C3.toRadians(a));
                        break;
                    case 3:
                        g = e = "" + 100 * this.inst.GetOpacity() +
                            a;
                        break;
                    case 4:
                        e = this.inst.GetWidth() + a;
                        g = f.targetparam2;
                        break;
                    case 5:
                        e = f.targetparam1;
                        g = this.inst.GetHeight() + a;
                        break;
                    case 6:
                        g = e = a
                }
                c = e + "," + g
            } else {
                switch (d) {
                    case 0:
                        e = a;
                        g = f.targetparam2;
                        break;
                    case 1:
                        e = f.targetparam1;
                        g = a;
                        break;
                    case 2:
                        g = e = a;
                        break;
                    case 3:
                        g = e = a;
                        break;
                    case 4:
                        e = a;
                        g = f.targetparam2;
                        break;
                    case 5:
                        e = f.targetparam1;
                        g = a;
                        break;
                    case 6:
                        g = e = a
                }
                this.target = c = e + "," + g
            }
            d = this.parseCurrent(this.tween_list["default"].tweened, "current");
            c = this.parseCurrent(this.tween_list["default"].tweened, c);
            f.setInitial(d);
            f.setTarget(c)
        }
    },
    SetTweenedProperty(d) {
        void 0 !== this.tween_list["default"] && (this.tween_list["default"].tweened = d)
    },
    SetEasing(d) {
        void 0 !== this.tween_list["default"] && (this.tween_list["default"].easefunc = d)
    },
    SetEasingParam(d, b, a, f, c) {
        void 0 !== this.tween_list["default"] && (this.tween_list["default"].easingparam[d].optimized = !1, this.tween_list["default"].easingparam[d].a = b, this.tween_list["default"].easingparam[d].p = a, this.tween_list["default"].easingparam[d].t = f, this.tween_list["default"].easingparam[d].s =
            c)
    },
    ResetEasingParam() {
        void 0 !== this.tween_list["default"] && (this.tween_list["default"].optimized = !0)
    },
    SetValue(d) {
        var b = this.tween_list["default"];
        this.value = d;
        6 === b.tweened && b.setInitial(this.parseCurrent(b.tweened, "current"))
    },
    SetParameter(d, b, a, f, c) {
        if (void 0 === this.tween_list["default"]) this.addToTweenList("default", d, b, initial, a, f, c, 0);
        else {
            var e = this.tween_list["default"];
            e.tweened = d;
            e.easefunc = b;
            e.setInitial(this.parseCurrent(d, "current"));
            e.setTarget(this.parseCurrent(d, a));
            e.duration = f;
            e.enforce = 1 === c
        }
    }
};
"use strict";
C3.Behaviors.lunarray_LiteTween.Exps = {
    State() {
        var d = "N/A";
        switch (this.tween_list["default"].state) {
            case 0:
                d = "paused";
                break;
            case 1:
                d = "playing";
                break;
            case 2:
                d = "reversing";
                break;
            case 3:
                d = "seeking"
        }
        return d
    },
    Progress() {
        return this.tween_list["default"].progress / this.tween_list["default"].duration
    },
    Duration() {
        return this.tween_list["default"].duration
    },
    Target() {
        var d = this.tween_list["default"],
            b = "N/A";
        switch (d.tweened) {
            case 0:
                b = d.targetparam1;
                break;
            case 1:
                b = d.targetparam2;
                break;
            case 2:
                b = d.targetparam1;
                break;
            case 3:
                b = d.targetparam1;
                break;
            case 4:
                b = d.targetparam1;
                break;
            case 5:
                b = d.targetparam2;
                break;
            case 6:
                b = d.targetparam1
        }
        return b
    },
    Value() {
        return this.value
    },
    Tween(d, b, a, f) {
        a = 1 < a ? 1 : a;
        f = easeFunc(f, 0 > a ? 0 : a, 0, 1, 1, !1, !1);
        return d + f * (b - d)
    }
};
"use strict";
{
    const d = self.C3;
    d.Behaviors.Fade = class extends d.SDKBehaviorBase {
        constructor(b) {
            super(b)
        }
        Release() {
            super.Release()
        }
    }
}
"use strict";
{
    const d = self.C3;
    d.Behaviors.Fade.Type = class extends d.SDKBehaviorTypeBase {
        constructor(b) {
            super(b)
        }
        Release() {
            super.Release()
        }
        OnCreate() {}
    }
}
"use strict";
{
    const d = self.C3;
    d.Behaviors.Fade.Instance = class extends d.SDKBehaviorInstanceBase {
        constructor(b, a) {
            super(b);
            this._fadeOutTime = this._waitTime = this._fadeInTime = 0;
            this._activeAtStart = this._destroy = !0;
            this._setMaxOpacity = !1;
            this._stage = 0;
            this._stageTime = d.New(d.KahanSum);
            this._maxOpacity = this._inst.GetWorldInfo().GetOpacity() || 1;
            a && (this._fadeInTime = a[0], this._waitTime = a[1], this._fadeOutTime = a[2], this._destroy = !!a[3], this._stage = (this._activeAtStart = !!a[4]) ? 0 : 3);
            this._activeAtStart && (0 === this._fadeInTime ?
                (this._stage = 1, 0 === this._waitTime && (this._stage = 2)) : (this._inst.GetWorldInfo().SetOpacity(0), this._runtime.UpdateRender()));
            this._StartTicking()
        }
        Release() {
            super.Release()
        }
        SaveToJson() {
            return {
                fit: this._fadeInTime,
                wt: this._waitTime,
                fot: this._fadeOutTime,
                d: this._destroy,
                s: this._stage,
                st: this._stageTime.Get(),
                mo: this._maxOpacity
            }
        }
        LoadFromJson(b) {
            this._fadeInTime = b.fit;
            this._waitTime = b.wt;
            this._fadeOutTime = b.fot;
            this._destroy = b.d;
            this._stage = b.s;
            this._stageTime.Set(b.st);
            this._maxOpacity = b.mo
        }
        Tick() {
            var b =
                this._runtime.GetDt(this._inst);
            this._stageTime.Add(b);
            b = this._inst.GetWorldInfo();
            0 === this._stage && (b.SetOpacity(this._stageTime.Get() / this._fadeInTime * this._maxOpacity), this._runtime.UpdateRender(), b.GetOpacity() >= this._maxOpacity && (b.SetOpacity(this._maxOpacity), this._stage = 1, this._stageTime.Reset(), this.Trigger(d.Behaviors.Fade.Cnds.OnFadeInEnd)));
            1 === this._stage && this._stageTime.Get() >= this._waitTime && (this._stage = 2, this._stageTime.Reset(), this.Trigger(d.Behaviors.Fade.Cnds.OnWaitEnd));
            2 === this._stage &&
                0 !== this._fadeOutTime && (b.SetOpacity(this._maxOpacity - this._stageTime.Get() / this._fadeOutTime * this._maxOpacity), this._runtime.UpdateRender(), 0 >= b.GetOpacity() && (this._stage = 3, this._stageTime.Reset(), this.Trigger(d.Behaviors.Fade.Cnds.OnFadeOutEnd), this._destroy && this._runtime.DestroyInstance(this._inst)))
        }
        Start() {
            this._stage = 0;
            this._stageTime.Reset();
            0 === this._fadeInTime ? (this._stage = 1, 0 === this._waitTime && (this._stage = 2)) : (this._inst.GetWorldInfo().SetOpacity(0), this._runtime.UpdateRender())
        }
        GetPropertyValueByIndex(b) {
            switch (b) {
                case 0:
                    return this._fadeInTime;
                case 1:
                    return this._waitTime;
                case 2:
                    return this._fadeOutTime;
                case 3:
                    return this._destroy
            }
        }
        SetPropertyValueByIndex(b, a) {
            switch (b) {
                case 0:
                    this._fadeInTime = a;
                    break;
                case 1:
                    this._waitTime = a;
                    break;
                case 2:
                    this._fadeOutTime = a;
                    break;
                case 3:
                    this._destroy = !!a
            }
        }
        GetDebuggerProperties() {
            return [{
                title: "$" + this.GetBehaviorType().GetName(),
                properties: [{
                    name: "behaviors.fade.properties.fade-in-time.name",
                    value: this._fadeInTime,
                    onedit: b => this._fadeInTime = b
                }, {
                    name: "behaviors.fade.properties.wait-time.name",
                    value: this._waitTime,
                    onedit: b => this._waitTime = b
                }, {
                    name: "behaviors.fade.properties.fade-out-time.name",
                    value: this._fadeOutTime,
                    onedit: b => this._fadeOutTime = b
                }, {
                    name: "behaviors.fade.debugger.stage",
                    value: ["behaviors.fade.debugger." + ["fade-in", "wait", "fade-out", "done"][this._stage]]
                }]
            }]
        }
    }
}
"use strict";
self.C3.Behaviors.Fade.Cnds = {
    OnFadeOutEnd() {
        return !0
    },
    OnFadeInEnd() {
        return !0
    },
    OnWaitEnd() {
        return !0
    }
};
"use strict";
self.C3.Behaviors.Fade.Acts = {
    StartFade() {
        this._activeAtStart || this._setMaxOpacity || (this._maxOpacity = this._inst.GetWorldInfo().GetOpacity() || 1, this._setMaxOpacity = !0);
        3 === this._stage && this.Start()
    },
    RestartFade() {
        this.Start()
    },
    SetFadeInTime(d) {
        0 > d && (d = 0);
        this._fadeInTime = d
    },
    SetWaitTime(d) {
        0 > d && (d = 0);
        this._waitTime = d
    },
    SetFadeOutTime(d) {
        0 > d && (d = 0);
        this._fadeOutTime = d
    }
};
"use strict";
self.C3.Behaviors.Fade.Exps = {
    FadeInTime() {
        return this._fadeInTime
    },
    WaitTime() {
        return this._waitTime
    },
    FadeOutTime() {
        return this._fadeOutTime
    }
};
"use strict";
{
    const d = self.C3;
    d.Behaviors.scrollto = class extends d.SDKBehaviorBase {
        constructor(b) {
            super(b);
            this._shakeMode = this._shakeEnd = this._shakeStart = this._shakeMag = 0
        }
        Release() {
            super.Release()
        }
        SetShakeMagnitude(b) {
            this._shakeMag = b
        }
        GetShakeMagnitude() {
            return this._shakeMag
        }
        SetShakeStart(b) {
            this._shakeStart = b
        }
        GetShakeStart() {
            return this._shakeStart
        }
        SetShakeEnd(b) {
            this._shakeEnd = b
        }
        GetShakeEnd() {
            return this._shakeEnd
        }
        SetShakeMode(b) {
            this._shakeMode = b
        }
        GetShakeMode() {
            return this._shakeMode
        }
    }
}
"use strict";
{
    const d = self.C3;
    d.Behaviors.scrollto.Type = class extends d.SDKBehaviorTypeBase {
        constructor(b) {
            super(b)
        }
        Release() {
            super.Release()
        }
        OnCreate() {}
    }
}
"use strict";
{
    const d = self.C3;
    d.Behaviors.scrollto.Instance = class extends d.SDKBehaviorInstanceBase {
        constructor(b, a) {
            super(b);
            this._isEnabled = !0;
            a && (this._isEnabled = a[0]);
            this._isEnabled && this._StartTicking2()
        }
        Release() {
            super.Release()
        }
        SaveToJson() {
            const b = this.GetBehavior();
            return {
                e: this._isEnabled,
                smg: b.GetShakeMagnitude(),
                ss: b.GetShakeStart(),
                se: b.GetShakeEnd(),
                smd: b.GetShakeMode()
            }
        }
        LoadFromJson(b) {
            const a = this.GetBehavior();
            a.SetShakeMagnitude(b.smg);
            a.SetShakeStart(b.ss);
            a.SetShakeEnd(b.se);
            a.SetShakeMode(b.smd);
            (this._isEnabled = b.e) ? this._StartTicking2(): this._StopTicking2()
        }
        IsEnabled() {
            return this._isEnabled
        }
        Tick2() {
            if (this.IsEnabled()) {
                this._runtime.GetDt(this._inst);
                var b = this.GetBehavior(),
                    a = b.GetInstances(),
                    f = 0,
                    c = 0,
                    e = 0;
                for (var g of a)(a = g.GetBehaviorInstanceFromCtor(d.Behaviors.scrollto)) && a.GetSdkInstance().IsEnabled() && (a = g.GetWorldInfo(), f += a.GetX(), c += a.GetY(), ++e);
                g = this._inst.GetWorldInfo().GetLayout();
                var h = this._runtime.GetGameTime(),
                    l = a = 0;
                h >= b.GetShakeStart() && h < b.GetShakeEnd() && (a = b.GetShakeMagnitude() *
                    Math.min(this._runtime.GetTimeScale(), 1), 0 === b.GetShakeMode() && (a *= 1 - (h - b.GetShakeStart()) / (b.GetShakeEnd() - b.GetShakeStart())), b = this._runtime.Random() * Math.PI * 2, h = this._runtime.Random() * a, a = Math.cos(b) * h, l = Math.sin(b) * h);
                g.SetScrollX(f / e + a);
                g.SetScrollY(c / e + l)
            }
        }
        GetPropertyValueByIndex(b) {
            switch (b) {
                case 0:
                    return this._isEnabled
            }
        }
        SetPropertyValueByIndex(b, a) {
            switch (b) {
                case 0:
                    (this._isEnabled = !!a) ? this._StartTicking2(): this._StopTicking2()
            }
        }
    }
}
"use strict";
self.C3.Behaviors.scrollto.Cnds = {
    IsEnabled() {
        return this._isEnabled
    }
};
"use strict";
self.C3.Behaviors.scrollto.Acts = {
    Shake(d, b, a) {
        const f = this.GetBehavior();
        f.SetShakeMagnitude(d);
        f.SetShakeStart(this._runtime.GetGameTime());
        f.SetShakeEnd(this._runtime.GetGameTime() + b);
        f.SetShakeMode(a)
    },
    SetEnabled(d) {
        (this._isEnabled = 0 !== d) ? this._StartTicking2(): this._StopTicking2()
    }
};
"use strict";
self.C3.Behaviors.scrollto.Exps = {};
{
    const d = self.C3;
    self.C3_GetObjectRefTable = function() {
        return [d.Plugins.TiledBg, d.Behaviors.solid, d.Plugins.Sprite, d.Behaviors.Platform, d.Behaviors.Rotate, d.Behaviors.lunarray_LiteTween, d.Behaviors.Fade, d.Plugins.Text, d.Behaviors.scrollto, d.Plugins.Keyboard, d.Plugins.Particles, d.Plugins.Touch, d.Plugins.Browser, d.Plugins.Spritefont2, d.Plugins.LocalStorage, d.Plugins.Audio, d.Plugins.Arr, d.Plugins.AJAX, d.Plugins.System.Cnds.IsGroupActive, d.Behaviors.Platform.Cnds.IsFalling, d.Plugins.System.Cnds.CompareVar,
            d.Plugins.System.Acts.SetVar, d.Behaviors.Platform.Acts.SetJumpStrength, d.Behaviors.Platform.Cnds.OnLand, d.Plugins.System.Cnds.TriggerOnce, d.Behaviors.Platform.Acts.SimulateControl, d.Behaviors.Platform.Cnds.IsOnFloor, d.Plugins.Keyboard.Cnds.OnKey, d.Plugins.Keyboard.Cnds.IsKeyDown, d.Plugins.System.Cnds.Else, d.Plugins.Touch.Cnds.OnTouchObject, d.Plugins.Touch.Cnds.IsTouchingObject, d.Behaviors.Rotate.Acts.SetSpeed, d.Plugins.Sprite.Acts.SetOpacity, d.Plugins.System.Acts.Wait, d.Plugins.System.Acts.SetGroupActive,
            d.Plugins.System.Cnds.OnLayoutStart, d.Plugins.System.Acts.SetTimescale, d.Behaviors.scrollto.Acts.SetEnabled, d.Plugins.System.Cnds.EveryTick, d.Plugins.Sprite.Acts.SetPos, d.Plugins.Sprite.Exps.X, d.Plugins.Sprite.Exps.Y, d.Plugins.Text.Acts.SetText, d.Plugins.Spritefont2.Acts.SetText, d.Plugins.System.Cnds.IsMobile, d.Plugins.Sprite.Acts.Destroy, d.Plugins.Sprite.Cnds.OnCollision, d.Plugins.Sprite.Cnds.PickByUID, d.Behaviors.lunarray_LiteTween.Acts.Start, d.Plugins.Sprite.Acts.SetCollisions, d.Behaviors.Platform.Acts.SetGravity,
            d.Plugins.Audio.Acts.Play, d.Behaviors.lunarray_LiteTween.Acts.Reverse, d.Plugins.Sprite.Acts.SetVisible, d.Plugins.Sprite.Acts.Spawn, d.Plugins.System.Acts.SubVar, d.Behaviors.Platform.Acts.SetDoubleJumpEnabled, d.Plugins.System.Acts.RestartLayout, d.Plugins.Touch.Cnds.OnTapGestureObject, d.Plugins.Sprite.Cnds.CompareFrame, d.Plugins.Text.Cnds.IsOnScreen, d.Plugins.Sprite.Cnds.CompareHeight, d.Plugins.Sprite.Cnds.IsOnScreen, d.Plugins.Browser.Acts.ExecJs, d.Plugins.Sprite.Acts.SetAnimFrame, d.Behaviors.lunarray_LiteTween.Acts.Stop,
            d.Plugins.System.Acts.AddVar, d.Plugins.Sprite.Acts.SetSize, d.Behaviors.Fade.Acts.StartFade, d.Plugins.System.Acts.GoToLayout, d.Plugins.LocalStorage.Acts.SetItem, d.Behaviors.solid.Acts.SetEnabled, d.Plugins.LocalStorage.Acts.CheckItemExists, d.Plugins.LocalStorage.Cnds.OnItemExists, d.Plugins.LocalStorage.Exps.ItemValue, d.Plugins.TiledBg.Acts.SetPos, d.Plugins.Audio.Acts.SetSilent, d.Plugins.Audio.Cnds.IsTagPlaying, d.Plugins.Audio.Acts.Stop, d.Plugins.Browser.Cnds.IsPortraitLandscape, d.Plugins.Sprite.Acts.MoveToTop,
            d.Plugins.System.Acts.CreateObject, d.Plugins.System.Acts.SetLayerBackground, d.Plugins.System.Acts.SetLayerTransparent, d.Plugins.Keyboard.Cnds.OnAnyKey, d.Plugins.Browser.Acts.RequestFullScreen, d.Plugins.Browser.Acts.CancelFullScreen, d.Plugins.Sprite.Acts.SetAnim, d.Plugins.AJAX.Cnds.OnComplete, d.Plugins.Sprite.Cnds.OnURLLoaded, d.Plugins.Sprite.Cnds.OnURLFailed, d.Plugins.AJAX.Acts.Request, d.Plugins.Arr.Acts.JSONLoad, d.Plugins.AJAX.Exps.LastData, d.ScriptsInEvents.Localization_Event3_Act1, d.Plugins.Sprite.Acts.LoadURL,
            d.Plugins.Arr.Exps.At
        ]
    };
    self.C3_JsPropNameTable = [{
            Solid: 0
        }, {
            TiledBackground01: 0
        }, {
            Platform: 0
        }, {
            Rotate: 0
        }, {
            LiteTween: 0
        }, {
            Fade: 0
        }, {
            LiteTween2: 0
        }, {
            LiteTween3: 0
        }, {
            LiteTween4: 0
        }, {
            LiteTween5: 0
        }, {
            LiteTween6: 0
        }, {
            LiteTween7: 0
        }, {
            ball: 0
        }, {
            Text: 0
        }, {
            ScrollTo: 0
        }, {
            camera: 0
        }, {
            enemy: 0
        }, {
            Sprite2: 0
        }, {
            Keyboard: 0
        }, {
            Sprite: 0
        }, {
            Sprite3: 0
        }, {
            Sprite4: 0
        }, {
            triangle: 0
        }, {
            Sprite6: 0
        }, {
            JUMPER: 0
        }, {
            Sprite7: 0
        }, {
            circle1: 0
        }, {
            slope: 0
        }, {
            Text2: 0
        }, {
            Text3: 0
        }, {
            Sprite5: 0
        }, {
            Sprite8: 0
        }, {
            Sprite9: 0
        }, {
            enemy2: 0
        }, {
            destroy: 0
        }, {
            life: 0
        }, {
            circle2: 0
        }, {
            Sprite10: 0
        },
        {
            blinkPoint: 0
        }, {
            Sprite11: 0
        }, {
            diamond: 0
        }, {
            position2: 0
        }, {
            position3: 0
        }, {
            TiledBackground2: 0
        }, {
            Sprite12: 0
        }, {
            TiledBackground3: 0
        }, {
            star2: 0
        }, {
            Sprite14: 0
        }, {
            star1: 0
        }, {
            Sprite16: 0
        }, {
            star3: 0
        }, {
            Sprite13: 0
        }, {
            Sprite17: 0
        }, {
            Sprite18: 0
        }, {
            Particles: 0
        }, {
            TiledBackground4: 0
        }, {
            particel2: 0
        }, {
            Sprite19: 0
        }, {
            Text4: 0
        }, {
            Text5: 0
        }, {
            Sprite20: 0
        }, {
            Sprite21: 0
        }, {
            Sprite22: 0
        }, {
            Sprite23: 0
        }, {
            ballFadeOut: 0
        }, {
            Touch: 0
        }, {
            LeftTouch: 0
        }, {
            RightTouch: 0
        }, {
            jump: 0
        }, {
            pole: 0
        }, {
            Sprite25: 0
        }, {
            Text6: 0
        }, {
            Sprite26: 0
        }, {
            Text7: 0
        }, {
            sizeIncreaser: 0
        }, {
            Sprite27: 0
        },
        {
            sizeReduce: 0
        }, {
            Sprite15: 0
        }, {
            SizeReducer: 0
        }, {
            CollisionPoint1: 0
        }, {
            Sprite28: 0
        }, {
            "2ndCamera": 0
        }, {
            "3rdCamera": 0
        }, {
            camera2: 0
        }, {
            "3rdcam": 0
        }, {
            lastStage: 0
        }, {
            "4thCam": 0
        }, {
            Sprite24: 0
        }, {
            TiledBackground5: 0
        }, {
            TiledBackground6: 0
        }, {
            Sprite29: 0
        }, {
            TiledBackground7: 0
        }, {
            TiledBackground8: 0
        }, {
            Sprite30: 0
        }, {
            TiledBackground9: 0
        }, {
            Sprite31: 0
        }, {
            TiledBackground10: 0
        }, {
            TiledBackground11: 0
        }, {
            TiledBackground12: 0
        }, {
            Sprite32: 0
        }, {
            Sprite33: 0
        }, {
            Sprite34: 0
        }, {
            TiledBackground13: 0
        }, {
            Sprite35: 0
        }, {
            TiledBackground14: 0
        }, {
            Sprite36: 0
        }, {
            Sprite37: 0
        },
        {
            Sprite38: 0
        }, {
            Sprite39: 0
        }, {
            Sprite40: 0
        }, {
            TiledBackground15: 0
        }, {
            enemy3: 0
        }, {
            TiledBackground16: 0
        }, {
            TiledBackground17: 0
        }, {
            TiledBackground18: 0
        }, {
            Sprite42: 0
        }, {
            Sprite43: 0
        }, {
            Sprite44: 0
        }, {
            Sprite45: 0
        }, {
            Sprite46: 0
        }, {
            "5thCam": 0
        }, {
            "6thCam": 0
        }, {
            fall: 0
        }, {
            groundCam: 0
        }, {
            float1: 0
        }, {
            Sprite47: 0
        }, {
            shadow: 0
        }, {
            Sprite48: 0
        }, {
            Sprite49: 0
        }, {
            Sprite50: 0
        }, {
            Sprite51: 0
        }, {
            Sprite52: 0
        }, {
            Sprite53: 0
        }, {
            ZeroGravity: 0
        }, {
            Sprite55: 0
        }, {
            Sprite56: 0
        }, {
            Sprite57: 0
        }, {
            Sprite58: 0
        }, {
            Sprite59: 0
        }, {
            Sprite60: 0
        }, {
            Sprite61: 0
        }, {
            SpriteGravity: 0
        }, {
            Sprite63: 0
        },
        {
            Sprite64: 0
        }, {
            Sprite65: 0
        }, {
            Text8: 0
        }, {
            Text9: 0
        }, {
            Sprite66: 0
        }, {
            Sprite67: 0
        }, {
            nxtLvl: 0
        }, {
            Text10: 0
        }, {
            pause1: 0
        }, {
            Browser: 0
        }, {
            TiledBackground19: 0
        }, {
            TiledBackground20: 0
        }, {
            TiledBackground21: 0
        }, {
            TiledBackground22: 0
        }, {
            TiledBackground23: 0
        }, {
            TiledBackground24: 0
        }, {
            tile: 0
        }, {
            TiledBackground25: 0
        }, {
            halftile: 0
        }, {
            Untitled: 0
        }, {
            Untitled2: 0
        }, {
            Untitled3: 0
        }, {
            sizeincreaser2: 0
        }, {
            Untitled1copycopy: 0
        }, {
            Untitled4: 0
        }, {
            Untitled5: 0
        }, {
            Sprite68: 0
        }, {
            Untitled1copycopy2: 0
        }, {
            Untitled1copycop: 0
        }, {
            Sprite69: 0
        }, {
            Untitled1copycopy3: 0
        }, {
            Untitled1copyc: 0
        },
        {
            Sprite70: 0
        }, {
            Sprite71: 0
        }, {
            Sprite72: 0
        }, {
            Text11: 0
        }, {
            Sprite73: 0
        }, {
            Text12: 0
        }, {
            Text13: 0
        }, {
            Sprite74: 0
        }, {
            Sprite75: 0
        }, {
            Sprite76: 0
        }, {
            Sprite77: 0
        }, {
            TiledBackground26: 0
        }, {
            TiledBackground27: 0
        }, {
            Sprite78: 0
        }, {
            Sprite79: 0
        }, {
            SpriteFont: 0
        }, {
            lifeNo01: 0
        }, {
            SpriteFont2: 0
        }, {
            lifeNo2: 0
        }, {
            lifeNo31: 0
        }, {
            lifeNo02: 0
        }, {
            lifeNo5: 0
        }, {
            lifeNo6: 0
        }, {
            lifeNo7: 0
        }, {
            lifeNo8: 0
        }, {
            PAUSE: 0
        }, {
            Sprite80: 0
        }, {
            Reload: 0
        }, {
            Sprite81: 0
        }, {
            Sprite82: 0
        }, {
            Play: 0
        }, {
            Home1: 0
        }, {
            Sprite83: 0
        }, {
            Sprite84: 0
        }, {
            SpriteFont3: 0
        }, {
            lifeno03: 0
        }, {
            LevelComplete: 0
        }, {
            NextLevel: 0
        },
        {
            Home2: 0
        }, {
            Reload2: 0
        }, {
            ball2: 0
        }, {
            Text14: 0
        }, {
            Home3: 0
        }, {
            Reload3: 0
        }, {
            NextLevel2: 0
        }, {
            LevelComplete2: 0
        }, {
            LevelComplete3: 0
        }, {
            ballFadeOut3: 0
        }, {
            GameOver: 0
        }, {
            Home4: 0
        }, {
            Reload4: 0
        }, {
            GameOver2: 0
        }, {
            GameOver3: 0
        }, {
            GameOver4: 0
        }, {
            Home5: 0
        }, {
            Reload5: 0
        }, {
            Home6: 0
        }, {
            Reload6: 0
        }, {
            Reload7: 0
        }, {
            Home7: 0
        }, {
            Home8: 0
        }, {
            LevelComplete4: 0
        }, {
            Text15: 0
        }, {
            life2: 0
        }, {
            life3: 0
        }, {
            Text16: 0
        }, {
            DoubleJump: 0
        }, {
            Sprite85: 0
        }, {
            Sprite86: 0
        }, {
            Sprite87: 0
        }, {
            Sprite88: 0
        }, {
            SpriteFont5: 0
        }, {
            SpriteFont6: 0
        }, {
            PAUSE2: 0
        }, {
            Home9: 0
        }, {
            Play2: 0
        }, {
            Reload8: 0
        }, {
            LevelComplete5: 0
        },
        {
            Home10: 0
        }, {
            NextLevel3: 0
        }, {
            Reload9: 0
        }, {
            GameOver5: 0
        }, {
            Home11: 0
        }, {
            Reload10: 0
        }, {
            Text17: 0
        }, {
            power: 0
        }, {
            Untitled6: 0
        }, {
            Untitled7: 0
        }, {
            SizeReducer2: 0
        }, {
            TiledBackground28: 0
        }, {
            SizeReducer3: 0
        }, {
            Sprite90: 0
        }, {
            sizeIncreaser3: 0
        }, {
            pole2: 0
        }, {
            Text18: 0
        }, {
            Untitled8: 0
        }, {
            TiledBackground29: 0
        }, {
            Sprite41: 0
        }, {
            gravity: 0
        }, {
            Sprite89: 0
        }, {
            Sprite91: 0
        }, {
            Sprite92: 0
        }, {
            Sprite93: 0
        }, {
            Sprite94: 0
        }, {
            Sprite95: 0
        }, {
            life4: 0
        }, {
            Sprite96: 0
        }, {
            TiledBackground30: 0
        }, {
            Sprite97: 0
        }, {
            Sprite98: 0
        }, {
            Sprite99: 0
        }, {
            Sprite100: 0
        }, {
            Sprite101: 0
        }, {
            Sprite102: 0
        }, {
            TiledBackground31: 0
        },
        {
            Sprite103: 0
        }, {
            TiledBackground32: 0
        }, {
            Sprite104: 0
        }, {
            Text19: 0
        }, {
            Sprite105: 0
        }, {
            door: 0
        }, {
            door2: 0
        }, {
            SpriteFont7: 0
        }, {
            lifeno05: 0
        }, {
            greenball: 0
        }, {
            Sprite106: 0
        }, {
            Sprite107: 0
        }, {
            circle3: 0
        }, {
            circle4: 0
        }, {
            PAUSE3: 0
        }, {
            Home12: 0
        }, {
            Play3: 0
        }, {
            Reload11: 0
        }, {
            enemy4: 0
        }, {
            enemy5: 0
        }, {
            pole3: 0
        }, {
            sizeIncreaser4: 0
        }, {
            pole4: 0
        }, {
            enemy6: 0
        }, {
            Sprite108: 0
        }, {
            SpriteFont9: 0
        }, {
            lifeno06: 0
        }, {
            Sprite109: 0
        }, {
            TiledBackground: 0
        }, {
            Sprite110: 0
        }, {
            TiledBackground33: 0
        }, {
            SizeReducer4: 0
        }, {
            Sprite111: 0
        }, {
            Sprite112: 0
        }, {
            Home13: 0
        }, {
            Play4: 0
        }, {
            Reload12: 0
        }, {
            PAUSE4: 0
        },
        {
            Home14: 0
        }, {
            Reload13: 0
        }, {
            GameOver6: 0
        }, {
            LevelComplete6: 0
        }, {
            Home15: 0
        }, {
            NextLevel4: 0
        }, {
            Reload14: 0
        }, {
            enemy7: 0
        }, {
            Untitled9: 0
        }, {
            lifeNo04: 0
        }, {
            Home16: 0
        }, {
            Home17: 0
        }, {
            enemy8: 0
        }, {
            enemy9: 0
        }, {
            enemy10: 0
        }, {
            LEVEL01: 0
        }, {
            LEVEL02: 0
        }, {
            LEVEL03: 0
        }, {
            LEVEL04: 0
        }, {
            LEVEL05: 0
        }, {
            LEVEL06: 0
        }, {
            SELECTLEVELPANNEL: 0
        }, {
            Lock: 0
        }, {
            ballFadeOut2: 0
        }, {
            Sprite113: 0
        }, {
            Sprite114: 0
        }, {
            Sprite115: 0
        }, {
            Sprite116: 0
        }, {
            home: 0
        }, {
            leftarrow: 0
        }, {
            Sprite117: 0
        }, {
            LocalStorage: 0
        }, {
            buttons2: 0
        }, {
            Audio: 0
        }, {
            Sprite118: 0
        }, {
            Sprite119: 0
        }, {
            gamename: 0
        }, {
            ball3: 0
        }, {
            Sprite121: 0
        },
        {
            Sprite122: 0
        }, {
            play5: 0
        }, {
            BtnFullscreen: 0
        }, {
            Sprite123: 0
        }, {
            Sprite124: 0
        }, {
            Sprite125: 0
        }, {
            Sprite54: 0
        }, {
            Text20: 0
        }, {
            Text21: 0
        }, {
            Text22: 0
        }, {
            Sprite62: 0
        }, {
            Sprite126: 0
        }, {
            Sprite127: 0
        }, {
            Sprite128: 0
        }, {
            Sprite129: 0
        }, {
            ball4: 0
        }, {
            Array: 0
        }, {
            AJAX: 0
        }, {
            rotate: 0
        }, {
            SizeSound: 0
        }, {
            audio: 0
        }, {
            jump1: 0
        }, {
            life6: 0
        }, {
            life5: 0
        }, {
            RingPosition1: 0
        }, {
            brick: 0
        }, {
            lifeball4: 0
        }, {
            main: 0
        }, {
            LifeBall3: 0
        }, {
            Ring3: 0
        }, {
            LifeBall2: 0
        }, {
            Ring2: 0
        }, {
            ballSize: 0
        }, {
            lifeball: 0
        }, {
            Ring1: 0
        }, {
            Life: 0
        }, {
            RingPosition: 0
        }, {
            Ring: 0
        }, {
            position: 0
        }, {
            level: 0
        }, {
            sound: 0
        }, {
            check: 0
        },
        {
            full: 0
        }, {
            fullscreen: 0
        }, {
            LngParma: 0
        }
    ]
}
"use strict";
{
    const d = self.C3;
    self.C3_ExpressionFuncs = [() => "desktop1", () => 0, () => 1, () => 400, () => 2, () => 1E3, () => "mobile1", () => "mobile", () => 450, () => 10, () => .2, () => 20, () => -450, () => "jump-mobile", () => "DEC", () => "desktop", () => "jump-desktop", b => {
            const a = b._GetNode(0),
                f = b._GetNode(1);
            return () => d.lerp(a.ExpObject(), f.ExpObject() - 50, .9)
        }, b => {
            const a = b._GetNode(0);
            return () => a.ExpObject()
        }, b => {
            const a = b._GetNode(0).GetVar();
            return () => a.GetValue()
        }, () => 427, () => 8274, () => 3072, () => 178, () => .5, () => .1, () => 428, () => 7222, () => 649, () => 7551,
        () => 716, () => "camera02", () => "camera01", () => 8272, () => 535, () => 7580, () => 668, () => -50, () => "", () => 1.5, () => "MobileJump", () => "DesktopJump", () => -5, () => 5, () => -15, () => 70, () => 90, () => "dog()", () => "ring position1", () => 7, () => 197, () => 8, () => 198, () => 9, () => 199, () => 200, () => 11, () => 202, () => 12, () => 207, () => 13, () => 211, () => 14, () => 228, () => "position3", () => 711, () => 587, () => 4, () => 6249, () => 188, () => 222, () => 8764, () => -239, () => 1718, () => -281, () => 225, () => 6, () => 8756, () => -1238, () => 1525, () => -955, () => 226, () => 3, () => "Diamond3", () => "Circle Frame3",
        () => 62, () => 66, () => 180, () => 179, () => 183, () => 182, () => 185, () => 184, () => 203, () => 147, () => 208, () => 204, () => 210, () => 214, () => 229, () => 232, () => 175, () => 223, () => "Camera Work", () => "camera1", () => 11124, () => 47, () => 10618, () => 122, () => 360, () => 11168, () => 123.5, () => 10604, () => 43.5, () => 11185, () => -635.5, () => 8816, () => -568, () => 11198, () => -590, () => 8835, () => 613, () => -195, () => 1216, () => 43, () => 765.706, () => -165.887, () => 452.704, () => -165.135, () => 610.217, () => -167.534, () => -3E3, () => .4, () => .3, () => 1200, () => 41, () => "bounce", () => .7, () => 1753, () =>
        262, () => "ring position", () => 134, () => 135, () => 136, () => 137, () => 138, () => 139, () => "position2", () => 752, () => 579, () => 2465, () => 280, () => 140, () => 3789, () => 266, () => 141, () => 8732, () => 367, () => 142, () => "Diamond2", () => "Circle Frame2", () => 69, () => 125, () => 34, () => 126, () => 35, () => 123, () => 37, () => 128, () => 71, () => 129, () => 72, () => 130, () => 120, () => 1205, () => 53, () => 623, () => 276, () => 307, () => 334, () => 348, () => 350, () => 352, () => 353, () => 368, () => 378, () => 315, () => 759, () => 1037, () => -1604, () => 584, () => 349, () => 397, () => -1526, () => 640, () => -533, () => 696,
        () => -445, () => 790, () => 351, () => -1565, () => 740, () => -426, () => 2333, () => 1479, () => 50, () => 1390, () => 2100, () => 1243, () => -1772, () => 2070, () => 308, () => 394, () => 132, () => 15, () => 293, () => 16, () => 318, () => 17, () => 324, () => 18, () => 354, () => 19, () => 398, () => 21, () => 407, () => 22, () => 281, () => 23, () => "RingPosition", () => 117, () => 217, () => 296, () => 297, () => 321, () => 319, () => 328, () => 325, () => 357, () => 355, () => 363, () => 361, () => 402, () => 399, () => 411, () => 408, () => 284, () => 285, b => {
            const a = b._GetNode(0),
                f = b._GetNode(1);
                
            return () => d.lerp(a.ExpObject(), f.ExpObject() - 220, .9)
        }, () => "position", () => 3003, () => 566, () => 1232, () => 1654, () => 930, () => 1490, () => 5265, () => 1501, () => 5346, () => 1423, () => 5268, () => 1898, () => 5316, () => 1613, () => 2315, () => 5276, () => 1883, () => 2739, () => 5266, () => 2323, () => 10660, () => 2758, () => 10286, () => 2933, () => 9054, () => 549, () => "RingPosition11", () => "dec", () => 1500, () => 7579, () => 3303, () => 8551, () => 3382, () => 3187, () => 7575, () => 2795, () => 7051, () => 7562, () => 7378, () => 3430, () => -129, () => 467, () => 412, () => 8014, () => 3338, () => 8521, () => 3102, () => -350, () => 7393, () => 3111, () => 493, () => 485, () =>
        510, () => 588, () => 591, () => 598, () => "RingPosition2", () => 24, () => 494, () => 498, () => 25, () => 488, () => 492, () => 26, () => 529, () => 533, () => 27, () => 544, () => 548, () => 28, () => 552, () => 29, () => 562, () => 30, () => 594, () => 597, () => 496, () => 490, () => 530, () => 546, () => 610, () => 563, () => 595, () => 525, () => 599, () => 731, () => -340, () => 1070, () => -51, () => 631, () => 246, () => 338, () => 1081, () => 630, () => "camera03", () => "camera04", b => {
            const a = b._GetNode(0),
                f = b._GetNode(1);
            return () => d.lerp(a.ExpObject(), f.ExpObject() - 50, .2)
        }, () => -4204, () => -1107, () => -4653, () => -418,
        () => 612, () => -4094, () => -1095, () => -4800, () => -424, () => "ring position3", () => "position4", () => 660, () => 150, () => 1887, () => 74, () => 3462, () => 80, () => 470, () => 356, () => -1679, () => 322, () => 1273, () => -510, () => 366, () => -345, () => -8122, () => -484, () => "ring position2", () => -8521, () => -6236, () => -489, () => -206, () => -6362.5, () => 626, () => 789, () => 410, b => {
            const a = b._GetNode(0).GetBoundMethod();
            return () => a()
        }, () => "camera4", () => "camera5", () => -1352, () => 963, () => -2526, () => 691, () => -2712, () => 1207, () => -2135, () => 1208, () => -2144, () => 1201, () => -2103,
        () => 627, () => -1623, () => 720, () => -1682, () => 619, () => 805, () => 5466.5, () => 1198, () => 5467, () => 1280, () => 734, () => -200, () => 1203, () => -2564, () => -2749, () => 495, () => -1903, () => 516, () => -113, () => 232.5, () => 726, () => 233, () => 772, () => 733, () => 753, () => 801, () => -2400, () => 621, () => -2618, () => -2733, () => 1187, () => -419, () => "ring position4", () => 32, () => 707, () => 33, () => 750, () => 818, () => 36, () => 782, () => "position6", () => 316, () => 684, () => 282, () => 1090, () => 589, () => 954, () => "RingPosition3", () => 708, () => 709, () => 717, () => 718, () => 751, () => 819, () => 815, () =>
        787, () => 798, () => 779, () => 854, () => 855, () => 899, () => 905, () => 936, () => "camera06", () => "camera07", () => "position7", () => 250, () => -10, () => 294, () => 1219, () => -4037, () => -528, () => -2832, () => -313, () => 1716, () => -217, () => 3729, () => -334, () => 2644, () => -853, () => 1456, () => -926, () => 881, () => 38, () => 887, () => 39, () => 988, () => 40, () => 908, () => 918, () => 941, () => 949, () => "RingPosition4", () => 883, () => 882, () => 889, () => 888, () => 990, () => 989, () => 907, () => 911, () => 917, () => 921, () => 943, () => 942, () => 951, () => 950, () => -294, () => 1235, () => 571, () => 163, () => 927, () =>
        -844, () => 87, () => 576, () => 662, () => -863, () => 133, () => -596, () => 618, () => -544, () => -46, () => -641, () => 625, () => -631, () => 973, () => "ring position5", () => -2442, () => -644, () => -1527, () => -948, () => -1891, () => -1591, () => -684, () => 2203, () => 1206, () => 56, () => 3E3, () => "main", () => -25, () => "Rotate-Screen", () => "Fullscreen_Settings", () => "FulLscreenON", () => "FulLscreenOFF", () => "loadLanguageFile", () => "localization.json", b => {
            const a = b._GetNode(0),
                f = b._GetNode(1).GetVar();
            return () => a.ExpObject(f.GetValue(), 4)
        },
        b => {
            const a = b._GetNode(0),
                f = b._GetNode(1).GetVar();
            return () => a.ExpObject(f.GetValue(), 0)
        },
        b => {
            const a = b._GetNode(0),
                f = b._GetNode(1).GetVar();
            return () => a.ExpObject(f.GetValue(), 1)
        },
        b => {
            const a = b._GetNode(0),
                f = b._GetNode(1).GetVar();
            return () => a.ExpObject(f.GetValue(), 2)
        },
        b => {
            const a = b._GetNode(0),
                f = b._GetNode(1).GetVar();
            return () => a.ExpObject(f.GetValue(), 3)
        },
        b => {
            const a = b._GetNode(0),
                f = b._GetNode(1).GetVar();
            return () => a.ExpObject(f.GetValue(), 6)
        }
    ]
}
var module$str$c3runtime = {};
self.C3.ScriptsInEvents = {
    async Localization_Event3_Act1(d, b) {
        d.setReturnValue(langreturn())
    }
};
var module$str$scriptsInEvents = {};
var module$str$__c3root__ = {};